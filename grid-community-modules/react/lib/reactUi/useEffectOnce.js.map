{"version":3,"sources":["reactUi/useEffectOnce.tsx"],"names":[],"mappings":";;;;AAAA,iCAAqE;AAExD,QAAA,aAAa,GAAG,CAAC,MAAiC,EAAE,EAAE;IAE/D,MAAM,QAAQ,GAAG,cAAM,CAA4B,MAAM,CAAC,CAAC;IAC3D,MAAM,SAAS,GAAG,cAAM,EAAuB,CAAC;IAChD,MAAM,YAAY,GAAG,cAAM,CAAC,KAAK,CAAC,CAAC;IACnC,MAAM,QAAQ,GAAG,cAAM,CAAC,KAAK,CAAC,CAAC;IAC/B,MAAM,CAAC,EAAE,MAAM,CAAC,GAAG,gBAAQ,CAAS,CAAC,CAAC,CAAC;IAEvC,IAAI,YAAY,CAAC,OAAO,EAAE;QACxB,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC;KACzB;IAED,iBAAS,CAAC,GAAG,EAAE;QACb,4CAA4C;QAC5C,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;YACzB,SAAS,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,EAAE,CAAC;YACvC,YAAY,CAAC,OAAO,GAAG,IAAI,CAAC;SAC7B;QAED,iDAAiD;QACjD,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;QAEzB,OAAO,GAAG,EAAE;YACV,4DAA4D;YAC5D,qCAAqC;YACrC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE;gBAAE,OAAO;aAAE;YAElC,kEAAkE;YAClE,IAAI,SAAS,CAAC,OAAO,EAAE;gBAAE,SAAS,CAAC,OAAO,EAAE,CAAC;aAAE;QACjD,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC,CAAC;AAGS,QAAA,mBAAmB,GAAG,CAAC,MAAiC,EAAE,EAAE;IAEvE,MAAM,QAAQ,GAAG,cAAM,CAA4B,MAAM,CAAC,CAAC;IAC3D,MAAM,SAAS,GAAG,cAAM,EAAuB,CAAC;IAChD,MAAM,YAAY,GAAG,cAAM,CAAC,KAAK,CAAC,CAAC;IACnC,MAAM,QAAQ,GAAG,cAAM,CAAC,KAAK,CAAC,CAAC;IAC/B,MAAM,CAAC,EAAE,MAAM,CAAC,GAAG,gBAAQ,CAAS,CAAC,CAAC,CAAC;IAEvC,IAAI,YAAY,CAAC,OAAO,EAAE;QACxB,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC;KACzB;IAED,uBAAe,CAAC,GAAG,EAAE;QACnB,4CAA4C;QAC5C,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;YACzB,SAAS,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,EAAE,CAAC;YACvC,YAAY,CAAC,OAAO,GAAG,IAAI,CAAC;SAC7B;QAED,iDAAiD;QACjD,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;QAEzB,OAAO,GAAG,EAAE;YACV,4DAA4D;YAC5D,qCAAqC;YACrC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE;gBAAE,OAAO;aAAE;YAElC,kEAAkE;YAClE,IAAI,SAAS,CAAC,OAAO,EAAE;gBAAE,SAAS,CAAC,OAAO,EAAE,CAAC;aAAE;QACjD,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC,CAAC","file":"useEffectOnce.js","sourcesContent":["import { useEffect, useLayoutEffect, useRef, useState } from 'react';\n\nexport const useEffectOnce = (effect: () => void | (() => void)) => {\n\n    const effectFn = useRef<() => void | (() => void)>(effect);\n    const destroyFn = useRef<void | (() => void)>();\n    const effectCalled = useRef(false);\n    const rendered = useRef(false);\n    const [, setVal] = useState<number>(0);\n  \n    if (effectCalled.current) {\n      rendered.current = true;\n    }\n  \n    useEffect(() => {\n      // only execute the effect first time around\n      if (!effectCalled.current) {\n        destroyFn.current = effectFn.current();\n        effectCalled.current = true;\n      }\n\n      // this forces one render after the effect is run\n      setVal((val) => val + 1);\n\n      return () => {\n        // if the comp didn't render since the useEffect was called,\n        // we know it's the dummy React cycle\n        if (!rendered.current) { return; }\n\n        // otherwise this is not a dummy destroy, so call the destroy func\n        if (destroyFn.current) { destroyFn.current(); }\n      };\n    }, []);\n  };\n\n\nexport const useLayoutEffectOnce = (effect: () => void | (() => void)) => {\n\n  const effectFn = useRef<() => void | (() => void)>(effect);\n  const destroyFn = useRef<void | (() => void)>();\n  const effectCalled = useRef(false);\n  const rendered = useRef(false);\n  const [, setVal] = useState<number>(0);\n\n  if (effectCalled.current) {\n    rendered.current = true;\n  }\n\n  useLayoutEffect(() => {\n    // only execute the effect first time around\n    if (!effectCalled.current) {\n      destroyFn.current = effectFn.current();\n      effectCalled.current = true;\n    }\n\n    // this forces one render after the effect is run\n    setVal((val) => val + 1);\n\n    return () => {\n      // if the comp didn't render since the useEffect was called,\n      // we know it's the dummy React cycle\n      if (!rendered.current) { return; }\n\n      // otherwise this is not a dummy destroy, so call the destroy func\n      if (destroyFn.current) { destroyFn.current(); }\n    };\n  }, []);\n};\n"]}