/******/ (function(modules) { // webpackBootstrap
    /******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
    /******/ 	this["webpackHotUpdate"] =
        /******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
        /******/ 		hotAddUpdateChunk(chunkId, moreModules);
        /******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
        /******/ 	}
    /******/
    /******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
        /******/ 		var head = document.getElementsByTagName("head")[0];
        /******/ 		var script = document.createElement("script");
        /******/ 		script.type = "text/javascript";
        /******/ 		script.charset = "utf-8";
        /******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
        /******/ 		head.appendChild(script);
        /******/ 	}
    /******/
    /******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
        /******/ 		if(typeof XMLHttpRequest === "undefined")
        /******/ 			return callback(new Error("No browser support"));
        /******/ 		try {
            /******/ 			var request = new XMLHttpRequest();
            /******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
            /******/ 			request.open("GET", requestPath, true);
            /******/ 			request.timeout = 10000;
            /******/ 			request.send(null);
            /******/ 		} catch(err) {
            /******/ 			return callback(err);
            /******/ 		}
        /******/ 		request.onreadystatechange = function() {
            /******/ 			if(request.readyState !== 4) return;
            /******/ 			if(request.status === 0) {
                /******/ 				// timeout
                /******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
                /******/ 			} else if(request.status === 404) {
                /******/ 				// no update available
                /******/ 				callback();
                /******/ 			} else if(request.status !== 200 && request.status !== 304) {
                /******/ 				// other failure
                /******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
                /******/ 			} else {
                /******/ 				// success
                /******/ 				try {
                    /******/ 					var update = JSON.parse(request.responseText);
                    /******/ 				} catch(e) {
                    /******/ 					callback(e);
                    /******/ 					return;
                    /******/ 				}
                /******/ 				callback(null, update);
                /******/ 			}
            /******/ 		};
        /******/ 	}

    /******/
    /******/
    /******/ 	var hotApplyOnUpdate = true;
    /******/ 	var hotCurrentHash = "244ce38a2e154ac2c6ed"; // eslint-disable-line no-unused-vars
    /******/ 	var hotCurrentModuleData = {};
    /******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
    /******/
    /******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
        /******/ 		var me = installedModules[moduleId];
        /******/ 		if(!me) return __webpack_require__;
        /******/ 		var fn = function(request) {
            /******/ 			if(me.hot.active) {
                /******/ 				if(installedModules[request]) {
                    /******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
                    /******/ 						installedModules[request].parents.push(moduleId);
                    /******/ 					if(me.children.indexOf(request) < 0)
                    /******/ 						me.children.push(request);
                    /******/ 				} else hotCurrentParents = [moduleId];
                /******/ 			} else {
                /******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
                /******/ 				hotCurrentParents = [];
                /******/ 			}
            /******/ 			return __webpack_require__(request);
            /******/ 		};
        /******/ 		for(var name in __webpack_require__) {
            /******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
                /******/ 				fn[name] = __webpack_require__[name];
                /******/ 			}
            /******/ 		}
        /******/ 		fn.e = function(chunkId, callback) {
            /******/ 			if(hotStatus === "ready")
            /******/ 				hotSetStatus("prepare");
            /******/ 			hotChunksLoading++;
            /******/ 			__webpack_require__.e(chunkId, function() {
                /******/ 				try {
                    /******/ 					callback.call(null, fn);
                    /******/ 				} finally {
                    /******/ 					finishChunkLoading();
                    /******/ 				}
                /******/
                /******/ 				function finishChunkLoading() {
                    /******/ 					hotChunksLoading--;
                    /******/ 					if(hotStatus === "prepare") {
                        /******/ 						if(!hotWaitingFilesMap[chunkId]) {
                            /******/ 							hotEnsureUpdateChunk(chunkId);
                            /******/ 						}
                        /******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
                            /******/ 							hotUpdateDownloaded();
                            /******/ 						}
                        /******/ 					}
                    /******/ 				}
                /******/ 			});
            /******/ 		};
        /******/ 		return fn;
        /******/ 	}
    /******/
    /******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
        /******/ 		var hot = {
            /******/ 			// private stuff
            /******/ 			_acceptedDependencies: {},
            /******/ 			_declinedDependencies: {},
            /******/ 			_selfAccepted: false,
            /******/ 			_selfDeclined: false,
            /******/ 			_disposeHandlers: [],
            /******/
            /******/ 			// Module API
            /******/ 			active: true,
            /******/ 			accept: function(dep, callback) {
                /******/ 				if(typeof dep === "undefined")
                /******/ 					hot._selfAccepted = true;
                /******/ 				else if(typeof dep === "function")
                /******/ 					hot._selfAccepted = dep;
                /******/ 				else if(typeof dep === "object")
                /******/ 					for(var i = 0; i < dep.length; i++)
                        /******/ 						hot._acceptedDependencies[dep[i]] = callback;
                /******/ 				else
                /******/ 					hot._acceptedDependencies[dep] = callback;
                /******/ 			},
            /******/ 			decline: function(dep) {
                /******/ 				if(typeof dep === "undefined")
                /******/ 					hot._selfDeclined = true;
                /******/ 				else if(typeof dep === "number")
                /******/ 					hot._declinedDependencies[dep] = true;
                /******/ 				else
                /******/ 					for(var i = 0; i < dep.length; i++)
                        /******/ 						hot._declinedDependencies[dep[i]] = true;
                /******/ 			},
            /******/ 			dispose: function(callback) {
                /******/ 				hot._disposeHandlers.push(callback);
                /******/ 			},
            /******/ 			addDisposeHandler: function(callback) {
                /******/ 				hot._disposeHandlers.push(callback);
                /******/ 			},
            /******/ 			removeDisposeHandler: function(callback) {
                /******/ 				var idx = hot._disposeHandlers.indexOf(callback);
                /******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
                /******/ 			},
            /******/
            /******/ 			// Management API
            /******/ 			check: hotCheck,
            /******/ 			apply: hotApply,
            /******/ 			status: function(l) {
                /******/ 				if(!l) return hotStatus;
                /******/ 				hotStatusHandlers.push(l);
                /******/ 			},
            /******/ 			addStatusHandler: function(l) {
                /******/ 				hotStatusHandlers.push(l);
                /******/ 			},
            /******/ 			removeStatusHandler: function(l) {
                /******/ 				var idx = hotStatusHandlers.indexOf(l);
                /******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
                /******/ 			},
            /******/
            /******/ 			//inherit from previous dispose call
            /******/ 			data: hotCurrentModuleData[moduleId]
            /******/ 		};
        /******/ 		return hot;
        /******/ 	}
    /******/
    /******/ 	var hotStatusHandlers = [];
    /******/ 	var hotStatus = "idle";
    /******/
    /******/ 	function hotSetStatus(newStatus) {
        /******/ 		hotStatus = newStatus;
        /******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
            /******/ 			hotStatusHandlers[i].call(null, newStatus);
        /******/ 	}
    /******/
    /******/ 	// while downloading
    /******/ 	var hotWaitingFiles = 0;
    /******/ 	var hotChunksLoading = 0;
    /******/ 	var hotWaitingFilesMap = {};
    /******/ 	var hotRequestedFilesMap = {};
    /******/ 	var hotAvailibleFilesMap = {};
    /******/ 	var hotCallback;
    /******/
    /******/ 	// The update info
    /******/ 	var hotUpdate, hotUpdateNewHash;
    /******/
    /******/ 	function toModuleId(id) {
        /******/ 		var isNumber = (+id) + "" === id;
        /******/ 		return isNumber ? +id : id;
        /******/ 	}
    /******/
    /******/ 	function hotCheck(apply, callback) {
        /******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
        /******/ 		if(typeof apply === "function") {
            /******/ 			hotApplyOnUpdate = false;
            /******/ 			callback = apply;
            /******/ 		} else {
            /******/ 			hotApplyOnUpdate = apply;
            /******/ 			callback = callback || function(err) {
                    /******/ 				if(err) throw err;
                    /******/ 			};
            /******/ 		}
        /******/ 		hotSetStatus("check");
        /******/ 		hotDownloadManifest(function(err, update) {
            /******/ 			if(err) return callback(err);
            /******/ 			if(!update) {
                /******/ 				hotSetStatus("idle");
                /******/ 				callback(null, null);
                /******/ 				return;
                /******/ 			}
            /******/
            /******/ 			hotRequestedFilesMap = {};
            /******/ 			hotAvailibleFilesMap = {};
            /******/ 			hotWaitingFilesMap = {};
            /******/ 			for(var i = 0; i < update.c.length; i++)
                /******/ 				hotAvailibleFilesMap[update.c[i]] = true;
            /******/ 			hotUpdateNewHash = update.h;
            /******/
            /******/ 			hotSetStatus("prepare");
            /******/ 			hotCallback = callback;
            /******/ 			hotUpdate = {};
            /******/ 			var chunkId = 0;
            /******/ 			{ // eslint-disable-line no-lone-blocks
                /******/ 				/*globals chunkId */
                /******/ 				hotEnsureUpdateChunk(chunkId);
                /******/ 			}
            /******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
                /******/ 				hotUpdateDownloaded();
                /******/ 			}
            /******/ 		});
        /******/ 	}
    /******/
    /******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
        /******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
        /******/ 			return;
        /******/ 		hotRequestedFilesMap[chunkId] = false;
        /******/ 		for(var moduleId in moreModules) {
            /******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
                /******/ 				hotUpdate[moduleId] = moreModules[moduleId];
                /******/ 			}
            /******/ 		}
        /******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
            /******/ 			hotUpdateDownloaded();
            /******/ 		}
        /******/ 	}
    /******/
    /******/ 	function hotEnsureUpdateChunk(chunkId) {
        /******/ 		if(!hotAvailibleFilesMap[chunkId]) {
            /******/ 			hotWaitingFilesMap[chunkId] = true;
            /******/ 		} else {
            /******/ 			hotRequestedFilesMap[chunkId] = true;
            /******/ 			hotWaitingFiles++;
            /******/ 			hotDownloadUpdateChunk(chunkId);
            /******/ 		}
        /******/ 	}
    /******/
    /******/ 	function hotUpdateDownloaded() {
        /******/ 		hotSetStatus("ready");
        /******/ 		var callback = hotCallback;
        /******/ 		hotCallback = null;
        /******/ 		if(!callback) return;
        /******/ 		if(hotApplyOnUpdate) {
            /******/ 			hotApply(hotApplyOnUpdate, callback);
            /******/ 		} else {
            /******/ 			var outdatedModules = [];
            /******/ 			for(var id in hotUpdate) {
                /******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
                    /******/ 					outdatedModules.push(toModuleId(id));
                    /******/ 				}
                /******/ 			}
            /******/ 			callback(null, outdatedModules);
            /******/ 		}
        /******/ 	}
    /******/
    /******/ 	function hotApply(options, callback) {
        /******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
        /******/ 		if(typeof options === "function") {
            /******/ 			callback = options;
            /******/ 			options = {};
            /******/ 		} else if(options && typeof options === "object") {
            /******/ 			callback = callback || function(err) {
                    /******/ 				if(err) throw err;
                    /******/ 			};
            /******/ 		} else {
            /******/ 			options = {};
            /******/ 			callback = callback || function(err) {
                    /******/ 				if(err) throw err;
                    /******/ 			};
            /******/ 		}
        /******/
        /******/ 		function getAffectedStuff(module) {
            /******/ 			var outdatedModules = [module];
            /******/ 			var outdatedDependencies = {};
            /******/
            /******/ 			var queue = outdatedModules.slice();
            /******/ 			while(queue.length > 0) {
                /******/ 				var moduleId = queue.pop();
                /******/ 				var module = installedModules[moduleId];
                /******/ 				if(!module || module.hot._selfAccepted)
                /******/ 					continue;
                /******/ 				if(module.hot._selfDeclined) {
                    /******/ 					return new Error("Aborted because of self decline: " + moduleId);
                    /******/ 				}
                /******/ 				if(moduleId === 0) {
                    /******/ 					return;
                    /******/ 				}
                /******/ 				for(var i = 0; i < module.parents.length; i++) {
                    /******/ 					var parentId = module.parents[i];
                    /******/ 					var parent = installedModules[parentId];
                    /******/ 					if(parent.hot._declinedDependencies[moduleId]) {
                        /******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
                        /******/ 					}
                    /******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
                    /******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
                        /******/ 						if(!outdatedDependencies[parentId])
                        /******/ 							outdatedDependencies[parentId] = [];
                        /******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
                        /******/ 						continue;
                        /******/ 					}
                    /******/ 					delete outdatedDependencies[parentId];
                    /******/ 					outdatedModules.push(parentId);
                    /******/ 					queue.push(parentId);
                    /******/ 				}
                /******/ 			}
            /******/
            /******/ 			return [outdatedModules, outdatedDependencies];
            /******/ 		}
        /******/
        /******/ 		function addAllToSet(a, b) {
            /******/ 			for(var i = 0; i < b.length; i++) {
                /******/ 				var item = b[i];
                /******/ 				if(a.indexOf(item) < 0)
                /******/ 					a.push(item);
                /******/ 			}
            /******/ 		}
        /******/
        /******/ 		// at begin all updates modules are outdated
        /******/ 		// the "outdated" status can propagate to parents if they don't accept the children
        /******/ 		var outdatedDependencies = {};
        /******/ 		var outdatedModules = [];
        /******/ 		var appliedUpdate = {};
        /******/ 		for(var id in hotUpdate) {
            /******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
                /******/ 				var moduleId = toModuleId(id);
                /******/ 				var result = getAffectedStuff(moduleId);
                /******/ 				if(!result) {
                    /******/ 					if(options.ignoreUnaccepted)
                    /******/ 						continue;
                    /******/ 					hotSetStatus("abort");
                    /******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
                    /******/ 				}
                /******/ 				if(result instanceof Error) {
                    /******/ 					hotSetStatus("abort");
                    /******/ 					return callback(result);
                    /******/ 				}
                /******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
                /******/ 				addAllToSet(outdatedModules, result[0]);
                /******/ 				for(var moduleId in result[1]) {
                    /******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
                        /******/ 						if(!outdatedDependencies[moduleId])
                        /******/ 							outdatedDependencies[moduleId] = [];
                        /******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
                        /******/ 					}
                    /******/ 				}
                /******/ 			}
            /******/ 		}
        /******/
        /******/ 		// Store self accepted outdated modules to require them later by the module system
        /******/ 		var outdatedSelfAcceptedModules = [];
        /******/ 		for(var i = 0; i < outdatedModules.length; i++) {
            /******/ 			var moduleId = outdatedModules[i];
            /******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
            /******/ 				outdatedSelfAcceptedModules.push({
                    /******/ 					module: moduleId,
                    /******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
                    /******/ 				});
            /******/ 		}
        /******/
        /******/ 		// Now in "dispose" phase
        /******/ 		hotSetStatus("dispose");
        /******/ 		var queue = outdatedModules.slice();
        /******/ 		while(queue.length > 0) {
            /******/ 			var moduleId = queue.pop();
            /******/ 			var module = installedModules[moduleId];
            /******/ 			if(!module) continue;
            /******/
            /******/ 			var data = {};
            /******/
            /******/ 			// Call dispose handlers
            /******/ 			var disposeHandlers = module.hot._disposeHandlers;
            /******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
                /******/ 				var cb = disposeHandlers[j];
                /******/ 				cb(data);
                /******/ 			}
            /******/ 			hotCurrentModuleData[moduleId] = data;
            /******/
            /******/ 			// disable module (this disables requires from this module)
            /******/ 			module.hot.active = false;
            /******/
            /******/ 			// remove module from cache
            /******/ 			delete installedModules[moduleId];
            /******/
            /******/ 			// remove "parents" references from all children
            /******/ 			for(var j = 0; j < module.children.length; j++) {
                /******/ 				var child = installedModules[module.children[j]];
                /******/ 				if(!child) continue;
                /******/ 				var idx = child.parents.indexOf(moduleId);
                /******/ 				if(idx >= 0) {
                    /******/ 					child.parents.splice(idx, 1);
                    /******/ 				}
                /******/ 			}
            /******/ 		}
        /******/
        /******/ 		// remove outdated dependency from module children
        /******/ 		for(var moduleId in outdatedDependencies) {
            /******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
                /******/ 				var module = installedModules[moduleId];
                /******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
                /******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
                    /******/ 					var dependency = moduleOutdatedDependencies[j];
                    /******/ 					var idx = module.children.indexOf(dependency);
                    /******/ 					if(idx >= 0) module.children.splice(idx, 1);
                    /******/ 				}
                /******/ 			}
            /******/ 		}
        /******/
        /******/ 		// Not in "apply" phase
        /******/ 		hotSetStatus("apply");
        /******/
        /******/ 		hotCurrentHash = hotUpdateNewHash;
        /******/
        /******/ 		// insert new code
        /******/ 		for(var moduleId in appliedUpdate) {
            /******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
                /******/ 				modules[moduleId] = appliedUpdate[moduleId];
                /******/ 			}
            /******/ 		}
        /******/
        /******/ 		// call accept handlers
        /******/ 		var error = null;
        /******/ 		for(var moduleId in outdatedDependencies) {
            /******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
                /******/ 				var module = installedModules[moduleId];
                /******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
                /******/ 				var callbacks = [];
                /******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
                    /******/ 					var dependency = moduleOutdatedDependencies[i];
                    /******/ 					var cb = module.hot._acceptedDependencies[dependency];
                    /******/ 					if(callbacks.indexOf(cb) >= 0) continue;
                    /******/ 					callbacks.push(cb);
                    /******/ 				}
                /******/ 				for(var i = 0; i < callbacks.length; i++) {
                    /******/ 					var cb = callbacks[i];
                    /******/ 					try {
                        /******/ 						cb(outdatedDependencies);
                        /******/ 					} catch(err) {
                        /******/ 						if(!error)
                        /******/ 							error = err;
                        /******/ 					}
                    /******/ 				}
                /******/ 			}
            /******/ 		}
        /******/
        /******/ 		// Load self accepted modules
        /******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
            /******/ 			var item = outdatedSelfAcceptedModules[i];
            /******/ 			var moduleId = item.module;
            /******/ 			hotCurrentParents = [moduleId];
            /******/ 			try {
                /******/ 				__webpack_require__(moduleId);
                /******/ 			} catch(err) {
                /******/ 				if(typeof item.errorHandler === "function") {
                    /******/ 					try {
                        /******/ 						item.errorHandler(err);
                        /******/ 					} catch(err) {
                        /******/ 						if(!error)
                        /******/ 							error = err;
                        /******/ 					}
                    /******/ 				} else if(!error)
                /******/ 					error = err;
                /******/ 			}
            /******/ 		}
        /******/
        /******/ 		// handle errors in accept handlers and self accepted module load
        /******/ 		if(error) {
            /******/ 			hotSetStatus("fail");
            /******/ 			return callback(error);
            /******/ 		}
        /******/
        /******/ 		hotSetStatus("idle");
        /******/ 		callback(null, outdatedModules);
        /******/ 	}

    /******/ 	// The module cache
    /******/ 	var installedModules = {};

    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {

        /******/ 		// Check if module is in cache
        /******/ 		if(installedModules[moduleId])
        /******/ 			return installedModules[moduleId].exports;

        /******/ 		// Create a new module (and put it into the cache)
        /******/ 		var module = installedModules[moduleId] = {
            /******/ 			exports: {},
            /******/ 			id: moduleId,
            /******/ 			loaded: false,
            /******/ 			hot: hotCreateModule(moduleId),
            /******/ 			parents: hotCurrentParents,
            /******/ 			children: []
            /******/ 		};

        /******/ 		// Execute the module function
        /******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));

        /******/ 		// Flag the module as loaded
        /******/ 		module.loaded = true;

        /******/ 		// Return the exports of the module
        /******/ 		return module.exports;
        /******/ 	}


    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;

    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;

    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";

    /******/ 	// __webpack_hash__
    /******/ 	__webpack_require__.h = function() { return hotCurrentHash; };

    /******/ 	// Load entry module and return exports
    /******/ 	return hotCreateRequire(0)(0);
    /******/ })
/************************************************************************/
/******/ ([
    /* 0 */
    /***/ function(module, exports, __webpack_require__) {

        __webpack_require__(1);
        __webpack_require__(74);
        module.exports = __webpack_require__(76);


        /***/ },
    /* 1 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(__resourceQuery) {var url = __webpack_require__(2);
            var SockJS = __webpack_require__(9);
            var stripAnsi = __webpack_require__(72);
            var scriptElements = document.getElementsByTagName("script");
            var scriptHost = scriptElements[scriptElements.length-1].getAttribute("src").replace(/\/[^\/]+$/, "");

            // If this bundle is inlined, use the resource query to get the correct url.
            // Else, get the url from the <script> this file was called with.
            var urlParts = url.parse( true ?
                __resourceQuery.substr(1) :
                (scriptHost ? scriptHost : "/")
            );

            var sock = null;
            var hot = false;
            var initial = true;
            var currentHash = "";

            var onSocketMsg = {
                hot: function() {
                    hot = true;
                    console.log("[WDS] Hot Module Replacement enabled.");
                },
                invalid: function() {
                    console.log("[WDS] App updated. Recompiling...");
                },
                hash: function(hash) {
                    currentHash = hash;
                },
                "still-ok": function() {
                    console.log("[WDS] Nothing changed.")
                },
                ok: function() {
                    if(initial) return initial = false;
                    reloadApp();
                },
                warnings: function(warnings) {
                    console.log("[WDS] Warnings while compiling.");
                    for(var i = 0; i < warnings.length; i++)
                        console.warn(stripAnsi(warnings[i]));
                    if(initial) return initial = false;
                    reloadApp();
                },
                errors: function(errors) {
                    console.log("[WDS] Errors while compiling.");
                    for(var i = 0; i < errors.length; i++)
                        console.error(stripAnsi(errors[i]));
                    if(initial) return initial = false;
                    reloadApp();
                },
                "proxy-error": function(errors) {
                    console.log("[WDS] Proxy error.");
                    for(var i = 0; i < errors.length; i++)
                        console.error(stripAnsi(errors[i]));
                    if(initial) return initial = false;
                    reloadApp();
                }
            };

            var newConnection = function() {
                sock = new SockJS(url.format({
                    protocol: urlParts.protocol,
                    auth: urlParts.auth,
                    hostname: (urlParts.hostname === '0.0.0.0') ? window.location.hostname : urlParts.hostname,
                    port: urlParts.port,
                    pathname: urlParts.path === '/' ? "/sockjs-node" : urlParts.path
                }));

                sock.onclose = function() {
                    console.error("[WDS] Disconnected!");

                    // Try to reconnect.
                    sock = null;
                    setTimeout(function () {
                        newConnection();
                    }, 2000);
                };

                sock.onmessage = function(e) {
                    // This assumes that all data sent via the websocket is JSON.
                    var msg = JSON.parse(e.data);
                    onSocketMsg[msg.type](msg.data);
                };
            };

            newConnection();

            function reloadApp() {
                if(hot) {
                    console.log("[WDS] App hot update...");
                    window.postMessage("webpackHotUpdate" + currentHash, "*");
                } else {
                    console.log("[WDS] App updated. Reloading...");
                    window.location.reload();
                }
            }

            /* WEBPACK VAR INJECTION */}.call(exports, "?http://localhost:8080"))

        /***/ },
    /* 2 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var punycode = __webpack_require__(3);

        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;

        exports.Url = Url;

        function Url() {
            this.protocol = null;
            this.slashes = null;
            this.auth = null;
            this.host = null;
            this.port = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.query = null;
            this.pathname = null;
            this.path = null;
            this.href = null;
        }

        // Reference: RFC 3986, RFC 1808, RFC 2396

        // define these here so at least they only have to be
        // compiled once on the first module load.
        var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]*$/,


            // RFC 2396: characters reserved for delimiting URLs.
            // We actually just auto-escape these.
            delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


            // RFC 2396: characters not allowed for various reasons.
            unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


            // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
            autoEscape = ['\''].concat(unwise),

            // Characters that are never ever allowed in a hostname.
            // Note that any invalid chars are also handled, but these
            // are the ones that are *expected* to be seen, so we fast-path
            // them.
            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
            hostEndingChars = ['/', '?', '#'],
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
            hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,

            // protocols that can allow "unsafe" and "unwise" chars.
            unsafeProtocol = {
                'javascript': true,
                'javascript:': true
            },

            // protocols that never have a hostname.
            hostlessProtocol = {
                'javascript': true,
                'javascript:': true
            },

            // protocols that always contain a // bit.
            slashedProtocol = {
                'http': true,
                'https': true,
                'ftp': true,
                'gopher': true,
                'file': true,
                'http:': true,
                'https:': true,
                'ftp:': true,
                'gopher:': true,
                'file:': true
            },
            querystring = __webpack_require__(6);

        function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && isObject(url) && url instanceof Url) return url;

            var u = new Url();
            u.parse(url, parseQueryString, slashesDenoteHost);
            return u;
        }

        Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
            if (!isString(url)) {
                throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === 'undefined' ? 'undefined' : _typeof(url)));
            }

            var rest = url;

            // trim before proceeding.
            // This is to support parse stuff like "  http://foo.com  \n"
            rest = rest.trim();

            var proto = protocolPattern.exec(rest);
            if (proto) {
                proto = proto[0];
                var lowerProto = proto.toLowerCase();
                this.protocol = lowerProto;
                rest = rest.substr(proto.length);
            }

            // figure out if it's got a host
            // user@server is *always* interpreted as a hostname, and url
            // resolution will treat //foo/bar as host=foo,path=bar because that's
            // how the browser resolves relative URLs.
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = rest.substr(0, 2) === '//';
                if (slashes && !(proto && hostlessProtocol[proto])) {
                    rest = rest.substr(2);
                    this.slashes = true;
                }
            }

            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

                // there's a hostname.
                // the first instance of /, ?, ;, or # ends the host.
                //
                // If there is an @ in the hostname, then non-host chars *are* allowed
                // to the left of the last @ sign, unless some host-ending character
                // comes *before* the @-sign.
                // URLs are obnoxious.
                //
                // ex:
                // http://a@b@c/ => user:a@b host:c
                // http://a@b?@c => user:a host:c path:/?@c

                // v0.12 TODO(isaacs): This is not quite how Chrome does things.
                // Review our test case against browsers more comprehensively.

                // find the first instance of any hostEndingChars
                var hostEnd = -1;
                for (var i = 0; i < hostEndingChars.length; i++) {
                    var hec = rest.indexOf(hostEndingChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
                }

                // at this point, either we have an explicit point where the
                // auth portion cannot go past, or the last @ char is the decider.
                var auth, atSign;
                if (hostEnd === -1) {
                    // atSign can be anywhere.
                    atSign = rest.lastIndexOf('@');
                } else {
                    // atSign must be in auth portion.
                    // http://a@b/c@d => host:b auth:a path:/c@d
                    atSign = rest.lastIndexOf('@', hostEnd);
                }

                // Now we have a portion which is definitely the auth.
                // Pull that off.
                if (atSign !== -1) {
                    auth = rest.slice(0, atSign);
                    rest = rest.slice(atSign + 1);
                    this.auth = decodeURIComponent(auth);
                }

                // the host is the remaining to the left of the first non-host char
                hostEnd = -1;
                for (var i = 0; i < nonHostChars.length; i++) {
                    var hec = rest.indexOf(nonHostChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
                }
                // if we still have not hit it, then the entire thing is a host.
                if (hostEnd === -1) hostEnd = rest.length;

                this.host = rest.slice(0, hostEnd);
                rest = rest.slice(hostEnd);

                // pull out port.
                this.parseHost();

                // we've indicated that there is a hostname,
                // so even if it's empty, it has to be present.
                this.hostname = this.hostname || '';

                // if hostname begins with [ and ends with ]
                // assume that it's an IPv6 address.
                var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

                // validate a little.
                if (!ipv6Hostname) {
                    var hostparts = this.hostname.split(/\./);
                    for (var i = 0, l = hostparts.length; i < l; i++) {
                        var part = hostparts[i];
                        if (!part) continue;
                        if (!part.match(hostnamePartPattern)) {
                            var newpart = '';
                            for (var j = 0, k = part.length; j < k; j++) {
                                if (part.charCodeAt(j) > 127) {
                                    // we replace non-ASCII char with a temporary placeholder
                                    // we need this to make sure size of hostname is not
                                    // broken by replacing non-ASCII by nothing
                                    newpart += 'x';
                                } else {
                                    newpart += part[j];
                                }
                            }
                            // we test again with ASCII char only
                            if (!newpart.match(hostnamePartPattern)) {
                                var validParts = hostparts.slice(0, i);
                                var notHost = hostparts.slice(i + 1);
                                var bit = part.match(hostnamePartStart);
                                if (bit) {
                                    validParts.push(bit[1]);
                                    notHost.unshift(bit[2]);
                                }
                                if (notHost.length) {
                                    rest = '/' + notHost.join('.') + rest;
                                }
                                this.hostname = validParts.join('.');
                                break;
                            }
                        }
                    }
                }

                if (this.hostname.length > hostnameMaxLen) {
                    this.hostname = '';
                } else {
                    // hostnames are always lower case.
                    this.hostname = this.hostname.toLowerCase();
                }

                if (!ipv6Hostname) {
                    // IDNA Support: Returns a puny coded representation of "domain".
                    // It only converts the part of the domain name that
                    // has non ASCII characters. I.e. it dosent matter if
                    // you call it with a domain that already is in ASCII.
                    var domainArray = this.hostname.split('.');
                    var newOut = [];
                    for (var i = 0; i < domainArray.length; ++i) {
                        var s = domainArray[i];
                        newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
                    }
                    this.hostname = newOut.join('.');
                }

                var p = this.port ? ':' + this.port : '';
                var h = this.hostname || '';
                this.host = h + p;
                this.href += this.host;

                // strip [ and ] from the hostname
                // the host field still retains them, though
                if (ipv6Hostname) {
                    this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                    if (rest[0] !== '/') {
                        rest = '/' + rest;
                    }
                }
            }

            // now rest is set to the post-host stuff.
            // chop off any delim chars.
            if (!unsafeProtocol[lowerProto]) {

                // First, make 100% sure that any "autoEscape" chars get
                // escaped, even if encodeURIComponent doesn't think they
                // need to be.
                for (var i = 0, l = autoEscape.length; i < l; i++) {
                    var ae = autoEscape[i];
                    var esc = encodeURIComponent(ae);
                    if (esc === ae) {
                        esc = escape(ae);
                    }
                    rest = rest.split(ae).join(esc);
                }
            }

            // chop off from the tail first.
            var hash = rest.indexOf('#');
            if (hash !== -1) {
                // got a fragment string.
                this.hash = rest.substr(hash);
                rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf('?');
            if (qm !== -1) {
                this.search = rest.substr(qm);
                this.query = rest.substr(qm + 1);
                if (parseQueryString) {
                    this.query = querystring.parse(this.query);
                }
                rest = rest.slice(0, qm);
            } else if (parseQueryString) {
                // no query string, but parseQueryString still requested
                this.search = '';
                this.query = {};
            }
            if (rest) this.pathname = rest;
            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                this.pathname = '/';
            }

            //to support http.request
            if (this.pathname || this.search) {
                var p = this.pathname || '';
                var s = this.search || '';
                this.path = p + s;
            }

            // finally, reconstruct the href based on what has been validated.
            this.href = this.format();
            return this;
        };

        // format a parsed object into a url string
        function urlFormat(obj) {
            // ensure it's an object, and not a string url.
            // If it's an obj, this is a no-op.
            // this way, you can call url_format() on strings
            // to clean up potentially wonky urls.
            if (isString(obj)) obj = urlParse(obj);
            if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
            return obj.format();
        }

        Url.prototype.format = function () {
            var auth = this.auth || '';
            if (auth) {
                auth = encodeURIComponent(auth);
                auth = auth.replace(/%3A/i, ':');
                auth += '@';
            }

            var protocol = this.protocol || '',
                pathname = this.pathname || '',
                hash = this.hash || '',
                host = false,
                query = '';

            if (this.host) {
                host = auth + this.host;
            } else if (this.hostname) {
                host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
                if (this.port) {
                    host += ':' + this.port;
                }
            }

            if (this.query && isObject(this.query) && Object.keys(this.query).length) {
                query = querystring.stringify(this.query);
            }

            var search = this.search || query && '?' + query || '';

            if (protocol && protocol.substr(-1) !== ':') protocol += ':';

            // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
            // unless they had them to begin with.
            if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
                host = '//' + (host || '');
                if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
            } else if (!host) {
                host = '';
            }

            if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
            if (search && search.charAt(0) !== '?') search = '?' + search;

            pathname = pathname.replace(/[?#]/g, function (match) {
                return encodeURIComponent(match);
            });
            search = search.replace('#', '%23');

            return protocol + host + pathname + search + hash;
        };

        function urlResolve(source, relative) {
            return urlParse(source, false, true).resolve(relative);
        }

        Url.prototype.resolve = function (relative) {
            return this.resolveObject(urlParse(relative, false, true)).format();
        };

        function urlResolveObject(source, relative) {
            if (!source) return relative;
            return urlParse(source, false, true).resolveObject(relative);
        }

        Url.prototype.resolveObject = function (relative) {
            if (isString(relative)) {
                var rel = new Url();
                rel.parse(relative, false, true);
                relative = rel;
            }

            var result = new Url();
            Object.keys(this).forEach(function (k) {
                result[k] = this[k];
            }, this);

            // hash is always overridden, no matter what.
            // even href="" will remove it.
            result.hash = relative.hash;

            // if the relative url is empty, then there's nothing left to do here.
            if (relative.href === '') {
                result.href = result.format();
                return result;
            }

            // hrefs like //foo/bar always cut to the protocol.
            if (relative.slashes && !relative.protocol) {
                // take everything except the protocol from relative
                Object.keys(relative).forEach(function (k) {
                    if (k !== 'protocol') result[k] = relative[k];
                });

                //urlParse appends trailing / to urls like http://www.example.com
                if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                    result.path = result.pathname = '/';
                }

                result.href = result.format();
                return result;
            }

            if (relative.protocol && relative.protocol !== result.protocol) {
                // if it's a known url protocol, then changing
                // the protocol does weird things
                // first, if it's not file:, then we MUST have a host,
                // and if there was a path
                // to begin with, then we MUST have a path.
                // if it is file:, then the host is dropped,
                // because that's known to be hostless.
                // anything else is assumed to be absolute.
                if (!slashedProtocol[relative.protocol]) {
                    Object.keys(relative).forEach(function (k) {
                        result[k] = relative[k];
                    });
                    result.href = result.format();
                    return result;
                }

                result.protocol = relative.protocol;
                if (!relative.host && !hostlessProtocol[relative.protocol]) {
                    var relPath = (relative.pathname || '').split('/');
                    while (relPath.length && !(relative.host = relPath.shift())) {}
                    if (!relative.host) relative.host = '';
                    if (!relative.hostname) relative.hostname = '';
                    if (relPath[0] !== '') relPath.unshift('');
                    if (relPath.length < 2) relPath.unshift('');
                    result.pathname = relPath.join('/');
                } else {
                    result.pathname = relative.pathname;
                }
                result.search = relative.search;
                result.query = relative.query;
                result.host = relative.host || '';
                result.auth = relative.auth;
                result.hostname = relative.hostname || relative.host;
                result.port = relative.port;
                // to support http.request
                if (result.pathname || result.search) {
                    var p = result.pathname || '';
                    var s = result.search || '';
                    result.path = p + s;
                }
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
            }

            var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
                isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
                mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
                removeAllDots = mustEndAbs,
                srcPath = result.pathname && result.pathname.split('/') || [],
                relPath = relative.pathname && relative.pathname.split('/') || [],
                psychotic = result.protocol && !slashedProtocol[result.protocol];

            // if the url is a non-slashed url, then relative
            // links like ../.. should be able
            // to crawl up to the hostname, as well.  This is strange.
            // result.protocol has already been set by now.
            // Later on, put the first path part into the host field.
            if (psychotic) {
                result.hostname = '';
                result.port = null;
                if (result.host) {
                    if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
                }
                result.host = '';
                if (relative.protocol) {
                    relative.hostname = null;
                    relative.port = null;
                    if (relative.host) {
                        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
                    }
                    relative.host = null;
                }
                mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
            }

            if (isRelAbs) {
                // it's absolute.
                result.host = relative.host || relative.host === '' ? relative.host : result.host;
                result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
                result.search = relative.search;
                result.query = relative.query;
                srcPath = relPath;
                // fall through to the dot-handling below.
            } else if (relPath.length) {
                // it's relative
                // throw away the existing file, and take the new path instead.
                if (!srcPath) srcPath = [];
                srcPath.pop();
                srcPath = srcPath.concat(relPath);
                result.search = relative.search;
                result.query = relative.query;
            } else if (!isNullOrUndefined(relative.search)) {
                // just pull out the search.
                // like href='?foo'.
                // Put this after the other two cases because it simplifies the booleans
                if (psychotic) {
                    result.hostname = result.host = srcPath.shift();
                    //occationaly the auth can get stuck only in host
                    //this especialy happens in cases like
                    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }
                result.search = relative.search;
                result.query = relative.query;
                //to support http.request
                if (!isNull(result.pathname) || !isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
                }
                result.href = result.format();
                return result;
            }

            if (!srcPath.length) {
                // no path at all.  easy.
                // we've already handled the other stuff above.
                result.pathname = null;
                //to support http.request
                if (result.search) {
                    result.path = '/' + result.search;
                } else {
                    result.path = null;
                }
                result.href = result.format();
                return result;
            }

            // if a url ENDs in . or .., then it must get a trailing slash.
            // however, if it ends in anything else non-slashy,
            // then it must NOT get a trailing slash.
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = (result.host || relative.host) && (last === '.' || last === '..') || last === '';

            // strip single dots, resolve double dots to parent dir
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
                last = srcPath[i];
                if (last == '.') {
                    srcPath.splice(i, 1);
                } else if (last === '..') {
                    srcPath.splice(i, 1);
                    up++;
                } else if (up) {
                    srcPath.splice(i, 1);
                    up--;
                }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (!mustEndAbs && !removeAllDots) {
                for (; up--; up) {
                    srcPath.unshift('..');
                }
            }

            if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
                srcPath.unshift('');
            }

            if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
                srcPath.push('');
            }

            var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

            // put the host back
            if (psychotic) {
                result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
                //occationaly the auth can get stuck only in host
                //this especialy happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }

            mustEndAbs = mustEndAbs || result.host && srcPath.length;

            if (mustEndAbs && !isAbsolute) {
                srcPath.unshift('');
            }

            if (!srcPath.length) {
                result.pathname = null;
                result.path = null;
            } else {
                result.pathname = srcPath.join('/');
            }

            //to support request.http
            if (!isNull(result.pathname) || !isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
            }
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        };

        Url.prototype.parseHost = function () {
            var host = this.host;
            var port = portPattern.exec(host);
            if (port) {
                port = port[0];
                if (port !== ':') {
                    this.port = port.substr(1);
                }
                host = host.substr(0, host.length - port.length);
            }
            if (host) this.hostname = host;
        };

        function isString(arg) {
            return typeof arg === "string";
        }

        function isObject(arg) {
            return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
        }

        function isNull(arg) {
            return arg === null;
        }
        function isNullOrUndefined(arg) {
            return arg == null;
        }

        /***/ },
    /* 3 */
    /***/ function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            /*! https://mths.be/punycode v1.3.2 by @mathias */
            ;(function (root) {

                /** Detect free variables */
                var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
                var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
                var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                    root = freeGlobal;
                }

                /**
                 * The `punycode` object.
                 * @name punycode
                 * @type Object
                 */
                var punycode,


                    /** Highest positive signed 32-bit float value */
                    maxInt = 2147483647,
                    // aka. 0x7FFFFFFF or 2^31-1

                    /** Bootstring parameters */
                    base = 36,
                    tMin = 1,
                    tMax = 26,
                    skew = 38,
                    damp = 700,
                    initialBias = 72,
                    initialN = 128,
                    // 0x80
                    delimiter = '-',
                    // '\x2D'

                    /** Regular expressions */
                    regexPunycode = /^xn--/,
                    regexNonASCII = /[^\x20-\x7E]/,
                    // unprintable ASCII chars + non-ASCII chars
                    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
                    // RFC 3490 separators

                    /** Error messages */
                    errors = {
                        'overflow': 'Overflow: input needs wider integers to process',
                        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                        'invalid-input': 'Invalid input'
                    },


                    /** Convenience shortcuts */
                    baseMinusTMin = base - tMin,
                    floor = Math.floor,
                    stringFromCharCode = String.fromCharCode,


                    /** Temporary variable */
                    key;

                /*--------------------------------------------------------------------------*/

                /**
                 * A generic error utility function.
                 * @private
                 * @param {String} type The error type.
                 * @returns {Error} Throws a `RangeError` with the applicable error message.
                 */
                function error(type) {
                    throw RangeError(errors[type]);
                }

                /**
                 * A generic `Array#map` utility function.
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} callback The function that gets called for every array
                 * item.
                 * @returns {Array} A new array of values returned by the callback function.
                 */
                function map(array, fn) {
                    var length = array.length;
                    var result = [];
                    while (length--) {
                        result[length] = fn(array[length]);
                    }
                    return result;
                }

                /**
                 * A simple `Array#map`-like wrapper to work with domain name strings or email
                 * addresses.
                 * @private
                 * @param {String} domain The domain name or email address.
                 * @param {Function} callback The function that gets called for every
                 * character.
                 * @returns {Array} A new string of characters returned by the callback
                 * function.
                 */
                function mapDomain(string, fn) {
                    var parts = string.split('@');
                    var result = '';
                    if (parts.length > 1) {
                        // In email addresses, only the domain name should be punycoded. Leave
                        // the local part (i.e. everything up to `@`) intact.
                        result = parts[0] + '@';
                        string = parts[1];
                    }
                    // Avoid `split(regex)` for IE8 compatibility. See #17.
                    string = string.replace(regexSeparators, '\x2E');
                    var labels = string.split('.');
                    var encoded = map(labels, fn).join('.');
                    return result + encoded;
                }

                /**
                 * Creates an array containing the numeric code points of each Unicode
                 * character in the string. While JavaScript uses UCS-2 internally,
                 * this function will convert a pair of surrogate halves (each of which
                 * UCS-2 exposes as separate characters) into a single code point,
                 * matching UTF-16.
                 * @see `punycode.ucs2.encode`
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode.ucs2
                 * @name decode
                 * @param {String} string The Unicode input string (UCS-2).
                 * @returns {Array} The new array of code points.
                 */
                function ucs2decode(string) {
                    var output = [],
                        counter = 0,
                        length = string.length,
                        value,
                        extra;
                    while (counter < length) {
                        value = string.charCodeAt(counter++);
                        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                            // high surrogate, and there is a next character
                            extra = string.charCodeAt(counter++);
                            if ((extra & 0xFC00) == 0xDC00) {
                                // low surrogate
                                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                            } else {
                                // unmatched surrogate; only append this code unit, in case the next
                                // code unit is the high surrogate of a surrogate pair
                                output.push(value);
                                counter--;
                            }
                        } else {
                            output.push(value);
                        }
                    }
                    return output;
                }

                /**
                 * Creates a string based on an array of numeric code points.
                 * @see `punycode.ucs2.decode`
                 * @memberOf punycode.ucs2
                 * @name encode
                 * @param {Array} codePoints The array of numeric code points.
                 * @returns {String} The new Unicode string (UCS-2).
                 */
                function ucs2encode(array) {
                    return map(array, function (value) {
                        var output = '';
                        if (value > 0xFFFF) {
                            value -= 0x10000;
                            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                            value = 0xDC00 | value & 0x3FF;
                        }
                        output += stringFromCharCode(value);
                        return output;
                    }).join('');
                }

                /**
                 * Converts a basic code point into a digit/integer.
                 * @see `digitToBasic()`
                 * @private
                 * @param {Number} codePoint The basic numeric code point value.
                 * @returns {Number} The numeric value of a basic code point (for use in
                 * representing integers) in the range `0` to `base - 1`, or `base` if
                 * the code point does not represent a value.
                 */
                function basicToDigit(codePoint) {
                    if (codePoint - 48 < 10) {
                        return codePoint - 22;
                    }
                    if (codePoint - 65 < 26) {
                        return codePoint - 65;
                    }
                    if (codePoint - 97 < 26) {
                        return codePoint - 97;
                    }
                    return base;
                }

                /**
                 * Converts a digit/integer into a basic code point.
                 * @see `basicToDigit()`
                 * @private
                 * @param {Number} digit The numeric value of a basic code point.
                 * @returns {Number} The basic code point whose value (when used for
                 * representing integers) is `digit`, which needs to be in the range
                 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                 * used; else, the lowercase form is used. The behavior is undefined
                 * if `flag` is non-zero and `digit` has no uppercase form.
                 */
                function digitToBasic(digit, flag) {
                    //  0..25 map to ASCII a..z or A..Z
                    // 26..35 map to ASCII 0..9
                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }

                /**
                 * Bias adaptation function as per section 3.4 of RFC 3492.
                 * http://tools.ietf.org/html/rfc3492#section-3.4
                 * @private
                 */
                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                        delta = floor(delta / baseMinusTMin);
                    }
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                }

                /**
                 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                 * symbols.
                 * @memberOf punycode
                 * @param {String} input The Punycode string of ASCII-only symbols.
                 * @returns {String} The resulting string of Unicode symbols.
                 */
                function decode(input) {
                    // Don't use UCS-2
                    var output = [],
                        inputLength = input.length,
                        out,
                        i = 0,
                        n = initialN,
                        bias = initialBias,
                        basic,
                        j,
                        index,
                        oldi,
                        w,
                        k,
                        digit,
                        t,

                        /** Cached calculation results */
                        baseMinusT;

                    // Handle the basic code points: let `basic` be the number of input code
                    // points before the last delimiter, or `0` if there is none, then copy
                    // the first basic code points to the output.

                    basic = input.lastIndexOf(delimiter);
                    if (basic < 0) {
                        basic = 0;
                    }

                    for (j = 0; j < basic; ++j) {
                        // if it's not a basic code point
                        if (input.charCodeAt(j) >= 0x80) {
                            error('not-basic');
                        }
                        output.push(input.charCodeAt(j));
                    }

                    // Main decoding loop: start just after the last delimiter if any basic code
                    // points were copied; start at the beginning otherwise.

                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                        // `index` is the index of the next character to be consumed.
                        // Decode a generalized variable-length integer into `delta`,
                        // which gets added to `i`. The overflow checking is easier
                        // if we increase `i` as we go, then subtract off its starting
                        // value at the end to obtain `delta`.
                        for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                            if (index >= inputLength) {
                                error('invalid-input');
                            }

                            digit = basicToDigit(input.charCodeAt(index++));

                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                error('overflow');
                            }

                            i += digit * w;
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                            if (digit < t) {
                                break;
                            }

                            baseMinusT = base - t;
                            if (w > floor(maxInt / baseMinusT)) {
                                error('overflow');
                            }

                            w *= baseMinusT;
                        }

                        out = output.length + 1;
                        bias = adapt(i - oldi, out, oldi == 0);

                        // `i` was supposed to wrap around from `out` to `0`,
                        // incrementing `n` each time, so we'll fix that now:
                        if (floor(i / out) > maxInt - n) {
                            error('overflow');
                        }

                        n += floor(i / out);
                        i %= out;

                        // Insert `n` at position `i` of the output
                        output.splice(i++, 0, n);
                    }

                    return ucs2encode(output);
                }

                /**
                 * Converts a string of Unicode symbols (e.g. a domain name label) to a
                 * Punycode string of ASCII-only symbols.
                 * @memberOf punycode
                 * @param {String} input The string of Unicode symbols.
                 * @returns {String} The resulting Punycode string of ASCII-only symbols.
                 */
                function encode(input) {
                    var n,
                        delta,
                        handledCPCount,
                        basicLength,
                        bias,
                        j,
                        m,
                        q,
                        k,
                        t,
                        currentValue,
                        output = [],

                        /** `inputLength` will hold the number of code points in `input`. */
                        inputLength,

                        /** Cached calculation results */
                        handledCPCountPlusOne,
                        baseMinusT,
                        qMinusT;

                    // Convert the input in UCS-2 to Unicode
                    input = ucs2decode(input);

                    // Cache the length
                    inputLength = input.length;

                    // Initialize the state
                    n = initialN;
                    delta = 0;
                    bias = initialBias;

                    // Handle the basic code points
                    for (j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue < 0x80) {
                            output.push(stringFromCharCode(currentValue));
                        }
                    }

                    handledCPCount = basicLength = output.length;

                    // `handledCPCount` is the number of code points that have been handled;
                    // `basicLength` is the number of basic code points.

                    // Finish the basic string - if it is not empty - with a delimiter
                    if (basicLength) {
                        output.push(delimiter);
                    }

                    // Main encoding loop:
                    while (handledCPCount < inputLength) {

                        // All non-basic code points < n have been handled already. Find the next
                        // larger one:
                        for (m = maxInt, j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue >= n && currentValue < m) {
                                m = currentValue;
                            }
                        }

                        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                        // but guard against overflow
                        handledCPCountPlusOne = handledCPCount + 1;
                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                            error('overflow');
                        }

                        delta += (m - n) * handledCPCountPlusOne;
                        n = m;

                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];

                            if (currentValue < n && ++delta > maxInt) {
                                error('overflow');
                            }

                            if (currentValue == n) {
                                // Represent delta as a generalized variable-length integer
                                for (q = delta, k = base;; /* no condition */k += base) {
                                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                    if (q < t) {
                                        break;
                                    }
                                    qMinusT = q - t;
                                    baseMinusT = base - t;
                                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                    q = floor(qMinusT / baseMinusT);
                                }

                                output.push(stringFromCharCode(digitToBasic(q, 0)));
                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                delta = 0;
                                ++handledCPCount;
                            }
                        }

                        ++delta;
                        ++n;
                    }
                    return output.join('');
                }

                /**
                 * Converts a Punycode string representing a domain name or an email address
                 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                 * it doesn't matter if you call it on a string that has already been
                 * converted to Unicode.
                 * @memberOf punycode
                 * @param {String} input The Punycoded domain name or email address to
                 * convert to Unicode.
                 * @returns {String} The Unicode representation of the given Punycode
                 * string.
                 */
                function toUnicode(input) {
                    return mapDomain(input, function (string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                }

                /**
                 * Converts a Unicode string representing a domain name or an email address to
                 * Punycode. Only the non-ASCII parts of the domain name will be converted,
                 * i.e. it doesn't matter if you call it with a domain that's already in
                 * ASCII.
                 * @memberOf punycode
                 * @param {String} input The domain name or email address to convert, as a
                 * Unicode string.
                 * @returns {String} The Punycode representation of the given domain name or
                 * email address.
                 */
                function toASCII(input) {
                    return mapDomain(input, function (string) {
                        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
                    });
                }

                /*--------------------------------------------------------------------------*/

                /** Define the public API */
                punycode = {
                    /**
                     * A string representing the current Punycode.js version number.
                     * @memberOf punycode
                     * @type String
                     */
                    'version': '1.3.2',
                    /**
                     * An object of methods to convert from JavaScript's internal character
                     * representation (UCS-2) to Unicode code points, and back.
                     * @see <https://mathiasbynens.be/notes/javascript-encoding>
                     * @memberOf punycode
                     * @type Object
                     */
                    'ucs2': {
                        'decode': ucs2decode,
                        'encode': ucs2encode
                    },
                    'decode': decode,
                    'encode': encode,
                    'toASCII': toASCII,
                    'toUnicode': toUnicode
                };

                /** Expose `punycode` */
                // Some AMD build optimizers, like r.js, check for specific condition patterns
                // like the following:
                if ("function" == 'function' && _typeof(__webpack_require__(5)) == 'object' && __webpack_require__(5)) {
                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                        return punycode;
                    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else if (freeExports && freeModule) {
                    if (module.exports == freeExports) {
                        // in Node.js or RingoJS v0.8.0+
                        freeModule.exports = punycode;
                    } else {
                        // in Narwhal or RingoJS v0.7.0-
                        for (key in punycode) {
                            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                        }
                    }
                } else {
                    // in Rhino or a web browser
                    root.punycode = punycode;
                }
            })(undefined);
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module), (function() { return this; }())))

        /***/ },
    /* 4 */
    /***/ function(module, exports) {

        "use strict";

        module.exports = function (module) {
            if (!module.webpackPolyfill) {
                module.deprecate = function () {};
                module.paths = [];
                // module.parent = undefined by default
                module.children = [];
                module.webpackPolyfill = 1;
            }
            return module;
        };

        /***/ },
    /* 5 */
    /***/ function(module, exports) {

        /* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

            /* WEBPACK VAR INJECTION */}.call(exports, {}))

        /***/ },
    /* 6 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        exports.decode = exports.parse = __webpack_require__(7);
        exports.encode = exports.stringify = __webpack_require__(8);

        /***/ },
    /* 7 */
    /***/ function(module, exports) {

        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        'use strict';

        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707

        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }

        module.exports = function (qs, sep, eq, options) {
            sep = sep || '&';
            eq = eq || '=';
            var obj = {};

            if (typeof qs !== 'string' || qs.length === 0) {
                return obj;
            }

            var regexp = /\+/g;
            qs = qs.split(sep);

            var maxKeys = 1000;
            if (options && typeof options.maxKeys === 'number') {
                maxKeys = options.maxKeys;
            }

            var len = qs.length;
            // maxKeys <= 0 means that we should not limit keys count
            if (maxKeys > 0 && len > maxKeys) {
                len = maxKeys;
            }

            for (var i = 0; i < len; ++i) {
                var x = qs[i].replace(regexp, '%20'),
                    idx = x.indexOf(eq),
                    kstr,
                    vstr,
                    k,
                    v;

                if (idx >= 0) {
                    kstr = x.substr(0, idx);
                    vstr = x.substr(idx + 1);
                } else {
                    kstr = x;
                    vstr = '';
                }

                k = decodeURIComponent(kstr);
                v = decodeURIComponent(vstr);

                if (!hasOwnProperty(obj, k)) {
                    obj[k] = v;
                } else if (Array.isArray(obj[k])) {
                    obj[k].push(v);
                } else {
                    obj[k] = [obj[k], v];
                }
            }

            return obj;
        };

        /***/ },
    /* 8 */
    /***/ function(module, exports) {

        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        var stringifyPrimitive = function stringifyPrimitive(v) {
            switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
                case 'string':
                    return v;

                case 'boolean':
                    return v ? 'true' : 'false';

                case 'number':
                    return isFinite(v) ? v : '';

                default:
                    return '';
            }
        };

        module.exports = function (obj, sep, eq, name) {
            sep = sep || '&';
            eq = eq || '=';
            if (obj === null) {
                obj = undefined;
            }

            if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
                return Object.keys(obj).map(function (k) {
                    var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                    if (Array.isArray(obj[k])) {
                        return obj[k].map(function (v) {
                            return ks + encodeURIComponent(stringifyPrimitive(v));
                        }).join(sep);
                    } else {
                        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                    }
                }).join(sep);
            }

            if (!name) return '';
            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };

        /***/ },
    /* 9 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            var transportList = __webpack_require__(10);

            module.exports = __webpack_require__(56)(transportList);

            // TODO can't get rid of this until all servers do
            if ('_sockjs_onload' in global) {
                setTimeout(global._sockjs_onload, 1);
            }
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 10 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        module.exports = [
            // streaming transports
            __webpack_require__(11), __webpack_require__(28), __webpack_require__(38), __webpack_require__(40), __webpack_require__(43)(__webpack_require__(40))

            // polling transports
            , __webpack_require__(49), __webpack_require__(43)(__webpack_require__(49)), __webpack_require__(51), __webpack_require__(52), __webpack_require__(43)(__webpack_require__(51)), __webpack_require__(53)];

        /***/ },
    /* 11 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var utils = __webpack_require__(13),
                urlUtils = __webpack_require__(16),
                inherits = __webpack_require__(24),
                EventEmitter = __webpack_require__(25).EventEmitter,
                WebsocketDriver = __webpack_require__(27);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:websocket');
            }

            function WebSocketTransport(transUrl, ignore, options) {
                if (!WebSocketTransport.enabled()) {
                    throw new Error('Transport created when disabled');
                }

                EventEmitter.call(this);
                debug('constructor', transUrl);

                var self = this;
                var url = urlUtils.addPath(transUrl, '/websocket');
                if (url.slice(0, 5) === 'https') {
                    url = 'wss' + url.slice(5);
                } else {
                    url = 'ws' + url.slice(4);
                }
                this.url = url;

                this.ws = new WebsocketDriver(this.url, [], options);
                this.ws.onmessage = function (e) {
                    debug('message event', e.data);
                    self.emit('message', e.data);
                };
                // Firefox has an interesting bug. If a websocket connection is
                // created after onunload, it stays alive even when user
                // navigates away from the page. In such situation let's lie -
                // let's not open the ws connection at all. See:
                // https://github.com/sockjs/sockjs-client/issues/28
                // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
                this.unloadRef = utils.unloadAdd(function () {
                    debug('unload');
                    self.ws.close();
                });
                this.ws.onclose = function (e) {
                    debug('close event', e.code, e.reason);
                    self.emit('close', e.code, e.reason);
                    self._cleanup();
                };
                this.ws.onerror = function (e) {
                    debug('error event', e);
                    self.emit('close', 1006, 'WebSocket connection broken');
                    self._cleanup();
                };
            }

            inherits(WebSocketTransport, EventEmitter);

            WebSocketTransport.prototype.send = function (data) {
                var msg = '[' + data + ']';
                debug('send', msg);
                this.ws.send(msg);
            };

            WebSocketTransport.prototype.close = function () {
                debug('close');
                if (this.ws) {
                    this.ws.close();
                }
                this._cleanup();
            };

            WebSocketTransport.prototype._cleanup = function () {
                debug('_cleanup');
                var ws = this.ws;
                if (ws) {
                    ws.onmessage = ws.onclose = ws.onerror = null;
                }
                utils.unloadDel(this.unloadRef);
                this.unloadRef = this.ws = null;
                this.removeAllListeners();
            };

            WebSocketTransport.enabled = function () {
                debug('enabled');
                return !!WebsocketDriver;
            };
            WebSocketTransport.transportName = 'websocket';

            // In theory, ws should require 1 round trip. But in chrome, this is
            // not very stable over SSL. Most likely a ws connection requires a
            // separate SSL connection, in which case 2 round trips are an
            // absolute minumum.
            WebSocketTransport.roundTrips = 2;

            module.exports = WebSocketTransport;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 12 */
    /***/ function(module, exports) {

        'use strict';

        // shim for using process in browser

        var process = module.exports = {};
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }

        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = setTimeout(cleanUpNextTick);
            draining = true;

            var len = queue.length;
            while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            clearTimeout(timeout);
        }

        process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                setTimeout(drainQueue, 0);
            }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function () {
            this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;

        process.binding = function (name) {
            throw new Error('process.binding is not supported');
        };

        process.cwd = function () {
            return '/';
        };
        process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
        };
        process.umask = function () {
            return 0;
        };

        /***/ },
    /* 13 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            var random = __webpack_require__(14);

            var onUnload = {},
                afterUnload = false
                // detect google chrome packaged apps because they don't allow the 'unload' event
                ,
                isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime;

            module.exports = {
                attachEvent: function attachEvent(event, listener) {
                    if (typeof global.addEventListener !== 'undefined') {
                        global.addEventListener(event, listener, false);
                    } else if (global.document && global.attachEvent) {
                        // IE quirks.
                        // According to: http://stevesouders.com/misc/test-postmessage.php
                        // the message gets delivered only to 'document', not 'window'.
                        global.document.attachEvent('on' + event, listener);
                        // I get 'window' for ie8.
                        global.attachEvent('on' + event, listener);
                    }
                },

                detachEvent: function detachEvent(event, listener) {
                    if (typeof global.addEventListener !== 'undefined') {
                        global.removeEventListener(event, listener, false);
                    } else if (global.document && global.detachEvent) {
                        global.document.detachEvent('on' + event, listener);
                        global.detachEvent('on' + event, listener);
                    }
                },

                unloadAdd: function unloadAdd(listener) {
                    if (isChromePackagedApp) {
                        return null;
                    }

                    var ref = random.string(8);
                    onUnload[ref] = listener;
                    if (afterUnload) {
                        setTimeout(this.triggerUnloadCallbacks, 0);
                    }
                    return ref;
                },

                unloadDel: function unloadDel(ref) {
                    if (ref in onUnload) {
                        delete onUnload[ref];
                    }
                },

                triggerUnloadCallbacks: function triggerUnloadCallbacks() {
                    for (var ref in onUnload) {
                        onUnload[ref]();
                        delete onUnload[ref];
                    }
                }
            };

            var unloadTriggered = function unloadTriggered() {
                if (afterUnload) {
                    return;
                }
                afterUnload = true;
                module.exports.triggerUnloadCallbacks();
            };

            // 'unload' alone is not reliable in opera within an iframe, but we
            // can't use `beforeunload` as IE fires it on javascript: links.
            if (!isChromePackagedApp) {
                module.exports.attachEvent('unload', unloadTriggered);
            }
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 14 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        /* global crypto:true */

        var crypto = __webpack_require__(15);

        // This string has length 32, a power of 2, so the modulus doesn't introduce a
        // bias.
        var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
        module.exports = {
            string: function string(length) {
                var max = _randomStringChars.length;
                var bytes = crypto.randomBytes(length);
                var ret = [];
                for (var i = 0; i < length; i++) {
                    ret.push(_randomStringChars.substr(bytes[i] % max, 1));
                }
                return ret.join('');
            },

            number: function number(max) {
                return Math.floor(Math.random() * max);
            },

            numberString: function numberString(max) {
                var t = ('' + (max - 1)).length;
                var p = new Array(t + 1).join('0');
                return (p + this.number(max)).slice(-t);
            }
        };

        /***/ },
    /* 15 */
    /***/ function(module, exports) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            if (global.crypto && global.crypto.getRandomValues) {
                module.exports.randomBytes = function (length) {
                    var bytes = new Uint8Array(length);
                    global.crypto.getRandomValues(bytes);
                    return bytes;
                };
            } else {
                module.exports.randomBytes = function (length) {
                    var bytes = new Array(length);
                    for (var i = 0; i < length; i++) {
                        bytes[i] = Math.floor(Math.random() * 256);
                    }
                    return bytes;
                };
            }
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 16 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var URL = __webpack_require__(17);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:utils:url');
            }

            module.exports = {
                getOrigin: function getOrigin(url) {
                    if (!url) {
                        return null;
                    }

                    var p = new URL(url);
                    if (p.protocol === 'file:') {
                        return null;
                    }

                    var port = p.port;
                    if (!port) {
                        port = p.protocol === 'https:' ? '443' : '80';
                    }

                    return p.protocol + '//' + p.hostname + ':' + port;
                },

                isOriginEqual: function isOriginEqual(a, b) {
                    var res = this.getOrigin(a) === this.getOrigin(b);
                    debug('same', a, b, res);
                    return res;
                },

                isSchemeEqual: function isSchemeEqual(a, b) {
                    return a.split(':')[0] === b.split(':')[0];
                },

                addPath: function addPath(url, path) {
                    var qs = url.split('?');
                    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
                },

                addQuery: function addQuery(url, q) {
                    return url + (url.indexOf('?') === -1 ? '?' + q : '&' + q);
                }
            };
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 17 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        var required = __webpack_require__(18),
            lolcation = __webpack_require__(19),
            qs = __webpack_require__(20),
            relativere = /^\/(?!\/)/,
            protocolre = /^([a-z0-9.+-]+:)?(\/\/)?(.*)$/i; // actual protocol is first match

        /**
         * These are the parse instructions for the URL parsers, it informs the parser
         * about:
         *
         * 0. The char it Needs to parse, if it's a string it should be done using
         *    indexOf, RegExp using exec and NaN means set as current value.
         * 1. The property we should set when parsing this value.
         * 2. Indication if it's backwards or forward parsing, when set as number it's
         *    the value of extra chars that should be split off.
         * 3. Inherit from location if non existing in the parser.
         * 4. `toLowerCase` the resulting value.
         */
        var instructions = [['#', 'hash'], // Extract from the back.
            ['?', 'query'], // Extract from the back.
            ['/', 'pathname'], // Extract from the back.
            ['@', 'auth', 1], // Extract from the front.
            [NaN, 'host', undefined, 1, 1], // Set left over value.
            [/\:(\d+)$/, 'port'], // RegExp the back.
            [NaN, 'hostname', undefined, 1, 1] // Set left over.
        ];

        /**
         * @typedef ProtocolExtract
         * @type Object
         * @property {String} protocol Protocol matched in the URL, in lowercase
         * @property {Boolean} slashes Indicates whether the protocol is followed by double slash ("//")
         * @property {String} rest     Rest of the URL that is not part of the protocol
         */

        /**
         * Extract protocol information from a URL with/without double slash ("//")
         *
         * @param  {String} address   URL we want to extract from.
         * @return {ProtocolExtract}  Extracted information
         * @private
         */
        function extractProtocol(address) {
            var match = protocolre.exec(address);
            return {
                protocol: match[1] ? match[1].toLowerCase() : '',
                slashes: !!match[2],
                rest: match[3] ? match[3] : ''
            };
        }

        /**
         * The actual URL instance. Instead of returning an object we've opted-in to
         * create an actual constructor as it's much more memory efficient and
         * faster and it pleases my CDO.
         *
         * @constructor
         * @param {String} address URL we want to parse.
         * @param {Object|String} location Location defaults for relative paths.
         * @param {Boolean|Function} parser Parser for the query string.
         * @api public
         */
        function URL(address, location, parser) {
            if (!(this instanceof URL)) {
                return new URL(address, location, parser);
            }

            var relative = relativere.test(address),
                parse,
                instruction,
                index,
                key,
                type = typeof location === 'undefined' ? 'undefined' : _typeof(location),
                url = this,
                i = 0;

            //
            // The following if statements allows this module two have compatibility with
            // 2 different API:
            //
            // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
            //    where the boolean indicates that the query string should also be parsed.
            //
            // 2. The `URL` interface of the browser which accepts a URL, object as
            //    arguments. The supplied object will be used as default values / fall-back
            //    for relative paths.
            //
            if ('object' !== type && 'string' !== type) {
                parser = location;
                location = null;
            }

            if (parser && 'function' !== typeof parser) {
                parser = qs.parse;
            }

            location = lolcation(location);

            // extract protocol information before running the instructions
            var extracted = extractProtocol(address);
            url.protocol = extracted.protocol || location.protocol || '';
            url.slashes = extracted.slashes || location.slashes;
            address = extracted.rest;

            for (; i < instructions.length; i++) {
                instruction = instructions[i];
                parse = instruction[0];
                key = instruction[1];

                if (parse !== parse) {
                    url[key] = address;
                } else if ('string' === typeof parse) {
                    if (~(index = address.indexOf(parse))) {
                        if ('number' === typeof instruction[2]) {
                            url[key] = address.slice(0, index);
                            address = address.slice(index + instruction[2]);
                        } else {
                            url[key] = address.slice(index);
                            address = address.slice(0, index);
                        }
                    }
                } else if (index = parse.exec(address)) {
                    url[key] = index[1];
                    address = address.slice(0, address.length - index[0].length);
                }

                url[key] = url[key] || (instruction[3] || 'port' === key && relative ? location[key] || '' : '');

                //
                // Hostname, host and protocol should be lowercased so they can be used to
                // create a proper `origin`.
                //
                if (instruction[4]) {
                    url[key] = url[key].toLowerCase();
                }
            }

            //
            // Also parse the supplied query string in to an object. If we're supplied
            // with a custom parser as function use that instead of the default build-in
            // parser.
            //
            if (parser) url.query = parser(url.query);

            //
            // We should not add port numbers if they are already the default port number
            // for a given protocol. As the host also contains the port number we're going
            // override it with the hostname which contains no port number.
            //
            if (!required(url.port, url.protocol)) {
                url.host = url.hostname;
                url.port = '';
            }

            //
            // Parse down the `auth` for the username and password.
            //
            url.username = url.password = '';
            if (url.auth) {
                instruction = url.auth.split(':');
                url.username = instruction[0] || '';
                url.password = instruction[1] || '';
            }

            //
            // The href is just the compiled result.
            //
            url.href = url.toString();
        }

        /**
         * This is convenience method for changing properties in the URL instance to
         * insure that they all propagate correctly.
         *
         * @param {String} prop          Property we need to adjust.
         * @param {Mixed} value          The newly assigned value.
         * @param {Boolean|Function} fn  When setting the query, it will be the function used to parse
         *                               the query.
         *                               When setting the protocol, double slash will be removed from
         *                               the final url if it is true.
         * @returns {URL}
         * @api public
         */
        URL.prototype.set = function set(part, value, fn) {
            var url = this;

            if ('query' === part) {
                if ('string' === typeof value && value.length) {
                    value = (fn || qs.parse)(value);
                }

                url[part] = value;
            } else if ('port' === part) {
                url[part] = value;

                if (!required(value, url.protocol)) {
                    url.host = url.hostname;
                    url[part] = '';
                } else if (value) {
                    url.host = url.hostname + ':' + value;
                }
            } else if ('hostname' === part) {
                url[part] = value;

                if (url.port) value += ':' + url.port;
                url.host = value;
            } else if ('host' === part) {
                url[part] = value;

                if (/\:\d+/.test(value)) {
                    value = value.split(':');
                    url.hostname = value[0];
                    url.port = value[1];
                }
            } else if ('protocol' === part) {
                url.protocol = value;
                url.slashes = !fn;
            } else {
                url[part] = value;
            }

            url.href = url.toString();
            return url;
        };

        /**
         * Transform the properties back in to a valid and full URL string.
         *
         * @param {Function} stringify Optional query stringify function.
         * @returns {String}
         * @api public
         */
        URL.prototype.toString = function toString(stringify) {
            if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

            var query,
                url = this,
                protocol = url.protocol;

            if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

            var result = protocol + (url.slashes ? '//' : '');

            if (url.username) {
                result += url.username;
                if (url.password) result += ':' + url.password;
                result += '@';
            }

            result += url.hostname;
            if (url.port) result += ':' + url.port;

            result += url.pathname;

            query = 'object' === _typeof(url.query) ? stringify(url.query) : url.query;
            if (query) result += '?' !== query.charAt(0) ? '?' + query : query;

            if (url.hash) result += url.hash;

            return result;
        };

        //
        // Expose the URL parser and some additional properties that might be useful for
        // others.
        //
        URL.qs = qs;
        URL.location = lolcation;
        module.exports = URL;

        /***/ },
    /* 18 */
    /***/ function(module, exports) {

        'use strict';

        /**
         * Check if we're required to add a port number.
         *
         * @see https://url.spec.whatwg.org/#default-port
         * @param {Number|String} port Port number we need to check
         * @param {String} protocol Protocol we need to check against.
         * @returns {Boolean} Is it a default port for the given protocol
         * @api private
         */

        module.exports = function required(port, protocol) {
            protocol = protocol.split(':')[0];
            port = +port;

            if (!port) return false;

            switch (protocol) {
                case 'http':
                case 'ws':
                    return port !== 80;

                case 'https':
                case 'wss':
                    return port !== 443;

                case 'ftp':
                    return port !== 21;

                case 'gopher':
                    return port !== 70;

                case 'file':
                    return false;
            }

            return port !== 0;
        };

        /***/ },
    /* 19 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

            /**
             * These properties should not be copied or inherited from. This is only needed
             * for all non blob URL's as a blob URL does not include a hash, only the
             * origin.
             *
             * @type {Object}
             * @private
             */
            var ignore = { hash: 1, query: 1 },
                URL;

            /**
             * The location object differs when your code is loaded through a normal page,
             * Worker or through a worker using a blob. And with the blobble begins the
             * trouble as the location object will contain the URL of the blob, not the
             * location of the page where our code is loaded in. The actual origin is
             * encoded in the `pathname` so we can thankfully generate a good "default"
             * location from it so we can generate proper relative URL's again.
             *
             * @param {Object|String} loc Optional default location object.
             * @returns {Object} lolcation object.
             * @api public
             */
            module.exports = function lolcation(loc) {
                loc = loc || global.location || {};
                URL = URL || __webpack_require__(17);

                var finaldestination = {},
                    type = typeof loc === 'undefined' ? 'undefined' : _typeof(loc),
                    key;

                if ('blob:' === loc.protocol) {
                    finaldestination = new URL(unescape(loc.pathname), {});
                } else if ('string' === type) {
                    finaldestination = new URL(loc, {});
                    for (key in ignore) {
                        delete finaldestination[key];
                    }
                } else if ('object' === type) {
                    for (key in loc) {
                        if (key in ignore) continue;
                        finaldestination[key] = loc[key];
                    }

                    if (finaldestination.slashes === undefined) {
                        finaldestination.slashes = slashes.test(loc.href);
                    }
                }

                return finaldestination;
            };
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 20 */
    /***/ function(module, exports) {

        'use strict';

        var has = Object.prototype.hasOwnProperty;

        /**
         * Simple query string parser.
         *
         * @param {String} query The query string that needs to be parsed.
         * @returns {Object}
         * @api public
         */
        function querystring(query) {
            var parser = /([^=?&]+)=([^&]*)/g,
                result = {},
                part;

            //
            // Little nifty parsing hack, leverage the fact that RegExp.exec increments
            // the lastIndex property so we can continue executing this loop until we've
            // parsed all results.
            //
            for (; part = parser.exec(query); result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])) {}

            return result;
        }

        /**
         * Transform a query string to an object.
         *
         * @param {Object} obj Object that should be transformed.
         * @param {String} prefix Optional prefix.
         * @returns {String}
         * @api public
         */
        function querystringify(obj, prefix) {
            prefix = prefix || '';

            var pairs = [];

            //
            // Optionally prefix with a '?' if needed
            //
            if ('string' !== typeof prefix) prefix = '?';

            for (var key in obj) {
                if (has.call(obj, key)) {
                    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));
                }
            }

            return pairs.length ? prefix + pairs.join('&') : '';
        }

        //
        // Expose the module.
        //
        exports.stringify = querystringify;
        exports.parse = querystring;

        /***/ },
    /* 21 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * This is the web browser implementation of `debug()`.
         *
         * Expose `debug()` as the module.
         */

        exports = module.exports = __webpack_require__(22);
        exports.log = log;
        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

        /**
         * Colors.
         */

        exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

        /**
         * Currently only WebKit-based Web Inspectors, Firefox >= v31,
         * and the Firebug extension (any Firefox version) are known
         * to support "%c" CSS customizations.
         *
         * TODO: add a `localStorage` variable to explicitly enable/disable colors
         */

        function useColors() {
            // is webkit? http://stackoverflow.com/a/16459606/376773
            return 'WebkitAppearance' in document.documentElement.style ||
                // is firebug? http://stackoverflow.com/a/398120/376773
                window.console && (console.firebug || console.exception && console.table) ||
                // is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
        }

        /**
         * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
         */

        exports.formatters.j = function (v) {
            return JSON.stringify(v);
        };

        /**
         * Colorize log arguments if enabled.
         *
         * @api public
         */

        function formatArgs() {
            var args = arguments;
            var useColors = this.useColors;

            args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

            if (!useColors) return args;

            var c = 'color: ' + this.color;
            args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

            // the final "%c" is somewhat tricky, because there could be other
            // arguments passed either before or after the %c, so we need to
            // figure out the correct index to insert the CSS into
            var index = 0;
            var lastC = 0;
            args[0].replace(/%[a-z%]/g, function (match) {
                if ('%%' === match) return;
                index++;
                if ('%c' === match) {
                    // we only are interested in the *last* %c
                    // (the user may have provided their own)
                    lastC = index;
                }
            });

            args.splice(lastC, 0, c);
            return args;
        }

        /**
         * Invokes `console.log()` when available.
         * No-op when `console.log` is not a "function".
         *
         * @api public
         */

        function log() {
            // this hackery is required for IE8/9, where
            // the `console.log` function doesn't have 'apply'
            return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }

        /**
         * Save `namespaces`.
         *
         * @param {String} namespaces
         * @api private
         */

        function save(namespaces) {
            try {
                if (null == namespaces) {
                    exports.storage.removeItem('debug');
                } else {
                    exports.storage.debug = namespaces;
                }
            } catch (e) {}
        }

        /**
         * Load `namespaces`.
         *
         * @return {String} returns the previously persisted debug modes
         * @api private
         */

        function load() {
            var r;
            try {
                r = exports.storage.debug;
            } catch (e) {}
            return r;
        }

        /**
         * Enable namespaces listed in `localStorage.debug` initially.
         */

        exports.enable(load());

        /**
         * Localstorage attempts to return the localstorage.
         *
         * This is necessary because safari throws
         * when a user disables cookies/localstorage
         * and you attempt to access it.
         *
         * @return {LocalStorage}
         * @api private
         */

        function localstorage() {
            try {
                return window.localStorage;
            } catch (e) {}
        }

        /***/ },
    /* 22 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        /**
         * This is the common logic for both the Node.js and web browser
         * implementations of `debug()`.
         *
         * Expose `debug()` as the module.
         */

        exports = module.exports = debug;
        exports.coerce = coerce;
        exports.disable = disable;
        exports.enable = enable;
        exports.enabled = enabled;
        exports.humanize = __webpack_require__(23);

        /**
         * The currently active debug mode names, and names to skip.
         */

        exports.names = [];
        exports.skips = [];

        /**
         * Map of special "%n" handling functions, for the debug "format" argument.
         *
         * Valid key names are a single, lowercased letter, i.e. "n".
         */

        exports.formatters = {};

        /**
         * Previously assigned color.
         */

        var prevColor = 0;

        /**
         * Previous log timestamp.
         */

        var prevTime;

        /**
         * Select a color.
         *
         * @return {Number}
         * @api private
         */

        function selectColor() {
            return exports.colors[prevColor++ % exports.colors.length];
        }

        /**
         * Create a debugger with the given `namespace`.
         *
         * @param {String} namespace
         * @return {Function}
         * @api public
         */

        function debug(namespace) {

            // define the `disabled` version
            function disabled() {}
            disabled.enabled = false;

            // define the `enabled` version
            function enabled() {

                var self = enabled;

                // set `diff` timestamp
                var curr = +new Date();
                var ms = curr - (prevTime || curr);
                self.diff = ms;
                self.prev = prevTime;
                self.curr = curr;
                prevTime = curr;

                // add the `color` if not set
                if (null == self.useColors) self.useColors = exports.useColors();
                if (null == self.color && self.useColors) self.color = selectColor();

                var args = Array.prototype.slice.call(arguments);

                args[0] = exports.coerce(args[0]);

                if ('string' !== typeof args[0]) {
                    // anything else let's inspect with %o
                    args = ['%o'].concat(args);
                }

                // apply any `formatters` transformations
                var index = 0;
                args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
                    // if we encounter an escaped % then don't increase the array index
                    if (match === '%%') return match;
                    index++;
                    var formatter = exports.formatters[format];
                    if ('function' === typeof formatter) {
                        var val = args[index];
                        match = formatter.call(self, val);

                        // now we need to remove `args[index]` since it's inlined in the `format`
                        args.splice(index, 1);
                        index--;
                    }
                    return match;
                });

                if ('function' === typeof exports.formatArgs) {
                    args = exports.formatArgs.apply(self, args);
                }
                var logFn = enabled.log || exports.log || console.log.bind(console);
                logFn.apply(self, args);
            }
            enabled.enabled = true;

            var fn = exports.enabled(namespace) ? enabled : disabled;

            fn.namespace = namespace;

            return fn;
        }

        /**
         * Enables a debug mode by namespaces. This can include modes
         * separated by a colon and wildcards.
         *
         * @param {String} namespaces
         * @api public
         */

        function enable(namespaces) {
            exports.save(namespaces);

            var split = (namespaces || '').split(/[\s,]+/);
            var len = split.length;

            for (var i = 0; i < len; i++) {
                if (!split[i]) continue; // ignore empty strings
                namespaces = split[i].replace(/\*/g, '.*?');
                if (namespaces[0] === '-') {
                    exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
                } else {
                    exports.names.push(new RegExp('^' + namespaces + '$'));
                }
            }
        }

        /**
         * Disable debug output.
         *
         * @api public
         */

        function disable() {
            exports.enable('');
        }

        /**
         * Returns true if the given mode name is enabled, false otherwise.
         *
         * @param {String} name
         * @return {Boolean}
         * @api public
         */

        function enabled(name) {
            var i, len;
            for (i = 0, len = exports.skips.length; i < len; i++) {
                if (exports.skips[i].test(name)) {
                    return false;
                }
            }
            for (i = 0, len = exports.names.length; i < len; i++) {
                if (exports.names[i].test(name)) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Coerce `val`.
         *
         * @param {Mixed} val
         * @return {Mixed}
         * @api private
         */

        function coerce(val) {
            if (val instanceof Error) return val.stack || val.message;
            return val;
        }

        /***/ },
    /* 23 */
    /***/ function(module, exports) {

        'use strict';

        /**
         * Helpers.
         */

        var s = 1000;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var y = d * 365.25;

        /**
         * Parse or format the given `val`.
         *
         * Options:
         *
         *  - `long` verbose formatting [false]
         *
         * @param {String|Number} val
         * @param {Object} options
         * @return {String|Number}
         * @api public
         */

        module.exports = function (val, options) {
            options = options || {};
            if ('string' == typeof val) return parse(val);
            return options.long ? long(val) : short(val);
        };

        /**
         * Parse the given `str` and return milliseconds.
         *
         * @param {String} str
         * @return {Number}
         * @api private
         */

        function parse(str) {
            str = '' + str;
            if (str.length > 10000) return;
            var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
            if (!match) return;
            var n = parseFloat(match[1]);
            var type = (match[2] || 'ms').toLowerCase();
            switch (type) {
                case 'years':
                case 'year':
                case 'yrs':
                case 'yr':
                case 'y':
                    return n * y;
                case 'days':
                case 'day':
                case 'd':
                    return n * d;
                case 'hours':
                case 'hour':
                case 'hrs':
                case 'hr':
                case 'h':
                    return n * h;
                case 'minutes':
                case 'minute':
                case 'mins':
                case 'min':
                case 'm':
                    return n * m;
                case 'seconds':
                case 'second':
                case 'secs':
                case 'sec':
                case 's':
                    return n * s;
                case 'milliseconds':
                case 'millisecond':
                case 'msecs':
                case 'msec':
                case 'ms':
                    return n;
            }
        }

        /**
         * Short format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function short(ms) {
            if (ms >= d) return Math.round(ms / d) + 'd';
            if (ms >= h) return Math.round(ms / h) + 'h';
            if (ms >= m) return Math.round(ms / m) + 'm';
            if (ms >= s) return Math.round(ms / s) + 's';
            return ms + 'ms';
        }

        /**
         * Long format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function long(ms) {
            return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
        }

        /**
         * Pluralization helper.
         */

        function plural(ms, n, name) {
            if (ms < n) return;
            if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
            return Math.ceil(ms / n) + ' ' + name + 's';
        }

        /***/ },
    /* 24 */
    /***/ function(module, exports) {

        'use strict';

        if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };
        } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function TempCtor() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            };
        }

        /***/ },
    /* 25 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            EventTarget = __webpack_require__(26);

        function EventEmitter() {
            EventTarget.call(this);
        }

        inherits(EventEmitter, EventTarget);

        EventEmitter.prototype.removeAllListeners = function (type) {
            if (type) {
                delete this._listeners[type];
            } else {
                this._listeners = {};
            }
        };

        EventEmitter.prototype.once = function (type, listener) {
            var self = this,
                fired = false;

            function g() {
                self.removeListener(type, g);

                if (!fired) {
                    fired = true;
                    listener.apply(this, arguments);
                }
            }

            this.on(type, g);
        };

        EventEmitter.prototype.emit = function () {
            var type = arguments[0];
            var listeners = this._listeners[type];
            if (!listeners) {
                return;
            }
            // equivalent of Array.prototype.slice.call(arguments, 1);
            var l = arguments.length;
            var args = new Array(l - 1);
            for (var ai = 1; ai < l; ai++) {
                args[ai - 1] = arguments[ai];
            }
            for (var i = 0; i < listeners.length; i++) {
                listeners[i].apply(this, args);
            }
        };

        EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
        EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

        module.exports.EventEmitter = EventEmitter;

        /***/ },
    /* 26 */
    /***/ function(module, exports) {

        'use strict';

        /* Simplified implementation of DOM2 EventTarget.
         *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
         */

        function EventTarget() {
            this._listeners = {};
        }

        EventTarget.prototype.addEventListener = function (eventType, listener) {
            if (!(eventType in this._listeners)) {
                this._listeners[eventType] = [];
            }
            var arr = this._listeners[eventType];
            // #4
            if (arr.indexOf(listener) === -1) {
                // Make a copy so as not to interfere with a current dispatchEvent.
                arr = arr.concat([listener]);
            }
            this._listeners[eventType] = arr;
        };

        EventTarget.prototype.removeEventListener = function (eventType, listener) {
            var arr = this._listeners[eventType];
            if (!arr) {
                return;
            }
            var idx = arr.indexOf(listener);
            if (idx !== -1) {
                if (arr.length > 1) {
                    // Make a copy so as not to interfere with a current dispatchEvent.
                    this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
                } else {
                    delete this._listeners[eventType];
                }
                return;
            }
        };

        EventTarget.prototype.dispatchEvent = function () {
            var event = arguments[0];
            var t = event.type;
            // equivalent of Array.prototype.slice.call(arguments, 0);
            var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
            // TODO: This doesn't match the real behavior; per spec, onfoo get
            // their place in line from the /first/ time they're set from
            // non-null. Although WebKit bumps it to the end every time it's
            // set.
            if (this['on' + t]) {
                this['on' + t].apply(this, args);
            }
            if (t in this._listeners) {
                // Grab a reference to the listeners list. removeEventListener may alter the list.
                var listeners = this._listeners[t];
                for (var i = 0; i < listeners.length; i++) {
                    listeners[i].apply(this, args);
                }
            }
        };

        module.exports = EventTarget;

        /***/ },
    /* 27 */
    /***/ function(module, exports) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            var Driver = global.WebSocket || global.MozWebSocket;
            if (Driver) {
                module.exports = function WebSocketBrowserDriver(url) {
                    return new Driver(url);
                };
            }
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 28 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            var inherits = __webpack_require__(24),
                AjaxBasedTransport = __webpack_require__(29),
                XhrReceiver = __webpack_require__(33),
                XHRCorsObject = __webpack_require__(34),
                XHRLocalObject = __webpack_require__(36),
                browser = __webpack_require__(37);

            function XhrStreamingTransport(transUrl) {
                if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
                    throw new Error('Transport created when disabled');
                }
                AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
            }

            inherits(XhrStreamingTransport, AjaxBasedTransport);

            XhrStreamingTransport.enabled = function (info) {
                if (info.nullOrigin) {
                    return false;
                }
                // Opera doesn't support xhr-streaming #60
                // But it might be able to #92
                if (browser.isOpera()) {
                    return false;
                }

                return XHRCorsObject.enabled;
            };

            XhrStreamingTransport.transportName = 'xhr-streaming';
            XhrStreamingTransport.roundTrips = 2; // preflight, ajax

            // Safari gets confused when a streaming ajax request is started
            // before onload. This causes the load indicator to spin indefinetely.
            // Only require body when used in a browser
            XhrStreamingTransport.needBody = !!global.document;

            module.exports = XhrStreamingTransport;
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 29 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var inherits = __webpack_require__(24),
                urlUtils = __webpack_require__(16),
                SenderReceiver = __webpack_require__(30);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:ajax-based');
            }

            function createAjaxSender(AjaxObject) {
                return function (url, payload, callback) {
                    debug('create ajax sender', url, payload);
                    var opt = {};
                    if (typeof payload === 'string') {
                        opt.headers = { 'Content-type': 'text/plain' };
                    }
                    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
                    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
                    xo.once('finish', function (status) {
                        debug('finish', status);
                        xo = null;

                        if (status !== 200 && status !== 204) {
                            return callback(new Error('http status ' + status));
                        }
                        callback();
                    });
                    return function () {
                        debug('abort');
                        xo.close();
                        xo = null;

                        var err = new Error('Aborted');
                        err.code = 1000;
                        callback(err);
                    };
                };
            }

            function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
                SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
            }

            inherits(AjaxBasedTransport, SenderReceiver);

            module.exports = AjaxBasedTransport;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 30 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var inherits = __webpack_require__(24),
                urlUtils = __webpack_require__(16),
                BufferedSender = __webpack_require__(31),
                Polling = __webpack_require__(32);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:sender-receiver');
            }

            function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
                var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
                debug(pollUrl);
                var self = this;
                BufferedSender.call(this, transUrl, senderFunc);

                this.poll = new Polling(Receiver, pollUrl, AjaxObject);
                this.poll.on('message', function (msg) {
                    debug('poll message', msg);
                    self.emit('message', msg);
                });
                this.poll.once('close', function (code, reason) {
                    debug('poll close', code, reason);
                    self.poll = null;
                    self.emit('close', code, reason);
                    self.close();
                });
            }

            inherits(SenderReceiver, BufferedSender);

            SenderReceiver.prototype.close = function () {
                debug('close');
                this.removeAllListeners();
                if (this.poll) {
                    this.poll.abort();
                    this.poll = null;
                }
                this.stop();
            };

            module.exports = SenderReceiver;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 31 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var inherits = __webpack_require__(24),
                EventEmitter = __webpack_require__(25).EventEmitter;

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:buffered-sender');
            }

            function BufferedSender(url, sender) {
                debug(url);
                EventEmitter.call(this);
                this.sendBuffer = [];
                this.sender = sender;
                this.url = url;
            }

            inherits(BufferedSender, EventEmitter);

            BufferedSender.prototype.send = function (message) {
                debug('send', message);
                this.sendBuffer.push(message);
                if (!this.sendStop) {
                    this.sendSchedule();
                }
            };

            // For polling transports in a situation when in the message callback,
            // new message is being send. If the sending connection was started
            // before receiving one, it is possible to saturate the network and
            // timeout due to the lack of receiving socket. To avoid that we delay
            // sending messages by some small time, in order to let receiving
            // connection be started beforehand. This is only a halfmeasure and
            // does not fix the big problem, but it does make the tests go more
            // stable on slow networks.
            BufferedSender.prototype.sendScheduleWait = function () {
                debug('sendScheduleWait');
                var self = this;
                var tref;
                this.sendStop = function () {
                    debug('sendStop');
                    self.sendStop = null;
                    clearTimeout(tref);
                };
                tref = setTimeout(function () {
                    debug('timeout');
                    self.sendStop = null;
                    self.sendSchedule();
                }, 25);
            };

            BufferedSender.prototype.sendSchedule = function () {
                debug('sendSchedule', this.sendBuffer.length);
                var self = this;
                if (this.sendBuffer.length > 0) {
                    var payload = '[' + this.sendBuffer.join(',') + ']';
                    this.sendStop = this.sender(this.url, payload, function (err) {
                        self.sendStop = null;
                        if (err) {
                            debug('error', err);
                            self.emit('close', err.code || 1006, 'Sending error: ' + err);
                            self._cleanup();
                        } else {
                            self.sendScheduleWait();
                        }
                    });
                    this.sendBuffer = [];
                }
            };

            BufferedSender.prototype._cleanup = function () {
                debug('_cleanup');
                this.removeAllListeners();
            };

            BufferedSender.prototype.stop = function () {
                debug('stop');
                this._cleanup();
                if (this.sendStop) {
                    this.sendStop();
                    this.sendStop = null;
                }
            };

            module.exports = BufferedSender;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 32 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var inherits = __webpack_require__(24),
                EventEmitter = __webpack_require__(25).EventEmitter;

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:polling');
            }

            function Polling(Receiver, receiveUrl, AjaxObject) {
                debug(receiveUrl);
                EventEmitter.call(this);
                this.Receiver = Receiver;
                this.receiveUrl = receiveUrl;
                this.AjaxObject = AjaxObject;
                this._scheduleReceiver();
            }

            inherits(Polling, EventEmitter);

            Polling.prototype._scheduleReceiver = function () {
                debug('_scheduleReceiver');
                var self = this;
                var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

                poll.on('message', function (msg) {
                    debug('message', msg);
                    self.emit('message', msg);
                });

                poll.once('close', function (code, reason) {
                    debug('close', code, reason, self.pollIsClosing);
                    self.poll = poll = null;

                    if (!self.pollIsClosing) {
                        if (reason === 'network') {
                            self._scheduleReceiver();
                        } else {
                            self.emit('close', code || 1006, reason);
                            self.removeAllListeners();
                        }
                    }
                });
            };

            Polling.prototype.abort = function () {
                debug('abort');
                this.removeAllListeners();
                this.pollIsClosing = true;
                if (this.poll) {
                    this.poll.abort();
                }
            };

            module.exports = Polling;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 33 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var inherits = __webpack_require__(24),
                EventEmitter = __webpack_require__(25).EventEmitter;

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:receiver:xhr');
            }

            function XhrReceiver(url, AjaxObject) {
                debug(url);
                EventEmitter.call(this);
                var self = this;

                this.bufferPosition = 0;

                this.xo = new AjaxObject('POST', url, null);
                this.xo.on('chunk', this._chunkHandler.bind(this));
                this.xo.once('finish', function (status, text) {
                    debug('finish', status, text);
                    self._chunkHandler(status, text);
                    self.xo = null;
                    var reason = status === 200 ? 'network' : 'permanent';
                    debug('close', reason);
                    self.emit('close', null, reason);
                    self._cleanup();
                });
            }

            inherits(XhrReceiver, EventEmitter);

            XhrReceiver.prototype._chunkHandler = function (status, text) {
                debug('_chunkHandler', status);
                if (status !== 200 || !text) {
                    return;
                }

                for (var idx = -1;; this.bufferPosition += idx + 1) {
                    var buf = text.slice(this.bufferPosition);
                    idx = buf.indexOf('\n');
                    if (idx === -1) {
                        break;
                    }
                    var msg = buf.slice(0, idx);
                    if (msg) {
                        debug('message', msg);
                        this.emit('message', msg);
                    }
                }
            };

            XhrReceiver.prototype._cleanup = function () {
                debug('_cleanup');
                this.removeAllListeners();
            };

            XhrReceiver.prototype.abort = function () {
                debug('abort');
                if (this.xo) {
                    this.xo.close();
                    debug('close');
                    this.emit('close', null, 'user');
                    this.xo = null;
                }
                this._cleanup();
            };

            module.exports = XhrReceiver;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 34 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            XhrDriver = __webpack_require__(35);

        function XHRCorsObject(method, url, payload, opts) {
            XhrDriver.call(this, method, url, payload, opts);
        }

        inherits(XHRCorsObject, XhrDriver);

        XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

        module.exports = XHRCorsObject;

        /***/ },
    /* 35 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(global, process) {'use strict';

            var EventEmitter = __webpack_require__(25).EventEmitter,
                inherits = __webpack_require__(24),
                utils = __webpack_require__(13),
                urlUtils = __webpack_require__(16),
                XHR = global.XMLHttpRequest;

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:browser:xhr');
            }

            function AbstractXHRObject(method, url, payload, opts) {
                debug(method, url);
                var self = this;
                EventEmitter.call(this);

                setTimeout(function () {
                    self._start(method, url, payload, opts);
                }, 0);
            }

            inherits(AbstractXHRObject, EventEmitter);

            AbstractXHRObject.prototype._start = function (method, url, payload, opts) {
                var self = this;

                try {
                    this.xhr = new XHR();
                } catch (x) {
                    // intentionally empty
                }

                if (!this.xhr) {
                    debug('no xhr');
                    this.emit('finish', 0, 'no xhr support');
                    this._cleanup();
                    return;
                }

                // several browsers cache POSTs
                url = urlUtils.addQuery(url, 't=' + +new Date());

                // Explorer tends to keep connection open, even after the
                // tab gets closed: http://bugs.jquery.com/ticket/5280
                this.unloadRef = utils.unloadAdd(function () {
                    debug('unload cleanup');
                    self._cleanup(true);
                });
                try {
                    this.xhr.open(method, url, true);
                    if (this.timeout && 'timeout' in this.xhr) {
                        this.xhr.timeout = this.timeout;
                        this.xhr.ontimeout = function () {
                            debug('xhr timeout');
                            self.emit('finish', 0, '');
                            self._cleanup(false);
                        };
                    }
                } catch (e) {
                    debug('exception', e);
                    // IE raises an exception on wrong port.
                    this.emit('finish', 0, '');
                    this._cleanup(false);
                    return;
                }

                if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
                    debug('withCredentials');
                    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
                    // "This never affects same-site requests."

                    this.xhr.withCredentials = 'true';
                }
                if (opts && opts.headers) {
                    for (var key in opts.headers) {
                        this.xhr.setRequestHeader(key, opts.headers[key]);
                    }
                }

                this.xhr.onreadystatechange = function () {
                    if (self.xhr) {
                        var x = self.xhr;
                        var text, status;
                        debug('readyState', x.readyState);
                        switch (x.readyState) {
                            case 3:
                                // IE doesn't like peeking into responseText or status
                                // on Microsoft.XMLHTTP and readystate=3
                                try {
                                    status = x.status;
                                    text = x.responseText;
                                } catch (e) {
                                    // intentionally empty
                                }
                                debug('status', status);
                                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                                if (status === 1223) {
                                    status = 204;
                                }

                                // IE does return readystate == 3 for 404 answers.
                                if (status === 200 && text && text.length > 0) {
                                    debug('chunk');
                                    self.emit('chunk', status, text);
                                }
                                break;
                            case 4:
                                status = x.status;
                                debug('status', status);
                                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                                if (status === 1223) {
                                    status = 204;
                                }
                                // IE returns this for a bad port
                                // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
                                if (status === 12005 || status === 12029) {
                                    status = 0;
                                }

                                debug('finish', status, x.responseText);
                                self.emit('finish', status, x.responseText);
                                self._cleanup(false);
                                break;
                        }
                    }
                };

                try {
                    self.xhr.send(payload);
                } catch (e) {
                    self.emit('finish', 0, '');
                    self._cleanup(false);
                }
            };

            AbstractXHRObject.prototype._cleanup = function (abort) {
                debug('cleanup');
                if (!this.xhr) {
                    return;
                }
                this.removeAllListeners();
                utils.unloadDel(this.unloadRef);

                // IE needs this field to be a function
                this.xhr.onreadystatechange = function () {};
                if (this.xhr.ontimeout) {
                    this.xhr.ontimeout = null;
                }

                if (abort) {
                    try {
                        this.xhr.abort();
                    } catch (x) {
                        // intentionally empty
                    }
                }
                this.unloadRef = this.xhr = null;
            };

            AbstractXHRObject.prototype.close = function () {
                debug('close');
                this._cleanup(true);
            };

            AbstractXHRObject.enabled = !!XHR;
            // override XMLHttpRequest for IE6/7
            // obfuscate to avoid firewalls
            var axo = ['Active'].concat('Object').join('X');
            if (!AbstractXHRObject.enabled && axo in global) {
                debug('overriding xmlhttprequest');
                XHR = function XHR() {
                    try {
                        return new global[axo]('Microsoft.XMLHTTP');
                    } catch (e) {
                        return null;
                    }
                };
                AbstractXHRObject.enabled = !!new XHR();
            }

            var cors = false;
            try {
                cors = 'withCredentials' in new XHR();
            } catch (ignored) {
                // intentionally empty
            }

            AbstractXHRObject.supportsCORS = cors;

            module.exports = AbstractXHRObject;
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(12)))

        /***/ },
    /* 36 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            XhrDriver = __webpack_require__(35);

        function XHRLocalObject(method, url, payload /*, opts */) {
            XhrDriver.call(this, method, url, payload, {
                noCredentials: true
            });
        }

        inherits(XHRLocalObject, XhrDriver);

        XHRLocalObject.enabled = XhrDriver.enabled;

        module.exports = XHRLocalObject;

        /***/ },
    /* 37 */
    /***/ function(module, exports) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            module.exports = {
                isOpera: function isOpera() {
                    return global.navigator && /opera/i.test(global.navigator.userAgent);
                },

                isKonqueror: function isKonqueror() {
                    return global.navigator && /konqueror/i.test(global.navigator.userAgent);
                }

                // #187 wrap document.domain in try/catch because of WP8 from file:///
                , hasDomain: function hasDomain() {
                    // non-browser client always has a domain
                    if (!global.document) {
                        return true;
                    }

                    try {
                        return !!global.document.domain;
                    } catch (e) {
                        return false;
                    }
                }
            };
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 38 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            AjaxBasedTransport = __webpack_require__(29),
            XhrReceiver = __webpack_require__(33),
            XDRObject = __webpack_require__(39);

        // According to:
        //   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
        //   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

        function XdrStreamingTransport(transUrl) {
            if (!XDRObject.enabled) {
                throw new Error('Transport created when disabled');
            }
            AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
        }

        inherits(XdrStreamingTransport, AjaxBasedTransport);

        XdrStreamingTransport.enabled = function (info) {
            if (info.cookie_needed || info.nullOrigin) {
                return false;
            }
            return XDRObject.enabled && info.sameScheme;
        };

        XdrStreamingTransport.transportName = 'xdr-streaming';
        XdrStreamingTransport.roundTrips = 2; // preflight, ajax

        module.exports = XdrStreamingTransport;

        /***/ },
    /* 39 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

            var EventEmitter = __webpack_require__(25).EventEmitter,
                inherits = __webpack_require__(24),
                eventUtils = __webpack_require__(13),
                browser = __webpack_require__(37),
                urlUtils = __webpack_require__(16);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:sender:xdr');
            }

            // References:
            //   http://ajaxian.com/archives/100-line-ajax-wrapper
            //   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

            function XDRObject(method, url, payload) {
                debug(method, url);
                var self = this;
                EventEmitter.call(this);

                setTimeout(function () {
                    self._start(method, url, payload);
                }, 0);
            }

            inherits(XDRObject, EventEmitter);

            XDRObject.prototype._start = function (method, url, payload) {
                debug('_start');
                var self = this;
                var xdr = new global.XDomainRequest();
                // IE caches even POSTs
                url = urlUtils.addQuery(url, 't=' + +new Date());

                xdr.onerror = function () {
                    debug('onerror');
                    self._error();
                };
                xdr.ontimeout = function () {
                    debug('ontimeout');
                    self._error();
                };
                xdr.onprogress = function () {
                    debug('progress', xdr.responseText);
                    self.emit('chunk', 200, xdr.responseText);
                };
                xdr.onload = function () {
                    debug('load');
                    self.emit('finish', 200, xdr.responseText);
                    self._cleanup(false);
                };
                this.xdr = xdr;
                this.unloadRef = eventUtils.unloadAdd(function () {
                    self._cleanup(true);
                });
                try {
                    // Fails with AccessDenied if port number is bogus
                    this.xdr.open(method, url);
                    if (this.timeout) {
                        this.xdr.timeout = this.timeout;
                    }
                    this.xdr.send(payload);
                } catch (x) {
                    this._error();
                }
            };

            XDRObject.prototype._error = function () {
                this.emit('finish', 0, '');
                this._cleanup(false);
            };

            XDRObject.prototype._cleanup = function (abort) {
                debug('cleanup', abort);
                if (!this.xdr) {
                    return;
                }
                this.removeAllListeners();
                eventUtils.unloadDel(this.unloadRef);

                this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
                if (abort) {
                    try {
                        this.xdr.abort();
                    } catch (x) {
                        // intentionally empty
                    }
                }
                this.unloadRef = this.xdr = null;
            };

            XDRObject.prototype.close = function () {
                debug('close');
                this._cleanup(true);
            };

            // IE 8/9 if the request target uses the same scheme - #79
            XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

            module.exports = XDRObject;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), (function() { return this; }())))

        /***/ },
    /* 40 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            AjaxBasedTransport = __webpack_require__(29),
            EventSourceReceiver = __webpack_require__(41),
            XHRCorsObject = __webpack_require__(34),
            EventSourceDriver = __webpack_require__(42);

        function EventSourceTransport(transUrl) {
            if (!EventSourceTransport.enabled()) {
                throw new Error('Transport created when disabled');
            }

            AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
        }

        inherits(EventSourceTransport, AjaxBasedTransport);

        EventSourceTransport.enabled = function () {
            return !!EventSourceDriver;
        };

        EventSourceTransport.transportName = 'eventsource';
        EventSourceTransport.roundTrips = 2;

        module.exports = EventSourceTransport;

        /***/ },
    /* 41 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var inherits = __webpack_require__(24),
                EventEmitter = __webpack_require__(25).EventEmitter,
                EventSourceDriver = __webpack_require__(42);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:receiver:eventsource');
            }

            function EventSourceReceiver(url) {
                debug(url);
                EventEmitter.call(this);

                var self = this;
                var es = this.es = new EventSourceDriver(url);
                es.onmessage = function (e) {
                    debug('message', e.data);
                    self.emit('message', decodeURI(e.data));
                };
                es.onerror = function (e) {
                    debug('error', es.readyState, e);
                    // ES on reconnection has readyState = 0 or 1.
                    // on network error it's CLOSED = 2
                    var reason = es.readyState !== 2 ? 'network' : 'permanent';
                    self._cleanup();
                    self._close(reason);
                };
            }

            inherits(EventSourceReceiver, EventEmitter);

            EventSourceReceiver.prototype.abort = function () {
                debug('abort');
                this._cleanup();
                this._close('user');
            };

            EventSourceReceiver.prototype._cleanup = function () {
                debug('cleanup');
                var es = this.es;
                if (es) {
                    es.onmessage = es.onerror = null;
                    es.close();
                    this.es = null;
                }
            };

            EventSourceReceiver.prototype._close = function (reason) {
                debug('close', reason);
                var self = this;
                // Safari and chrome < 15 crash if we close window before
                // waiting for ES cleanup. See:
                // https://code.google.com/p/chromium/issues/detail?id=89155
                setTimeout(function () {
                    self.emit('close', null, reason);
                    self.removeAllListeners();
                }, 200);
            };

            module.exports = EventSourceReceiver;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 42 */
    /***/ function(module, exports) {

        /* WEBPACK VAR INJECTION */(function(global) {"use strict";

            module.exports = global.EventSource;
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 43 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            var inherits = __webpack_require__(24),
                IframeTransport = __webpack_require__(44),
                objectUtils = __webpack_require__(48);

            module.exports = function (transport) {

                function IframeWrapTransport(transUrl, baseUrl) {
                    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
                }

                inherits(IframeWrapTransport, IframeTransport);

                IframeWrapTransport.enabled = function (url, info) {
                    if (!global.document) {
                        return false;
                    }

                    var iframeInfo = objectUtils.extend({}, info);
                    iframeInfo.sameOrigin = true;
                    return transport.enabled(iframeInfo) && IframeTransport.enabled();
                };

                IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
                IframeWrapTransport.needBody = true;
                IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

                IframeWrapTransport.facadeTransport = transport;

                return IframeWrapTransport;
            };
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 44 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            // Few cool transports do work only for same-origin. In order to make
            // them work cross-domain we shall use iframe, served from the
            // remote domain. New browsers have capabilities to communicate with
            // cross domain iframe using postMessage(). In IE it was implemented
            // from IE 8+, but of course, IE got some details wrong:
            //    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
            //    http://stevesouders.com/misc/test-postmessage.php

            var inherits = __webpack_require__(24),
                JSON3 = __webpack_require__(45),
                EventEmitter = __webpack_require__(25).EventEmitter,
                version = __webpack_require__(46),
                urlUtils = __webpack_require__(16),
                iframeUtils = __webpack_require__(47),
                eventUtils = __webpack_require__(13),
                random = __webpack_require__(14);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:transport:iframe');
            }

            function IframeTransport(transport, transUrl, baseUrl) {
                if (!IframeTransport.enabled()) {
                    throw new Error('Transport created when disabled');
                }
                EventEmitter.call(this);

                var self = this;
                this.origin = urlUtils.getOrigin(baseUrl);
                this.baseUrl = baseUrl;
                this.transUrl = transUrl;
                this.transport = transport;
                this.windowId = random.string(8);

                var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
                debug(transport, transUrl, iframeUrl);

                this.iframeObj = iframeUtils.createIframe(iframeUrl, function (r) {
                    debug('err callback');
                    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
                    self.close();
                });

                this.onmessageCallback = this._message.bind(this);
                eventUtils.attachEvent('message', this.onmessageCallback);
            }

            inherits(IframeTransport, EventEmitter);

            IframeTransport.prototype.close = function () {
                debug('close');
                this.removeAllListeners();
                if (this.iframeObj) {
                    eventUtils.detachEvent('message', this.onmessageCallback);
                    try {
                        // When the iframe is not loaded, IE raises an exception
                        // on 'contentWindow'.
                        this.postMessage('c');
                    } catch (x) {
                        // intentionally empty
                    }
                    this.iframeObj.cleanup();
                    this.iframeObj = null;
                    this.onmessageCallback = this.iframeObj = null;
                }
            };

            IframeTransport.prototype._message = function (e) {
                debug('message', e.data);
                if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
                    debug('not same origin', e.origin, this.origin);
                    return;
                }

                var iframeMessage;
                try {
                    iframeMessage = JSON3.parse(e.data);
                } catch (ignored) {
                    debug('bad json', e.data);
                    return;
                }

                if (iframeMessage.windowId !== this.windowId) {
                    debug('mismatched window id', iframeMessage.windowId, this.windowId);
                    return;
                }

                switch (iframeMessage.type) {
                    case 's':
                        this.iframeObj.loaded();
                        // window global dependency
                        this.postMessage('s', JSON3.stringify([version, this.transport, this.transUrl, this.baseUrl]));
                        break;
                    case 't':
                        this.emit('message', iframeMessage.data);
                        break;
                    case 'c':
                        var cdata;
                        try {
                            cdata = JSON3.parse(iframeMessage.data);
                        } catch (ignored) {
                            debug('bad json', iframeMessage.data);
                            return;
                        }
                        this.emit('close', cdata[0], cdata[1]);
                        this.close();
                        break;
                }
            };

            IframeTransport.prototype.postMessage = function (type, data) {
                debug('postMessage', type, data);
                this.iframeObj.post(JSON3.stringify({
                    windowId: this.windowId,
                    type: type,
                    data: data || ''
                }), this.origin);
            };

            IframeTransport.prototype.send = function (message) {
                debug('send', message);
                this.postMessage('m', message);
            };

            IframeTransport.enabled = function () {
                return iframeUtils.iframeEnabled;
            };

            IframeTransport.transportName = 'iframe';
            IframeTransport.roundTrips = 2;

            module.exports = IframeTransport;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 45 */
    /***/ function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            /*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
            ;(function () {
                // Detect the `define` function exposed by asynchronous module loaders. The
                // strict `define` check is necessary for compatibility with `r.js`.
                var isLoader = "function" === "function" && __webpack_require__(5);

                // A set of types used to distinguish objects from primitives.
                var objectTypes = {
                    "function": true,
                    "object": true
                };

                // Detect the `exports` object exposed by CommonJS implementations.
                var freeExports = objectTypes[ false ? "undefined" : _typeof(exports)] && exports && !exports.nodeType && exports;

                // Use the `global` object exposed by Node (including Browserify via
                // `insert-module-globals`), Narwhal, and Ringo as the default context,
                // and the `window` object in browsers. Rhino exports a `global` function
                // instead.
                var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this,
                    freeGlobal = freeExports && objectTypes[ false ? "undefined" : _typeof(module)] && module && !module.nodeType && (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;

                if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
                    root = freeGlobal;
                }

                // Public: Initializes JSON 3 using the given `context` object, attaching the
                // `stringify` and `parse` functions to the specified `exports` object.
                function runInContext(context, exports) {
                    context || (context = root["Object"]());
                    exports || (exports = root["Object"]());

                    // Native constructor aliases.
                    var Number = context["Number"] || root["Number"],
                        String = context["String"] || root["String"],
                        Object = context["Object"] || root["Object"],
                        Date = context["Date"] || root["Date"],
                        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
                        TypeError = context["TypeError"] || root["TypeError"],
                        Math = context["Math"] || root["Math"],
                        nativeJSON = context["JSON"] || root["JSON"];

                    // Delegate to the native `stringify` and `parse` implementations.
                    if ((typeof nativeJSON === "undefined" ? "undefined" : _typeof(nativeJSON)) == "object" && nativeJSON) {
                        exports.stringify = nativeJSON.stringify;
                        exports.parse = nativeJSON.parse;
                    }

                    // Convenience aliases.
                    var objectProto = Object.prototype,
                        getClass = objectProto.toString,
                        _isProperty,
                        _forEach,
                        undef;

                    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
                    var isExtended = new Date(-3509827334573292);
                    try {
                        // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
                        // results for certain dates in Opera >= 10.53.
                        isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
                            // Safari < 2.0.2 stores the internal millisecond time value correctly,
                            // but clips the values returned by the date methods to the range of
                            // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
                            isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
                    } catch (exception) {}

                    // Internal: Determines whether the native `JSON.stringify` and `parse`
                    // implementations are spec-compliant. Based on work by Ken Snyder.
                    function has(name) {
                        if (has[name] !== undef) {
                            // Return cached feature test result.
                            return has[name];
                        }
                        var isSupported;
                        if (name == "bug-string-char-index") {
                            // IE <= 7 doesn't support accessing string characters using square
                            // bracket notation. IE 8 only supports this for primitives.
                            isSupported = "a"[0] != "a";
                        } else if (name == "json") {
                            // Indicates whether both `JSON.stringify` and `JSON.parse` are
                            // supported.
                            isSupported = has("json-stringify") && has("json-parse");
                        } else {
                            var value,
                                serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";
                            // Test `JSON.stringify`.
                            if (name == "json-stringify") {
                                var stringify = exports.stringify,
                                    stringifySupported = typeof stringify == "function" && isExtended;
                                if (stringifySupported) {
                                    // A test function object with a custom `toJSON` method.
                                    (value = function value() {
                                        return 1;
                                    }).toJSON = value;
                                    try {
                                        stringifySupported =
                                            // Firefox 3.1b1 and b2 serialize string, number, and boolean
                                            // primitives as object literals.
                                            stringify(0) === "0" &&
                                            // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                                            // literals.
                                            stringify(new Number()) === "0" && stringify(new String()) == '""' &&
                                            // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                                            // does not define a canonical JSON representation (this applies to
                                            // objects with `toJSON` properties as well, *unless* they are nested
                                            // within an object or array).
                                            stringify(getClass) === undef &&
                                            // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                                            // FF 3.1b3 pass this test.
                                            stringify(undef) === undef &&
                                            // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                                            // respectively, if the value is omitted entirely.
                                            stringify() === undef &&
                                            // FF 3.1b1, 2 throw an error if the given value is not a number,
                                            // string, array, object, Boolean, or `null` literal. This applies to
                                            // objects with custom `toJSON` methods as well, unless they are nested
                                            // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                                            // methods entirely.
                                            stringify(value) === "1" && stringify([value]) == "[1]" &&
                                            // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                                            // `"[null]"`.
                                            stringify([undef]) == "[null]" &&
                                            // YUI 3.0.0b1 fails to serialize `null` literals.
                                            stringify(null) == "null" &&
                                            // FF 3.1b1, 2 halts serialization if an array contains a function:
                                            // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                                            // elides non-JSON values from objects and arrays, unless they
                                            // define custom `toJSON` methods.
                                            stringify([undef, getClass, null]) == "[null,null,null]" &&
                                            // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                                            // where character escape codes are expected (e.g., `\b` => `\u0008`).
                                            stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                                            // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                                            stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                                            // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                                            // serialize extended years.
                                            stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                                            // The milliseconds are optional in ES 5, but required in 5.1.
                                            stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                                            // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                                            // four-digit years instead of six-digit years. Credits: @Yaffle.
                                            stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                                            // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                                            // values less than 1000. Credits: @Yaffle.
                                            stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                                    } catch (exception) {
                                        stringifySupported = false;
                                    }
                                }
                                isSupported = stringifySupported;
                            }
                            // Test `JSON.parse`.
                            if (name == "json-parse") {
                                var parse = exports.parse;
                                if (typeof parse == "function") {
                                    try {
                                        // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                                        // Conforming implementations should also coerce the initial argument to
                                        // a string prior to parsing.
                                        if (parse("0") === 0 && !parse(false)) {
                                            // Simple parsing test.
                                            value = parse(serialized);
                                            var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                                            if (parseSupported) {
                                                try {
                                                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                                                    parseSupported = !parse('"\t"');
                                                } catch (exception) {}
                                                if (parseSupported) {
                                                    try {
                                                        // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                                                        // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                                                        // certain octal literals.
                                                        parseSupported = parse("01") !== 1;
                                                    } catch (exception) {}
                                                }
                                                if (parseSupported) {
                                                    try {
                                                        // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                                                        // points. These environments, along with FF 3.1b1 and 2,
                                                        // also allow trailing commas in JSON objects and arrays.
                                                        parseSupported = parse("1.") !== 1;
                                                    } catch (exception) {}
                                                }
                                            }
                                        }
                                    } catch (exception) {
                                        parseSupported = false;
                                    }
                                }
                                isSupported = parseSupported;
                            }
                        }
                        return has[name] = !!isSupported;
                    }

                    if (!has("json")) {
                        // Common `[[Class]]` name aliases.
                        var functionClass = "[object Function]",
                            dateClass = "[object Date]",
                            numberClass = "[object Number]",
                            stringClass = "[object String]",
                            arrayClass = "[object Array]",
                            booleanClass = "[object Boolean]";

                        // Detect incomplete support for accessing string characters by index.
                        var charIndexBuggy = has("bug-string-char-index");

                        // Define additional utility methods if the `Date` methods are buggy.
                        if (!isExtended) {
                            var floor = Math.floor;
                            // A mapping between the months of the year and the number of days between
                            // January 1st and the first of the respective month.
                            var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
                            // Internal: Calculates the number of days between the Unix epoch and the
                            // first day of the given month.
                            var getDay = function getDay(year, month) {
                                return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                            };
                        }

                        // Internal: Determines if a property is a direct property of the given
                        // object. Delegates to the native `Object#hasOwnProperty` method.
                        if (!(_isProperty = objectProto.hasOwnProperty)) {
                            _isProperty = function isProperty(property) {
                                var members = {},
                                    constructor;
                                if ((members.__proto__ = null, members.__proto__ = {
                                        // The *proto* property cannot be set multiple times in recent
                                        // versions of Firefox and SeaMonkey.
                                        "toString": 1
                                    }, members).toString != getClass) {
                                    // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
                                    // supports the mutable *proto* property.
                                    _isProperty = function isProperty(property) {
                                        // Capture and break the object's prototype chain (see section 8.6.2
                                        // of the ES 5.1 spec). The parenthesized expression prevents an
                                        // unsafe transformation by the Closure Compiler.
                                        var original = this.__proto__,
                                            result = property in (this.__proto__ = null, this);
                                        // Restore the original prototype chain.
                                        this.__proto__ = original;
                                        return result;
                                    };
                                } else {
                                    // Capture a reference to the top-level `Object` constructor.
                                    constructor = members.constructor;
                                    // Use the `constructor` property to simulate `Object#hasOwnProperty` in
                                    // other environments.
                                    _isProperty = function isProperty(property) {
                                        var parent = (this.constructor || constructor).prototype;
                                        return property in this && !(property in parent && this[property] === parent[property]);
                                    };
                                }
                                members = null;
                                return _isProperty.call(this, property);
                            };
                        }

                        // Internal: Normalizes the `for...in` iteration algorithm across
                        // environments. Each enumerated key is yielded to a `callback` function.
                        _forEach = function forEach(object, callback) {
                            var size = 0,
                                Properties,
                                members,
                                property;

                            // Tests for bugs in the current environment's `for...in` algorithm. The
                            // `valueOf` property inherits the non-enumerable flag from
                            // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
                            (Properties = function Properties() {
                                this.valueOf = 0;
                            }).prototype.valueOf = 0;

                            // Iterate over a new instance of the `Properties` class.
                            members = new Properties();
                            for (property in members) {
                                // Ignore all properties inherited from `Object.prototype`.
                                if (_isProperty.call(members, property)) {
                                    size++;
                                }
                            }
                            Properties = members = null;

                            // Normalize the iteration algorithm.
                            if (!size) {
                                // A list of non-enumerable properties inherited from `Object.prototype`.
                                members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
                                // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
                                // properties.
                                _forEach = function forEach(object, callback) {
                                    var isFunction = getClass.call(object) == functionClass,
                                        property,
                                        length;
                                    var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;
                                    for (property in object) {
                                        // Gecko <= 1.0 enumerates the `prototype` property of functions under
                                        // certain conditions; IE does not.
                                        if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                                            callback(property);
                                        }
                                    }
                                    // Manually invoke the callback for each non-enumerable property.
                                    for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}
                                };
                            } else if (size == 2) {
                                // Safari <= 2.0.4 enumerates shadowed properties twice.
                                _forEach = function forEach(object, callback) {
                                    // Create a set of iterated properties.
                                    var members = {},
                                        isFunction = getClass.call(object) == functionClass,
                                        property;
                                    for (property in object) {
                                        // Store each property name to prevent double enumeration. The
                                        // `prototype` property of functions is not enumerated due to cross-
                                        // environment inconsistencies.
                                        if (!(isFunction && property == "prototype") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {
                                            callback(property);
                                        }
                                    }
                                };
                            } else {
                                // No bugs detected; use the standard `for...in` algorithm.
                                _forEach = function forEach(object, callback) {
                                    var isFunction = getClass.call(object) == functionClass,
                                        property,
                                        isConstructor;
                                    for (property in object) {
                                        if (!(isFunction && property == "prototype") && _isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                                            callback(property);
                                        }
                                    }
                                    // Manually invoke the callback for the `constructor` property due to
                                    // cross-environment inconsistencies.
                                    if (isConstructor || _isProperty.call(object, property = "constructor")) {
                                        callback(property);
                                    }
                                };
                            }
                            return _forEach(object, callback);
                        };

                        // Public: Serializes a JavaScript `value` as a JSON string. The optional
                        // `filter` argument may specify either a function that alters how object and
                        // array members are serialized, or an array of strings and numbers that
                        // indicates which properties should be serialized. The optional `width`
                        // argument may be either a string or number that specifies the indentation
                        // level of the output.
                        if (!has("json-stringify")) {
                            // Internal: A map of control characters and their escaped equivalents.
                            var Escapes = {
                                92: "\\\\",
                                34: '\\"',
                                8: "\\b",
                                12: "\\f",
                                10: "\\n",
                                13: "\\r",
                                9: "\\t"
                            };

                            // Internal: Converts `value` into a zero-padded string such that its
                            // length is at least equal to `width`. The `width` must be <= 6.
                            var leadingZeroes = "000000";
                            var toPaddedString = function toPaddedString(width, value) {
                                // The `|| 0` expression is necessary to work around a bug in
                                // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
                                return (leadingZeroes + (value || 0)).slice(-width);
                            };

                            // Internal: Double-quotes a string `value`, replacing all ASCII control
                            // characters (characters with code unit values between 0 and 31) with
                            // their escaped equivalents. This is an implementation of the
                            // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
                            var unicodePrefix = "\\u00";
                            var quote = function quote(value) {
                                var result = '"',
                                    index = 0,
                                    length = value.length,
                                    useCharIndex = !charIndexBuggy || length > 10;
                                var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
                                for (; index < length; index++) {
                                    var charCode = value.charCodeAt(index);
                                    // If the character is a control character, append its Unicode or
                                    // shorthand escape sequence; otherwise, append the character as-is.
                                    switch (charCode) {
                                        case 8:case 9:case 10:case 12:case 13:case 34:case 92:
                                        result += Escapes[charCode];
                                        break;
                                        default:
                                            if (charCode < 32) {
                                                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                                                break;
                                            }
                                            result += useCharIndex ? symbols[index] : value.charAt(index);
                                    }
                                }
                                return result + '"';
                            };

                            // Internal: Recursively serializes an object. Implements the
                            // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
                            var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
                                var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
                                try {
                                    // Necessary for host object support.
                                    value = object[property];
                                } catch (exception) {}
                                if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
                                    className = getClass.call(value);
                                    if (className == dateClass && !_isProperty.call(value, "toJSON")) {
                                        if (value > -1 / 0 && value < 1 / 0) {
                                            // Dates are serialized according to the `Date#toJSON` method
                                            // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                                            // for the ISO 8601 date time string format.
                                            if (getDay) {
                                                // Manually compute the year, month, date, hours, minutes,
                                                // seconds, and milliseconds if the `getUTC*` methods are
                                                // buggy. Adapted from @Yaffle's `date-shim` project.
                                                date = floor(value / 864e5);
                                                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}
                                                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}
                                                date = 1 + date - getDay(year, month);
                                                // The `time` value specifies the time within the day (see ES
                                                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                                                // to compute `A modulo B`, as the `%` operator does not
                                                // correspond to the `modulo` operation for negative numbers.
                                                time = (value % 864e5 + 864e5) % 864e5;
                                                // The hours, minutes, seconds, and milliseconds are obtained by
                                                // decomposing the time within the day. See section 15.9.1.10.
                                                hours = floor(time / 36e5) % 24;
                                                minutes = floor(time / 6e4) % 60;
                                                seconds = floor(time / 1e3) % 60;
                                                milliseconds = time % 1e3;
                                            } else {
                                                year = value.getUTCFullYear();
                                                month = value.getUTCMonth();
                                                date = value.getUTCDate();
                                                hours = value.getUTCHours();
                                                minutes = value.getUTCMinutes();
                                                seconds = value.getUTCSeconds();
                                                milliseconds = value.getUTCMilliseconds();
                                            }
                                            // Serialize extended years correctly.
                                            value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                                                // Months, dates, hours, minutes, and seconds should have two
                                                // digits; milliseconds should have three.
                                                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                                                // Milliseconds are optional in ES 5.0, but required in 5.1.
                                                "." + toPaddedString(3, milliseconds) + "Z";
                                        } else {
                                            value = null;
                                        }
                                    } else if (typeof value.toJSON == "function" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, "toJSON"))) {
                                        // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
                                        // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
                                        // ignores all `toJSON` methods on these objects unless they are
                                        // defined directly on an instance.
                                        value = value.toJSON(property);
                                    }
                                }
                                if (callback) {
                                    // If a replacement function was provided, call it to obtain the value
                                    // for serialization.
                                    value = callback.call(object, property, value);
                                }
                                if (value === null) {
                                    return "null";
                                }
                                className = getClass.call(value);
                                if (className == booleanClass) {
                                    // Booleans are represented literally.
                                    return "" + value;
                                } else if (className == numberClass) {
                                    // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                                    // `"null"`.
                                    return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
                                } else if (className == stringClass) {
                                    // Strings are double-quoted and escaped.
                                    return quote("" + value);
                                }
                                // Recursively serialize objects and arrays.
                                if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object") {
                                    // Check for cyclic structures. This is a linear search; performance
                                    // is inversely proportional to the number of unique nested objects.
                                    for (length = stack.length; length--;) {
                                        if (stack[length] === value) {
                                            // Cyclic structures cannot be serialized by `JSON.stringify`.
                                            throw TypeError();
                                        }
                                    }
                                    // Add the object to the stack of traversed objects.
                                    stack.push(value);
                                    results = [];
                                    // Save the current indentation level and indent one additional level.
                                    prefix = indentation;
                                    indentation += whitespace;
                                    if (className == arrayClass) {
                                        // Recursively serialize array elements.
                                        for (index = 0, length = value.length; index < length; index++) {
                                            element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                                            results.push(element === undef ? "null" : element);
                                        }
                                        result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
                                    } else {
                                        // Recursively serialize object members. Members are selected from
                                        // either a user-specified list of property names, or the object
                                        // itself.
                                        _forEach(properties || value, function (property) {
                                            var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                                            if (element !== undef) {
                                                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                                                // is not the empty string, let `member` {quote(property) + ":"}
                                                // be the concatenation of `member` and the `space` character."
                                                // The "`space` character" refers to the literal space
                                                // character, not the `space` {width} argument provided to
                                                // `JSON.stringify`.
                                                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                                            }
                                        });
                                        result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
                                    }
                                    // Remove the object from the traversed object stack.
                                    stack.pop();
                                    return result;
                                }
                            };

                            // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
                            exports.stringify = function (source, filter, width) {
                                var whitespace, callback, properties, className;
                                if (objectTypes[typeof filter === "undefined" ? "undefined" : _typeof(filter)] && filter) {
                                    if ((className = getClass.call(filter)) == functionClass) {
                                        callback = filter;
                                    } else if (className == arrayClass) {
                                        // Convert the property names array into a makeshift set.
                                        properties = {};
                                        for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}
                                    }
                                }
                                if (width) {
                                    if ((className = getClass.call(width)) == numberClass) {
                                        // Convert the `width` to an integer and create a string containing
                                        // `width` number of space characters.
                                        if ((width -= width % 1) > 0) {
                                            for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") {}
                                        }
                                    } else if (className == stringClass) {
                                        whitespace = width.length <= 10 ? width : width.slice(0, 10);
                                    }
                                }
                                // Opera <= 7.54u2 discards the values associated with empty string keys
                                // (`""`) only if they are used directly within an object member list
                                // (e.g., `!("" in { "": 1})`).
                                return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
                            };
                        }

                        // Public: Parses a JSON source string.
                        if (!has("json-parse")) {
                            var fromCharCode = String.fromCharCode;

                            // Internal: A map of escaped control characters and their unescaped
                            // equivalents.
                            var Unescapes = {
                                92: "\\",
                                34: '"',
                                47: "/",
                                98: "\b",
                                116: "\t",
                                110: "\n",
                                102: "\f",
                                114: "\r"
                            };

                            // Internal: Stores the parser state.
                            var Index, Source;

                            // Internal: Resets the parser state and throws a `SyntaxError`.
                            var abort = function abort() {
                                Index = Source = null;
                                throw SyntaxError();
                            };

                            // Internal: Returns the next token, or `"$"` if the parser has reached
                            // the end of the source string. A token may be a string, number, `null`
                            // literal, or Boolean literal.
                            var lex = function lex() {
                                var source = Source,
                                    length = source.length,
                                    value,
                                    begin,
                                    position,
                                    isSigned,
                                    charCode;
                                while (Index < length) {
                                    charCode = source.charCodeAt(Index);
                                    switch (charCode) {
                                        case 9:case 10:case 13:case 32:
                                        // Skip whitespace tokens, including tabs, carriage returns, line
                                        // feeds, and space characters.
                                        Index++;
                                        break;
                                        case 123:case 125:case 91:case 93:case 58:case 44:
                                        // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                                        // the current position.
                                        value = charIndexBuggy ? source.charAt(Index) : source[Index];
                                        Index++;
                                        return value;
                                        case 34:
                                            // `"` delimits a JSON string; advance to the next character and
                                            // begin parsing the string. String tokens are prefixed with the
                                            // sentinel `@` character to distinguish them from punctuators and
                                            // end-of-string tokens.
                                            for (value = "@", Index++; Index < length;) {
                                                charCode = source.charCodeAt(Index);
                                                if (charCode < 32) {
                                                    // Unescaped ASCII control characters (those with a code unit
                                                    // less than the space character) are not permitted.
                                                    abort();
                                                } else if (charCode == 92) {
                                                    // A reverse solidus (`\`) marks the beginning of an escaped
                                                    // control character (including `"`, `\`, and `/`) or Unicode
                                                    // escape sequence.
                                                    charCode = source.charCodeAt(++Index);
                                                    switch (charCode) {
                                                        case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
                                                        // Revive escaped control characters.
                                                        value += Unescapes[charCode];
                                                        Index++;
                                                        break;
                                                        case 117:
                                                            // `\u` marks the beginning of a Unicode escape sequence.
                                                            // Advance to the first character and validate the
                                                            // four-digit code point.
                                                            begin = ++Index;
                                                            for (position = Index + 4; Index < position; Index++) {
                                                                charCode = source.charCodeAt(Index);
                                                                // A valid sequence comprises four hexdigits (case-
                                                                // insensitive) that form a single hexadecimal value.
                                                                if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                                                    // Invalid Unicode escape sequence.
                                                                    abort();
                                                                }
                                                            }
                                                            // Revive the escaped character.
                                                            value += fromCharCode("0x" + source.slice(begin, Index));
                                                            break;
                                                        default:
                                                            // Invalid escape sequence.
                                                            abort();
                                                    }
                                                } else {
                                                    if (charCode == 34) {
                                                        // An unescaped double-quote character marks the end of the
                                                        // string.
                                                        break;
                                                    }
                                                    charCode = source.charCodeAt(Index);
                                                    begin = Index;
                                                    // Optimize for the common case where a string is valid.
                                                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                                                        charCode = source.charCodeAt(++Index);
                                                    }
                                                    // Append the string as-is.
                                                    value += source.slice(begin, Index);
                                                }
                                            }
                                            if (source.charCodeAt(Index) == 34) {
                                                // Advance to the next character and return the revived string.
                                                Index++;
                                                return value;
                                            }
                                            // Unterminated string.
                                            abort();
                                        default:
                                            // Parse numbers and literals.
                                            begin = Index;
                                            // Advance past the negative sign, if one is specified.
                                            if (charCode == 45) {
                                                isSigned = true;
                                                charCode = source.charCodeAt(++Index);
                                            }
                                            // Parse an integer or floating-point value.
                                            if (charCode >= 48 && charCode <= 57) {
                                                // Leading zeroes are interpreted as octal literals.
                                                if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
                                                    // Illegal octal literal.
                                                    abort();
                                                }
                                                isSigned = false;
                                                // Parse the integer component.
                                                for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}
                                                // Floats cannot contain a leading decimal point; however, this
                                                // case is already accounted for by the parser.
                                                if (source.charCodeAt(Index) == 46) {
                                                    position = ++Index;
                                                    // Parse the decimal component.
                                                    for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
                                                    if (position == Index) {
                                                        // Illegal trailing decimal.
                                                        abort();
                                                    }
                                                    Index = position;
                                                }
                                                // Parse exponents. The `e` denoting the exponent is
                                                // case-insensitive.
                                                charCode = source.charCodeAt(Index);
                                                if (charCode == 101 || charCode == 69) {
                                                    charCode = source.charCodeAt(++Index);
                                                    // Skip past the sign following the exponent, if one is
                                                    // specified.
                                                    if (charCode == 43 || charCode == 45) {
                                                        Index++;
                                                    }
                                                    // Parse the exponential component.
                                                    for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
                                                    if (position == Index) {
                                                        // Illegal empty exponent.
                                                        abort();
                                                    }
                                                    Index = position;
                                                }
                                                // Coerce the parsed value to a JavaScript number.
                                                return +source.slice(begin, Index);
                                            }
                                            // A negative sign may only precede numbers.
                                            if (isSigned) {
                                                abort();
                                            }
                                            // `true`, `false`, and `null` literals.
                                            if (source.slice(Index, Index + 4) == "true") {
                                                Index += 4;
                                                return true;
                                            } else if (source.slice(Index, Index + 5) == "false") {
                                                Index += 5;
                                                return false;
                                            } else if (source.slice(Index, Index + 4) == "null") {
                                                Index += 4;
                                                return null;
                                            }
                                            // Unrecognized token.
                                            abort();
                                    }
                                }
                                // Return the sentinel `$` character if the parser has reached the end
                                // of the source string.
                                return "$";
                            };

                            // Internal: Parses a JSON `value` token.
                            var get = function get(value) {
                                var results, hasMembers;
                                if (value == "$") {
                                    // Unexpected end of input.
                                    abort();
                                }
                                if (typeof value == "string") {
                                    if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                                        // Remove the sentinel `@` character.
                                        return value.slice(1);
                                    }
                                    // Parse object and array literals.
                                    if (value == "[") {
                                        // Parses a JSON array, returning a new JavaScript array.
                                        results = [];
                                        for (;; hasMembers || (hasMembers = true)) {
                                            value = lex();
                                            // A closing square bracket marks the end of the array literal.
                                            if (value == "]") {
                                                break;
                                            }
                                            // If the array literal contains elements, the current token
                                            // should be a comma separating the previous element from the
                                            // next.
                                            if (hasMembers) {
                                                if (value == ",") {
                                                    value = lex();
                                                    if (value == "]") {
                                                        // Unexpected trailing `,` in array literal.
                                                        abort();
                                                    }
                                                } else {
                                                    // A `,` must separate each array element.
                                                    abort();
                                                }
                                            }
                                            // Elisions and leading commas are not permitted.
                                            if (value == ",") {
                                                abort();
                                            }
                                            results.push(get(value));
                                        }
                                        return results;
                                    } else if (value == "{") {
                                        // Parses a JSON object, returning a new JavaScript object.
                                        results = {};
                                        for (;; hasMembers || (hasMembers = true)) {
                                            value = lex();
                                            // A closing curly brace marks the end of the object literal.
                                            if (value == "}") {
                                                break;
                                            }
                                            // If the object literal contains members, the current token
                                            // should be a comma separator.
                                            if (hasMembers) {
                                                if (value == ",") {
                                                    value = lex();
                                                    if (value == "}") {
                                                        // Unexpected trailing `,` in object literal.
                                                        abort();
                                                    }
                                                } else {
                                                    // A `,` must separate each object member.
                                                    abort();
                                                }
                                            }
                                            // Leading commas are not permitted, object property names must be
                                            // double-quoted strings, and a `:` must separate each property
                                            // name and value.
                                            if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                                                abort();
                                            }
                                            results[value.slice(1)] = get(lex());
                                        }
                                        return results;
                                    }
                                    // Unexpected token encountered.
                                    abort();
                                }
                                return value;
                            };

                            // Internal: Updates a traversed object member.
                            var update = function update(source, property, callback) {
                                var element = walk(source, property, callback);
                                if (element === undef) {
                                    delete source[property];
                                } else {
                                    source[property] = element;
                                }
                            };

                            // Internal: Recursively traverses a parsed JSON object, invoking the
                            // `callback` function for each value. This is an implementation of the
                            // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
                            var walk = function walk(source, property, callback) {
                                var value = source[property],
                                    length;
                                if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
                                    // `forEach` can't be used to traverse an array in Opera <= 8.54
                                    // because its `Object#hasOwnProperty` implementation returns `false`
                                    // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                                    if (getClass.call(value) == arrayClass) {
                                        for (length = value.length; length--;) {
                                            update(value, length, callback);
                                        }
                                    } else {
                                        _forEach(value, function (property) {
                                            update(value, property, callback);
                                        });
                                    }
                                }
                                return callback.call(source, property, value);
                            };

                            // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
                            exports.parse = function (source, callback) {
                                var result, value;
                                Index = 0;
                                Source = "" + source;
                                result = get(lex());
                                // If a JSON string contains multiple tokens, it is invalid.
                                if (lex() != "$") {
                                    abort();
                                }
                                // Reset the parser state.
                                Index = Source = null;
                                return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
                            };
                        }
                    }

                    exports["runInContext"] = runInContext;
                    return exports;
                }

                if (freeExports && !isLoader) {
                    // Export for CommonJS environments.
                    runInContext(root, freeExports);
                } else {
                    // Export for web browsers and JavaScript engines.
                    var nativeJSON = root.JSON,
                        previousJSON = root["JSON3"],
                        isRestored = false;

                    var JSON3 = runInContext(root, root["JSON3"] = {
                        // Public: Restores the original value of the global `JSON` object and
                        // returns a reference to the `JSON3` object.
                        "noConflict": function noConflict() {
                            if (!isRestored) {
                                isRestored = true;
                                root.JSON = nativeJSON;
                                root["JSON3"] = previousJSON;
                                nativeJSON = previousJSON = null;
                            }
                            return JSON3;
                        }
                    });

                    root.JSON = {
                        "parse": JSON3.parse,
                        "stringify": JSON3.stringify
                    };
                }

                // Export for asynchronous module loaders.
                if (isLoader) {
                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                        return JSON3;
                    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                }
            }).call(undefined);
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module), (function() { return this; }())))

        /***/ },
    /* 46 */
    /***/ function(module, exports) {

        'use strict';

        module.exports = '1.1.1';

        /***/ },
    /* 47 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var eventUtils = __webpack_require__(13),
                JSON3 = __webpack_require__(45),
                browser = __webpack_require__(37);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:utils:iframe');
            }

            module.exports = {
                WPrefix: '_jp',
                currentWindowId: null,

                polluteGlobalNamespace: function polluteGlobalNamespace() {
                    if (!(module.exports.WPrefix in global)) {
                        global[module.exports.WPrefix] = {};
                    }
                },

                postMessage: function postMessage(type, data) {
                    if (global.parent !== global) {
                        global.parent.postMessage(JSON3.stringify({
                            windowId: module.exports.currentWindowId,
                            type: type,
                            data: data || ''
                        }), '*');
                    } else {
                        debug('Cannot postMessage, no parent window.', type, data);
                    }
                },

                createIframe: function createIframe(iframeUrl, errorCallback) {
                    var iframe = global.document.createElement('iframe');
                    var tref, unloadRef;
                    var unattach = function unattach() {
                        debug('unattach');
                        clearTimeout(tref);
                        // Explorer had problems with that.
                        try {
                            iframe.onload = null;
                        } catch (x) {
                            // intentionally empty
                        }
                        iframe.onerror = null;
                    };
                    var cleanup = function cleanup() {
                        debug('cleanup');
                        if (iframe) {
                            unattach();
                            // This timeout makes chrome fire onbeforeunload event
                            // within iframe. Without the timeout it goes straight to
                            // onunload.
                            setTimeout(function () {
                                if (iframe) {
                                    iframe.parentNode.removeChild(iframe);
                                }
                                iframe = null;
                            }, 0);
                            eventUtils.unloadDel(unloadRef);
                        }
                    };
                    var onerror = function onerror(err) {
                        debug('onerror', err);
                        if (iframe) {
                            cleanup();
                            errorCallback(err);
                        }
                    };
                    var post = function post(msg, origin) {
                        debug('post', msg, origin);
                        try {
                            // When the iframe is not loaded, IE raises an exception
                            // on 'contentWindow'.
                            setTimeout(function () {
                                if (iframe && iframe.contentWindow) {
                                    iframe.contentWindow.postMessage(msg, origin);
                                }
                            }, 0);
                        } catch (x) {
                            // intentionally empty
                        }
                    };

                    iframe.src = iframeUrl;
                    iframe.style.display = 'none';
                    iframe.style.position = 'absolute';
                    iframe.onerror = function () {
                        onerror('onerror');
                    };
                    iframe.onload = function () {
                        debug('onload');
                        // `onload` is triggered before scripts on the iframe are
                        // executed. Give it few seconds to actually load stuff.
                        clearTimeout(tref);
                        tref = setTimeout(function () {
                            onerror('onload timeout');
                        }, 2000);
                    };
                    global.document.body.appendChild(iframe);
                    tref = setTimeout(function () {
                        onerror('timeout');
                    }, 15000);
                    unloadRef = eventUtils.unloadAdd(cleanup);
                    return {
                        post: post,
                        cleanup: cleanup,
                        loaded: unattach
                    };
                }

                /* jshint undef: false, newcap: false */
                /* eslint no-undef: 0, new-cap: 0 */
                , createHtmlfile: function createHtmlfile(iframeUrl, errorCallback) {
                    var axo = ['Active'].concat('Object').join('X');
                    var doc = new global[axo]('htmlfile');
                    var tref, unloadRef;
                    var iframe;
                    var unattach = function unattach() {
                        clearTimeout(tref);
                        iframe.onerror = null;
                    };
                    var cleanup = function cleanup() {
                        if (doc) {
                            unattach();
                            eventUtils.unloadDel(unloadRef);
                            iframe.parentNode.removeChild(iframe);
                            iframe = doc = null;
                            CollectGarbage();
                        }
                    };
                    var onerror = function onerror(r) {
                        debug('onerror', r);
                        if (doc) {
                            cleanup();
                            errorCallback(r);
                        }
                    };
                    var post = function post(msg, origin) {
                        try {
                            // When the iframe is not loaded, IE raises an exception
                            // on 'contentWindow'.
                            setTimeout(function () {
                                if (iframe && iframe.contentWindow) {
                                    iframe.contentWindow.postMessage(msg, origin);
                                }
                            }, 0);
                        } catch (x) {
                            // intentionally empty
                        }
                    };

                    doc.open();
                    doc.write('<html><s' + 'cript>' + 'document.domain="' + global.document.domain + '";' + '</s' + 'cript></html>');
                    doc.close();
                    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
                    var c = doc.createElement('div');
                    doc.body.appendChild(c);
                    iframe = doc.createElement('iframe');
                    c.appendChild(iframe);
                    iframe.src = iframeUrl;
                    iframe.onerror = function () {
                        onerror('onerror');
                    };
                    tref = setTimeout(function () {
                        onerror('timeout');
                    }, 15000);
                    unloadRef = eventUtils.unloadAdd(cleanup);
                    return {
                        post: post,
                        cleanup: cleanup,
                        loaded: unattach
                    };
                }
            };

            module.exports.iframeEnabled = false;
            if (global.document) {
                // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
                // huge delay, or not at all.
                module.exports.iframeEnabled = (typeof global.postMessage === 'function' || _typeof(global.postMessage) === 'object') && !browser.isKonqueror();
            }
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), (function() { return this; }())))

        /***/ },
    /* 48 */
    /***/ function(module, exports) {

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        module.exports = {
            isObject: function isObject(obj) {
                var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
                return type === 'function' || type === 'object' && !!obj;
            },

            extend: function extend(obj) {
                if (!this.isObject(obj)) {
                    return obj;
                }
                var source, prop;
                for (var i = 1, length = arguments.length; i < length; i++) {
                    source = arguments[i];
                    for (prop in source) {
                        if (Object.prototype.hasOwnProperty.call(source, prop)) {
                            obj[prop] = source[prop];
                        }
                    }
                }
                return obj;
            }
        };

        /***/ },
    /* 49 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            HtmlfileReceiver = __webpack_require__(50),
            XHRLocalObject = __webpack_require__(36),
            AjaxBasedTransport = __webpack_require__(29);

        function HtmlFileTransport(transUrl) {
            if (!HtmlfileReceiver.enabled) {
                throw new Error('Transport created when disabled');
            }
            AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
        }

        inherits(HtmlFileTransport, AjaxBasedTransport);

        HtmlFileTransport.enabled = function (info) {
            return HtmlfileReceiver.enabled && info.sameOrigin;
        };

        HtmlFileTransport.transportName = 'htmlfile';
        HtmlFileTransport.roundTrips = 2;

        module.exports = HtmlFileTransport;

        /***/ },
    /* 50 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

            var inherits = __webpack_require__(24),
                iframeUtils = __webpack_require__(47),
                urlUtils = __webpack_require__(16),
                EventEmitter = __webpack_require__(25).EventEmitter,
                random = __webpack_require__(14);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:receiver:htmlfile');
            }

            function HtmlfileReceiver(url) {
                debug(url);
                EventEmitter.call(this);
                var self = this;
                iframeUtils.polluteGlobalNamespace();

                this.id = 'a' + random.string(6);
                url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

                debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
                var constructFunc = HtmlfileReceiver.htmlfileEnabled ? iframeUtils.createHtmlfile : iframeUtils.createIframe;

                global[iframeUtils.WPrefix][this.id] = {
                    start: function start() {
                        debug('start');
                        self.iframeObj.loaded();
                    },
                    message: function message(data) {
                        debug('message', data);
                        self.emit('message', data);
                    },
                    stop: function stop() {
                        debug('stop');
                        self._cleanup();
                        self._close('network');
                    }
                };
                this.iframeObj = constructFunc(url, function () {
                    debug('callback');
                    self._cleanup();
                    self._close('permanent');
                });
            }

            inherits(HtmlfileReceiver, EventEmitter);

            HtmlfileReceiver.prototype.abort = function () {
                debug('abort');
                this._cleanup();
                this._close('user');
            };

            HtmlfileReceiver.prototype._cleanup = function () {
                debug('_cleanup');
                if (this.iframeObj) {
                    this.iframeObj.cleanup();
                    this.iframeObj = null;
                }
                delete global[iframeUtils.WPrefix][this.id];
            };

            HtmlfileReceiver.prototype._close = function (reason) {
                debug('_close', reason);
                this.emit('close', null, reason);
                this.removeAllListeners();
            };

            HtmlfileReceiver.htmlfileEnabled = false;

            // obfuscate to avoid firewalls
            var axo = ['Active'].concat('Object').join('X');
            if (axo in global) {
                try {
                    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
                } catch (x) {
                    // intentionally empty
                }
            }

            HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

            module.exports = HtmlfileReceiver;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), (function() { return this; }())))

        /***/ },
    /* 51 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            AjaxBasedTransport = __webpack_require__(29),
            XhrReceiver = __webpack_require__(33),
            XHRCorsObject = __webpack_require__(34),
            XHRLocalObject = __webpack_require__(36);

        function XhrPollingTransport(transUrl) {
            if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
                throw new Error('Transport created when disabled');
            }
            AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
        }

        inherits(XhrPollingTransport, AjaxBasedTransport);

        XhrPollingTransport.enabled = function (info) {
            if (info.nullOrigin) {
                return false;
            }

            if (XHRLocalObject.enabled && info.sameOrigin) {
                return true;
            }
            return XHRCorsObject.enabled;
        };

        XhrPollingTransport.transportName = 'xhr-polling';
        XhrPollingTransport.roundTrips = 2; // preflight, ajax

        module.exports = XhrPollingTransport;

        /***/ },
    /* 52 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            AjaxBasedTransport = __webpack_require__(29),
            XdrStreamingTransport = __webpack_require__(38),
            XhrReceiver = __webpack_require__(33),
            XDRObject = __webpack_require__(39);

        function XdrPollingTransport(transUrl) {
            if (!XDRObject.enabled) {
                throw new Error('Transport created when disabled');
            }
            AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
        }

        inherits(XdrPollingTransport, AjaxBasedTransport);

        XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
        XdrPollingTransport.transportName = 'xdr-polling';
        XdrPollingTransport.roundTrips = 2; // preflight, ajax

        module.exports = XdrPollingTransport;

        /***/ },
    /* 53 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            // The simplest and most robust transport, using the well-know cross
            // domain hack - JSONP. This transport is quite inefficient - one
            // message could use up to one http request. But at least it works almost
            // everywhere.
            // Known limitations:
            //   o you will get a spinning cursor
            //   o for Konqueror a dumb timer is needed to detect errors

            var inherits = __webpack_require__(24),
                SenderReceiver = __webpack_require__(30),
                JsonpReceiver = __webpack_require__(54),
                jsonpSender = __webpack_require__(55);

            function JsonPTransport(transUrl) {
                if (!JsonPTransport.enabled()) {
                    throw new Error('Transport created when disabled');
                }
                SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
            }

            inherits(JsonPTransport, SenderReceiver);

            JsonPTransport.enabled = function () {
                return !!global.document;
            };

            JsonPTransport.transportName = 'jsonp-polling';
            JsonPTransport.roundTrips = 1;
            JsonPTransport.needBody = true;

            module.exports = JsonPTransport;
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 54 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

            var utils = __webpack_require__(47),
                random = __webpack_require__(14),
                browser = __webpack_require__(37),
                urlUtils = __webpack_require__(16),
                inherits = __webpack_require__(24),
                EventEmitter = __webpack_require__(25).EventEmitter;

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:receiver:jsonp');
            }

            function JsonpReceiver(url) {
                debug(url);
                var self = this;
                EventEmitter.call(this);

                utils.polluteGlobalNamespace();

                this.id = 'a' + random.string(6);
                var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

                global[utils.WPrefix][this.id] = this._callback.bind(this);
                this._createScript(urlWithId);

                // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
                this.timeoutId = setTimeout(function () {
                    debug('timeout');
                    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
                }, JsonpReceiver.timeout);
            }

            inherits(JsonpReceiver, EventEmitter);

            JsonpReceiver.prototype.abort = function () {
                debug('abort');
                if (global[utils.WPrefix][this.id]) {
                    var err = new Error('JSONP user aborted read');
                    err.code = 1000;
                    this._abort(err);
                }
            };

            JsonpReceiver.timeout = 35000;
            JsonpReceiver.scriptErrorTimeout = 1000;

            JsonpReceiver.prototype._callback = function (data) {
                debug('_callback', data);
                this._cleanup();

                if (this.aborting) {
                    return;
                }

                if (data) {
                    debug('message', data);
                    this.emit('message', data);
                }
                this.emit('close', null, 'network');
                this.removeAllListeners();
            };

            JsonpReceiver.prototype._abort = function (err) {
                debug('_abort', err);
                this._cleanup();
                this.aborting = true;
                this.emit('close', err.code, err.message);
                this.removeAllListeners();
            };

            JsonpReceiver.prototype._cleanup = function () {
                debug('_cleanup');
                clearTimeout(this.timeoutId);
                if (this.script2) {
                    this.script2.parentNode.removeChild(this.script2);
                    this.script2 = null;
                }
                if (this.script) {
                    var script = this.script;
                    // Unfortunately, you can't really abort script loading of
                    // the script.
                    script.parentNode.removeChild(script);
                    script.onreadystatechange = script.onerror = script.onload = script.onclick = null;
                    this.script = null;
                }
                delete global[utils.WPrefix][this.id];
            };

            JsonpReceiver.prototype._scriptError = function () {
                debug('_scriptError');
                var self = this;
                if (this.errorTimer) {
                    return;
                }

                this.errorTimer = setTimeout(function () {
                    if (!self.loadedOkay) {
                        self._abort(new Error('JSONP script loaded abnormally (onerror)'));
                    }
                }, JsonpReceiver.scriptErrorTimeout);
            };

            JsonpReceiver.prototype._createScript = function (url) {
                debug('_createScript', url);
                var self = this;
                var script = this.script = global.document.createElement('script');
                var script2; // Opera synchronous load trick.

                script.id = 'a' + random.string(8);
                script.src = url;
                script.type = 'text/javascript';
                script.charset = 'UTF-8';
                script.onerror = this._scriptError.bind(this);
                script.onload = function () {
                    debug('onload');
                    self._abort(new Error('JSONP script loaded abnormally (onload)'));
                };

                // IE9 fires 'error' event after onreadystatechange or before, in random order.
                // Use loadedOkay to determine if actually errored
                script.onreadystatechange = function () {
                    debug('onreadystatechange', script.readyState);
                    if (/loaded|closed/.test(script.readyState)) {
                        if (script && script.htmlFor && script.onclick) {
                            self.loadedOkay = true;
                            try {
                                // In IE, actually execute the script.
                                script.onclick();
                            } catch (x) {
                                // intentionally empty
                            }
                        }
                        if (script) {
                            self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
                        }
                    }
                };
                // IE: event/htmlFor/onclick trick.
                // One can't rely on proper order for onreadystatechange. In order to
                // make sure, set a 'htmlFor' and 'event' properties, so that
                // script code will be installed as 'onclick' handler for the
                // script object. Later, onreadystatechange, manually execute this
                // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
                // set. For reference see:
                //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
                // Also, read on that about script ordering:
                //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
                if (typeof script.async === 'undefined' && global.document.attachEvent) {
                    // According to mozilla docs, in recent browsers script.async defaults
                    // to 'true', so we may use it to detect a good browser:
                    // https://developer.mozilla.org/en/HTML/Element/script
                    if (!browser.isOpera()) {
                        // Naively assume we're in IE
                        try {
                            script.htmlFor = script.id;
                            script.event = 'onclick';
                        } catch (x) {
                            // intentionally empty
                        }
                        script.async = true;
                    } else {
                        // Opera, second sync script hack
                        script2 = this.script2 = global.document.createElement('script');
                        script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
                        script.async = script2.async = false;
                    }
                }
                if (typeof script.async !== 'undefined') {
                    script.async = true;
                }

                var head = global.document.getElementsByTagName('head')[0];
                head.insertBefore(script, head.firstChild);
                if (script2) {
                    head.insertBefore(script2, head.firstChild);
                }
            };

            module.exports = JsonpReceiver;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), (function() { return this; }())))

        /***/ },
    /* 55 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

            var random = __webpack_require__(14),
                urlUtils = __webpack_require__(16);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:sender:jsonp');
            }

            var form, area;

            function createIframe(id) {
                debug('createIframe', id);
                try {
                    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
                    return global.document.createElement('<iframe name="' + id + '">');
                } catch (x) {
                    var iframe = global.document.createElement('iframe');
                    iframe.name = id;
                    return iframe;
                }
            }

            function createForm() {
                debug('createForm');
                form = global.document.createElement('form');
                form.style.display = 'none';
                form.style.position = 'absolute';
                form.method = 'POST';
                form.enctype = 'application/x-www-form-urlencoded';
                form.acceptCharset = 'UTF-8';

                area = global.document.createElement('textarea');
                area.name = 'd';
                form.appendChild(area);

                global.document.body.appendChild(form);
            }

            module.exports = function (url, payload, callback) {
                debug(url, payload);
                if (!form) {
                    createForm();
                }
                var id = 'a' + random.string(8);
                form.target = id;
                form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

                var iframe = createIframe(id);
                iframe.id = id;
                iframe.style.display = 'none';
                form.appendChild(iframe);

                try {
                    area.value = payload;
                } catch (e) {
                    // seriously broken browsers get here
                }
                form.submit();

                var completed = function completed(err) {
                    debug('completed', id, err);
                    if (!iframe.onerror) {
                        return;
                    }
                    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
                    // Opera mini doesn't like if we GC iframe
                    // immediately, thus this timeout.
                    setTimeout(function () {
                        debug('cleaning up', id);
                        iframe.parentNode.removeChild(iframe);
                        iframe = null;
                    }, 500);
                    area.value = '';
                    // It is not possible to detect if the iframe succeeded or
                    // failed to submit our form.
                    callback(err);
                };
                iframe.onerror = function () {
                    debug('onerror', id);
                    completed();
                };
                iframe.onload = function () {
                    debug('onload', id);
                    completed();
                };
                iframe.onreadystatechange = function (e) {
                    debug('onreadystatechange', id, iframe.readyState, e);
                    if (iframe.readyState === 'complete') {
                        completed();
                    }
                };
                return function () {
                    debug('aborted', id);
                    completed(new Error('Aborted'));
                };
            };
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), (function() { return this; }())))

        /***/ },
    /* 56 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

            __webpack_require__(57);

            var URL = __webpack_require__(17),
                inherits = __webpack_require__(24),
                JSON3 = __webpack_require__(45),
                random = __webpack_require__(14),
                escape = __webpack_require__(58),
                urlUtils = __webpack_require__(16),
                eventUtils = __webpack_require__(13),
                transport = __webpack_require__(59),
                objectUtils = __webpack_require__(48),
                browser = __webpack_require__(37),
                log = __webpack_require__(60),
                Event = __webpack_require__(61),
                EventTarget = __webpack_require__(26),
                loc = __webpack_require__(62),
                CloseEvent = __webpack_require__(63),
                TransportMessageEvent = __webpack_require__(64),
                InfoReceiver = __webpack_require__(65);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:main');
            }

            var transports;

            // follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
            function SockJS(url, protocols, options) {
                if (!(this instanceof SockJS)) {
                    return new SockJS(url, protocols, options);
                }
                if (arguments.length < 1) {
                    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
                }
                EventTarget.call(this);

                this.readyState = SockJS.CONNECTING;
                this.extensions = '';
                this.protocol = '';

                // non-standard extension
                options = options || {};
                if (options.protocols_whitelist) {
                    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
                }
                this._transportsWhitelist = options.transports;
                this._transportOptions = options.transportOptions || {};

                var sessionId = options.sessionId || 8;
                if (typeof sessionId === 'function') {
                    this._generateSessionId = sessionId;
                } else if (typeof sessionId === 'number') {
                    this._generateSessionId = function () {
                        return random.string(sessionId);
                    };
                } else {
                    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
                }

                this._server = options.server || random.numberString(1000);

                // Step 1 of WS spec - parse and validate the url. Issue #8
                var parsedUrl = new URL(url);
                if (!parsedUrl.host || !parsedUrl.protocol) {
                    throw new SyntaxError("The URL '" + url + "' is invalid");
                } else if (parsedUrl.hash) {
                    throw new SyntaxError('The URL must not contain a fragment');
                } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
                    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
                }

                var secure = parsedUrl.protocol === 'https:';
                // Step 2 - don't allow secure origin with an insecure protocol
                if (loc.protocol === 'https' && !secure) {
                    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
                }

                // Step 3 - check port access - no need here
                // Step 4 - parse protocols argument
                if (!protocols) {
                    protocols = [];
                } else if (!Array.isArray(protocols)) {
                    protocols = [protocols];
                }

                // Step 5 - check protocols argument
                var sortedProtocols = protocols.sort();
                sortedProtocols.forEach(function (proto, i) {
                    if (!proto) {
                        throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
                    }
                    if (i < sortedProtocols.length - 1 && proto === sortedProtocols[i + 1]) {
                        throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
                    }
                });

                // Step 6 - convert origin
                var o = urlUtils.getOrigin(loc.href);
                this._origin = o ? o.toLowerCase() : null;

                // remove the trailing slash
                parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

                // store the sanitized url
                this.url = parsedUrl.href;
                debug('using url', this.url);

                // Step 7 - start connection in background
                // obtain server info
                // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
                this._urlInfo = {
                    nullOrigin: !browser.hasDomain(),
                    sameOrigin: urlUtils.isOriginEqual(this.url, loc.href),
                    sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
                };

                this._ir = new InfoReceiver(this.url, this._urlInfo);
                this._ir.once('finish', this._receiveInfo.bind(this));
            }

            inherits(SockJS, EventTarget);

            function userSetCode(code) {
                return code === 1000 || code >= 3000 && code <= 4999;
            }

            SockJS.prototype.close = function (code, reason) {
                // Step 1
                if (code && !userSetCode(code)) {
                    throw new Error('InvalidAccessError: Invalid code');
                }
                // Step 2.4 states the max is 123 bytes, but we are just checking length
                if (reason && reason.length > 123) {
                    throw new SyntaxError('reason argument has an invalid length');
                }

                // Step 3.1
                if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
                    return;
                }

                // TODO look at docs to determine how to set this
                var wasClean = true;
                this._close(code || 1000, reason || 'Normal closure', wasClean);
            };

            SockJS.prototype.send = function (data) {
                // #13 - convert anything non-string to string
                // TODO this currently turns objects into [object Object]
                if (typeof data !== 'string') {
                    data = '' + data;
                }
                if (this.readyState === SockJS.CONNECTING) {
                    throw new Error('InvalidStateError: The connection has not been established yet');
                }
                if (this.readyState !== SockJS.OPEN) {
                    return;
                }
                this._transport.send(escape.quote(data));
            };

            SockJS.version = __webpack_require__(46);

            SockJS.CONNECTING = 0;
            SockJS.OPEN = 1;
            SockJS.CLOSING = 2;
            SockJS.CLOSED = 3;

            SockJS.prototype._receiveInfo = function (info, rtt) {
                debug('_receiveInfo', rtt);
                this._ir = null;
                if (!info) {
                    this._close(1002, 'Cannot connect to server');
                    return;
                }

                // establish a round-trip timeout (RTO) based on the
                // round-trip time (RTT)
                this._rto = this.countRTO(rtt);
                // allow server to override url used for the actual transport
                this._transUrl = info.base_url ? info.base_url : this.url;
                info = objectUtils.extend(info, this._urlInfo);
                debug('info', info);
                // determine list of desired and supported transports
                var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
                this._transports = enabledTransports.main;
                debug(this._transports.length + ' enabled transports');

                this._connect();
            };

            SockJS.prototype._connect = function () {
                for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
                    debug('attempt', Transport.transportName);
                    if (Transport.needBody) {
                        if (!global.document.body || typeof global.document.readyState !== 'undefined' && global.document.readyState !== 'complete' && global.document.readyState !== 'interactive') {
                            debug('waiting for body');
                            this._transports.unshift(Transport);
                            eventUtils.attachEvent('load', this._connect.bind(this));
                            return;
                        }
                    }

                    // calculate timeout based on RTO and round trips. Default to 5s
                    var timeoutMs = this._rto * Transport.roundTrips || 5000;
                    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
                    debug('using timeout', timeoutMs);

                    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
                    var options = this._transportOptions[Transport.transportName];
                    debug('transport url', transportUrl);
                    var transportObj = new Transport(transportUrl, this._transUrl, options);
                    transportObj.on('message', this._transportMessage.bind(this));
                    transportObj.once('close', this._transportClose.bind(this));
                    transportObj.transportName = Transport.transportName;
                    this._transport = transportObj;

                    return;
                }
                this._close(2000, 'All transports failed', false);
            };

            SockJS.prototype._transportTimeout = function () {
                debug('_transportTimeout');
                if (this.readyState === SockJS.CONNECTING) {
                    this._transportClose(2007, 'Transport timed out');
                }
            };

            SockJS.prototype._transportMessage = function (msg) {
                debug('_transportMessage', msg);
                var self = this,
                    type = msg.slice(0, 1),
                    content = msg.slice(1),
                    payload;

                // first check for messages that don't need a payload
                switch (type) {
                    case 'o':
                        this._open();
                        return;
                    case 'h':
                        this.dispatchEvent(new Event('heartbeat'));
                        debug('heartbeat', this.transport);
                        return;
                }

                if (content) {
                    try {
                        payload = JSON3.parse(content);
                    } catch (e) {
                        debug('bad json', content);
                    }
                }

                if (typeof payload === 'undefined') {
                    debug('empty payload', content);
                    return;
                }

                switch (type) {
                    case 'a':
                        if (Array.isArray(payload)) {
                            payload.forEach(function (p) {
                                debug('message', self.transport, p);
                                self.dispatchEvent(new TransportMessageEvent(p));
                            });
                        }
                        break;
                    case 'm':
                        debug('message', this.transport, payload);
                        this.dispatchEvent(new TransportMessageEvent(payload));
                        break;
                    case 'c':
                        if (Array.isArray(payload) && payload.length === 2) {
                            this._close(payload[0], payload[1], true);
                        }
                        break;
                }
            };

            SockJS.prototype._transportClose = function (code, reason) {
                debug('_transportClose', this.transport, code, reason);
                if (this._transport) {
                    this._transport.removeAllListeners();
                    this._transport = null;
                    this.transport = null;
                }

                if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
                    this._connect();
                    return;
                }

                this._close(code, reason);
            };

            SockJS.prototype._open = function () {
                debug('_open', this._transport.transportName, this.readyState);
                if (this.readyState === SockJS.CONNECTING) {
                    if (this._transportTimeoutId) {
                        clearTimeout(this._transportTimeoutId);
                        this._transportTimeoutId = null;
                    }
                    this.readyState = SockJS.OPEN;
                    this.transport = this._transport.transportName;
                    this.dispatchEvent(new Event('open'));
                    debug('connected', this.transport);
                } else {
                    // The server might have been restarted, and lost track of our
                    // connection.
                    this._close(1006, 'Server lost session');
                }
            };

            SockJS.prototype._close = function (code, reason, wasClean) {
                debug('_close', this.transport, code, reason, wasClean, this.readyState);
                var forceFail = false;

                if (this._ir) {
                    forceFail = true;
                    this._ir.close();
                    this._ir = null;
                }
                if (this._transport) {
                    this._transport.close();
                    this._transport = null;
                    this.transport = null;
                }

                if (this.readyState === SockJS.CLOSED) {
                    throw new Error('InvalidStateError: SockJS has already been closed');
                }

                this.readyState = SockJS.CLOSING;
                setTimeout(function () {
                    this.readyState = SockJS.CLOSED;

                    if (forceFail) {
                        this.dispatchEvent(new Event('error'));
                    }

                    var e = new CloseEvent('close');
                    e.wasClean = wasClean || false;
                    e.code = code || 1000;
                    e.reason = reason;

                    this.dispatchEvent(e);
                    this.onmessage = this.onclose = this.onerror = null;
                    debug('disconnected');
                }.bind(this), 0);
            };

            // See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
            // and RFC 2988.
            SockJS.prototype.countRTO = function (rtt) {
                // In a local environment, when using IE8/9 and the `jsonp-polling`
                // transport the time needed to establish a connection (the time that pass
                // from the opening of the transport to the call of `_dispatchOpen`) is
                // around 200msec (the lower bound used in the article above) and this
                // causes spurious timeouts. For this reason we calculate a value slightly
                // larger than that used in the article.
                if (rtt > 100) {
                    return 4 * rtt; // rto > 400msec
                }
                return 300 + rtt; // 300msec < rto <= 400msec
            };

            module.exports = function (availableTransports) {
                transports = transport(availableTransports);
                __webpack_require__(70)(SockJS, availableTransports);
                return SockJS;
            };
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), (function() { return this; }())))

        /***/ },
    /* 57 */
    /***/ function(module, exports) {

        /* eslint-disable */
        /* jscs: disable */
        'use strict';

        // pulled specific shims from https://github.com/es-shims/es5-shim

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        var ArrayPrototype = Array.prototype;
        var ObjectPrototype = Object.prototype;
        var FunctionPrototype = Function.prototype;
        var StringPrototype = String.prototype;
        var array_slice = ArrayPrototype.slice;

        var _toString = ObjectPrototype.toString;
        var isFunction = function isFunction(val) {
            return ObjectPrototype.toString.call(val) === '[object Function]';
        };
        var isArray = function isArray(obj) {
            return _toString.call(obj) === '[object Array]';
        };
        var isString = function isString(obj) {
            return _toString.call(obj) === '[object String]';
        };

        var supportsDescriptors = Object.defineProperty && function () {
                try {
                    Object.defineProperty({}, 'x', {});
                    return true;
                } catch (e) {
                    /* this is ES3 */
                    return false;
                }
            }();

        // Define configurable, writable and non-enumerable props
        // if they don't exist.
        var defineProperty;
        if (supportsDescriptors) {
            defineProperty = function defineProperty(object, name, method, forceAssign) {
                if (!forceAssign && name in object) {
                    return;
                }
                Object.defineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: method
                });
            };
        } else {
            defineProperty = function defineProperty(object, name, method, forceAssign) {
                if (!forceAssign && name in object) {
                    return;
                }
                object[name] = method;
            };
        }
        var defineProperties = function defineProperties(object, map, forceAssign) {
            for (var name in map) {
                if (ObjectPrototype.hasOwnProperty.call(map, name)) {
                    defineProperty(object, name, map[name], forceAssign);
                }
            }
        };

        var toObject = function toObject(o) {
            if (o == null) {
                // this matches both null and undefined
                throw new TypeError("can't convert " + o + ' to object');
            }
            return Object(o);
        };

        //
        // Util
        // ======
        //

        // ES5 9.4
        // http://es5.github.com/#x9.4
        // http://jsperf.com/to-integer

        function toInteger(num) {
            var n = +num;
            if (n !== n) {
                // isNaN
                n = 0;
            } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
            return n;
        }

        function ToUint32(x) {
            return x >>> 0;
        }

        //
        // Function
        // ========
        //

        // ES-5 15.3.4.5
        // http://es5.github.com/#x15.3.4.5

        function Empty() {}

        defineProperties(FunctionPrototype, {
            bind: function bind(that) {
                // .length is 1
                // 1. Let Target be the this value.
                var target = this;
                // 2. If IsCallable(Target) is false, throw a TypeError exception.
                if (!isFunction(target)) {
                    throw new TypeError('Function.prototype.bind called on incompatible ' + target);
                }
                // 3. Let A be a new (possibly empty) internal list of all of the
                //   argument values provided after thisArg (arg1, arg2 etc), in order.
                // XXX slicedArgs will stand in for "A" if used
                var args = array_slice.call(arguments, 1); // for normal call
                // 4. Let F be a new native ECMAScript object.
                // 11. Set the [[Prototype]] internal property of F to the standard
                //   built-in Function prototype object as specified in 15.3.3.1.
                // 12. Set the [[Call]] internal property of F as described in
                //   15.3.4.5.1.
                // 13. Set the [[Construct]] internal property of F as described in
                //   15.3.4.5.2.
                // 14. Set the [[HasInstance]] internal property of F as described in
                //   15.3.4.5.3.
                var binder = function binder() {

                    if (this instanceof bound) {
                        // 15.3.4.5.2 [[Construct]]
                        // When the [[Construct]] internal method of a function object,
                        // F that was created using the bind function is called with a
                        // list of arguments ExtraArgs, the following steps are taken:
                        // 1. Let target be the value of F's [[TargetFunction]]
                        //   internal property.
                        // 2. If target has no [[Construct]] internal method, a
                        //   TypeError exception is thrown.
                        // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                        //   property.
                        // 4. Let args be a new list containing the same values as the
                        //   list boundArgs in the same order followed by the same
                        //   values as the list ExtraArgs in the same order.
                        // 5. Return the result of calling the [[Construct]] internal
                        //   method of target providing args as the arguments.

                        var result = target.apply(this, args.concat(array_slice.call(arguments)));
                        if (Object(result) === result) {
                            return result;
                        }
                        return this;
                    } else {
                        // 15.3.4.5.1 [[Call]]
                        // When the [[Call]] internal method of a function object, F,
                        // which was created using the bind function is called with a
                        // this value and a list of arguments ExtraArgs, the following
                        // steps are taken:
                        // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                        //   property.
                        // 2. Let boundThis be the value of F's [[BoundThis]] internal
                        //   property.
                        // 3. Let target be the value of F's [[TargetFunction]] internal
                        //   property.
                        // 4. Let args be a new list containing the same values as the
                        //   list boundArgs in the same order followed by the same
                        //   values as the list ExtraArgs in the same order.
                        // 5. Return the result of calling the [[Call]] internal method
                        //   of target providing boundThis as the this value and
                        //   providing args as the arguments.

                        // equiv: target.call(this, ...boundArgs, ...args)
                        return target.apply(that, args.concat(array_slice.call(arguments)));
                    }
                };

                // 15. If the [[Class]] internal property of Target is "Function", then
                //     a. Let L be the length property of Target minus the length of A.
                //     b. Set the length own property of F to either 0 or L, whichever is
                //       larger.
                // 16. Else set the length own property of F to 0.

                var boundLength = Math.max(0, target.length - args.length);

                // 17. Set the attributes of the length own property of F to the values
                //   specified in 15.3.5.1.
                var boundArgs = [];
                for (var i = 0; i < boundLength; i++) {
                    boundArgs.push('$' + i);
                }

                // XXX Build a dynamic function with desired amount of arguments is the only
                // way to set the length property of a function.
                // In environments where Content Security Policies enabled (Chrome extensions,
                // for ex.) all use of eval or Function costructor throws an exception.
                // However in all of these environments Function.prototype.bind exists
                // and so this code will never be executed.
                var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

                if (target.prototype) {
                    Empty.prototype = target.prototype;
                    bound.prototype = new Empty();
                    // Clean up dangling references.
                    Empty.prototype = null;
                }

                // TODO
                // 18. Set the [[Extensible]] internal property of F to true.

                // TODO
                // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
                // 20. Call the [[DefineOwnProperty]] internal method of F with
                //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
                //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
                //   false.
                // 21. Call the [[DefineOwnProperty]] internal method of F with
                //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
                //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
                //   and false.

                // TODO
                // NOTE Function objects created using Function.prototype.bind do not
                // have a prototype property or the [[Code]], [[FormalParameters]], and
                // [[Scope]] internal properties.
                // XXX can't delete prototype in pure-js.

                // 22. Return F.
                return bound;
            }
        });

        //
        // Array
        // =====
        //

        // ES5 15.4.3.2
        // http://es5.github.com/#x15.4.3.2
        // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
        defineProperties(Array, { isArray: isArray });

        var boxedString = Object('a');
        var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

        var properlyBoxesContext = function properlyBoxed(method) {
            // Check node 0.6.21 bug where third parameter is not boxed
            var properlyBoxesNonStrict = true;
            var properlyBoxesStrict = true;
            if (method) {
                method.call('foo', function (_, __, context) {
                    if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) !== 'object') {
                        properlyBoxesNonStrict = false;
                    }
                });

                method.call([1], function () {
                    'use strict';

                    properlyBoxesStrict = typeof this === 'string';
                }, 'x');
            }
            return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
        };

        defineProperties(ArrayPrototype, {
            forEach: function forEach(fun /*, thisp*/) {
                var object = toObject(this),
                    self = splitString && isString(this) ? this.split('') : object,
                    thisp = arguments[1],
                    i = -1,
                    length = self.length >>> 0;

                // If no callback function or if callback is not a callable function
                if (!isFunction(fun)) {
                    throw new TypeError(); // TODO message
                }

                while (++i < length) {
                    if (i in self) {
                        // Invoke the callback function with call, passing arguments:
                        // context, property value, property key, thisArg object
                        // context
                        fun.call(thisp, self[i], i, object);
                    }
                }
            }
        }, !properlyBoxesContext(ArrayPrototype.forEach));

        // ES5 15.4.4.14
        // http://es5.github.com/#x15.4.4.14
        // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
        var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
        defineProperties(ArrayPrototype, {
            indexOf: function indexOf(sought /*, fromIndex */) {
                var self = splitString && isString(this) ? this.split('') : toObject(this),
                    length = self.length >>> 0;

                if (!length) {
                    return -1;
                }

                var i = 0;
                if (arguments.length > 1) {
                    i = toInteger(arguments[1]);
                }

                // handle negative indices
                i = i >= 0 ? i : Math.max(0, length + i);
                for (; i < length; i++) {
                    if (i in self && self[i] === sought) {
                        return i;
                    }
                }
                return -1;
            }
        }, hasFirefox2IndexOfBug);

        //
        // String
        // ======
        //

        // ES5 15.5.4.14
        // http://es5.github.com/#x15.5.4.14

        // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
        // Many browsers do not split properly with regular expressions or they
        // do not perform the split correctly under obscure conditions.
        // See http://blog.stevenlevithan.com/archives/cross-browser-split
        // I've tested in many browsers and this seems to cover the deviant ones:
        //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
        //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
        //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
        //       [undefined, "t", undefined, "e", ...]
        //    ''.split(/.?/) should be [], not [""]
        //    '.'.split(/()()/) should be ["."], not ["", "", "."]

        var string_split = StringPrototype.split;
        if ('ab'.split(/(?:ab)*/).length !== 2 || '.'.split(/(.?)(.?)/).length !== 4 || 'tesst'.split(/(s)*/)[1] === 't' || 'test'.split(/(?:)/, -1).length !== 4 || ''.split(/.?/).length || '.'.split(/()()/).length > 1) {
            (function () {
                var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

                StringPrototype.split = function (separator, limit) {
                    var string = this;
                    if (separator === void 0 && limit === 0) {
                        return [];
                    }

                    // If `separator` is not a regex, use native split
                    if (_toString.call(separator) !== '[object RegExp]') {
                        return string_split.call(this, separator, limit);
                    }

                    var output = [],
                        flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.extended ? 'x' : '') + ( // Proposed for ES6
                                separator.sticky ? 'y' : ''),
                        // Firefox 3+
                        lastLastIndex = 0,

                        // Make `global` and avoid `lastIndex` issues by working with a copy
                        separator2,
                        match,
                        lastIndex,
                        lastLength;
                    separator = new RegExp(separator.source, flags + 'g');
                    string += ''; // Type-convert
                    if (!compliantExecNpcg) {
                        // Doesn't need flags gy, but they don't hurt
                        separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
                    }
                    /* Values for `limit`, per the spec:
                     * If undefined: 4294967295 // Math.pow(2, 32) - 1
                     * If 0, Infinity, or NaN: 0
                     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
                     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
                     * If other: Type-convert, then use the above rules
                     */
                    limit = limit === void 0 ? -1 >>> 0 : // Math.pow(2, 32) - 1
                        ToUint32(limit);
                    while (match = separator.exec(string)) {
                        // `separator.lastIndex` is not reliable cross-browser
                        lastIndex = match.index + match[0].length;
                        if (lastIndex > lastLastIndex) {
                            output.push(string.slice(lastLastIndex, match.index));
                            // Fix browsers whose `exec` methods don't consistently return `undefined` for
                            // nonparticipating capturing groups
                            if (!compliantExecNpcg && match.length > 1) {
                                match[0].replace(separator2, function () {
                                    for (var i = 1; i < arguments.length - 2; i++) {
                                        if (arguments[i] === void 0) {
                                            match[i] = void 0;
                                        }
                                    }
                                });
                            }
                            if (match.length > 1 && match.index < string.length) {
                                ArrayPrototype.push.apply(output, match.slice(1));
                            }
                            lastLength = match[0].length;
                            lastLastIndex = lastIndex;
                            if (output.length >= limit) {
                                break;
                            }
                        }
                        if (separator.lastIndex === match.index) {
                            separator.lastIndex++; // Avoid an infinite loop
                        }
                    }
                    if (lastLastIndex === string.length) {
                        if (lastLength || !separator.test('')) {
                            output.push('');
                        }
                    } else {
                        output.push(string.slice(lastLastIndex));
                    }
                    return output.length > limit ? output.slice(0, limit) : output;
                };
            })();

            // [bugfix, chrome]
            // If separator is undefined, then the result array contains just one String,
            // which is the this value (converted to a String). If limit is not undefined,
            // then the output array is truncated so that it contains no more than limit
            // elements.
            // "0".split(undefined, 0) -> []
        } else if ('0'.split(void 0, 0).length) {
            StringPrototype.split = function split(separator, limit) {
                if (separator === void 0 && limit === 0) {
                    return [];
                }
                return string_split.call(this, separator, limit);
            };
        }

        // ES5 15.5.4.20
        // whitespace from: http://es5.github.io/#x15.5.4.20
        var ws = '\t\n\u000b\f\r ' + '\u2028' + '\u2029';
        var zeroWidth = '';
        var wsRegexChars = '[' + ws + ']';
        var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
        var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
        var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
        defineProperties(StringPrototype, {
            // http://blog.stevenlevithan.com/archives/faster-trim-javascript
            // http://perfectionkills.com/whitespace-deviations/
            trim: function trim() {
                if (this === void 0 || this === null) {
                    throw new TypeError("can't convert " + this + ' to object');
                }
                return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
            }
        }, hasTrimWhitespaceBug);

        // ECMA-262, 3rd B.2.3
        // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
        // non-normative section suggesting uniform semantics and it should be
        // normalized across all browsers
        // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
        var string_substr = StringPrototype.substr;
        var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
        defineProperties(StringPrototype, {
            substr: function substr(start, length) {
                return string_substr.call(this, start < 0 ? (start = this.length + start) < 0 ? 0 : start : start, length);
            }
        }, hasNegativeSubstrBug);

        /***/ },
    /* 58 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var JSON3 = __webpack_require__(45);

        // Some extra characters that Chrome gets wrong, and substitutes with
        // something else on the wire.
        var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
            extraLookup;

        // This may be quite slow, so let's delay until user actually uses bad
        // characters.
        var unrollLookup = function unrollLookup(escapable) {
            var i;
            var unrolled = {};
            var c = [];
            for (i = 0; i < 65536; i++) {
                c.push(String.fromCharCode(i));
            }
            escapable.lastIndex = 0;
            c.join('').replace(escapable, function (a) {
                unrolled[a] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                return '';
            });
            escapable.lastIndex = 0;
            return unrolled;
        };

        // Quote string, also taking care of unicode characters that browsers
        // often break. Especially, take care of unicode surrogates:
        // http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
        module.exports = {
            quote: function quote(string) {
                var quoted = JSON3.stringify(string);

                // In most cases this should be very fast and good enough.
                extraEscapable.lastIndex = 0;
                if (!extraEscapable.test(quoted)) {
                    return quoted;
                }

                if (!extraLookup) {
                    extraLookup = unrollLookup(extraEscapable);
                }

                return quoted.replace(extraEscapable, function (a) {
                    return extraLookup[a];
                });
            }
        };

        /***/ },
    /* 59 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:utils:transport');
            }

            module.exports = function (availableTransports) {
                return {
                    filterToEnabled: function filterToEnabled(transportsWhitelist, info) {
                        var transports = {
                            main: [],
                            facade: []
                        };
                        if (!transportsWhitelist) {
                            transportsWhitelist = [];
                        } else if (typeof transportsWhitelist === 'string') {
                            transportsWhitelist = [transportsWhitelist];
                        }

                        availableTransports.forEach(function (trans) {
                            if (!trans) {
                                return;
                            }

                            if (trans.transportName === 'websocket' && info.websocket === false) {
                                debug('disabled from server', 'websocket');
                                return;
                            }

                            if (transportsWhitelist.length && transportsWhitelist.indexOf(trans.transportName) === -1) {
                                debug('not in whitelist', trans.transportName);
                                return;
                            }

                            if (trans.enabled(info)) {
                                debug('enabled', trans.transportName);
                                transports.main.push(trans);
                                if (trans.facadeTransport) {
                                    transports.facade.push(trans.facadeTransport);
                                }
                            } else {
                                debug('disabled', trans.transportName);
                            }
                        });
                        return transports;
                    }
                };
            };
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 60 */
    /***/ function(module, exports) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            var logObject = {};
            ['log', 'debug', 'warn'].forEach(function (level) {
                var levelExists;

                try {
                    levelExists = global.console && global.console[level] && global.console[level].apply;
                } catch (e) {
                    // do nothing
                }

                logObject[level] = levelExists ? function () {
                    return global.console[level].apply(global.console, arguments);
                } : level === 'log' ? function () {} : logObject.log;
            });

            module.exports = logObject;
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 61 */
    /***/ function(module, exports) {

        'use strict';

        function Event(eventType) {
            this.type = eventType;
        }

        Event.prototype.initEvent = function (eventType, canBubble, cancelable) {
            this.type = eventType;
            this.bubbles = canBubble;
            this.cancelable = cancelable;
            this.timeStamp = +new Date();
            return this;
        };

        Event.prototype.stopPropagation = function () {};
        Event.prototype.preventDefault = function () {};

        Event.CAPTURING_PHASE = 1;
        Event.AT_TARGET = 2;
        Event.BUBBLING_PHASE = 3;

        module.exports = Event;

        /***/ },
    /* 62 */
    /***/ function(module, exports) {

        /* WEBPACK VAR INJECTION */(function(global) {'use strict';

            module.exports = global.location || {
                    origin: 'http://localhost:80',
                    protocol: 'http',
                    host: 'localhost',
                    port: 80,
                    href: 'http://localhost/',
                    hash: ''
                };
            /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

        /***/ },
    /* 63 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            Event = __webpack_require__(61);

        function CloseEvent() {
            Event.call(this);
            this.initEvent('close', false, false);
            this.wasClean = false;
            this.code = 0;
            this.reason = '';
        }

        inherits(CloseEvent, Event);

        module.exports = CloseEvent;

        /***/ },
    /* 64 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            Event = __webpack_require__(61);

        function TransportMessageEvent(data) {
            Event.call(this);
            this.initEvent('message', false, false);
            this.data = data;
        }

        inherits(TransportMessageEvent, Event);

        module.exports = TransportMessageEvent;

        /***/ },
    /* 65 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var EventEmitter = __webpack_require__(25).EventEmitter,
                inherits = __webpack_require__(24),
                urlUtils = __webpack_require__(16),
                XDR = __webpack_require__(39),
                XHRCors = __webpack_require__(34),
                XHRLocal = __webpack_require__(36),
                XHRFake = __webpack_require__(66),
                InfoIframe = __webpack_require__(67),
                InfoAjax = __webpack_require__(69);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:info-receiver');
            }

            function InfoReceiver(baseUrl, urlInfo) {
                debug(baseUrl);
                var self = this;
                EventEmitter.call(this);

                setTimeout(function () {
                    self.doXhr(baseUrl, urlInfo);
                }, 0);
            }

            inherits(InfoReceiver, EventEmitter);

            // TODO this is currently ignoring the list of available transports and the whitelist

            InfoReceiver._getReceiver = function (baseUrl, url, urlInfo) {
                // determine method of CORS support (if needed)
                if (urlInfo.sameOrigin) {
                    return new InfoAjax(url, XHRLocal);
                }
                if (XHRCors.enabled) {
                    return new InfoAjax(url, XHRCors);
                }
                if (XDR.enabled && urlInfo.sameScheme) {
                    return new InfoAjax(url, XDR);
                }
                if (InfoIframe.enabled()) {
                    return new InfoIframe(baseUrl, url);
                }
                return new InfoAjax(url, XHRFake);
            };

            InfoReceiver.prototype.doXhr = function (baseUrl, urlInfo) {
                var self = this,
                    url = urlUtils.addPath(baseUrl, '/info');
                debug('doXhr', url);

                this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

                this.timeoutRef = setTimeout(function () {
                    debug('timeout');
                    self._cleanup(false);
                    self.emit('finish');
                }, InfoReceiver.timeout);

                this.xo.once('finish', function (info, rtt) {
                    debug('finish', info, rtt);
                    self._cleanup(true);
                    self.emit('finish', info, rtt);
                });
            };

            InfoReceiver.prototype._cleanup = function (wasClean) {
                debug('_cleanup');
                clearTimeout(this.timeoutRef);
                this.timeoutRef = null;
                if (!wasClean && this.xo) {
                    this.xo.close();
                }
                this.xo = null;
            };

            InfoReceiver.prototype.close = function () {
                debug('close');
                this.removeAllListeners();
                this._cleanup(false);
            };

            InfoReceiver.timeout = 8000;

            module.exports = InfoReceiver;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 66 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var EventEmitter = __webpack_require__(25).EventEmitter,
            inherits = __webpack_require__(24);

        function XHRFake() /* method, url, payload, opts */{
            var self = this;
            EventEmitter.call(this);

            this.to = setTimeout(function () {
                self.emit('finish', 200, '{}');
            }, XHRFake.timeout);
        }

        inherits(XHRFake, EventEmitter);

        XHRFake.prototype.close = function () {
            clearTimeout(this.to);
        };

        XHRFake.timeout = 2000;

        module.exports = XHRFake;

        /***/ },
    /* 67 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

            var EventEmitter = __webpack_require__(25).EventEmitter,
                inherits = __webpack_require__(24),
                JSON3 = __webpack_require__(45),
                utils = __webpack_require__(13),
                IframeTransport = __webpack_require__(44),
                InfoReceiverIframe = __webpack_require__(68);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:info-iframe');
            }

            function InfoIframe(baseUrl, url) {
                var self = this;
                EventEmitter.call(this);

                var go = function go() {
                    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

                    ifr.once('message', function (msg) {
                        if (msg) {
                            var d;
                            try {
                                d = JSON3.parse(msg);
                            } catch (e) {
                                debug('bad json', msg);
                                self.emit('finish');
                                self.close();
                                return;
                            }

                            var info = d[0],
                                rtt = d[1];
                            self.emit('finish', info, rtt);
                        }
                        self.close();
                    });

                    ifr.once('close', function () {
                        self.emit('finish');
                        self.close();
                    });
                };

                // TODO this seems the same as the 'needBody' from transports
                if (!global.document.body) {
                    utils.attachEvent('load', go);
                } else {
                    go();
                }
            }

            inherits(InfoIframe, EventEmitter);

            InfoIframe.enabled = function () {
                return IframeTransport.enabled();
            };

            InfoIframe.prototype.close = function () {
                if (this.ifr) {
                    this.ifr.close();
                }
                this.removeAllListeners();
                this.ifr = null;
            };

            module.exports = InfoIframe;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), (function() { return this; }())))

        /***/ },
    /* 68 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var inherits = __webpack_require__(24),
            EventEmitter = __webpack_require__(25).EventEmitter,
            JSON3 = __webpack_require__(45),
            XHRLocalObject = __webpack_require__(36),
            InfoAjax = __webpack_require__(69);

        function InfoReceiverIframe(transUrl) {
            var self = this;
            EventEmitter.call(this);

            this.ir = new InfoAjax(transUrl, XHRLocalObject);
            this.ir.once('finish', function (info, rtt) {
                self.ir = null;
                self.emit('message', JSON3.stringify([info, rtt]));
            });
        }

        inherits(InfoReceiverIframe, EventEmitter);

        InfoReceiverIframe.transportName = 'iframe-info-receiver';

        InfoReceiverIframe.prototype.close = function () {
            if (this.ir) {
                this.ir.close();
                this.ir = null;
            }
            this.removeAllListeners();
        };

        module.exports = InfoReceiverIframe;

        /***/ },
    /* 69 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var EventEmitter = __webpack_require__(25).EventEmitter,
                inherits = __webpack_require__(24),
                JSON3 = __webpack_require__(45),
                objectUtils = __webpack_require__(48);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:info-ajax');
            }

            function InfoAjax(url, AjaxObject) {
                EventEmitter.call(this);

                var self = this;
                var t0 = +new Date();
                this.xo = new AjaxObject('GET', url);

                this.xo.once('finish', function (status, text) {
                    var info, rtt;
                    if (status === 200) {
                        rtt = +new Date() - t0;
                        if (text) {
                            try {
                                info = JSON3.parse(text);
                            } catch (e) {
                                debug('bad json', text);
                            }
                        }

                        if (!objectUtils.isObject(info)) {
                            info = {};
                        }
                    }
                    self.emit('finish', info, rtt);
                    self.removeAllListeners();
                });
            }

            inherits(InfoAjax, EventEmitter);

            InfoAjax.prototype.close = function () {
                this.removeAllListeners();
                this.xo.close();
            };

            module.exports = InfoAjax;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 70 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {'use strict';

            var urlUtils = __webpack_require__(16),
                eventUtils = __webpack_require__(13),
                JSON3 = __webpack_require__(45),
                FacadeJS = __webpack_require__(71),
                InfoIframeReceiver = __webpack_require__(68),
                iframeUtils = __webpack_require__(47),
                loc = __webpack_require__(62);

            var debug = function debug() {};
            if (process.env.NODE_ENV !== 'production') {
                debug = __webpack_require__(21)('sockjs-client:iframe-bootstrap');
            }

            module.exports = function (SockJS, availableTransports) {
                var transportMap = {};
                availableTransports.forEach(function (at) {
                    if (at.facadeTransport) {
                        transportMap[at.facadeTransport.transportName] = at.facadeTransport;
                    }
                });

                // hard-coded for the info iframe
                // TODO see if we can make this more dynamic
                transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
                var parentOrigin;

                /* eslint-disable camelcase */
                SockJS.bootstrap_iframe = function () {
                    /* eslint-enable camelcase */
                    var facade;
                    iframeUtils.currentWindowId = loc.hash.slice(1);
                    var onMessage = function onMessage(e) {
                        if (e.source !== parent) {
                            return;
                        }
                        if (typeof parentOrigin === 'undefined') {
                            parentOrigin = e.origin;
                        }
                        if (e.origin !== parentOrigin) {
                            return;
                        }

                        var iframeMessage;
                        try {
                            iframeMessage = JSON3.parse(e.data);
                        } catch (ignored) {
                            debug('bad json', e.data);
                            return;
                        }

                        if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
                            return;
                        }
                        switch (iframeMessage.type) {
                            case 's':
                                var p;
                                try {
                                    p = JSON3.parse(iframeMessage.data);
                                } catch (ignored) {
                                    debug('bad json', iframeMessage.data);
                                    break;
                                }
                                var version = p[0];
                                var transport = p[1];
                                var transUrl = p[2];
                                var baseUrl = p[3];
                                debug(version, transport, transUrl, baseUrl);
                                // change this to semver logic
                                if (version !== SockJS.version) {
                                    throw new Error('Incompatible SockJS! Main site uses:' + ' "' + version + '", the iframe:' + ' "' + SockJS.version + '".');
                                }

                                if (!urlUtils.isOriginEqual(transUrl, loc.href) || !urlUtils.isOriginEqual(baseUrl, loc.href)) {
                                    throw new Error('Can\'t connect to different domain from within an ' + 'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
                                }
                                facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
                                break;
                            case 'm':
                                facade._send(iframeMessage.data);
                                break;
                            case 'c':
                                if (facade) {
                                    facade._close();
                                }
                                facade = null;
                                break;
                        }
                    };

                    eventUtils.attachEvent('message', onMessage);

                    // Start
                    iframeUtils.postMessage('s');
                };
            };
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 71 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var JSON3 = __webpack_require__(45),
            iframeUtils = __webpack_require__(47);

        function FacadeJS(transport) {
            this._transport = transport;
            transport.on('message', this._transportMessage.bind(this));
            transport.on('close', this._transportClose.bind(this));
        }

        FacadeJS.prototype._transportClose = function (code, reason) {
            iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
        };
        FacadeJS.prototype._transportMessage = function (frame) {
            iframeUtils.postMessage('t', frame);
        };
        FacadeJS.prototype._send = function (data) {
            this._transport.send(data);
        };
        FacadeJS.prototype._close = function () {
            this._transport.close();
            this._transport.removeAllListeners();
        };

        module.exports = FacadeJS;

        /***/ },
    /* 72 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var ansiRegex = __webpack_require__(73)();

        module.exports = function (str) {
            return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
        };

        /***/ },
    /* 73 */
    /***/ function(module, exports) {

        'use strict';

        module.exports = function () {
            return (/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g
            );
        };

        /***/ },
    /* 74 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /*
         MIT License http://www.opensource.org/licenses/mit-license.php
         Author Tobias Koppers @sokra
         */
        /*globals window __webpack_hash__ */
        if (true) {
            var lastData;
            var upToDate = function upToDate() {
                return lastData.indexOf(__webpack_require__.h()) >= 0;
            };
            var check = function check() {
                module.hot.check(true, function (err, updatedModules) {
                    if (err) {
                        if (module.hot.status() in {
                                abort: 1,
                                fail: 1
                            }) {
                            console.warn("[HMR] Cannot apply update. Need to do a full reload!");
                            console.warn("[HMR] " + err.stack || err.message);
                            window.location.reload();
                        } else {
                            console.warn("[HMR] Update failed: " + err.stack || err.message);
                        }
                        return;
                    }

                    if (!updatedModules) {
                        console.warn("[HMR] Cannot find update. Need to do a full reload!");
                        console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");
                        window.location.reload();
                        return;
                    }

                    if (!upToDate()) {
                        check();
                    }

                    __webpack_require__(75)(updatedModules, updatedModules);

                    if (upToDate()) {
                        console.log("[HMR] App is up to date.");
                    }
                });
            };
            var addEventListener = window.addEventListener ? function (eventName, listener) {
                window.addEventListener(eventName, listener, false);
            } : function (eventName, listener) {
                window.attachEvent("on" + eventName, listener);
            };
            addEventListener("message", function (event) {
                if (typeof event.data === "string" && event.data.indexOf("webpackHotUpdate") === 0) {
                    lastData = event.data;
                    if (!upToDate() && module.hot.status() === "idle") {
                        console.log("[HMR] Checking for updates on the server...");
                        check();
                    }
                }
            });
            console.log("[HMR] Waiting for update signal from WDS...");
        } else {
            throw new Error("[HMR] Hot Module Replacement is disabled.");
        }

        /***/ },
    /* 75 */
    /***/ function(module, exports) {

        "use strict";

        /*
         MIT License http://www.opensource.org/licenses/mit-license.php
         Author Tobias Koppers @sokra
         */
        module.exports = function (updatedModules, renewedModules) {
            var unacceptedModules = updatedModules.filter(function (moduleId) {
                return renewedModules && renewedModules.indexOf(moduleId) < 0;
            });

            if (unacceptedModules.length > 0) {
                console.warn("[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
                unacceptedModules.forEach(function (moduleId) {
                    console.warn("[HMR]  - " + moduleId);
                });
            }

            if (!renewedModules || renewedModules.length === 0) {
                console.log("[HMR] Nothing hot updated.");
            } else {
                console.log("[HMR] Updated modules:");
                renewedModules.forEach(function (moduleId) {
                    console.log("[HMR]  - " + moduleId);
                });
            }
        };

        /***/ },
    /* 76 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        var _reactDom = __webpack_require__(77);

        var _reactDom2 = _interopRequireDefault(_reactDom);

        var _react = __webpack_require__(222);

        var _react2 = _interopRequireDefault(_react);

        var _myApp = __webpack_require__(234);

        var _myApp2 = _interopRequireDefault(_myApp);

        __webpack_require__(390);

        __webpack_require__(392);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        // waiting for dom to load before booting react. we could alternatively
        // put the index.js reference at the end fo the index.html, but i prefer this way.

        // is there a better way of doing this?
        document.addEventListener('DOMContentLoaded', function () {
            var container = document.getElementById('myAppContainer');
            _reactDom2.default.render(_react2.default.createElement(_myApp2.default), container);
        });

        /***/ },
    /* 77 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        module.exports = __webpack_require__(78);

        /***/ },
    /* 78 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOM
         */

            /* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

            'use strict';

            var ReactCurrentOwner = __webpack_require__(79);
            var ReactDOMTextComponent = __webpack_require__(80);
            var ReactDefaultInjection = __webpack_require__(145);
            var ReactInstanceHandles = __webpack_require__(119);
            var ReactMount = __webpack_require__(102);
            var ReactPerf = __webpack_require__(92);
            var ReactReconciler = __webpack_require__(124);
            var ReactUpdates = __webpack_require__(128);
            var ReactVersion = __webpack_require__(220);

            var findDOMNode = __webpack_require__(165);
            var renderSubtreeIntoContainer = __webpack_require__(221);
            var warning = __webpack_require__(99);

            ReactDefaultInjection.inject();

            var render = ReactPerf.measure('React', 'render', ReactMount.render);

            var React = {
                findDOMNode: findDOMNode,
                render: render,
                unmountComponentAtNode: ReactMount.unmountComponentAtNode,
                version: ReactVersion,

                /* eslint-disable camelcase */
                unstable_batchedUpdates: ReactUpdates.batchedUpdates,
                unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
            };

            // Inject the runtime into a devtools global hook regardless of browser.
            // Allows for debugging when the hook is injected on the page.
            /* eslint-enable camelcase */
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
                    CurrentOwner: ReactCurrentOwner,
                    InstanceHandles: ReactInstanceHandles,
                    Mount: ReactMount,
                    Reconciler: ReactReconciler,
                    TextComponent: ReactDOMTextComponent
                });
            }

            if (process.env.NODE_ENV !== 'production') {
                var ExecutionEnvironment = __webpack_require__(83);
                if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

                    // First check if devtools is not installed
                    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                        // If we're in Chrome or Firefox, provide a download link if not installed.
                        if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
                            console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
                        }
                    }

                    // If we're in IE8, check to see if we are in compatibility mode and provide
                    // information on preventing compatibility mode
                    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

                    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;

                    var expectedFeatures = [
                        // shims
                        Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,

                        // shams
                        Object.create, Object.freeze];

                    for (var i = 0; i < expectedFeatures.length; i++) {
                        if (!expectedFeatures[i]) {
                            console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
                            break;
                        }
                    }
                }
            }

            module.exports = React;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 79 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactCurrentOwner
         */

        'use strict';

        /**
         * Keeps track of the current owner.
         *
         * The current owner is the component who should own any components that are
         * currently being constructed.
         */

        var ReactCurrentOwner = {

            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null

        };

        module.exports = ReactCurrentOwner;

        /***/ },
    /* 80 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMTextComponent
         * @typechecks static-only
         */

        'use strict';

            var DOMChildrenOperations = __webpack_require__(81);
            var DOMPropertyOperations = __webpack_require__(96);
            var ReactComponentBrowserEnvironment = __webpack_require__(100);
            var ReactMount = __webpack_require__(102);

            var assign = __webpack_require__(113);
            var escapeTextContentForBrowser = __webpack_require__(95);
            var setTextContent = __webpack_require__(94);
            var validateDOMNesting = __webpack_require__(144);

            /**
             * Text nodes violate a couple assumptions that React makes about components:
             *
             *  - When mounting text into the DOM, adjacent text nodes are merged.
             *  - Text nodes cannot be assigned a React root ID.
             *
             * This component is used to wrap strings in elements so that they can undergo
             * the same reconciliation that is applied to elements.
             *
             * TODO: Investigate representing React components in the DOM with text nodes.
             *
             * @class ReactDOMTextComponent
             * @extends ReactComponent
             * @internal
             */
            var ReactDOMTextComponent = function ReactDOMTextComponent(props) {
                // This constructor and its argument is currently used by mocks.
            };

            assign(ReactDOMTextComponent.prototype, {

                /**
                 * @param {ReactText} text
                 * @internal
                 */
                construct: function construct(text) {
                    // TODO: This is really a ReactText (ReactNode), not a ReactElement
                    this._currentElement = text;
                    this._stringText = '' + text;

                    // Properties
                    this._rootNodeID = null;
                    this._mountIndex = 0;
                },

                /**
                 * Creates the markup for this text node. This node is not intended to have
                 * any features besides containing text content.
                 *
                 * @param {string} rootID DOM ID of the root node.
                 * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
                 * @return {string} Markup for this text node.
                 * @internal
                 */
                mountComponent: function mountComponent(rootID, transaction, context) {
                    if (process.env.NODE_ENV !== 'production') {
                        if (context[validateDOMNesting.ancestorInfoContextKey]) {
                            validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
                        }
                    }

                    this._rootNodeID = rootID;
                    if (transaction.useCreateElement) {
                        var ownerDocument = context[ReactMount.ownerDocumentContextKey];
                        var el = ownerDocument.createElement('span');
                        DOMPropertyOperations.setAttributeForID(el, rootID);
                        // Populate node cache
                        ReactMount.getID(el);
                        setTextContent(el, this._stringText);
                        return el;
                    } else {
                        var escapedText = escapeTextContentForBrowser(this._stringText);

                        if (transaction.renderToStaticMarkup) {
                            // Normally we'd wrap this in a `span` for the reasons stated above, but
                            // since this is a situation where React won't take over (static pages),
                            // we can simply return the text as it is.
                            return escapedText;
                        }

                        return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
                    }
                },

                /**
                 * Updates this component by updating the text content.
                 *
                 * @param {ReactText} nextText The next text content
                 * @param {ReactReconcileTransaction} transaction
                 * @internal
                 */
                receiveComponent: function receiveComponent(nextText, transaction) {
                    if (nextText !== this._currentElement) {
                        this._currentElement = nextText;
                        var nextStringText = '' + nextText;
                        if (nextStringText !== this._stringText) {
                            // TODO: Save this as pending props and use performUpdateIfNecessary
                            // and/or updateComponent to do the actual update for consistency with
                            // other component types?
                            this._stringText = nextStringText;
                            var node = ReactMount.getNode(this._rootNodeID);
                            DOMChildrenOperations.updateTextContent(node, nextStringText);
                        }
                    }
                },

                unmountComponent: function unmountComponent() {
                    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
                }

            });

            module.exports = ReactDOMTextComponent;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 81 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule DOMChildrenOperations
         * @typechecks static-only
         */

        'use strict';

            var Danger = __webpack_require__(82);
            var ReactMultiChildUpdateTypes = __webpack_require__(90);
            var ReactPerf = __webpack_require__(92);

            var setInnerHTML = __webpack_require__(93);
            var setTextContent = __webpack_require__(94);
            var invariant = __webpack_require__(87);

            /**
             * Inserts `childNode` as a child of `parentNode` at the `index`.
             *
             * @param {DOMElement} parentNode Parent node in which to insert.
             * @param {DOMElement} childNode Child node to insert.
             * @param {number} index Index at which to insert the child.
             * @internal
             */
            function insertChildAt(parentNode, childNode, index) {
                // By exploiting arrays returning `undefined` for an undefined index, we can
                // rely exclusively on `insertBefore(node, null)` instead of also using
                // `appendChild(node)`. However, using `undefined` is not allowed by all
                // browsers so we must replace it with `null`.

                // fix render order error in safari
                // IE8 will throw error when index out of list size.
                var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);

                parentNode.insertBefore(childNode, beforeChild);
            }

            /**
             * Operations for updating with DOM children.
             */
            var DOMChildrenOperations = {

                dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

                updateTextContent: setTextContent,

                /**
                 * Updates a component's children by processing a series of updates. The
                 * update configurations are each expected to have a `parentNode` property.
                 *
                 * @param {array<object>} updates List of update configurations.
                 * @param {array<string>} markupList List of markup strings.
                 * @internal
                 */
                processUpdates: function processUpdates(updates, markupList) {
                    var update;
                    // Mapping from parent IDs to initial child orderings.
                    var initialChildren = null;
                    // List of children that will be moved or removed.
                    var updatedChildren = null;

                    for (var i = 0; i < updates.length; i++) {
                        update = updates[i];
                        if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
                            var updatedIndex = update.fromIndex;
                            var updatedChild = update.parentNode.childNodes[updatedIndex];
                            var parentID = update.parentID;

                            !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;

                            initialChildren = initialChildren || {};
                            initialChildren[parentID] = initialChildren[parentID] || [];
                            initialChildren[parentID][updatedIndex] = updatedChild;

                            updatedChildren = updatedChildren || [];
                            updatedChildren.push(updatedChild);
                        }
                    }

                    var renderedMarkup;
                    // markupList is either a list of markup or just a list of elements
                    if (markupList.length && typeof markupList[0] === 'string') {
                        renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
                    } else {
                        renderedMarkup = markupList;
                    }

                    // Remove updated children first so that `toIndex` is consistent.
                    if (updatedChildren) {
                        for (var j = 0; j < updatedChildren.length; j++) {
                            updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
                        }
                    }

                    for (var k = 0; k < updates.length; k++) {
                        update = updates[k];
                        switch (update.type) {
                            case ReactMultiChildUpdateTypes.INSERT_MARKUP:
                                insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
                                break;
                            case ReactMultiChildUpdateTypes.MOVE_EXISTING:
                                insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
                                break;
                            case ReactMultiChildUpdateTypes.SET_MARKUP:
                                setInnerHTML(update.parentNode, update.content);
                                break;
                            case ReactMultiChildUpdateTypes.TEXT_CONTENT:
                                setTextContent(update.parentNode, update.content);
                                break;
                            case ReactMultiChildUpdateTypes.REMOVE_NODE:
                                // Already removed by the for-loop above.
                                break;
                        }
                    }
                }

            };

            ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
                updateTextContent: 'updateTextContent'
            });

            module.exports = DOMChildrenOperations;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 82 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule Danger
         * @typechecks static-only
         */

        'use strict';

            var ExecutionEnvironment = __webpack_require__(83);

            var createNodesFromMarkup = __webpack_require__(84);
            var emptyFunction = __webpack_require__(89);
            var getMarkupWrap = __webpack_require__(88);
            var invariant = __webpack_require__(87);

            var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
            var RESULT_INDEX_ATTR = 'data-danger-index';

            /**
             * Extracts the `nodeName` from a string of markup.
             *
             * NOTE: Extracting the `nodeName` does not require a regular expression match
             * because we make assumptions about React-generated markup (i.e. there are no
             * spaces surrounding the opening tag and there is at least one attribute).
             *
             * @param {string} markup String of markup.
             * @return {string} Node name of the supplied markup.
             * @see http://jsperf.com/extract-nodename
             */
            function getNodeName(markup) {
                return markup.substring(1, markup.indexOf(' '));
            }

            var Danger = {

                /**
                 * Renders markup into an array of nodes. The markup is expected to render
                 * into a list of root nodes. Also, the length of `resultList` and
                 * `markupList` should be the same.
                 *
                 * @param {array<string>} markupList List of markup strings to render.
                 * @return {array<DOMElement>} List of rendered nodes.
                 * @internal
                 */
                dangerouslyRenderMarkup: function dangerouslyRenderMarkup(markupList) {
                    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
                    var nodeName;
                    var markupByNodeName = {};
                    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
                    for (var i = 0; i < markupList.length; i++) {
                        !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
                        nodeName = getNodeName(markupList[i]);
                        nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
                        markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
                        markupByNodeName[nodeName][i] = markupList[i];
                    }
                    var resultList = [];
                    var resultListAssignmentCount = 0;
                    for (nodeName in markupByNodeName) {
                        if (!markupByNodeName.hasOwnProperty(nodeName)) {
                            continue;
                        }
                        var markupListByNodeName = markupByNodeName[nodeName];

                        // This for-in loop skips the holes of the sparse array. The order of
                        // iteration should follow the order of assignment, which happens to match
                        // numerical index order, but we don't rely on that.
                        var resultIndex;
                        for (resultIndex in markupListByNodeName) {
                            if (markupListByNodeName.hasOwnProperty(resultIndex)) {
                                var markup = markupListByNodeName[resultIndex];

                                // Push the requested markup with an additional RESULT_INDEX_ATTR
                                // attribute.  If the markup does not start with a < character, it
                                // will be discarded below (with an appropriate console.error).
                                markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
                                    // This index will be parsed back out below.
                                    '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
                            }
                        }

                        // Render each group of markup with similar wrapping `nodeName`.
                        var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
                        );

                        for (var j = 0; j < renderNodes.length; ++j) {
                            var renderNode = renderNodes[j];
                            if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

                                resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
                                renderNode.removeAttribute(RESULT_INDEX_ATTR);

                                !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;

                                resultList[resultIndex] = renderNode;

                                // This should match resultList.length and markupList.length when
                                // we're done.
                                resultListAssignmentCount += 1;
                            } else if (process.env.NODE_ENV !== 'production') {
                                console.error('Danger: Discarding unexpected node:', renderNode);
                            }
                        }
                    }

                    // Although resultList was populated out of order, it should now be a dense
                    // array.
                    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;

                    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;

                    return resultList;
                },

                /**
                 * Replaces a node with a string of markup at its current position within its
                 * parent. The markup must render into a single root node.
                 *
                 * @param {DOMElement} oldChild Child node to replace.
                 * @param {string} markup Markup to render in place of the child node.
                 * @internal
                 */
                dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
                    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
                    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
                    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;

                    var newChild;
                    if (typeof markup === 'string') {
                        newChild = createNodesFromMarkup(markup, emptyFunction)[0];
                    } else {
                        newChild = markup;
                    }
                    oldChild.parentNode.replaceChild(newChild, oldChild);
                }

            };

            module.exports = Danger;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 83 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ExecutionEnvironment
         */

        'use strict';

        var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

        /**
         * Simple, lightweight module assisting with the detection and context of
         * Worker. Helps avoid circular dependencies and allows code to reason about
         * whether or not they are in a Worker, even if they never include the main
         * `ReactWorker` dependency.
         */
        var ExecutionEnvironment = {

            canUseDOM: canUseDOM,

            canUseWorkers: typeof Worker !== 'undefined',

            canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

            canUseViewport: canUseDOM && !!window.screen,

            isInWorker: !canUseDOM // For now, this is true - might change in the future.

        };

        module.exports = ExecutionEnvironment;

        /***/ },
    /* 84 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule createNodesFromMarkup
         * @typechecks
         */

            /*eslint-disable fb-www/unsafe-html*/

            'use strict';

            var ExecutionEnvironment = __webpack_require__(83);

            var createArrayFromMixed = __webpack_require__(85);
            var getMarkupWrap = __webpack_require__(88);
            var invariant = __webpack_require__(87);

            /**
             * Dummy container used to render all markup.
             */
            var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

            /**
             * Pattern used by `getNodeName`.
             */
            var nodeNamePattern = /^\s*<(\w+)/;

            /**
             * Extracts the `nodeName` of the first element in a string of markup.
             *
             * @param {string} markup String of markup.
             * @return {?string} Node name of the supplied markup.
             */
            function getNodeName(markup) {
                var nodeNameMatch = markup.match(nodeNamePattern);
                return nodeNameMatch && nodeNameMatch[1].toLowerCase();
            }

            /**
             * Creates an array containing the nodes rendered from the supplied markup. The
             * optionally supplied `handleScript` function will be invoked once for each
             * <script> element that is rendered. If no `handleScript` function is supplied,
             * an exception is thrown if any <script> elements are rendered.
             *
             * @param {string} markup A string of valid HTML markup.
             * @param {?function} handleScript Invoked once for each rendered <script>.
             * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
             */
            function createNodesFromMarkup(markup, handleScript) {
                var node = dummyNode;
                !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
                var nodeName = getNodeName(markup);

                var wrap = nodeName && getMarkupWrap(nodeName);
                if (wrap) {
                    node.innerHTML = wrap[1] + markup + wrap[2];

                    var wrapDepth = wrap[0];
                    while (wrapDepth--) {
                        node = node.lastChild;
                    }
                } else {
                    node.innerHTML = markup;
                }

                var scripts = node.getElementsByTagName('script');
                if (scripts.length) {
                    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
                    createArrayFromMixed(scripts).forEach(handleScript);
                }

                var nodes = createArrayFromMixed(node.childNodes);
                while (node.lastChild) {
                    node.removeChild(node.lastChild);
                }
                return nodes;
            }

            module.exports = createNodesFromMarkup;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 85 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule createArrayFromMixed
         * @typechecks
         */

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        var toArray = __webpack_require__(86);

        /**
         * Perform a heuristic test to determine if an object is "array-like".
         *
         *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
         *   Joshu replied: "Mu."
         *
         * This function determines if its argument has "array nature": it returns
         * true if the argument is an actual array, an `arguments' object, or an
         * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
         *
         * It will return false for other array-like objects like Filelist.
         *
         * @param {*} obj
         * @return {boolean}
         */
        function hasArrayNature(obj) {
            return(
                // not null/false
                !!obj && (
                    // arrays are objects, NodeLists are functions in Safari
                (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
                // quacks like an array
                'length' in obj &&
                // not window
                !('setInterval' in obj) &&
                // no DOM node should be considered an array-like
                // a 'select' element has 'length' and 'item' properties on IE8
                typeof obj.nodeType != 'number' && (
                    // a real array
                Array.isArray(obj) ||
                // arguments
                'callee' in obj ||
                // HTMLCollection/NodeList
                'item' in obj)
            );
        }

        /**
         * Ensure that the argument is an array by wrapping it in an array if it is not.
         * Creates a copy of the argument if it is already an array.
         *
         * This is mostly useful idiomatically:
         *
         *   var createArrayFromMixed = require('createArrayFromMixed');
         *
         *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
         *
         * This allows you to treat `things' as an array, but accept scalars in the API.
         *
         * If you need to convert an array-like object, like `arguments`, into an array
         * use toArray instead.
         *
         * @param {*} obj
         * @return {array}
         */
        function createArrayFromMixed(obj) {
            if (!hasArrayNature(obj)) {
                return [obj];
            } else if (Array.isArray(obj)) {
                return obj.slice();
            } else {
                return toArray(obj);
            }
        }

        module.exports = createArrayFromMixed;

        /***/ },
    /* 86 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule toArray
         * @typechecks
         */

        'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var invariant = __webpack_require__(87);

            /**
             * Convert array-like objects to arrays.
             *
             * This API assumes the caller knows the contents of the data type. For less
             * well defined inputs use createArrayFromMixed.
             *
             * @param {object|function|filelist} obj
             * @return {array}
             */
            function toArray(obj) {
                var length = obj.length;

                // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
                // old versions of Safari).
                !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;

                !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;

                !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;

                // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
                // without method will throw during the slice call and skip straight to the
                // fallback.
                if (obj.hasOwnProperty) {
                    try {
                        return Array.prototype.slice.call(obj);
                    } catch (e) {
                        // IE < 9 does not support Array#slice on collections objects
                    }
                }

                // Fall back to copying key by key. This assumes all keys have a value,
                // so will not preserve sparsely populated inputs.
                var ret = Array(length);
                for (var ii = 0; ii < length; ii++) {
                    ret[ii] = obj[ii];
                }
                return ret;
            }

            module.exports = toArray;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 87 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule invariant
         */

        'use strict';

            /**
             * Use invariant() to assert state which your program assumes to be true.
             *
             * Provide sprintf-style format (only %s is supported) and arguments
             * to provide information about what broke and what you were
             * expecting.
             *
             * The invariant message will be stripped in production, but the invariant
             * will remain to ensure logic does not differ in production.
             */

            function invariant(condition, format, a, b, c, d, e, f) {
                if (process.env.NODE_ENV !== 'production') {
                    if (format === undefined) {
                        throw new Error('invariant requires an error message argument');
                    }
                }

                if (!condition) {
                    var error;
                    if (format === undefined) {
                        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
                    } else {
                        var args = [a, b, c, d, e, f];
                        var argIndex = 0;
                        error = new Error(format.replace(/%s/g, function () {
                            return args[argIndex++];
                        }));
                        error.name = 'Invariant Violation';
                    }

                    error.framesToPop = 1; // we don't care about invariant's own frame
                    throw error;
                }
            }

            module.exports = invariant;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 88 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getMarkupWrap
         */

            /*eslint-disable fb-www/unsafe-html */

            'use strict';

            var ExecutionEnvironment = __webpack_require__(83);

            var invariant = __webpack_require__(87);

            /**
             * Dummy container used to detect which wraps are necessary.
             */
            var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

            /**
             * Some browsers cannot use `innerHTML` to render certain elements standalone,
             * so we wrap them, render the wrapped nodes, then extract the desired node.
             *
             * In IE8, certain elements cannot render alone, so wrap all elements ('*').
             */

            var shouldWrap = {};

            var selectWrap = [1, '<select multiple="true">', '</select>'];
            var tableWrap = [1, '<table>', '</table>'];
            var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

            var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

            var markupWrap = {
                '*': [1, '?<div>', '</div>'],

                'area': [1, '<map>', '</map>'],
                'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
                'legend': [1, '<fieldset>', '</fieldset>'],
                'param': [1, '<object>', '</object>'],
                'tr': [2, '<table><tbody>', '</tbody></table>'],

                'optgroup': selectWrap,
                'option': selectWrap,

                'caption': tableWrap,
                'colgroup': tableWrap,
                'tbody': tableWrap,
                'tfoot': tableWrap,
                'thead': tableWrap,

                'td': trWrap,
                'th': trWrap
            };

            // Initialize the SVG elements since we know they'll always need to be wrapped
            // consistently. If they are created inside a <div> they will be initialized in
            // the wrong namespace (and will not display).
            var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
            svgElements.forEach(function (nodeName) {
                markupWrap[nodeName] = svgWrap;
                shouldWrap[nodeName] = true;
            });

            /**
             * Gets the markup wrap configuration for the supplied `nodeName`.
             *
             * NOTE: This lazily detects which wraps are necessary for the current browser.
             *
             * @param {string} nodeName Lowercase `nodeName`.
             * @return {?array} Markup wrap configuration, if applicable.
             */
            function getMarkupWrap(nodeName) {
                !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
                if (!markupWrap.hasOwnProperty(nodeName)) {
                    nodeName = '*';
                }
                if (!shouldWrap.hasOwnProperty(nodeName)) {
                    if (nodeName === '*') {
                        dummyNode.innerHTML = '<link />';
                    } else {
                        dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
                    }
                    shouldWrap[nodeName] = !dummyNode.firstChild;
                }
                return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
            }

            module.exports = getMarkupWrap;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 89 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule emptyFunction
         */

        "use strict";

        function makeEmptyFunction(arg) {
            return function () {
                return arg;
            };
        }

        /**
         * This function accepts and discards inputs; it has no side effects. This is
         * primarily useful idiomatically for overridable function endpoints which
         * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
         */
        function emptyFunction() {}

        emptyFunction.thatReturns = makeEmptyFunction;
        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
        emptyFunction.thatReturnsNull = makeEmptyFunction(null);
        emptyFunction.thatReturnsThis = function () {
            return this;
        };
        emptyFunction.thatReturnsArgument = function (arg) {
            return arg;
        };

        module.exports = emptyFunction;

        /***/ },
    /* 90 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactMultiChildUpdateTypes
         */

        'use strict';

        var keyMirror = __webpack_require__(91);

        /**
         * When a component's children are updated, a series of update configuration
         * objects are created in order to batch and serialize the required changes.
         *
         * Enumerates all the possible types of update configurations.
         *
         * @internal
         */
        var ReactMultiChildUpdateTypes = keyMirror({
            INSERT_MARKUP: null,
            MOVE_EXISTING: null,
            REMOVE_NODE: null,
            SET_MARKUP: null,
            TEXT_CONTENT: null
        });

        module.exports = ReactMultiChildUpdateTypes;

        /***/ },
    /* 91 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule keyMirror
         * @typechecks static-only
         */

        'use strict';

            var invariant = __webpack_require__(87);

            /**
             * Constructs an enumeration with keys equal to their value.
             *
             * For example:
             *
             *   var COLORS = keyMirror({blue: null, red: null});
             *   var myColor = COLORS.blue;
             *   var isColorValid = !!COLORS[myColor];
             *
             * The last line could not be performed if the values of the generated enum were
             * not equal to their keys.
             *
             *   Input:  {key1: val1, key2: val2}
             *   Output: {key1: key1, key2: key2}
             *
             * @param {object} obj
             * @return {object}
             */
            var keyMirror = function keyMirror(obj) {
                var ret = {};
                var key;
                !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
                for (key in obj) {
                    if (!obj.hasOwnProperty(key)) {
                        continue;
                    }
                    ret[key] = key;
                }
                return ret;
            };

            module.exports = keyMirror;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 92 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactPerf
         * @typechecks static-only
         */

        'use strict';

            /**
             * ReactPerf is a general AOP system designed to measure performance. This
             * module only has the hooks: see ReactDefaultPerf for the analysis tool.
             */

            var ReactPerf = {
                /**
                 * Boolean to enable/disable measurement. Set to false by default to prevent
                 * accidental logging and perf loss.
                 */
                enableMeasure: false,

                /**
                 * Holds onto the measure function in use. By default, don't measure
                 * anything, but we'll override this if we inject a measure function.
                 */
                storedMeasure: _noMeasure,

                /**
                 * @param {object} object
                 * @param {string} objectName
                 * @param {object<string>} methodNames
                 */
                measureMethods: function measureMethods(object, objectName, methodNames) {
                    if (process.env.NODE_ENV !== 'production') {
                        for (var key in methodNames) {
                            if (!methodNames.hasOwnProperty(key)) {
                                continue;
                            }
                            object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
                        }
                    }
                },

                /**
                 * Use this to wrap methods you want to measure. Zero overhead in production.
                 *
                 * @param {string} objName
                 * @param {string} fnName
                 * @param {function} func
                 * @return {function}
                 */
                measure: function measure(objName, fnName, func) {
                    if (process.env.NODE_ENV !== 'production') {
                        var measuredFunc = null;
                        var wrapper = function wrapper() {
                            if (ReactPerf.enableMeasure) {
                                if (!measuredFunc) {
                                    measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
                                }
                                return measuredFunc.apply(this, arguments);
                            }
                            return func.apply(this, arguments);
                        };
                        wrapper.displayName = objName + '_' + fnName;
                        return wrapper;
                    }
                    return func;
                },

                injection: {
                    /**
                     * @param {function} measure
                     */
                    injectMeasure: function injectMeasure(measure) {
                        ReactPerf.storedMeasure = measure;
                    }
                }
            };

            /**
             * Simply passes through the measured function, without measuring it.
             *
             * @param {string} objName
             * @param {string} fnName
             * @param {function} func
             * @return {function}
             */
            function _noMeasure(objName, fnName, func) {
                return func;
            }

            module.exports = ReactPerf;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 93 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule setInnerHTML
         */

        /* globals MSApp */

        'use strict';

        var ExecutionEnvironment = __webpack_require__(83);

        var WHITESPACE_TEST = /^[ \r\n\t\f]/;
        var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

        /**
         * Set the innerHTML property of a node, ensuring that whitespace is preserved
         * even in IE8.
         *
         * @param {DOMElement} node
         * @param {string} html
         * @internal
         */
        var setInnerHTML = function setInnerHTML(node, html) {
            node.innerHTML = html;
        };

        // Win8 apps: Allow all html to be inserted
        if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
            setInnerHTML = function setInnerHTML(node, html) {
                MSApp.execUnsafeLocalFunction(function () {
                    node.innerHTML = html;
                });
            };
        }

        if (ExecutionEnvironment.canUseDOM) {
            // IE8: When updating a just created node with innerHTML only leading
            // whitespace is removed. When updating an existing node with innerHTML
            // whitespace in root TextNodes is also collapsed.
            // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

            // Feature detection; only IE8 is known to behave improperly like this.
            var testElement = document.createElement('div');
            testElement.innerHTML = ' ';
            if (testElement.innerHTML === '') {
                setInnerHTML = function setInnerHTML(node, html) {
                    // Magic theory: IE8 supposedly differentiates between added and updated
                    // nodes when processing innerHTML, innerHTML on updated nodes suffers
                    // from worse whitespace behavior. Re-adding a node like this triggers
                    // the initial and more favorable whitespace behavior.
                    // TODO: What to do on a detached node?
                    if (node.parentNode) {
                        node.parentNode.replaceChild(node, node);
                    }

                    // We also implement a workaround for non-visible tags disappearing into
                    // thin air on IE8, this only happens if there is no visible text
                    // in-front of the non-visible tags. Piggyback on the whitespace fix
                    // and simply check if any non-visible tags appear in the source.
                    if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
                        // Recover leading whitespace by temporarily prepending any character.
                        // \uFEFF has the potential advantage of being zero-width/invisible.
                        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
                        // in hopes that this is preserved even if "\uFEFF" is transformed to
                        // the actual Unicode character (by Babel, for example).
                        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
                        node.innerHTML = String.fromCharCode(0xFEFF) + html;

                        // deleteData leaves an empty `TextNode` which offsets the index of all
                        // children. Definitely want to avoid this.
                        var textNode = node.firstChild;
                        if (textNode.data.length === 1) {
                            node.removeChild(textNode);
                        } else {
                            textNode.deleteData(0, 1);
                        }
                    } else {
                        node.innerHTML = html;
                    }
                };
            }
        }

        module.exports = setInnerHTML;

        /***/ },
    /* 94 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule setTextContent
         */

        'use strict';

        var ExecutionEnvironment = __webpack_require__(83);
        var escapeTextContentForBrowser = __webpack_require__(95);
        var setInnerHTML = __webpack_require__(93);

        /**
         * Set the textContent property of a node, ensuring that whitespace is preserved
         * even in IE8. innerText is a poor substitute for textContent and, among many
         * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
         * as it should.
         *
         * @param {DOMElement} node
         * @param {string} text
         * @internal
         */
        var setTextContent = function setTextContent(node, text) {
            node.textContent = text;
        };

        if (ExecutionEnvironment.canUseDOM) {
            if (!('textContent' in document.documentElement)) {
                setTextContent = function setTextContent(node, text) {
                    setInnerHTML(node, escapeTextContentForBrowser(text));
                };
            }
        }

        module.exports = setTextContent;

        /***/ },
    /* 95 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule escapeTextContentForBrowser
         */

        'use strict';

        var ESCAPE_LOOKUP = {
            '&': '&amp;',
            '>': '&gt;',
            '<': '&lt;',
            '"': '&quot;',
            '\'': '&#x27;'
        };

        var ESCAPE_REGEX = /[&><"']/g;

        function escaper(match) {
            return ESCAPE_LOOKUP[match];
        }

        /**
         * Escapes text to prevent scripting attacks.
         *
         * @param {*} text Text value to escape.
         * @return {string} An escaped string.
         */
        function escapeTextContentForBrowser(text) {
            return ('' + text).replace(ESCAPE_REGEX, escaper);
        }

        module.exports = escapeTextContentForBrowser;

        /***/ },
    /* 96 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule DOMPropertyOperations
         * @typechecks static-only
         */

        'use strict';

            var DOMProperty = __webpack_require__(97);
            var ReactPerf = __webpack_require__(92);

            var quoteAttributeValueForBrowser = __webpack_require__(98);
            var warning = __webpack_require__(99);

            // Simplified subset
            var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
            var illegalAttributeNameCache = {};
            var validatedAttributeNameCache = {};

            function isAttributeNameSafe(attributeName) {
                if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
                    return true;
                }
                if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
                    return false;
                }
                if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
                    validatedAttributeNameCache[attributeName] = true;
                    return true;
                }
                illegalAttributeNameCache[attributeName] = true;
                process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
                return false;
            }

            function shouldIgnoreValue(propertyInfo, value) {
                return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
            }

            if (process.env.NODE_ENV !== 'production') {
                var reactProps = {
                    children: true,
                    dangerouslySetInnerHTML: true,
                    key: true,
                    ref: true
                };
                var warnedProperties = {};

                var warnUnknownProperty = function warnUnknownProperty(name) {
                    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
                        return;
                    }

                    warnedProperties[name] = true;
                    var lowerCasedName = name.toLowerCase();

                    // data-* attributes should be lowercase; suggest the lowercase version
                    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

                    // For now, only warn when we have a suggested correction. This prevents
                    // logging too much when using transferPropsTo.
                    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
                };
            }

            /**
             * Operations for dealing with DOM properties.
             */
            var DOMPropertyOperations = {

                /**
                 * Creates markup for the ID property.
                 *
                 * @param {string} id Unescaped ID.
                 * @return {string} Markup string.
                 */
                createMarkupForID: function createMarkupForID(id) {
                    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
                },

                setAttributeForID: function setAttributeForID(node, id) {
                    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
                },

                /**
                 * Creates markup for a property.
                 *
                 * @param {string} name
                 * @param {*} value
                 * @return {?string} Markup string, or null if the property was invalid.
                 */
                createMarkupForProperty: function createMarkupForProperty(name, value) {
                    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
                    if (propertyInfo) {
                        if (shouldIgnoreValue(propertyInfo, value)) {
                            return '';
                        }
                        var attributeName = propertyInfo.attributeName;
                        if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
                            return attributeName + '=""';
                        }
                        return attributeName + '=' + quoteAttributeValueForBrowser(value);
                    } else if (DOMProperty.isCustomAttribute(name)) {
                        if (value == null) {
                            return '';
                        }
                        return name + '=' + quoteAttributeValueForBrowser(value);
                    } else if (process.env.NODE_ENV !== 'production') {
                        warnUnknownProperty(name);
                    }
                    return null;
                },

                /**
                 * Creates markup for a custom property.
                 *
                 * @param {string} name
                 * @param {*} value
                 * @return {string} Markup string, or empty string if the property was invalid.
                 */
                createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
                    if (!isAttributeNameSafe(name) || value == null) {
                        return '';
                    }
                    return name + '=' + quoteAttributeValueForBrowser(value);
                },

                /**
                 * Sets the value for a property on a node.
                 *
                 * @param {DOMElement} node
                 * @param {string} name
                 * @param {*} value
                 */
                setValueForProperty: function setValueForProperty(node, name, value) {
                    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
                    if (propertyInfo) {
                        var mutationMethod = propertyInfo.mutationMethod;
                        if (mutationMethod) {
                            mutationMethod(node, value);
                        } else if (shouldIgnoreValue(propertyInfo, value)) {
                            this.deleteValueForProperty(node, name);
                        } else if (propertyInfo.mustUseAttribute) {
                            var attributeName = propertyInfo.attributeName;
                            var namespace = propertyInfo.attributeNamespace;
                            // `setAttribute` with objects becomes only `[object]` in IE8/9,
                            // ('' + value) makes it output the correct toString()-value.
                            if (namespace) {
                                node.setAttributeNS(namespace, attributeName, '' + value);
                            } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
                                node.setAttribute(attributeName, '');
                            } else {
                                node.setAttribute(attributeName, '' + value);
                            }
                        } else {
                            var propName = propertyInfo.propertyName;
                            // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
                            // property type before comparing; only `value` does and is string.
                            if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
                                // Contrary to `setAttribute`, object properties are properly
                                // `toString`ed by IE8/9.
                                node[propName] = value;
                            }
                        }
                    } else if (DOMProperty.isCustomAttribute(name)) {
                        DOMPropertyOperations.setValueForAttribute(node, name, value);
                    } else if (process.env.NODE_ENV !== 'production') {
                        warnUnknownProperty(name);
                    }
                },

                setValueForAttribute: function setValueForAttribute(node, name, value) {
                    if (!isAttributeNameSafe(name)) {
                        return;
                    }
                    if (value == null) {
                        node.removeAttribute(name);
                    } else {
                        node.setAttribute(name, '' + value);
                    }
                },

                /**
                 * Deletes the value for a property on a node.
                 *
                 * @param {DOMElement} node
                 * @param {string} name
                 */
                deleteValueForProperty: function deleteValueForProperty(node, name) {
                    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
                    if (propertyInfo) {
                        var mutationMethod = propertyInfo.mutationMethod;
                        if (mutationMethod) {
                            mutationMethod(node, undefined);
                        } else if (propertyInfo.mustUseAttribute) {
                            node.removeAttribute(propertyInfo.attributeName);
                        } else {
                            var propName = propertyInfo.propertyName;
                            var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
                            if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
                                node[propName] = defaultValue;
                            }
                        }
                    } else if (DOMProperty.isCustomAttribute(name)) {
                        node.removeAttribute(name);
                    } else if (process.env.NODE_ENV !== 'production') {
                        warnUnknownProperty(name);
                    }
                }

            };

            ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
                setValueForProperty: 'setValueForProperty',
                setValueForAttribute: 'setValueForAttribute',
                deleteValueForProperty: 'deleteValueForProperty'
            });

            module.exports = DOMPropertyOperations;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 97 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule DOMProperty
         * @typechecks static-only
         */

        'use strict';

            var invariant = __webpack_require__(87);

            function checkMask(value, bitmask) {
                return (value & bitmask) === bitmask;
            }

            var DOMPropertyInjection = {
                /**
                 * Mapping from normalized, camelcased property names to a configuration that
                 * specifies how the associated DOM property should be accessed or rendered.
                 */
                MUST_USE_ATTRIBUTE: 0x1,
                MUST_USE_PROPERTY: 0x2,
                HAS_SIDE_EFFECTS: 0x4,
                HAS_BOOLEAN_VALUE: 0x8,
                HAS_NUMERIC_VALUE: 0x10,
                HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
                HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

                /**
                 * Inject some specialized knowledge about the DOM. This takes a config object
                 * with the following properties:
                 *
                 * isCustomAttribute: function that given an attribute name will return true
                 * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
                 * attributes where it's impossible to enumerate all of the possible
                 * attribute names,
                 *
                 * Properties: object mapping DOM property name to one of the
                 * DOMPropertyInjection constants or null. If your attribute isn't in here,
                 * it won't get written to the DOM.
                 *
                 * DOMAttributeNames: object mapping React attribute name to the DOM
                 * attribute name. Attribute names not specified use the **lowercase**
                 * normalized name.
                 *
                 * DOMAttributeNamespaces: object mapping React attribute name to the DOM
                 * attribute namespace URL. (Attribute names not specified use no namespace.)
                 *
                 * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
                 * Property names not specified use the normalized name.
                 *
                 * DOMMutationMethods: Properties that require special mutation methods. If
                 * `value` is undefined, the mutation method should unset the property.
                 *
                 * @param {object} domPropertyConfig the config as described above.
                 */
                injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
                    var Injection = DOMPropertyInjection;
                    var Properties = domPropertyConfig.Properties || {};
                    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
                    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
                    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
                    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

                    if (domPropertyConfig.isCustomAttribute) {
                        DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
                    }

                    for (var propName in Properties) {
                        !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;

                        var lowerCased = propName.toLowerCase();
                        var propConfig = Properties[propName];

                        var propertyInfo = {
                            attributeName: lowerCased,
                            attributeNamespace: null,
                            propertyName: propName,
                            mutationMethod: null,

                            mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
                            mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
                            hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
                            hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
                            hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
                            hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
                            hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
                        };

                        !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
                        !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
                        !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;

                        if (process.env.NODE_ENV !== 'production') {
                            DOMProperty.getPossibleStandardName[lowerCased] = propName;
                        }

                        if (DOMAttributeNames.hasOwnProperty(propName)) {
                            var attributeName = DOMAttributeNames[propName];
                            propertyInfo.attributeName = attributeName;
                            if (process.env.NODE_ENV !== 'production') {
                                DOMProperty.getPossibleStandardName[attributeName] = propName;
                            }
                        }

                        if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
                            propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
                        }

                        if (DOMPropertyNames.hasOwnProperty(propName)) {
                            propertyInfo.propertyName = DOMPropertyNames[propName];
                        }

                        if (DOMMutationMethods.hasOwnProperty(propName)) {
                            propertyInfo.mutationMethod = DOMMutationMethods[propName];
                        }

                        DOMProperty.properties[propName] = propertyInfo;
                    }
                }
            };
            var defaultValueCache = {};

            /**
             * DOMProperty exports lookup objects that can be used like functions:
             *
             *   > DOMProperty.isValid['id']
             *   true
             *   > DOMProperty.isValid['foobar']
             *   undefined
             *
             * Although this may be confusing, it performs better in general.
             *
             * @see http://jsperf.com/key-exists
             * @see http://jsperf.com/key-missing
             */
            var DOMProperty = {

                ID_ATTRIBUTE_NAME: 'data-reactid',

                /**
                 * Map from property "standard name" to an object with info about how to set
                 * the property in the DOM. Each object contains:
                 *
                 * attributeName:
                 *   Used when rendering markup or with `*Attribute()`.
                 * attributeNamespace
                 * propertyName:
                 *   Used on DOM node instances. (This includes properties that mutate due to
                 *   external factors.)
                 * mutationMethod:
                 *   If non-null, used instead of the property or `setAttribute()` after
                 *   initial render.
                 * mustUseAttribute:
                 *   Whether the property must be accessed and mutated using `*Attribute()`.
                 *   (This includes anything that fails `<propName> in <element>`.)
                 * mustUseProperty:
                 *   Whether the property must be accessed and mutated as an object property.
                 * hasSideEffects:
                 *   Whether or not setting a value causes side effects such as triggering
                 *   resources to be loaded or text selection changes. If true, we read from
                 *   the DOM before updating to ensure that the value is only set if it has
                 *   changed.
                 * hasBooleanValue:
                 *   Whether the property should be removed when set to a falsey value.
                 * hasNumericValue:
                 *   Whether the property must be numeric or parse as a numeric and should be
                 *   removed when set to a falsey value.
                 * hasPositiveNumericValue:
                 *   Whether the property must be positive numeric or parse as a positive
                 *   numeric and should be removed when set to a falsey value.
                 * hasOverloadedBooleanValue:
                 *   Whether the property can be used as a flag as well as with a value.
                 *   Removed when strictly equal to false; present without a value when
                 *   strictly equal to true; present with a value otherwise.
                 */
                properties: {},

                /**
                 * Mapping from lowercase property names to the properly cased version, used
                 * to warn in the case of missing properties. Available only in __DEV__.
                 * @type {Object}
                 */
                getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,

                /**
                 * All of the isCustomAttribute() functions that have been injected.
                 */
                _isCustomAttributeFunctions: [],

                /**
                 * Checks whether a property name is a custom attribute.
                 * @method
                 */
                isCustomAttribute: function isCustomAttribute(attributeName) {
                    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
                        var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
                        if (isCustomAttributeFn(attributeName)) {
                            return true;
                        }
                    }
                    return false;
                },

                /**
                 * Returns the default property value for a DOM property (i.e., not an
                 * attribute). Most default values are '' or false, but not all. Worse yet,
                 * some (in particular, `type`) vary depending on the type of element.
                 *
                 * TODO: Is it better to grab all the possible properties when creating an
                 * element to avoid having to create the same element twice?
                 */
                getDefaultValueForProperty: function getDefaultValueForProperty(nodeName, prop) {
                    var nodeDefaults = defaultValueCache[nodeName];
                    var testElement;
                    if (!nodeDefaults) {
                        defaultValueCache[nodeName] = nodeDefaults = {};
                    }
                    if (!(prop in nodeDefaults)) {
                        testElement = document.createElement(nodeName);
                        nodeDefaults[prop] = testElement[prop];
                    }
                    return nodeDefaults[prop];
                },

                injection: DOMPropertyInjection
            };

            module.exports = DOMProperty;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 98 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule quoteAttributeValueForBrowser
         */

        'use strict';

        var escapeTextContentForBrowser = __webpack_require__(95);

        /**
         * Escapes attribute value to prevent scripting attacks.
         *
         * @param {*} value Value to escape.
         * @return {string} An escaped string.
         */
        function quoteAttributeValueForBrowser(value) {
            return '"' + escapeTextContentForBrowser(value) + '"';
        }

        module.exports = quoteAttributeValueForBrowser;

        /***/ },
    /* 99 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule warning
         */

        'use strict';

            var emptyFunction = __webpack_require__(89);

            /**
             * Similar to invariant but only logs a warning if the condition is not met.
             * This can be used to log issues in development environments in critical
             * paths. Removing the logging code for production environments will keep the
             * same logic and follow the same code paths.
             */

            var warning = emptyFunction;

            if (process.env.NODE_ENV !== 'production') {
                warning = function warning(condition, format) {
                    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                        args[_key - 2] = arguments[_key];
                    }

                    if (format === undefined) {
                        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
                    }

                    if (format.indexOf('Failed Composite propType: ') === 0) {
                        return; // Ignore CompositeComponent proptype check.
                    }

                    if (!condition) {
                        var argIndex = 0;
                        var message = 'Warning: ' + format.replace(/%s/g, function () {
                                return args[argIndex++];
                            });
                        if (typeof console !== 'undefined') {
                            console.error(message);
                        }
                        try {
                            // --- Welcome to debugging React ---
                            // This error was thrown as a convenience so that you can use this stack
                            // to find the callsite that caused this warning to fire.
                            throw new Error(message);
                        } catch (x) {}
                    }
                };
            }

            module.exports = warning;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 100 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactComponentBrowserEnvironment
         */

        'use strict';

        var ReactDOMIDOperations = __webpack_require__(101);
        var ReactMount = __webpack_require__(102);

        /**
         * Abstracts away all functionality of the reconciler that requires knowledge of
         * the browser context. TODO: These callers should be refactored to avoid the
         * need for this injection.
         */
        var ReactComponentBrowserEnvironment = {

            processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

            replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

            /**
             * If a particular environment requires that some resources be cleaned up,
             * specify this in the injected Mixin. In the DOM, we would likely want to
             * purge any cached node ID lookups.
             *
             * @private
             */
            unmountIDFromEnvironment: function unmountIDFromEnvironment(rootNodeID) {
                ReactMount.purgeID(rootNodeID);
            }

        };

        module.exports = ReactComponentBrowserEnvironment;

        /***/ },
    /* 101 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMIDOperations
         * @typechecks static-only
         */

        'use strict';

            var DOMChildrenOperations = __webpack_require__(81);
            var DOMPropertyOperations = __webpack_require__(96);
            var ReactMount = __webpack_require__(102);
            var ReactPerf = __webpack_require__(92);

            var invariant = __webpack_require__(87);

            /**
             * Errors for properties that should not be updated with `updatePropertyByID()`.
             *
             * @type {object}
             * @private
             */
            var INVALID_PROPERTY_ERRORS = {
                dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
                style: '`style` must be set using `updateStylesByID()`.'
            };

            /**
             * Operations used to process updates to DOM nodes.
             */
            var ReactDOMIDOperations = {

                /**
                 * Updates a DOM node with new property values. This should only be used to
                 * update DOM properties in `DOMProperty`.
                 *
                 * @param {string} id ID of the node to update.
                 * @param {string} name A valid property name, see `DOMProperty`.
                 * @param {*} value New value of the property.
                 * @internal
                 */
                updatePropertyByID: function updatePropertyByID(id, name, value) {
                    var node = ReactMount.getNode(id);
                    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;

                    // If we're updating to null or undefined, we should remove the property
                    // from the DOM node instead of inadvertantly setting to a string. This
                    // brings us in line with the same behavior we have on initial render.
                    if (value != null) {
                        DOMPropertyOperations.setValueForProperty(node, name, value);
                    } else {
                        DOMPropertyOperations.deleteValueForProperty(node, name);
                    }
                },

                /**
                 * Replaces a DOM node that exists in the document with markup.
                 *
                 * @param {string} id ID of child to be replaced.
                 * @param {string} markup Dangerous markup to inject in place of child.
                 * @internal
                 * @see {Danger.dangerouslyReplaceNodeWithMarkup}
                 */
                dangerouslyReplaceNodeWithMarkupByID: function dangerouslyReplaceNodeWithMarkupByID(id, markup) {
                    var node = ReactMount.getNode(id);
                    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
                },

                /**
                 * Updates a component's children by processing a series of updates.
                 *
                 * @param {array<object>} updates List of update configurations.
                 * @param {array<string>} markup List of markup strings.
                 * @internal
                 */
                dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(updates, markup) {
                    for (var i = 0; i < updates.length; i++) {
                        updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
                    }
                    DOMChildrenOperations.processUpdates(updates, markup);
                }
            };

            ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
                dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
                dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
            });

            module.exports = ReactDOMIDOperations;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 102 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactMount
         */

        'use strict';

            var DOMProperty = __webpack_require__(97);
            var ReactBrowserEventEmitter = __webpack_require__(103);
            var ReactCurrentOwner = __webpack_require__(79);
            var ReactDOMFeatureFlags = __webpack_require__(115);
            var ReactElement = __webpack_require__(116);
            var ReactEmptyComponentRegistry = __webpack_require__(118);
            var ReactInstanceHandles = __webpack_require__(119);
            var ReactInstanceMap = __webpack_require__(121);
            var ReactMarkupChecksum = __webpack_require__(122);
            var ReactPerf = __webpack_require__(92);
            var ReactReconciler = __webpack_require__(124);
            var ReactUpdateQueue = __webpack_require__(127);
            var ReactUpdates = __webpack_require__(128);

            var assign = __webpack_require__(113);
            var emptyObject = __webpack_require__(132);
            var containsNode = __webpack_require__(133);
            var instantiateReactComponent = __webpack_require__(136);
            var invariant = __webpack_require__(87);
            var setInnerHTML = __webpack_require__(93);
            var shouldUpdateReactComponent = __webpack_require__(141);
            var validateDOMNesting = __webpack_require__(144);
            var warning = __webpack_require__(99);

            var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
            var nodeCache = {};

            var ELEMENT_NODE_TYPE = 1;
            var DOC_NODE_TYPE = 9;
            var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

            var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);

            /** Mapping from reactRootID to React component instance. */
            var instancesByReactRootID = {};

            /** Mapping from reactRootID to `container` nodes. */
            var containersByReactRootID = {};

            if (process.env.NODE_ENV !== 'production') {
                /** __DEV__-only mapping from reactRootID to root elements. */
                var rootElementsByReactRootID = {};
            }

            // Used to store breadth-first search state in findComponentRoot.
            var findComponentRootReusableArray = [];

            /**
             * Finds the index of the first character
             * that's not common between the two given strings.
             *
             * @return {number} the index of the character where the strings diverge
             */
            function firstDifferenceIndex(string1, string2) {
                var minLen = Math.min(string1.length, string2.length);
                for (var i = 0; i < minLen; i++) {
                    if (string1.charAt(i) !== string2.charAt(i)) {
                        return i;
                    }
                }
                return string1.length === string2.length ? -1 : minLen;
            }

            /**
             * @param {DOMElement|DOMDocument} container DOM element that may contain
             * a React component
             * @return {?*} DOM element that may have the reactRoot ID, or null.
             */
            function getReactRootElementInContainer(container) {
                if (!container) {
                    return null;
                }

                if (container.nodeType === DOC_NODE_TYPE) {
                    return container.documentElement;
                } else {
                    return container.firstChild;
                }
            }

            /**
             * @param {DOMElement} container DOM element that may contain a React component.
             * @return {?string} A "reactRoot" ID, if a React component is rendered.
             */
            function getReactRootID(container) {
                var rootElement = getReactRootElementInContainer(container);
                return rootElement && ReactMount.getID(rootElement);
            }

            /**
             * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
             * element can return its control whose name or ID equals ATTR_NAME. All
             * DOM nodes support `getAttributeNode` but this can also get called on
             * other objects so just return '' if we're given something other than a
             * DOM node (such as window).
             *
             * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
             * @return {string} ID of the supplied `domNode`.
             */
            function getID(node) {
                var id = internalGetID(node);
                if (id) {
                    if (nodeCache.hasOwnProperty(id)) {
                        var cached = nodeCache[id];
                        if (cached !== node) {
                            !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;

                            nodeCache[id] = node;
                        }
                    } else {
                        nodeCache[id] = node;
                    }
                }

                return id;
            }

            function internalGetID(node) {
                // If node is something like a window, document, or text node, none of
                // which support attributes or a .getAttribute method, gracefully return
                // the empty string, as if the attribute were missing.
                return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
            }

            /**
             * Sets the React-specific ID of the given node.
             *
             * @param {DOMElement} node The DOM node whose ID will be set.
             * @param {string} id The value of the ID attribute.
             */
            function setID(node, id) {
                var oldID = internalGetID(node);
                if (oldID !== id) {
                    delete nodeCache[oldID];
                }
                node.setAttribute(ATTR_NAME, id);
                nodeCache[id] = node;
            }

            /**
             * Finds the node with the supplied React-generated DOM ID.
             *
             * @param {string} id A React-generated DOM ID.
             * @return {DOMElement} DOM node with the suppled `id`.
             * @internal
             */
            function getNode(id) {
                if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
                    nodeCache[id] = ReactMount.findReactNodeByID(id);
                }
                return nodeCache[id];
            }

            /**
             * Finds the node with the supplied public React instance.
             *
             * @param {*} instance A public React instance.
             * @return {?DOMElement} DOM node with the suppled `id`.
             * @internal
             */
            function getNodeFromInstance(instance) {
                var id = ReactInstanceMap.get(instance)._rootNodeID;
                if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
                    return null;
                }
                if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
                    nodeCache[id] = ReactMount.findReactNodeByID(id);
                }
                return nodeCache[id];
            }

            /**
             * A node is "valid" if it is contained by a currently mounted container.
             *
             * This means that the node does not have to be contained by a document in
             * order to be considered valid.
             *
             * @param {?DOMElement} node The candidate DOM node.
             * @param {string} id The expected ID of the node.
             * @return {boolean} Whether the node is contained by a mounted container.
             */
            function isValid(node, id) {
                if (node) {
                    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;

                    var container = ReactMount.findReactContainerForID(id);
                    if (container && containsNode(container, node)) {
                        return true;
                    }
                }

                return false;
            }

            /**
             * Causes the cache to forget about one React-specific ID.
             *
             * @param {string} id The ID to forget.
             */
            function purgeID(id) {
                delete nodeCache[id];
            }

            var deepestNodeSoFar = null;
            function findDeepestCachedAncestorImpl(ancestorID) {
                var ancestor = nodeCache[ancestorID];
                if (ancestor && isValid(ancestor, ancestorID)) {
                    deepestNodeSoFar = ancestor;
                } else {
                    // This node isn't populated in the cache, so presumably none of its
                    // descendants are. Break out of the loop.
                    return false;
                }
            }

            /**
             * Return the deepest cached node whose ID is a prefix of `targetID`.
             */
            function findDeepestCachedAncestor(targetID) {
                deepestNodeSoFar = null;
                ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);

                var foundNode = deepestNodeSoFar;
                deepestNodeSoFar = null;
                return foundNode;
            }

            /**
             * Mounts this component and inserts it into the DOM.
             *
             * @param {ReactComponent} componentInstance The instance to mount.
             * @param {string} rootID DOM ID of the root node.
             * @param {DOMElement} container DOM element to mount into.
             * @param {ReactReconcileTransaction} transaction
             * @param {boolean} shouldReuseMarkup If true, do not insert markup
             */
            function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
                if (ReactDOMFeatureFlags.useCreateElement) {
                    context = assign({}, context);
                    if (container.nodeType === DOC_NODE_TYPE) {
                        context[ownerDocumentContextKey] = container;
                    } else {
                        context[ownerDocumentContextKey] = container.ownerDocument;
                    }
                }
                if (process.env.NODE_ENV !== 'production') {
                    if (context === emptyObject) {
                        context = {};
                    }
                    var tag = container.nodeName.toLowerCase();
                    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
                }
                var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
                componentInstance._renderedComponent._topLevelWrapper = componentInstance;
                ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
            }

            /**
             * Batched mount.
             *
             * @param {ReactComponent} componentInstance The instance to mount.
             * @param {string} rootID DOM ID of the root node.
             * @param {DOMElement} container DOM element to mount into.
             * @param {boolean} shouldReuseMarkup If true, do not insert markup
             */
            function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
                var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
                    /* forceHTML */shouldReuseMarkup);
                transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
                ReactUpdates.ReactReconcileTransaction.release(transaction);
            }

            /**
             * Unmounts a component and removes it from the DOM.
             *
             * @param {ReactComponent} instance React component instance.
             * @param {DOMElement} container DOM element to unmount from.
             * @final
             * @internal
             * @see {ReactMount.unmountComponentAtNode}
             */
            function unmountComponentFromNode(instance, container) {
                ReactReconciler.unmountComponent(instance);

                if (container.nodeType === DOC_NODE_TYPE) {
                    container = container.documentElement;
                }

                // http://jsperf.com/emptying-a-node
                while (container.lastChild) {
                    container.removeChild(container.lastChild);
                }
            }

            /**
             * True if the supplied DOM node has a direct React-rendered child that is
             * not a React root element. Useful for warning in `render`,
             * `unmountComponentAtNode`, etc.
             *
             * @param {?DOMElement} node The candidate DOM node.
             * @return {boolean} True if the DOM element contains a direct child that was
             * rendered by React but is not a root element.
             * @internal
             */
            function hasNonRootReactChild(node) {
                var reactRootID = getReactRootID(node);
                return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
            }

            /**
             * Returns the first (deepest) ancestor of a node which is rendered by this copy
             * of React.
             */
            function findFirstReactDOMImpl(node) {
                // This node might be from another React instance, so we make sure not to
                // examine the node cache here
                for (; node && node.parentNode !== node; node = node.parentNode) {
                    if (node.nodeType !== 1) {
                        // Not a DOMElement, therefore not a React component
                        continue;
                    }
                    var nodeID = internalGetID(node);
                    if (!nodeID) {
                        continue;
                    }
                    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);

                    // If containersByReactRootID contains the container we find by crawling up
                    // the tree, we know that this instance of React rendered the node.
                    // nb. isValid's strategy (with containsNode) does not work because render
                    // trees may be nested and we don't want a false positive in that case.
                    var current = node;
                    var lastID;
                    do {
                        lastID = internalGetID(current);
                        current = current.parentNode;
                        if (current == null) {
                            // The passed-in node has been detached from the container it was
                            // originally rendered into.
                            return null;
                        }
                    } while (lastID !== reactRootID);

                    if (current === containersByReactRootID[reactRootID]) {
                        return node;
                    }
                }
                return null;
            }

            /**
             * Temporary (?) hack so that we can store all top-level pending updates on
             * composites instead of having to worry about different types of components
             * here.
             */
            var TopLevelWrapper = function TopLevelWrapper() {};
            TopLevelWrapper.prototype.isReactComponent = {};
            if (process.env.NODE_ENV !== 'production') {
                TopLevelWrapper.displayName = 'TopLevelWrapper';
            }
            TopLevelWrapper.prototype.render = function () {
                // this.props is actually a ReactElement
                return this.props;
            };

            /**
             * Mounting is the process of initializing a React component by creating its
             * representative DOM elements and inserting them into a supplied `container`.
             * Any prior content inside `container` is destroyed in the process.
             *
             *   ReactMount.render(
             *     component,
             *     document.getElementById('container')
             *   );
             *
             *   <div id="container">                   <-- Supplied `container`.
             *     <div data-reactid=".3">              <-- Rendered reactRoot of React
             *       // ...                                 component.
             *     </div>
             *   </div>
             *
             * Inside of `container`, the first element rendered is the "reactRoot".
             */
            var ReactMount = {

                TopLevelWrapper: TopLevelWrapper,

                /** Exposed for debugging purposes **/
                _instancesByReactRootID: instancesByReactRootID,

                /**
                 * This is a hook provided to support rendering React components while
                 * ensuring that the apparent scroll position of its `container` does not
                 * change.
                 *
                 * @param {DOMElement} container The `container` being rendered into.
                 * @param {function} renderCallback This must be called once to do the render.
                 */
                scrollMonitor: function scrollMonitor(container, renderCallback) {
                    renderCallback();
                },

                /**
                 * Take a component that's already mounted into the DOM and replace its props
                 * @param {ReactComponent} prevComponent component instance already in the DOM
                 * @param {ReactElement} nextElement component instance to render
                 * @param {DOMElement} container container to render into
                 * @param {?function} callback function triggered on completion
                 */
                _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, container, callback) {
                    ReactMount.scrollMonitor(container, function () {
                        ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
                        if (callback) {
                            ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
                        }
                    });

                    if (process.env.NODE_ENV !== 'production') {
                        // Record the root element in case it later gets transplanted.
                        rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
                    }

                    return prevComponent;
                },

                /**
                 * Register a component into the instance map and starts scroll value
                 * monitoring
                 * @param {ReactComponent} nextComponent component instance to render
                 * @param {DOMElement} container container to render into
                 * @return {string} reactRoot ID prefix
                 */
                _registerComponent: function _registerComponent(nextComponent, container) {
                    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;

                    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

                    var reactRootID = ReactMount.registerContainer(container);
                    instancesByReactRootID[reactRootID] = nextComponent;
                    return reactRootID;
                },

                /**
                 * Render a new component into the DOM.
                 * @param {ReactElement} nextElement element to render
                 * @param {DOMElement} container container to render into
                 * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
                 * @return {ReactComponent} nextComponent
                 */
                _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
                    // Various parts of our code (such as ReactCompositeComponent's
                    // _renderValidatedComponent) assume that calls to render aren't nested;
                    // verify that that's the case.
                    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

                    var componentInstance = instantiateReactComponent(nextElement, null);
                    var reactRootID = ReactMount._registerComponent(componentInstance, container);

                    // The initial render is synchronous but any updates that happen during
                    // rendering, in componentWillMount or componentDidMount, will be batched
                    // according to the current batching strategy.

                    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);

                    if (process.env.NODE_ENV !== 'production') {
                        // Record the root element in case it later gets transplanted.
                        rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
                    }

                    return componentInstance;
                },

                /**
                 * Renders a React component into the DOM in the supplied `container`.
                 *
                 * If the React component was previously rendered into `container`, this will
                 * perform an update on it and only mutate the DOM as necessary to reflect the
                 * latest React component.
                 *
                 * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
                 * @param {ReactElement} nextElement Component element to render.
                 * @param {DOMElement} container DOM element to render into.
                 * @param {?function} callback function triggered on completion
                 * @return {ReactComponent} Component instance rendered in `container`.
                 */
                renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
                    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
                    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
                },

                _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
                    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
                        // Check if it quacks like an element
                        nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;

                    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;

                    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);

                    var prevComponent = instancesByReactRootID[getReactRootID(container)];

                    if (prevComponent) {
                        var prevWrappedElement = prevComponent._currentElement;
                        var prevElement = prevWrappedElement.props;
                        if (shouldUpdateReactComponent(prevElement, nextElement)) {
                            var publicInst = prevComponent._renderedComponent.getPublicInstance();
                            var updatedCallback = callback && function () {
                                    callback.call(publicInst);
                                };
                            ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
                            return publicInst;
                        } else {
                            ReactMount.unmountComponentAtNode(container);
                        }
                    }

                    var reactRootElement = getReactRootElementInContainer(container);
                    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
                    var containerHasNonRootReactChild = hasNonRootReactChild(container);

                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;

                        if (!containerHasReactMarkup || reactRootElement.nextSibling) {
                            var rootElementSibling = reactRootElement;
                            while (rootElementSibling) {
                                if (internalGetID(rootElementSibling)) {
                                    process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
                                    break;
                                }
                                rootElementSibling = rootElementSibling.nextSibling;
                            }
                        }
                    }

                    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
                    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
                    if (callback) {
                        callback.call(component);
                    }
                    return component;
                },

                /**
                 * Renders a React component into the DOM in the supplied `container`.
                 *
                 * If the React component was previously rendered into `container`, this will
                 * perform an update on it and only mutate the DOM as necessary to reflect the
                 * latest React component.
                 *
                 * @param {ReactElement} nextElement Component element to render.
                 * @param {DOMElement} container DOM element to render into.
                 * @param {?function} callback function triggered on completion
                 * @return {ReactComponent} Component instance rendered in `container`.
                 */
                render: function render(nextElement, container, callback) {
                    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
                },

                /**
                 * Registers a container node into which React components will be rendered.
                 * This also creates the "reactRoot" ID that will be assigned to the element
                 * rendered within.
                 *
                 * @param {DOMElement} container DOM element to register as a container.
                 * @return {string} The "reactRoot" ID of elements rendered within.
                 */
                registerContainer: function registerContainer(container) {
                    var reactRootID = getReactRootID(container);
                    if (reactRootID) {
                        // If one exists, make sure it is a valid "reactRoot" ID.
                        reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
                    }
                    if (!reactRootID) {
                        // No valid "reactRoot" ID found, create one.
                        reactRootID = ReactInstanceHandles.createReactRootID();
                    }
                    containersByReactRootID[reactRootID] = container;
                    return reactRootID;
                },

                /**
                 * Unmounts and destroys the React component rendered in the `container`.
                 *
                 * @param {DOMElement} container DOM element containing a React component.
                 * @return {boolean} True if a component was found in and unmounted from
                 *                   `container`
                 */
                unmountComponentAtNode: function unmountComponentAtNode(container) {
                    // Various parts of our code (such as ReactCompositeComponent's
                    // _renderValidatedComponent) assume that calls to render aren't nested;
                    // verify that that's the case. (Strictly speaking, unmounting won't cause a
                    // render but we still don't expect to be in a render call here.)
                    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

                    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;

                    var reactRootID = getReactRootID(container);
                    var component = instancesByReactRootID[reactRootID];
                    if (!component) {
                        // Check if the node being unmounted was rendered by React, but isn't a
                        // root node.
                        var containerHasNonRootReactChild = hasNonRootReactChild(container);

                        // Check if the container itself is a React root node.
                        var containerID = internalGetID(container);
                        var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);

                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
                        }

                        return false;
                    }
                    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
                    delete instancesByReactRootID[reactRootID];
                    delete containersByReactRootID[reactRootID];
                    if (process.env.NODE_ENV !== 'production') {
                        delete rootElementsByReactRootID[reactRootID];
                    }
                    return true;
                },

                /**
                 * Finds the container DOM element that contains React component to which the
                 * supplied DOM `id` belongs.
                 *
                 * @param {string} id The ID of an element rendered by a React component.
                 * @return {?DOMElement} DOM element that contains the `id`.
                 */
                findReactContainerForID: function findReactContainerForID(id) {
                    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
                    var container = containersByReactRootID[reactRootID];

                    if (process.env.NODE_ENV !== 'production') {
                        var rootElement = rootElementsByReactRootID[reactRootID];
                        if (rootElement && rootElement.parentNode !== container) {
                            process.env.NODE_ENV !== 'production' ? warning(
                                // Call internalGetID here because getID calls isValid which calls
                                // findReactContainerForID (this function).
                                internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
                            var containerChild = container.firstChild;
                            if (containerChild && reactRootID === internalGetID(containerChild)) {
                                // If the container has a new child with the same ID as the old
                                // root element, then rootElementsByReactRootID[reactRootID] is
                                // just stale and needs to be updated. The case that deserves a
                                // warning is when the container is empty.
                                rootElementsByReactRootID[reactRootID] = containerChild;
                            } else {
                                process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
                            }
                        }
                    }

                    return container;
                },

                /**
                 * Finds an element rendered by React with the supplied ID.
                 *
                 * @param {string} id ID of a DOM node in the React component.
                 * @return {DOMElement} Root DOM node of the React component.
                 */
                findReactNodeByID: function findReactNodeByID(id) {
                    var reactRoot = ReactMount.findReactContainerForID(id);
                    return ReactMount.findComponentRoot(reactRoot, id);
                },

                /**
                 * Traverses up the ancestors of the supplied node to find a node that is a
                 * DOM representation of a React component rendered by this copy of React.
                 *
                 * @param {*} node
                 * @return {?DOMEventTarget}
                 * @internal
                 */
                getFirstReactDOM: function getFirstReactDOM(node) {
                    return findFirstReactDOMImpl(node);
                },

                /**
                 * Finds a node with the supplied `targetID` inside of the supplied
                 * `ancestorNode`.  Exploits the ID naming scheme to perform the search
                 * quickly.
                 *
                 * @param {DOMEventTarget} ancestorNode Search from this root.
                 * @pararm {string} targetID ID of the DOM representation of the component.
                 * @return {DOMEventTarget} DOM node with the supplied `targetID`.
                 * @internal
                 */
                findComponentRoot: function findComponentRoot(ancestorNode, targetID) {
                    var firstChildren = findComponentRootReusableArray;
                    var childIndex = 0;

                    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

                    if (process.env.NODE_ENV !== 'production') {
                        // This will throw on the next line; give an early warning
                        process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
                    }

                    firstChildren[0] = deepestAncestor.firstChild;
                    firstChildren.length = 1;

                    while (childIndex < firstChildren.length) {
                        var child = firstChildren[childIndex++];
                        var targetChild;

                        while (child) {
                            var childID = ReactMount.getID(child);
                            if (childID) {
                                // Even if we find the node we're looking for, we finish looping
                                // through its siblings to ensure they're cached so that we don't have
                                // to revisit this node again. Otherwise, we make n^2 calls to getID
                                // when visiting the many children of a single node in order.

                                if (targetID === childID) {
                                    targetChild = child;
                                } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                                    // If we find a child whose ID is an ancestor of the given ID,
                                    // then we can be sure that we only want to search the subtree
                                    // rooted at this child, so we can throw out the rest of the
                                    // search state.
                                    firstChildren.length = childIndex = 0;
                                    firstChildren.push(child.firstChild);
                                }
                            } else {
                                // If this child had no ID, then there's a chance that it was
                                // injected automatically by the browser, as when a `<table>`
                                // element sprouts an extra `<tbody>` child as a side effect of
                                // `.innerHTML` parsing. Optimistically continue down this
                                // branch, but not before examining the other siblings.
                                firstChildren.push(child.firstChild);
                            }

                            child = child.nextSibling;
                        }

                        if (targetChild) {
                            // Emptying firstChildren/findComponentRootReusableArray is
                            // not necessary for correctness, but it helps the GC reclaim
                            // any nodes that were left at the end of the search.
                            firstChildren.length = 0;

                            return targetChild;
                        }
                    }

                    firstChildren.length = 0;

                    true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
                },

                _mountImageIntoNode: function _mountImageIntoNode(markup, container, shouldReuseMarkup, transaction) {
                    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;

                    if (shouldReuseMarkup) {
                        var rootElement = getReactRootElementInContainer(container);
                        if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
                            return;
                        } else {
                            var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
                            rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

                            var rootMarkup = rootElement.outerHTML;
                            rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

                            var normalizedMarkup = markup;
                            if (process.env.NODE_ENV !== 'production') {
                                // because rootMarkup is retrieved from the DOM, various normalizations
                                // will have occurred which will not be present in `markup`. Here,
                                // insert markup into a <div> or <iframe> depending on the container
                                // type to perform the same normalizations before comparing.
                                var normalizer;
                                if (container.nodeType === ELEMENT_NODE_TYPE) {
                                    normalizer = document.createElement('div');
                                    normalizer.innerHTML = markup;
                                    normalizedMarkup = normalizer.innerHTML;
                                } else {
                                    normalizer = document.createElement('iframe');
                                    document.body.appendChild(normalizer);
                                    normalizer.contentDocument.write(markup);
                                    normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
                                    document.body.removeChild(normalizer);
                                }
                            }

                            var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
                            var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

                            !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;

                            if (process.env.NODE_ENV !== 'production') {
                                process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
                            }
                        }
                    }

                    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;

                    if (transaction.useCreateElement) {
                        while (container.lastChild) {
                            container.removeChild(container.lastChild);
                        }
                        container.appendChild(markup);
                    } else {
                        setInnerHTML(container, markup);
                    }
                },

                ownerDocumentContextKey: ownerDocumentContextKey,

                /**
                 * React ID utilities.
                 */

                getReactRootID: getReactRootID,

                getID: getID,

                setID: setID,

                getNode: getNode,

                getNodeFromInstance: getNodeFromInstance,

                isValid: isValid,

                purgeID: purgeID
            };

            ReactPerf.measureMethods(ReactMount, 'ReactMount', {
                _renderNewRootComponent: '_renderNewRootComponent',
                _mountImageIntoNode: '_mountImageIntoNode'
            });

            module.exports = ReactMount;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 103 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactBrowserEventEmitter
         * @typechecks static-only
         */

        'use strict';

        var EventConstants = __webpack_require__(104);
        var EventPluginHub = __webpack_require__(105);
        var EventPluginRegistry = __webpack_require__(106);
        var ReactEventEmitterMixin = __webpack_require__(111);
        var ReactPerf = __webpack_require__(92);
        var ViewportMetrics = __webpack_require__(112);

        var assign = __webpack_require__(113);
        var isEventSupported = __webpack_require__(114);

        /**
         * Summary of `ReactBrowserEventEmitter` event handling:
         *
         *  - Top-level delegation is used to trap most native browser events. This
         *    may only occur in the main thread and is the responsibility of
         *    ReactEventListener, which is injected and can therefore support pluggable
         *    event sources. This is the only work that occurs in the main thread.
         *
         *  - We normalize and de-duplicate events to account for browser quirks. This
         *    may be done in the worker thread.
         *
         *  - Forward these native events (with the associated top-level type used to
         *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
         *    to extract any synthetic events.
         *
         *  - The `EventPluginHub` will then process each event by annotating them with
         *    "dispatches", a sequence of listeners and IDs that care about that event.
         *
         *  - The `EventPluginHub` then dispatches the events.
         *
         * Overview of React and the event system:
         *
         * +------------+    .
         * |    DOM     |    .
         * +------------+    .
         *       |           .
         *       v           .
         * +------------+    .
         * | ReactEvent |    .
         * |  Listener  |    .
         * +------------+    .                         +-----------+
         *       |           .               +--------+|SimpleEvent|
         *       |           .               |         |Plugin     |
         * +-----|------+    .               v         +-----------+
         * |     |      |    .    +--------------+                    +------------+
         * |     +-----------.--->|EventPluginHub|                    |    Event   |
         * |            |    .    |              |     +-----------+  | Propagators|
         * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
         * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
         * |            |    .    |              |     +-----------+  |  utilities |
         * |     +-----------.--->|              |                    +------------+
         * |     |      |    .    +--------------+
         * +-----|------+    .                ^        +-----------+
         *       |           .                |        |Enter/Leave|
         *       +           .                +-------+|Plugin     |
         * +-------------+   .                         +-----------+
         * | application |   .
         * |-------------|   .
         * |             |   .
         * |             |   .
         * +-------------+   .
         *                   .
         *    React Core     .  General Purpose Event Plugin System
         */

        var alreadyListeningTo = {};
        var isMonitoringScrollValue = false;
        var reactTopListenersCounter = 0;

        // For events like 'submit' which don't consistently bubble (which we trap at a
        // lower node than `document`), binding at `document` would cause duplicate
        // events so we don't include them here
        var topEventMapping = {
            topAbort: 'abort',
            topBlur: 'blur',
            topCanPlay: 'canplay',
            topCanPlayThrough: 'canplaythrough',
            topChange: 'change',
            topClick: 'click',
            topCompositionEnd: 'compositionend',
            topCompositionStart: 'compositionstart',
            topCompositionUpdate: 'compositionupdate',
            topContextMenu: 'contextmenu',
            topCopy: 'copy',
            topCut: 'cut',
            topDoubleClick: 'dblclick',
            topDrag: 'drag',
            topDragEnd: 'dragend',
            topDragEnter: 'dragenter',
            topDragExit: 'dragexit',
            topDragLeave: 'dragleave',
            topDragOver: 'dragover',
            topDragStart: 'dragstart',
            topDrop: 'drop',
            topDurationChange: 'durationchange',
            topEmptied: 'emptied',
            topEncrypted: 'encrypted',
            topEnded: 'ended',
            topError: 'error',
            topFocus: 'focus',
            topInput: 'input',
            topKeyDown: 'keydown',
            topKeyPress: 'keypress',
            topKeyUp: 'keyup',
            topLoadedData: 'loadeddata',
            topLoadedMetadata: 'loadedmetadata',
            topLoadStart: 'loadstart',
            topMouseDown: 'mousedown',
            topMouseMove: 'mousemove',
            topMouseOut: 'mouseout',
            topMouseOver: 'mouseover',
            topMouseUp: 'mouseup',
            topPaste: 'paste',
            topPause: 'pause',
            topPlay: 'play',
            topPlaying: 'playing',
            topProgress: 'progress',
            topRateChange: 'ratechange',
            topScroll: 'scroll',
            topSeeked: 'seeked',
            topSeeking: 'seeking',
            topSelectionChange: 'selectionchange',
            topStalled: 'stalled',
            topSuspend: 'suspend',
            topTextInput: 'textInput',
            topTimeUpdate: 'timeupdate',
            topTouchCancel: 'touchcancel',
            topTouchEnd: 'touchend',
            topTouchMove: 'touchmove',
            topTouchStart: 'touchstart',
            topVolumeChange: 'volumechange',
            topWaiting: 'waiting',
            topWheel: 'wheel'
        };

        /**
         * To ensure no conflicts with other potential React instances on the page
         */
        var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

        function getListeningForDocument(mountAt) {
            // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
            // directly.
            if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
                mountAt[topListenersIDKey] = reactTopListenersCounter++;
                alreadyListeningTo[mountAt[topListenersIDKey]] = {};
            }
            return alreadyListeningTo[mountAt[topListenersIDKey]];
        }

        /**
         * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
         * example:
         *
         *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
         *
         * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
         *
         * @internal
         */
        var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

            /**
             * Injectable event backend
             */
            ReactEventListener: null,

            injection: {
                /**
                 * @param {object} ReactEventListener
                 */
                injectReactEventListener: function injectReactEventListener(ReactEventListener) {
                    ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
                    ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
                }
            },

            /**
             * Sets whether or not any created callbacks should be enabled.
             *
             * @param {boolean} enabled True if callbacks should be enabled.
             */
            setEnabled: function setEnabled(enabled) {
                if (ReactBrowserEventEmitter.ReactEventListener) {
                    ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
                }
            },

            /**
             * @return {boolean} True if callbacks are enabled.
             */
            isEnabled: function isEnabled() {
                return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
            },

            /**
             * We listen for bubbled touch events on the document object.
             *
             * Firefox v8.01 (and possibly others) exhibited strange behavior when
             * mounting `onmousemove` events at some node that was not the document
             * element. The symptoms were that if your mouse is not moving over something
             * contained within that mount point (for example on the background) the
             * top-level listeners for `onmousemove` won't be called. However, if you
             * register the `mousemove` on the document object, then it will of course
             * catch all `mousemove`s. This along with iOS quirks, justifies restricting
             * top-level listeners to the document object only, at least for these
             * movement types of events and possibly all events.
             *
             * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
             *
             * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
             * they bubble to document.
             *
             * @param {string} registrationName Name of listener (e.g. `onClick`).
             * @param {object} contentDocumentHandle Document which owns the container
             */
            listenTo: function listenTo(registrationName, contentDocumentHandle) {
                var mountAt = contentDocumentHandle;
                var isListening = getListeningForDocument(mountAt);
                var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

                var topLevelTypes = EventConstants.topLevelTypes;
                for (var i = 0; i < dependencies.length; i++) {
                    var dependency = dependencies[i];
                    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
                        if (dependency === topLevelTypes.topWheel) {
                            if (isEventSupported('wheel')) {
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
                            } else if (isEventSupported('mousewheel')) {
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
                            } else {
                                // Firefox needs to capture a different mouse scroll event.
                                // @see http://www.quirksmode.org/dom/events/tests/scroll.html
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
                            }
                        } else if (dependency === topLevelTypes.topScroll) {

                            if (isEventSupported('scroll', true)) {
                                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
                            } else {
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
                            }
                        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

                            if (isEventSupported('focus', true)) {
                                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
                                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
                            } else if (isEventSupported('focusin')) {
                                // IE has `focusin` and `focusout` events which bubble.
                                // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
                                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
                            }

                            // to make sure blur and focus event listeners are only attached once
                            isListening[topLevelTypes.topBlur] = true;
                            isListening[topLevelTypes.topFocus] = true;
                        } else if (topEventMapping.hasOwnProperty(dependency)) {
                            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
                        }

                        isListening[dependency] = true;
                    }
                }
            },

            trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
                return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
            },

            trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
                return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
            },

            /**
             * Listens to window scroll and resize events. We cache scroll values so that
             * application code can access them without triggering reflows.
             *
             * NOTE: Scroll events do not bubble.
             *
             * @see http://www.quirksmode.org/dom/events/scroll.html
             */
            ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
                if (!isMonitoringScrollValue) {
                    var refresh = ViewportMetrics.refreshScrollValues;
                    ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
                    isMonitoringScrollValue = true;
                }
            },

            eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

            registrationNameModules: EventPluginHub.registrationNameModules,

            putListener: EventPluginHub.putListener,

            getListener: EventPluginHub.getListener,

            deleteListener: EventPluginHub.deleteListener,

            deleteAllListeners: EventPluginHub.deleteAllListeners

        });

        ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
            putListener: 'putListener',
            deleteListener: 'deleteListener'
        });

        module.exports = ReactBrowserEventEmitter;

        /***/ },
    /* 104 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule EventConstants
         */

        'use strict';

        var keyMirror = __webpack_require__(91);

        var PropagationPhases = keyMirror({ bubbled: null, captured: null });

        /**
         * Types of raw signals from the browser caught at the top level.
         */
        var topLevelTypes = keyMirror({
            topAbort: null,
            topBlur: null,
            topCanPlay: null,
            topCanPlayThrough: null,
            topChange: null,
            topClick: null,
            topCompositionEnd: null,
            topCompositionStart: null,
            topCompositionUpdate: null,
            topContextMenu: null,
            topCopy: null,
            topCut: null,
            topDoubleClick: null,
            topDrag: null,
            topDragEnd: null,
            topDragEnter: null,
            topDragExit: null,
            topDragLeave: null,
            topDragOver: null,
            topDragStart: null,
            topDrop: null,
            topDurationChange: null,
            topEmptied: null,
            topEncrypted: null,
            topEnded: null,
            topError: null,
            topFocus: null,
            topInput: null,
            topKeyDown: null,
            topKeyPress: null,
            topKeyUp: null,
            topLoad: null,
            topLoadedData: null,
            topLoadedMetadata: null,
            topLoadStart: null,
            topMouseDown: null,
            topMouseMove: null,
            topMouseOut: null,
            topMouseOver: null,
            topMouseUp: null,
            topPaste: null,
            topPause: null,
            topPlay: null,
            topPlaying: null,
            topProgress: null,
            topRateChange: null,
            topReset: null,
            topScroll: null,
            topSeeked: null,
            topSeeking: null,
            topSelectionChange: null,
            topStalled: null,
            topSubmit: null,
            topSuspend: null,
            topTextInput: null,
            topTimeUpdate: null,
            topTouchCancel: null,
            topTouchEnd: null,
            topTouchMove: null,
            topTouchStart: null,
            topVolumeChange: null,
            topWaiting: null,
            topWheel: null
        });

        var EventConstants = {
            topLevelTypes: topLevelTypes,
            PropagationPhases: PropagationPhases
        };

        module.exports = EventConstants;

        /***/ },
    /* 105 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule EventPluginHub
         */

        'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var EventPluginRegistry = __webpack_require__(106);
            var EventPluginUtils = __webpack_require__(107);
            var ReactErrorUtils = __webpack_require__(108);

            var accumulateInto = __webpack_require__(109);
            var forEachAccumulated = __webpack_require__(110);
            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            /**
             * Internal store for event listeners
             */
            var listenerBank = {};

            /**
             * Internal queue of events that have accumulated their dispatches and are
             * waiting to have their dispatches executed.
             */
            var eventQueue = null;

            /**
             * Dispatches an event and releases it back into the pool, unless persistent.
             *
             * @param {?object} event Synthetic event to be dispatched.
             * @param {boolean} simulated If the event is simulated (changes exn behavior)
             * @private
             */
            var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
                if (event) {
                    EventPluginUtils.executeDispatchesInOrder(event, simulated);

                    if (!event.isPersistent()) {
                        event.constructor.release(event);
                    }
                }
            };
            var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
                return executeDispatchesAndRelease(e, true);
            };
            var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
                return executeDispatchesAndRelease(e, false);
            };

            /**
             * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
             *   hierarchy given ids of the logical DOM elements involved.
             */
            var InstanceHandle = null;

            function validateInstanceHandle() {
                var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
                process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
            }

            /**
             * This is a unified interface for event plugins to be installed and configured.
             *
             * Event plugins can implement the following properties:
             *
             *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
             *     Required. When a top-level event is fired, this method is expected to
             *     extract synthetic events that will in turn be queued and dispatched.
             *
             *   `eventTypes` {object}
             *     Optional, plugins that fire events must publish a mapping of registration
             *     names that are used to register listeners. Values of this mapping must
             *     be objects that contain `registrationName` or `phasedRegistrationNames`.
             *
             *   `executeDispatch` {function(object, function, string)}
             *     Optional, allows plugins to override how an event gets dispatched. By
             *     default, the listener is simply invoked.
             *
             * Each plugin that is injected into `EventsPluginHub` is immediately operable.
             *
             * @public
             */
            var EventPluginHub = {

                /**
                 * Methods for injecting dependencies.
                 */
                injection: {

                    /**
                     * @param {object} InjectedMount
                     * @public
                     */
                    injectMount: EventPluginUtils.injection.injectMount,

                    /**
                     * @param {object} InjectedInstanceHandle
                     * @public
                     */
                    injectInstanceHandle: function injectInstanceHandle(InjectedInstanceHandle) {
                        InstanceHandle = InjectedInstanceHandle;
                        if (process.env.NODE_ENV !== 'production') {
                            validateInstanceHandle();
                        }
                    },

                    getInstanceHandle: function getInstanceHandle() {
                        if (process.env.NODE_ENV !== 'production') {
                            validateInstanceHandle();
                        }
                        return InstanceHandle;
                    },

                    /**
                     * @param {array} InjectedEventPluginOrder
                     * @public
                     */
                    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

                    /**
                     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
                     */
                    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

                },

                eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

                registrationNameModules: EventPluginRegistry.registrationNameModules,

                /**
                 * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
                 *
                 * @param {string} id ID of the DOM element.
                 * @param {string} registrationName Name of listener (e.g. `onClick`).
                 * @param {?function} listener The callback to store.
                 */
                putListener: function putListener(id, registrationName, listener) {
                    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : invariant(false) : undefined;

                    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
                    bankForRegistrationName[id] = listener;

                    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
                    if (PluginModule && PluginModule.didPutListener) {
                        PluginModule.didPutListener(id, registrationName, listener);
                    }
                },

                /**
                 * @param {string} id ID of the DOM element.
                 * @param {string} registrationName Name of listener (e.g. `onClick`).
                 * @return {?function} The stored callback.
                 */
                getListener: function getListener(id, registrationName) {
                    var bankForRegistrationName = listenerBank[registrationName];
                    return bankForRegistrationName && bankForRegistrationName[id];
                },

                /**
                 * Deletes a listener from the registration bank.
                 *
                 * @param {string} id ID of the DOM element.
                 * @param {string} registrationName Name of listener (e.g. `onClick`).
                 */
                deleteListener: function deleteListener(id, registrationName) {
                    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
                    if (PluginModule && PluginModule.willDeleteListener) {
                        PluginModule.willDeleteListener(id, registrationName);
                    }

                    var bankForRegistrationName = listenerBank[registrationName];
                    // TODO: This should never be null -- when is it?
                    if (bankForRegistrationName) {
                        delete bankForRegistrationName[id];
                    }
                },

                /**
                 * Deletes all listeners for the DOM element with the supplied ID.
                 *
                 * @param {string} id ID of the DOM element.
                 */
                deleteAllListeners: function deleteAllListeners(id) {
                    for (var registrationName in listenerBank) {
                        if (!listenerBank[registrationName][id]) {
                            continue;
                        }

                        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
                        if (PluginModule && PluginModule.willDeleteListener) {
                            PluginModule.willDeleteListener(id, registrationName);
                        }

                        delete listenerBank[registrationName][id];
                    }
                },

                /**
                 * Allows registered plugins an opportunity to extract events from top-level
                 * native browser events.
                 *
                 * @param {string} topLevelType Record from `EventConstants`.
                 * @param {DOMEventTarget} topLevelTarget The listening component root node.
                 * @param {string} topLevelTargetID ID of `topLevelTarget`.
                 * @param {object} nativeEvent Native browser event.
                 * @return {*} An accumulation of synthetic events.
                 * @internal
                 */
                extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
                    var events;
                    var plugins = EventPluginRegistry.plugins;
                    for (var i = 0; i < plugins.length; i++) {
                        // Not every plugin in the ordering may be loaded at runtime.
                        var possiblePlugin = plugins[i];
                        if (possiblePlugin) {
                            var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
                            if (extractedEvents) {
                                events = accumulateInto(events, extractedEvents);
                            }
                        }
                    }
                    return events;
                },

                /**
                 * Enqueues a synthetic event that should be dispatched when
                 * `processEventQueue` is invoked.
                 *
                 * @param {*} events An accumulation of synthetic events.
                 * @internal
                 */
                enqueueEvents: function enqueueEvents(events) {
                    if (events) {
                        eventQueue = accumulateInto(eventQueue, events);
                    }
                },

                /**
                 * Dispatches all synthetic events on the event queue.
                 *
                 * @internal
                 */
                processEventQueue: function processEventQueue(simulated) {
                    // Set `eventQueue` to null before processing it so that we can tell if more
                    // events get enqueued while processing.
                    var processingEventQueue = eventQueue;
                    eventQueue = null;
                    if (simulated) {
                        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
                    } else {
                        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
                    }
                    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
                    // This would be a good time to rethrow if any of the event handlers threw.
                    ReactErrorUtils.rethrowCaughtError();
                },

                /**
                 * These are needed for tests only. Do not use!
                 */
                __purge: function __purge() {
                    listenerBank = {};
                },

                __getListenerBank: function __getListenerBank() {
                    return listenerBank;
                }

            };

            module.exports = EventPluginHub;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 106 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule EventPluginRegistry
         * @typechecks static-only
         */

        'use strict';

            var invariant = __webpack_require__(87);

            /**
             * Injectable ordering of event plugins.
             */
            var EventPluginOrder = null;

            /**
             * Injectable mapping from names to event plugin modules.
             */
            var namesToPlugins = {};

            /**
             * Recomputes the plugin list using the injected plugins and plugin ordering.
             *
             * @private
             */
            function recomputePluginOrdering() {
                if (!EventPluginOrder) {
                    // Wait until an `EventPluginOrder` is injected.
                    return;
                }
                for (var pluginName in namesToPlugins) {
                    var PluginModule = namesToPlugins[pluginName];
                    var pluginIndex = EventPluginOrder.indexOf(pluginName);
                    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
                    if (EventPluginRegistry.plugins[pluginIndex]) {
                        continue;
                    }
                    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
                    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
                    var publishedEvents = PluginModule.eventTypes;
                    for (var eventName in publishedEvents) {
                        !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
                    }
                }
            }

            /**
             * Publishes an event so that it can be dispatched by the supplied plugin.
             *
             * @param {object} dispatchConfig Dispatch configuration for the event.
             * @param {object} PluginModule Plugin publishing the event.
             * @return {boolean} True if the event was successfully published.
             * @private
             */
            function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
                !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
                EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

                var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
                if (phasedRegistrationNames) {
                    for (var phaseName in phasedRegistrationNames) {
                        if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
                            var phasedRegistrationName = phasedRegistrationNames[phaseName];
                            publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
                        }
                    }
                    return true;
                } else if (dispatchConfig.registrationName) {
                    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
                    return true;
                }
                return false;
            }

            /**
             * Publishes a registration name that is used to identify dispatched events and
             * can be used with `EventPluginHub.putListener` to register listeners.
             *
             * @param {string} registrationName Registration name to add.
             * @param {object} PluginModule Plugin publishing the event.
             * @private
             */
            function publishRegistrationName(registrationName, PluginModule, eventName) {
                !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
                EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
                EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
            }

            /**
             * Registers plugins so that they can extract and dispatch events.
             *
             * @see {EventPluginHub}
             */
            var EventPluginRegistry = {

                /**
                 * Ordered list of injected plugins.
                 */
                plugins: [],

                /**
                 * Mapping from event name to dispatch config
                 */
                eventNameDispatchConfigs: {},

                /**
                 * Mapping from registration name to plugin module
                 */
                registrationNameModules: {},

                /**
                 * Mapping from registration name to event name
                 */
                registrationNameDependencies: {},

                /**
                 * Injects an ordering of plugins (by plugin name). This allows the ordering
                 * to be decoupled from injection of the actual plugins so that ordering is
                 * always deterministic regardless of packaging, on-the-fly injection, etc.
                 *
                 * @param {array} InjectedEventPluginOrder
                 * @internal
                 * @see {EventPluginHub.injection.injectEventPluginOrder}
                 */
                injectEventPluginOrder: function injectEventPluginOrder(InjectedEventPluginOrder) {
                    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
                    // Clone the ordering so it cannot be dynamically mutated.
                    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
                    recomputePluginOrdering();
                },

                /**
                 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
                 * in the ordering injected by `injectEventPluginOrder`.
                 *
                 * Plugins can be injected as part of page initialization or on-the-fly.
                 *
                 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
                 * @internal
                 * @see {EventPluginHub.injection.injectEventPluginsByName}
                 */
                injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
                    var isOrderingDirty = false;
                    for (var pluginName in injectedNamesToPlugins) {
                        if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
                            continue;
                        }
                        var PluginModule = injectedNamesToPlugins[pluginName];
                        if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
                            !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
                            namesToPlugins[pluginName] = PluginModule;
                            isOrderingDirty = true;
                        }
                    }
                    if (isOrderingDirty) {
                        recomputePluginOrdering();
                    }
                },

                /**
                 * Looks up the plugin for the supplied event.
                 *
                 * @param {object} event A synthetic event.
                 * @return {?object} The plugin that created the supplied event.
                 * @internal
                 */
                getPluginModuleForEvent: function getPluginModuleForEvent(event) {
                    var dispatchConfig = event.dispatchConfig;
                    if (dispatchConfig.registrationName) {
                        return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
                    }
                    for (var phase in dispatchConfig.phasedRegistrationNames) {
                        if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
                            continue;
                        }
                        var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
                        if (PluginModule) {
                            return PluginModule;
                        }
                    }
                    return null;
                },

                /**
                 * Exposed for unit testing.
                 * @private
                 */
                _resetEventPlugins: function _resetEventPlugins() {
                    EventPluginOrder = null;
                    for (var pluginName in namesToPlugins) {
                        if (namesToPlugins.hasOwnProperty(pluginName)) {
                            delete namesToPlugins[pluginName];
                        }
                    }
                    EventPluginRegistry.plugins.length = 0;

                    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
                    for (var eventName in eventNameDispatchConfigs) {
                        if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
                            delete eventNameDispatchConfigs[eventName];
                        }
                    }

                    var registrationNameModules = EventPluginRegistry.registrationNameModules;
                    for (var registrationName in registrationNameModules) {
                        if (registrationNameModules.hasOwnProperty(registrationName)) {
                            delete registrationNameModules[registrationName];
                        }
                    }
                }

            };

            module.exports = EventPluginRegistry;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 107 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule EventPluginUtils
         */

        'use strict';

            var EventConstants = __webpack_require__(104);
            var ReactErrorUtils = __webpack_require__(108);

            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            /**
             * Injected dependencies:
             */

            /**
             * - `Mount`: [required] Module that can convert between React dom IDs and
             *   actual node references.
             */
            var injection = {
                Mount: null,
                injectMount: function injectMount(InjectedMount) {
                    injection.Mount = InjectedMount;
                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
                    }
                }
            };

            var topLevelTypes = EventConstants.topLevelTypes;

            function isEndish(topLevelType) {
                return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
            }

            function isMoveish(topLevelType) {
                return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
            }
            function isStartish(topLevelType) {
                return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
            }

            var validateEventDispatches;
            if (process.env.NODE_ENV !== 'production') {
                validateEventDispatches = function validateEventDispatches(event) {
                    var dispatchListeners = event._dispatchListeners;
                    var dispatchIDs = event._dispatchIDs;

                    var listenersIsArr = Array.isArray(dispatchListeners);
                    var idsIsArr = Array.isArray(dispatchIDs);
                    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
                    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

                    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
                };
            }

            /**
             * Dispatch the event to the listener.
             * @param {SyntheticEvent} event SyntheticEvent to handle
             * @param {boolean} simulated If the event is simulated (changes exn behavior)
             * @param {function} listener Application-level callback
             * @param {string} domID DOM id to pass to the callback.
             */
            function executeDispatch(event, simulated, listener, domID) {
                var type = event.type || 'unknown-event';
                event.currentTarget = injection.Mount.getNode(domID);
                if (simulated) {
                    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
                } else {
                    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
                }
                event.currentTarget = null;
            }

            /**
             * Standard/simple iteration through an event's collected dispatches.
             */
            function executeDispatchesInOrder(event, simulated) {
                var dispatchListeners = event._dispatchListeners;
                var dispatchIDs = event._dispatchIDs;
                if (process.env.NODE_ENV !== 'production') {
                    validateEventDispatches(event);
                }
                if (Array.isArray(dispatchListeners)) {
                    for (var i = 0; i < dispatchListeners.length; i++) {
                        if (event.isPropagationStopped()) {
                            break;
                        }
                        // Listeners and IDs are two parallel arrays that are always in sync.
                        executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
                    }
                } else if (dispatchListeners) {
                    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
                }
                event._dispatchListeners = null;
                event._dispatchIDs = null;
            }

            /**
             * Standard/simple iteration through an event's collected dispatches, but stops
             * at the first dispatch execution returning true, and returns that id.
             *
             * @return {?string} id of the first dispatch execution who's listener returns
             * true, or null if no listener returned true.
             */
            function executeDispatchesInOrderStopAtTrueImpl(event) {
                var dispatchListeners = event._dispatchListeners;
                var dispatchIDs = event._dispatchIDs;
                if (process.env.NODE_ENV !== 'production') {
                    validateEventDispatches(event);
                }
                if (Array.isArray(dispatchListeners)) {
                    for (var i = 0; i < dispatchListeners.length; i++) {
                        if (event.isPropagationStopped()) {
                            break;
                        }
                        // Listeners and IDs are two parallel arrays that are always in sync.
                        if (dispatchListeners[i](event, dispatchIDs[i])) {
                            return dispatchIDs[i];
                        }
                    }
                } else if (dispatchListeners) {
                    if (dispatchListeners(event, dispatchIDs)) {
                        return dispatchIDs;
                    }
                }
                return null;
            }

            /**
             * @see executeDispatchesInOrderStopAtTrueImpl
             */
            function executeDispatchesInOrderStopAtTrue(event) {
                var ret = executeDispatchesInOrderStopAtTrueImpl(event);
                event._dispatchIDs = null;
                event._dispatchListeners = null;
                return ret;
            }

            /**
             * Execution of a "direct" dispatch - there must be at most one dispatch
             * accumulated on the event or it is considered an error. It doesn't really make
             * sense for an event with multiple dispatches (bubbled) to keep track of the
             * return values at each dispatch execution, but it does tend to make sense when
             * dealing with "direct" dispatches.
             *
             * @return {*} The return value of executing the single dispatch.
             */
            function executeDirectDispatch(event) {
                if (process.env.NODE_ENV !== 'production') {
                    validateEventDispatches(event);
                }
                var dispatchListener = event._dispatchListeners;
                var dispatchID = event._dispatchIDs;
                !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
                var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
                event._dispatchListeners = null;
                event._dispatchIDs = null;
                return res;
            }

            /**
             * @param {SyntheticEvent} event
             * @return {boolean} True iff number of dispatches accumulated is greater than 0.
             */
            function hasDispatches(event) {
                return !!event._dispatchListeners;
            }

            /**
             * General utilities that are useful in creating custom Event Plugins.
             */
            var EventPluginUtils = {
                isEndish: isEndish,
                isMoveish: isMoveish,
                isStartish: isStartish,

                executeDirectDispatch: executeDirectDispatch,
                executeDispatchesInOrder: executeDispatchesInOrder,
                executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
                hasDispatches: hasDispatches,

                getNode: function getNode(id) {
                    return injection.Mount.getNode(id);
                },
                getID: function getID(node) {
                    return injection.Mount.getID(node);
                },

                injection: injection
            };

            module.exports = EventPluginUtils;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 108 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactErrorUtils
         * @typechecks
         */

        'use strict';

            var caughtError = null;

            /**
             * Call a function while guarding against errors that happens within it.
             *
             * @param {?String} name of the guard to use for logging or debugging
             * @param {Function} func The function to invoke
             * @param {*} a First argument
             * @param {*} b Second argument
             */
            function invokeGuardedCallback(name, func, a, b) {
                try {
                    return func(a, b);
                } catch (x) {
                    if (caughtError === null) {
                        caughtError = x;
                    }
                    return undefined;
                }
            }

            var ReactErrorUtils = {
                invokeGuardedCallback: invokeGuardedCallback,

                /**
                 * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
                 * handler are sure to be rethrown by rethrowCaughtError.
                 */
                invokeGuardedCallbackWithCatch: invokeGuardedCallback,

                /**
                 * During execution of guarded functions we will capture the first error which
                 * we will rethrow to be handled by the top level error handler.
                 */
                rethrowCaughtError: function rethrowCaughtError() {
                    if (caughtError) {
                        var error = caughtError;
                        caughtError = null;
                        throw error;
                    }
                }
            };

            if (process.env.NODE_ENV !== 'production') {
                /**
                 * To help development we can get better devtools integration by simulating a
                 * real browser event.
                 */
                if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
                    var fakeNode = document.createElement('react');
                    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
                        var boundFunc = func.bind(null, a, b);
                        var evtType = 'react-' + name;
                        fakeNode.addEventListener(evtType, boundFunc, false);
                        var evt = document.createEvent('Event');
                        evt.initEvent(evtType, false, false);
                        fakeNode.dispatchEvent(evt);
                        fakeNode.removeEventListener(evtType, boundFunc, false);
                    };
                }
            }

            module.exports = ReactErrorUtils;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 109 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule accumulateInto
         */

        'use strict';

            var invariant = __webpack_require__(87);

            /**
             *
             * Accumulates items that must not be null or undefined into the first one. This
             * is used to conserve memory by avoiding array allocations, and thus sacrifices
             * API cleanness. Since `current` can be null before being passed in and not
             * null after this function, make sure to assign it back to `current`:
             *
             * `a = accumulateInto(a, b);`
             *
             * This API should be sparingly used. Try `accumulate` for something cleaner.
             *
             * @return {*|array<*>} An accumulation of items.
             */

            function accumulateInto(current, next) {
                !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
                if (current == null) {
                    return next;
                }

                // Both are not empty. Warning: Never call x.concat(y) when you are not
                // certain that x is an Array (x could be a string with concat method).
                var currentIsArray = Array.isArray(current);
                var nextIsArray = Array.isArray(next);

                if (currentIsArray && nextIsArray) {
                    current.push.apply(current, next);
                    return current;
                }

                if (currentIsArray) {
                    current.push(next);
                    return current;
                }

                if (nextIsArray) {
                    // A bit too dangerous to mutate `next`.
                    return [current].concat(next);
                }

                return [current, next];
            }

            module.exports = accumulateInto;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 110 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule forEachAccumulated
         */

        'use strict';

        /**
         * @param {array} arr an "accumulation" of items which is either an Array or
         * a single item. Useful when paired with the `accumulate` module. This is a
         * simple utility that allows us to reason about a collection of items, but
         * handling the case when there is exactly one item (and we do not need to
         * allocate an array).
         */

        var forEachAccumulated = function forEachAccumulated(arr, cb, scope) {
            if (Array.isArray(arr)) {
                arr.forEach(cb, scope);
            } else if (arr) {
                cb.call(scope, arr);
            }
        };

        module.exports = forEachAccumulated;

        /***/ },
    /* 111 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactEventEmitterMixin
         */

        'use strict';

        var EventPluginHub = __webpack_require__(105);

        function runEventQueueInBatch(events) {
            EventPluginHub.enqueueEvents(events);
            EventPluginHub.processEventQueue(false);
        }

        var ReactEventEmitterMixin = {

            /**
             * Streams a fired top-level event to `EventPluginHub` where plugins have the
             * opportunity to create `ReactEvent`s to be dispatched.
             *
             * @param {string} topLevelType Record from `EventConstants`.
             * @param {object} topLevelTarget The listening component root node.
             * @param {string} topLevelTargetID ID of `topLevelTarget`.
             * @param {object} nativeEvent Native environment event.
             */
            handleTopLevel: function handleTopLevel(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
                var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
                runEventQueueInBatch(events);
            }
        };

        module.exports = ReactEventEmitterMixin;

        /***/ },
    /* 112 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ViewportMetrics
         */

        'use strict';

        var ViewportMetrics = {

            currentScrollLeft: 0,

            currentScrollTop: 0,

            refreshScrollValues: function refreshScrollValues(scrollPosition) {
                ViewportMetrics.currentScrollLeft = scrollPosition.x;
                ViewportMetrics.currentScrollTop = scrollPosition.y;
            }

        };

        module.exports = ViewportMetrics;

        /***/ },
    /* 113 */
    /***/ function(module, exports) {

        /**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule Object.assign
         */

        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

        'use strict';

        function assign(target, sources) {
            if (target == null) {
                throw new TypeError('Object.assign target cannot be null or undefined');
            }

            var to = Object(target);
            var hasOwnProperty = Object.prototype.hasOwnProperty;

            for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
                var nextSource = arguments[nextIndex];
                if (nextSource == null) {
                    continue;
                }

                var from = Object(nextSource);

                // We don't currently support accessors nor proxies. Therefore this
                // copy cannot throw. If we ever supported this then we must handle
                // exceptions and side-effects. We don't support symbols so they won't
                // be transferred.

                for (var key in from) {
                    if (hasOwnProperty.call(from, key)) {
                        to[key] = from[key];
                    }
                }
            }

            return to;
        }

        module.exports = assign;

        /***/ },
    /* 114 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule isEventSupported
         */

        'use strict';

        var ExecutionEnvironment = __webpack_require__(83);

        var useHasFeature;
        if (ExecutionEnvironment.canUseDOM) {
            useHasFeature = document.implementation && document.implementation.hasFeature &&
                // always returns true in newer browsers as per the standard.
                // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
                document.implementation.hasFeature('', '') !== true;
        }

        /**
         * Checks if an event is supported in the current execution environment.
         *
         * NOTE: This will not work correctly for non-generic events such as `change`,
         * `reset`, `load`, `error`, and `select`.
         *
         * Borrows from Modernizr.
         *
         * @param {string} eventNameSuffix Event name, e.g. "click".
         * @param {?boolean} capture Check if the capture phase is supported.
         * @return {boolean} True if the event is supported.
         * @internal
         * @license Modernizr 3.0.0pre (Custom Build) | MIT
         */
        function isEventSupported(eventNameSuffix, capture) {
            if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
                return false;
            }

            var eventName = 'on' + eventNameSuffix;
            var isSupported = eventName in document;

            if (!isSupported) {
                var element = document.createElement('div');
                element.setAttribute(eventName, 'return;');
                isSupported = typeof element[eventName] === 'function';
            }

            if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
                // This is the only way to test support for the `wheel` event in IE9+.
                isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
            }

            return isSupported;
        }

        module.exports = isEventSupported;

        /***/ },
    /* 115 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMFeatureFlags
         */

        'use strict';

        var ReactDOMFeatureFlags = {
            useCreateElement: false
        };

        module.exports = ReactDOMFeatureFlags;

        /***/ },
    /* 116 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactElement
         */

        'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var ReactCurrentOwner = __webpack_require__(79);

            var assign = __webpack_require__(113);
            var canDefineProperty = __webpack_require__(117);

            // The Symbol used to tag the ReactElement type. If there is no native Symbol
            // nor polyfill, then a plain number is used for performance.
            var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

            var RESERVED_PROPS = {
                key: true,
                ref: true,
                __self: true,
                __source: true
            };

            /**
             * Base constructor for all React elements. This is only used to make this
             * work with a dynamic instanceof check. Nothing should live on this prototype.
             *
             * @param {*} type
             * @param {*} key
             * @param {string|object} ref
             * @param {*} self A *temporary* helper to detect places where `this` is
             * different from the `owner` when React.createElement is called, so that we
             * can warn. We want to get rid of owner and replace string `ref`s with arrow
             * functions, and as long as `this` and owner are the same, there will be no
             * change in behavior.
             * @param {*} source An annotation object (added by a transpiler or otherwise)
             * indicating filename, line number, and/or other information.
             * @param {*} owner
             * @param {*} props
             * @internal
             */
            var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
                var element = {
                    // This tag allow us to uniquely identify this as a React Element
                    $$typeof: REACT_ELEMENT_TYPE,

                    // Built-in properties that belong on the element
                    type: type,
                    key: key,
                    ref: ref,
                    props: props,

                    // Record the component responsible for creating this element.
                    _owner: owner
                };

                if (process.env.NODE_ENV !== 'production') {
                    // The validation flag is currently mutative. We put it on
                    // an external backing store so that we can freeze the whole object.
                    // This can be replaced with a WeakMap once they are implemented in
                    // commonly used development environments.
                    element._store = {};

                    // To make comparing ReactElements easier for testing purposes, we make
                    // the validation flag non-enumerable (where possible, which should
                    // include every environment we run tests in), so the test framework
                    // ignores it.
                    if (canDefineProperty) {
                        Object.defineProperty(element._store, 'validated', {
                            configurable: false,
                            enumerable: false,
                            writable: true,
                            value: false
                        });
                        // self and source are DEV only properties.
                        Object.defineProperty(element, '_self', {
                            configurable: false,
                            enumerable: false,
                            writable: false,
                            value: self
                        });
                        // Two elements created in two different places should be considered
                        // equal for testing purposes and therefore we hide it from enumeration.
                        Object.defineProperty(element, '_source', {
                            configurable: false,
                            enumerable: false,
                            writable: false,
                            value: source
                        });
                    } else {
                        element._store.validated = false;
                        element._self = self;
                        element._source = source;
                    }
                    Object.freeze(element.props);
                    Object.freeze(element);
                }

                return element;
            };

            ReactElement.createElement = function (type, config, children) {
                var propName;

                // Reserved names are extracted
                var props = {};

                var key = null;
                var ref = null;
                var self = null;
                var source = null;

                if (config != null) {
                    ref = config.ref === undefined ? null : config.ref;
                    key = config.key === undefined ? null : '' + config.key;
                    self = config.__self === undefined ? null : config.__self;
                    source = config.__source === undefined ? null : config.__source;
                    // Remaining properties are added to a new props object
                    for (propName in config) {
                        if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                            props[propName] = config[propName];
                        }
                    }
                }

                // Children can be more than one argument, and those are transferred onto
                // the newly allocated props object.
                var childrenLength = arguments.length - 2;
                if (childrenLength === 1) {
                    props.children = children;
                } else if (childrenLength > 1) {
                    var childArray = Array(childrenLength);
                    for (var i = 0; i < childrenLength; i++) {
                        childArray[i] = arguments[i + 2];
                    }
                    props.children = childArray;
                }

                // Resolve default props
                if (type && type.defaultProps) {
                    var defaultProps = type.defaultProps;
                    for (propName in defaultProps) {
                        if (typeof props[propName] === 'undefined') {
                            props[propName] = defaultProps[propName];
                        }
                    }
                }

                return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
            };

            ReactElement.createFactory = function (type) {
                var factory = ReactElement.createElement.bind(null, type);
                // Expose the type on the factory and the prototype so that it can be
                // easily accessed on elements. E.g. `<Foo />.type === Foo`.
                // This should not be named `constructor` since this may not be the function
                // that created the element, and it may not even be a constructor.
                // Legacy hook TODO: Warn if this is accessed
                factory.type = type;
                return factory;
            };

            ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
                var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

                return newElement;
            };

            ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
                var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);

                if (process.env.NODE_ENV !== 'production') {
                    // If the key on the original is valid, then the clone is valid
                    newElement._store.validated = oldElement._store.validated;
                }

                return newElement;
            };

            ReactElement.cloneElement = function (element, config, children) {
                var propName;

                // Original props are copied
                var props = assign({}, element.props);

                // Reserved names are extracted
                var key = element.key;
                var ref = element.ref;
                // Self is preserved since the owner is preserved.
                var self = element._self;
                // Source is preserved since cloneElement is unlikely to be targeted by a
                // transpiler, and the original source is probably a better indicator of the
                // true owner.
                var source = element._source;

                // Owner will be preserved, unless ref is overridden
                var owner = element._owner;

                if (config != null) {
                    if (config.ref !== undefined) {
                        // Silently steal the ref from the parent.
                        ref = config.ref;
                        owner = ReactCurrentOwner.current;
                    }
                    if (config.key !== undefined) {
                        key = '' + config.key;
                    }
                    // Remaining properties override existing props
                    for (propName in config) {
                        if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                            props[propName] = config[propName];
                        }
                    }
                }

                // Children can be more than one argument, and those are transferred onto
                // the newly allocated props object.
                var childrenLength = arguments.length - 2;
                if (childrenLength === 1) {
                    props.children = children;
                } else if (childrenLength > 1) {
                    var childArray = Array(childrenLength);
                    for (var i = 0; i < childrenLength; i++) {
                        childArray[i] = arguments[i + 2];
                    }
                    props.children = childArray;
                }

                return ReactElement(element.type, key, ref, self, source, owner, props);
            };

            /**
             * @param {?object} object
             * @return {boolean} True if `object` is a valid component.
             * @final
             */
            ReactElement.isValidElement = function (object) {
                return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            };

            module.exports = ReactElement;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 117 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule canDefineProperty
         */

        'use strict';

            var canDefineProperty = false;
            if (process.env.NODE_ENV !== 'production') {
                try {
                    Object.defineProperty({}, 'x', { get: function get() {} });
                    canDefineProperty = true;
                } catch (x) {
                    // IE will fail on defineProperty
                }
            }

            module.exports = canDefineProperty;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 118 */
    /***/ function(module, exports) {

        /**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactEmptyComponentRegistry
         */

        'use strict';

        // This registry keeps track of the React IDs of the components that rendered to
        // `null` (in reality a placeholder such as `noscript`)

        var nullComponentIDsRegistry = {};

        /**
         * @param {string} id Component's `_rootNodeID`.
         * @return {boolean} True if the component is rendered to null.
         */
        function isNullComponentID(id) {
            return !!nullComponentIDsRegistry[id];
        }

        /**
         * Mark the component as having rendered to null.
         * @param {string} id Component's `_rootNodeID`.
         */
        function registerNullComponentID(id) {
            nullComponentIDsRegistry[id] = true;
        }

        /**
         * Unmark the component as having rendered to null: it renders to something now.
         * @param {string} id Component's `_rootNodeID`.
         */
        function deregisterNullComponentID(id) {
            delete nullComponentIDsRegistry[id];
        }

        var ReactEmptyComponentRegistry = {
            isNullComponentID: isNullComponentID,
            registerNullComponentID: registerNullComponentID,
            deregisterNullComponentID: deregisterNullComponentID
        };

        module.exports = ReactEmptyComponentRegistry;

        /***/ },
    /* 119 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactInstanceHandles
         * @typechecks static-only
         */

        'use strict';

            var ReactRootIndex = __webpack_require__(120);

            var invariant = __webpack_require__(87);

            var SEPARATOR = '.';
            var SEPARATOR_LENGTH = SEPARATOR.length;

            /**
             * Maximum depth of traversals before we consider the possibility of a bad ID.
             */
            var MAX_TREE_DEPTH = 10000;

            /**
             * Creates a DOM ID prefix to use when mounting React components.
             *
             * @param {number} index A unique integer
             * @return {string} React root ID.
             * @internal
             */
            function getReactRootIDString(index) {
                return SEPARATOR + index.toString(36);
            }

            /**
             * Checks if a character in the supplied ID is a separator or the end.
             *
             * @param {string} id A React DOM ID.
             * @param {number} index Index of the character to check.
             * @return {boolean} True if the character is a separator or end of the ID.
             * @private
             */
            function isBoundary(id, index) {
                return id.charAt(index) === SEPARATOR || index === id.length;
            }

            /**
             * Checks if the supplied string is a valid React DOM ID.
             *
             * @param {string} id A React DOM ID, maybe.
             * @return {boolean} True if the string is a valid React DOM ID.
             * @private
             */
            function isValidID(id) {
                return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
            }

            /**
             * Checks if the first ID is an ancestor of or equal to the second ID.
             *
             * @param {string} ancestorID
             * @param {string} descendantID
             * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
             * @internal
             */
            function isAncestorIDOf(ancestorID, descendantID) {
                return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
            }

            /**
             * Gets the parent ID of the supplied React DOM ID, `id`.
             *
             * @param {string} id ID of a component.
             * @return {string} ID of the parent, or an empty string.
             * @private
             */
            function getParentID(id) {
                return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
            }

            /**
             * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
             * supplied `destinationID`. If they are equal, the ID is returned.
             *
             * @param {string} ancestorID ID of an ancestor node of `destinationID`.
             * @param {string} destinationID ID of the destination node.
             * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
             * @private
             */
            function getNextDescendantID(ancestorID, destinationID) {
                !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
                !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
                if (ancestorID === destinationID) {
                    return ancestorID;
                }
                // Skip over the ancestor and the immediate separator. Traverse until we hit
                // another separator or we reach the end of `destinationID`.
                var start = ancestorID.length + SEPARATOR_LENGTH;
                var i;
                for (i = start; i < destinationID.length; i++) {
                    if (isBoundary(destinationID, i)) {
                        break;
                    }
                }
                return destinationID.substr(0, i);
            }

            /**
             * Gets the nearest common ancestor ID of two IDs.
             *
             * Using this ID scheme, the nearest common ancestor ID is the longest common
             * prefix of the two IDs that immediately preceded a "marker" in both strings.
             *
             * @param {string} oneID
             * @param {string} twoID
             * @return {string} Nearest common ancestor ID, or the empty string if none.
             * @private
             */
            function getFirstCommonAncestorID(oneID, twoID) {
                var minLength = Math.min(oneID.length, twoID.length);
                if (minLength === 0) {
                    return '';
                }
                var lastCommonMarkerIndex = 0;
                // Use `<=` to traverse until the "EOL" of the shorter string.
                for (var i = 0; i <= minLength; i++) {
                    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
                        lastCommonMarkerIndex = i;
                    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
                        break;
                    }
                }
                var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
                !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
                return longestCommonID;
            }

            /**
             * Traverses the parent path between two IDs (either up or down). The IDs must
             * not be the same, and there must exist a parent path between them. If the
             * callback returns `false`, traversal is stopped.
             *
             * @param {?string} start ID at which to start traversal.
             * @param {?string} stop ID at which to end traversal.
             * @param {function} cb Callback to invoke each ID with.
             * @param {*} arg Argument to invoke the callback with.
             * @param {?boolean} skipFirst Whether or not to skip the first node.
             * @param {?boolean} skipLast Whether or not to skip the last node.
             * @private
             */
            function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
                start = start || '';
                stop = stop || '';
                !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
                var traverseUp = isAncestorIDOf(stop, start);
                !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
                // Traverse from `start` to `stop` one depth at a time.
                var depth = 0;
                var traverse = traverseUp ? getParentID : getNextDescendantID;
                for (var id = start;; /* until break */id = traverse(id, stop)) {
                    var ret;
                    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
                        ret = cb(id, traverseUp, arg);
                    }
                    if (ret === false || id === stop) {
                        // Only break //after// visiting `stop`.
                        break;
                    }
                    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
                }
            }

            /**
             * Manages the IDs assigned to DOM representations of React components. This
             * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
             * order to simulate events).
             *
             * @internal
             */
            var ReactInstanceHandles = {

                /**
                 * Constructs a React root ID
                 * @return {string} A React root ID.
                 */
                createReactRootID: function createReactRootID() {
                    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
                },

                /**
                 * Constructs a React ID by joining a root ID with a name.
                 *
                 * @param {string} rootID Root ID of a parent component.
                 * @param {string} name A component's name (as flattened children).
                 * @return {string} A React ID.
                 * @internal
                 */
                createReactID: function createReactID(rootID, name) {
                    return rootID + name;
                },

                /**
                 * Gets the DOM ID of the React component that is the root of the tree that
                 * contains the React component with the supplied DOM ID.
                 *
                 * @param {string} id DOM ID of a React component.
                 * @return {?string} DOM ID of the React component that is the root.
                 * @internal
                 */
                getReactRootIDFromNodeID: function getReactRootIDFromNodeID(id) {
                    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
                        var index = id.indexOf(SEPARATOR, 1);
                        return index > -1 ? id.substr(0, index) : id;
                    }
                    return null;
                },

                /**
                 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
                 * should would receive a `mouseEnter` or `mouseLeave` event.
                 *
                 * NOTE: Does not invoke the callback on the nearest common ancestor because
                 * nothing "entered" or "left" that element.
                 *
                 * @param {string} leaveID ID being left.
                 * @param {string} enterID ID being entered.
                 * @param {function} cb Callback to invoke on each entered/left ID.
                 * @param {*} upArg Argument to invoke the callback with on left IDs.
                 * @param {*} downArg Argument to invoke the callback with on entered IDs.
                 * @internal
                 */
                traverseEnterLeave: function traverseEnterLeave(leaveID, enterID, cb, upArg, downArg) {
                    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
                    if (ancestorID !== leaveID) {
                        traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
                    }
                    if (ancestorID !== enterID) {
                        traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
                    }
                },

                /**
                 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
                 *
                 * NOTE: This traversal happens on IDs without touching the DOM.
                 *
                 * @param {string} targetID ID of the target node.
                 * @param {function} cb Callback to invoke.
                 * @param {*} arg Argument to invoke the callback with.
                 * @internal
                 */
                traverseTwoPhase: function traverseTwoPhase(targetID, cb, arg) {
                    if (targetID) {
                        traverseParentPath('', targetID, cb, arg, true, false);
                        traverseParentPath(targetID, '', cb, arg, false, true);
                    }
                },

                /**
                 * Same as `traverseTwoPhase` but skips the `targetID`.
                 */
                traverseTwoPhaseSkipTarget: function traverseTwoPhaseSkipTarget(targetID, cb, arg) {
                    if (targetID) {
                        traverseParentPath('', targetID, cb, arg, true, true);
                        traverseParentPath(targetID, '', cb, arg, true, true);
                    }
                },

                /**
                 * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
                 * example, passing `.0.$row-0.1` would result in `cb` getting called
                 * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
                 *
                 * NOTE: This traversal happens on IDs without touching the DOM.
                 *
                 * @param {string} targetID ID of the target node.
                 * @param {function} cb Callback to invoke.
                 * @param {*} arg Argument to invoke the callback with.
                 * @internal
                 */
                traverseAncestors: function traverseAncestors(targetID, cb, arg) {
                    traverseParentPath('', targetID, cb, arg, true, false);
                },

                getFirstCommonAncestorID: getFirstCommonAncestorID,

                /**
                 * Exposed for unit testing.
                 * @private
                 */
                _getNextDescendantID: getNextDescendantID,

                isAncestorIDOf: isAncestorIDOf,

                SEPARATOR: SEPARATOR

            };

            module.exports = ReactInstanceHandles;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 120 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactRootIndex
         * @typechecks
         */

        'use strict';

        var ReactRootIndexInjection = {
            /**
             * @param {function} _createReactRootIndex
             */
            injectCreateReactRootIndex: function injectCreateReactRootIndex(_createReactRootIndex) {
                ReactRootIndex.createReactRootIndex = _createReactRootIndex;
            }
        };

        var ReactRootIndex = {
            createReactRootIndex: null,
            injection: ReactRootIndexInjection
        };

        module.exports = ReactRootIndex;

        /***/ },
    /* 121 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactInstanceMap
         */

        'use strict';

        /**
         * `ReactInstanceMap` maintains a mapping from a public facing stateful
         * instance (key) and the internal representation (value). This allows public
         * methods to accept the user facing instance as an argument and map them back
         * to internal methods.
         */

            // TODO: Replace this with ES6: var ReactInstanceMap = new Map();

        var ReactInstanceMap = {

                /**
                 * This API should be called `delete` but we'd have to make sure to always
                 * transform these to strings for IE support. When this transform is fully
                 * supported we can rename it.
                 */
                remove: function remove(key) {
                    key._reactInternalInstance = undefined;
                },

                get: function get(key) {
                    return key._reactInternalInstance;
                },

                has: function has(key) {
                    return key._reactInternalInstance !== undefined;
                },

                set: function set(key, value) {
                    key._reactInternalInstance = value;
                }

            };

        module.exports = ReactInstanceMap;

        /***/ },
    /* 122 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactMarkupChecksum
         */

        'use strict';

        var adler32 = __webpack_require__(123);

        var TAG_END = /\/?>/;

        var ReactMarkupChecksum = {
            CHECKSUM_ATTR_NAME: 'data-react-checksum',

            /**
             * @param {string} markup Markup string
             * @return {string} Markup string with checksum attribute attached
             */
            addChecksumToMarkup: function addChecksumToMarkup(markup) {
                var checksum = adler32(markup);

                // Add checksum (handle both parent tags and self-closing tags)
                return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
            },

            /**
             * @param {string} markup to use
             * @param {DOMElement} element root React element
             * @returns {boolean} whether or not the markup is the same
             */
            canReuseMarkup: function canReuseMarkup(markup, element) {
                var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
                existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
                var markupChecksum = adler32(markup);
                return markupChecksum === existingChecksum;
            }
        };

        module.exports = ReactMarkupChecksum;

        /***/ },
    /* 123 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule adler32
         */

        'use strict';

        var MOD = 65521;

        // adler32 is not cryptographically strong, and is only used to sanity check that
        // markup generated on the server matches the markup generated on the client.
        // This implementation (a modified version of the SheetJS version) has been optimized
        // for our use case, at the expense of conforming to the adler32 specification
        // for non-ascii inputs.
        function adler32(data) {
            var a = 1;
            var b = 0;
            var i = 0;
            var l = data.length;
            var m = l & ~0x3;
            while (i < m) {
                for (; i < Math.min(i + 4096, m); i += 4) {
                    b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
                }
                a %= MOD;
                b %= MOD;
            }
            for (; i < l; i++) {
                b += a += data.charCodeAt(i);
            }
            a %= MOD;
            b %= MOD;
            return a | b << 16;
        }

        module.exports = adler32;

        /***/ },
    /* 124 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactReconciler
         */

        'use strict';

        var ReactRef = __webpack_require__(125);

        /**
         * Helper to call ReactRef.attachRefs with this composite component, split out
         * to avoid allocations in the transaction mount-ready queue.
         */
        function attachRefs() {
            ReactRef.attachRefs(this, this._currentElement);
        }

        var ReactReconciler = {

            /**
             * Initializes the component, renders markup, and registers event listeners.
             *
             * @param {ReactComponent} internalInstance
             * @param {string} rootID DOM ID of the root node.
             * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
             * @return {?string} Rendered markup to be inserted into the DOM.
             * @final
             * @internal
             */
            mountComponent: function mountComponent(internalInstance, rootID, transaction, context) {
                var markup = internalInstance.mountComponent(rootID, transaction, context);
                if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
                    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
                }
                return markup;
            },

            /**
             * Releases any resources allocated by `mountComponent`.
             *
             * @final
             * @internal
             */
            unmountComponent: function unmountComponent(internalInstance) {
                ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
                internalInstance.unmountComponent();
            },

            /**
             * Update a component using a new element.
             *
             * @param {ReactComponent} internalInstance
             * @param {ReactElement} nextElement
             * @param {ReactReconcileTransaction} transaction
             * @param {object} context
             * @internal
             */
            receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
                var prevElement = internalInstance._currentElement;

                if (nextElement === prevElement && context === internalInstance._context) {
                    // Since elements are immutable after the owner is rendered,
                    // we can do a cheap identity compare here to determine if this is a
                    // superfluous reconcile. It's possible for state to be mutable but such
                    // change should trigger an update of the owner which would recreate
                    // the element. We explicitly check for the existence of an owner since
                    // it's possible for an element created outside a composite to be
                    // deeply mutated and reused.

                    // TODO: Bailing out early is just a perf optimization right?
                    // TODO: Removing the return statement should affect correctness?
                    return;
                }

                var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

                if (refsChanged) {
                    ReactRef.detachRefs(internalInstance, prevElement);
                }

                internalInstance.receiveComponent(nextElement, transaction, context);

                if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
                    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
                }
            },

            /**
             * Flush any dirty changes in a component.
             *
             * @param {ReactComponent} internalInstance
             * @param {ReactReconcileTransaction} transaction
             * @internal
             */
            performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction) {
                internalInstance.performUpdateIfNecessary(transaction);
            }

        };

        module.exports = ReactReconciler;

        /***/ },
    /* 125 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactRef
         */

        'use strict';

        var ReactOwner = __webpack_require__(126);

        var ReactRef = {};

        function attachRef(ref, component, owner) {
            if (typeof ref === 'function') {
                ref(component.getPublicInstance());
            } else {
                // Legacy ref
                ReactOwner.addComponentAsRefTo(component, ref, owner);
            }
        }

        function detachRef(ref, component, owner) {
            if (typeof ref === 'function') {
                ref(null);
            } else {
                // Legacy ref
                ReactOwner.removeComponentAsRefFrom(component, ref, owner);
            }
        }

        ReactRef.attachRefs = function (instance, element) {
            if (element === null || element === false) {
                return;
            }
            var ref = element.ref;
            if (ref != null) {
                attachRef(ref, instance, element._owner);
            }
        };

        ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
            // If either the owner or a `ref` has changed, make sure the newest owner
            // has stored a reference to `this`, and the previous owner (if different)
            // has forgotten the reference to `this`. We use the element instead
            // of the public this.props because the post processing cannot determine
            // a ref. The ref conceptually lives on the element.

            // TODO: Should this even be possible? The owner cannot change because
            // it's forbidden by shouldUpdateReactComponent. The ref can change
            // if you swap the keys of but not the refs. Reconsider where this check
            // is made. It probably belongs where the key checking and
            // instantiateReactComponent is done.

            var prevEmpty = prevElement === null || prevElement === false;
            var nextEmpty = nextElement === null || nextElement === false;

            return(
                // This has a few false positives w/r/t empty components.
                prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
            );
        };

        ReactRef.detachRefs = function (instance, element) {
            if (element === null || element === false) {
                return;
            }
            var ref = element.ref;
            if (ref != null) {
                detachRef(ref, instance, element._owner);
            }
        };

        module.exports = ReactRef;

        /***/ },
    /* 126 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactOwner
         */

        'use strict';

            var invariant = __webpack_require__(87);

            /**
             * ReactOwners are capable of storing references to owned components.
             *
             * All components are capable of //being// referenced by owner components, but
             * only ReactOwner components are capable of //referencing// owned components.
             * The named reference is known as a "ref".
             *
             * Refs are available when mounted and updated during reconciliation.
             *
             *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
             *
             * Refs should rarely be used. When refs are used, they should only be done to
             * control data that is not handled by React's data flow.
             *
             * @class ReactOwner
             */
            var ReactOwner = {

                /**
                 * @param {?object} object
                 * @return {boolean} True if `object` is a valid owner.
                 * @final
                 */
                isValidOwner: function isValidOwner(object) {
                    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
                },

                /**
                 * Adds a component by ref to an owner component.
                 *
                 * @param {ReactComponent} component Component to reference.
                 * @param {string} ref Name by which to refer to the component.
                 * @param {ReactOwner} owner Component on which to record the ref.
                 * @final
                 * @internal
                 */
                addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
                    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
                    owner.attachRef(ref, component);
                },

                /**
                 * Removes a component by ref from an owner component.
                 *
                 * @param {ReactComponent} component Component to dereference.
                 * @param {string} ref Name of the ref to remove.
                 * @param {ReactOwner} owner Component on which the ref is recorded.
                 * @final
                 * @internal
                 */
                removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
                    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
                    // Check that `component` is still the current ref because we do not want to
                    // detach the ref if another component stole it.
                    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
                        owner.detachRef(ref);
                    }
                }

            };

            module.exports = ReactOwner;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 127 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactUpdateQueue
         */

        'use strict';

            var ReactCurrentOwner = __webpack_require__(79);
            var ReactElement = __webpack_require__(116);
            var ReactInstanceMap = __webpack_require__(121);
            var ReactUpdates = __webpack_require__(128);

            var assign = __webpack_require__(113);
            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            function enqueueUpdate(internalInstance) {
                ReactUpdates.enqueueUpdate(internalInstance);
            }

            function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
                var internalInstance = ReactInstanceMap.get(publicInstance);
                if (!internalInstance) {
                    if (process.env.NODE_ENV !== 'production') {
                        // Only warn when we have a callerName. Otherwise we should be silent.
                        // We're probably calling from enqueueCallback. We don't want to warn
                        // there because we already warned for the corresponding lifecycle method.
                        process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
                    }
                    return null;
                }

                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
                }

                return internalInstance;
            }

            /**
             * ReactUpdateQueue allows for state updates to be scheduled into a later
             * reconciliation step.
             */
            var ReactUpdateQueue = {

                /**
                 * Checks whether or not this composite component is mounted.
                 * @param {ReactClass} publicInstance The instance we want to test.
                 * @return {boolean} True if mounted, false otherwise.
                 * @protected
                 * @final
                 */
                isMounted: function isMounted(publicInstance) {
                    if (process.env.NODE_ENV !== 'production') {
                        var owner = ReactCurrentOwner.current;
                        if (owner !== null) {
                            process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
                            owner._warnedAboutRefsInRender = true;
                        }
                    }
                    var internalInstance = ReactInstanceMap.get(publicInstance);
                    if (internalInstance) {
                        // During componentWillMount and render this will still be null but after
                        // that will always render to something. At least for now. So we can use
                        // this hack.
                        return !!internalInstance._renderedComponent;
                    } else {
                        return false;
                    }
                },

                /**
                 * Enqueue a callback that will be executed after all the pending updates
                 * have processed.
                 *
                 * @param {ReactClass} publicInstance The instance to use as `this` context.
                 * @param {?function} callback Called after state is updated.
                 * @internal
                 */
                enqueueCallback: function enqueueCallback(publicInstance, callback) {
                    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

                    // Previously we would throw an error if we didn't have an internal
                    // instance. Since we want to make it a no-op instead, we mirror the same
                    // behavior we have in other enqueue* methods.
                    // We also need to ignore callbacks in componentWillMount. See
                    // enqueueUpdates.
                    if (!internalInstance) {
                        return null;
                    }

                    if (internalInstance._pendingCallbacks) {
                        internalInstance._pendingCallbacks.push(callback);
                    } else {
                        internalInstance._pendingCallbacks = [callback];
                    }
                    // TODO: The callback here is ignored when setState is called from
                    // componentWillMount. Either fix it or disallow doing so completely in
                    // favor of getInitialState. Alternatively, we can disallow
                    // componentWillMount during server-side rendering.
                    enqueueUpdate(internalInstance);
                },

                enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
                    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
                    if (internalInstance._pendingCallbacks) {
                        internalInstance._pendingCallbacks.push(callback);
                    } else {
                        internalInstance._pendingCallbacks = [callback];
                    }
                    enqueueUpdate(internalInstance);
                },

                /**
                 * Forces an update. This should only be invoked when it is known with
                 * certainty that we are **not** in a DOM transaction.
                 *
                 * You may want to call this when you know that some deeper aspect of the
                 * component's state has changed but `setState` was not called.
                 *
                 * This will not invoke `shouldComponentUpdate`, but it will invoke
                 * `componentWillUpdate` and `componentDidUpdate`.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @internal
                 */
                enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

                    if (!internalInstance) {
                        return;
                    }

                    internalInstance._pendingForceUpdate = true;

                    enqueueUpdate(internalInstance);
                },

                /**
                 * Replaces all of the state. Always use this or `setState` to mutate state.
                 * You should treat `this.state` as immutable.
                 *
                 * There is no guarantee that `this.state` will be immediately updated, so
                 * accessing `this.state` after calling this method may return the old value.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} completeState Next state.
                 * @internal
                 */
                enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

                    if (!internalInstance) {
                        return;
                    }

                    internalInstance._pendingStateQueue = [completeState];
                    internalInstance._pendingReplaceState = true;

                    enqueueUpdate(internalInstance);
                },

                /**
                 * Sets a subset of the state. This only exists because _pendingState is
                 * internal. This provides a merging strategy that is not available to deep
                 * properties which is confusing. TODO: Expose pendingState or don't use it
                 * during the merge.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} partialState Next partial state to be merged with state.
                 * @internal
                 */
                enqueueSetState: function enqueueSetState(publicInstance, partialState) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

                    if (!internalInstance) {
                        return;
                    }

                    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
                    queue.push(partialState);

                    enqueueUpdate(internalInstance);
                },

                /**
                 * Sets a subset of the props.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} partialProps Subset of the next props.
                 * @internal
                 */
                enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
                    if (!internalInstance) {
                        return;
                    }
                    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
                },

                enqueueSetPropsInternal: function enqueueSetPropsInternal(internalInstance, partialProps) {
                    var topLevelWrapper = internalInstance._topLevelWrapper;
                    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

                    // Merge with the pending element if it exists, otherwise with existing
                    // element props.
                    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
                    var element = wrapElement.props;
                    var props = assign({}, element.props, partialProps);
                    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

                    enqueueUpdate(topLevelWrapper);
                },

                /**
                 * Replaces all of the props.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} props New props.
                 * @internal
                 */
                enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
                    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
                    if (!internalInstance) {
                        return;
                    }
                    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
                },

                enqueueReplacePropsInternal: function enqueueReplacePropsInternal(internalInstance, props) {
                    var topLevelWrapper = internalInstance._topLevelWrapper;
                    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

                    // Merge with the pending element if it exists, otherwise with existing
                    // element props.
                    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
                    var element = wrapElement.props;
                    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

                    enqueueUpdate(topLevelWrapper);
                },

                enqueueElementInternal: function enqueueElementInternal(internalInstance, newElement) {
                    internalInstance._pendingElement = newElement;
                    enqueueUpdate(internalInstance);
                }

            };

            module.exports = ReactUpdateQueue;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 128 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactUpdates
         */

        'use strict';

            var CallbackQueue = __webpack_require__(129);
            var PooledClass = __webpack_require__(130);
            var ReactPerf = __webpack_require__(92);
            var ReactReconciler = __webpack_require__(124);
            var Transaction = __webpack_require__(131);

            var assign = __webpack_require__(113);
            var invariant = __webpack_require__(87);

            var dirtyComponents = [];
            var asapCallbackQueue = CallbackQueue.getPooled();
            var asapEnqueued = false;

            var batchingStrategy = null;

            function ensureInjected() {
                !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
            }

            var NESTED_UPDATES = {
                initialize: function initialize() {
                    this.dirtyComponentsLength = dirtyComponents.length;
                },
                close: function close() {
                    if (this.dirtyComponentsLength !== dirtyComponents.length) {
                        // Additional updates were enqueued by componentDidUpdate handlers or
                        // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
                        // these new updates so that if A's componentDidUpdate calls setState on
                        // B, B will update before the callback A's updater provided when calling
                        // setState.
                        dirtyComponents.splice(0, this.dirtyComponentsLength);
                        flushBatchedUpdates();
                    } else {
                        dirtyComponents.length = 0;
                    }
                }
            };

            var UPDATE_QUEUEING = {
                initialize: function initialize() {
                    this.callbackQueue.reset();
                },
                close: function close() {
                    this.callbackQueue.notifyAll();
                }
            };

            var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

            function ReactUpdatesFlushTransaction() {
                this.reinitializeTransaction();
                this.dirtyComponentsLength = null;
                this.callbackQueue = CallbackQueue.getPooled();
                this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
            }

            assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
                getTransactionWrappers: function getTransactionWrappers() {
                    return TRANSACTION_WRAPPERS;
                },

                destructor: function destructor() {
                    this.dirtyComponentsLength = null;
                    CallbackQueue.release(this.callbackQueue);
                    this.callbackQueue = null;
                    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
                    this.reconcileTransaction = null;
                },

                perform: function perform(method, scope, a) {
                    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
                    // with this transaction's wrappers around it.
                    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
                }
            });

            PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

            function batchedUpdates(callback, a, b, c, d, e) {
                ensureInjected();
                batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
            }

            /**
             * Array comparator for ReactComponents by mount ordering.
             *
             * @param {ReactComponent} c1 first component you're comparing
             * @param {ReactComponent} c2 second component you're comparing
             * @return {number} Return value usable by Array.prototype.sort().
             */
            function mountOrderComparator(c1, c2) {
                return c1._mountOrder - c2._mountOrder;
            }

            function runBatchedUpdates(transaction) {
                var len = transaction.dirtyComponentsLength;
                !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;

                // Since reconciling a component higher in the owner hierarchy usually (not
                // always -- see shouldComponentUpdate()) will reconcile children, reconcile
                // them before their children by sorting the array.
                dirtyComponents.sort(mountOrderComparator);

                for (var i = 0; i < len; i++) {
                    // If a component is unmounted before pending changes apply, it will still
                    // be here, but we assume that it has cleared its _pendingCallbacks and
                    // that performUpdateIfNecessary is a noop.
                    var component = dirtyComponents[i];

                    // If performUpdateIfNecessary happens to enqueue any new updates, we
                    // shouldn't execute the callbacks until the next render happens, so
                    // stash the callbacks first
                    var callbacks = component._pendingCallbacks;
                    component._pendingCallbacks = null;

                    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

                    if (callbacks) {
                        for (var j = 0; j < callbacks.length; j++) {
                            transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
                        }
                    }
                }
            }

            var flushBatchedUpdates = function flushBatchedUpdates() {
                // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
                // array and perform any updates enqueued by mount-ready handlers (i.e.,
                // componentDidUpdate) but we need to check here too in order to catch
                // updates enqueued by setState callbacks and asap calls.
                while (dirtyComponents.length || asapEnqueued) {
                    if (dirtyComponents.length) {
                        var transaction = ReactUpdatesFlushTransaction.getPooled();
                        transaction.perform(runBatchedUpdates, null, transaction);
                        ReactUpdatesFlushTransaction.release(transaction);
                    }

                    if (asapEnqueued) {
                        asapEnqueued = false;
                        var queue = asapCallbackQueue;
                        asapCallbackQueue = CallbackQueue.getPooled();
                        queue.notifyAll();
                        CallbackQueue.release(queue);
                    }
                }
            };
            flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);

            /**
             * Mark a component as needing a rerender, adding an optional callback to a
             * list of functions which will be executed once the rerender occurs.
             */
            function enqueueUpdate(component) {
                ensureInjected();

                // Various parts of our code (such as ReactCompositeComponent's
                // _renderValidatedComponent) assume that calls to render aren't nested;
                // verify that that's the case. (This is called by each top-level update
                // function, like setProps, setState, forceUpdate, etc.; creation and
                // destruction of top-level components is guarded in ReactMount.)

                if (!batchingStrategy.isBatchingUpdates) {
                    batchingStrategy.batchedUpdates(enqueueUpdate, component);
                    return;
                }

                dirtyComponents.push(component);
            }

            /**
             * Enqueue a callback to be run at the end of the current batching cycle. Throws
             * if no updates are currently being performed.
             */
            function asap(callback, context) {
                !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
                asapCallbackQueue.enqueue(callback, context);
                asapEnqueued = true;
            }

            var ReactUpdatesInjection = {
                injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
                    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
                    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
                },

                injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
                    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
                    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
                    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
                    batchingStrategy = _batchingStrategy;
                }
            };

            var ReactUpdates = {
                /**
                 * React references `ReactReconcileTransaction` using this property in order
                 * to allow dependency injection.
                 *
                 * @internal
                 */
                ReactReconcileTransaction: null,

                batchedUpdates: batchedUpdates,
                enqueueUpdate: enqueueUpdate,
                flushBatchedUpdates: flushBatchedUpdates,
                injection: ReactUpdatesInjection,
                asap: asap
            };

            module.exports = ReactUpdates;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 129 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule CallbackQueue
         */

        'use strict';

            var PooledClass = __webpack_require__(130);

            var assign = __webpack_require__(113);
            var invariant = __webpack_require__(87);

            /**
             * A specialized pseudo-event module to help keep track of components waiting to
             * be notified when their DOM representations are available for use.
             *
             * This implements `PooledClass`, so you should never need to instantiate this.
             * Instead, use `CallbackQueue.getPooled()`.
             *
             * @class ReactMountReady
             * @implements PooledClass
             * @internal
             */
            function CallbackQueue() {
                this._callbacks = null;
                this._contexts = null;
            }

            assign(CallbackQueue.prototype, {

                /**
                 * Enqueues a callback to be invoked when `notifyAll` is invoked.
                 *
                 * @param {function} callback Invoked when `notifyAll` is invoked.
                 * @param {?object} context Context to call `callback` with.
                 * @internal
                 */
                enqueue: function enqueue(callback, context) {
                    this._callbacks = this._callbacks || [];
                    this._contexts = this._contexts || [];
                    this._callbacks.push(callback);
                    this._contexts.push(context);
                },

                /**
                 * Invokes all enqueued callbacks and clears the queue. This is invoked after
                 * the DOM representation of a component has been created or updated.
                 *
                 * @internal
                 */
                notifyAll: function notifyAll() {
                    var callbacks = this._callbacks;
                    var contexts = this._contexts;
                    if (callbacks) {
                        !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
                        this._callbacks = null;
                        this._contexts = null;
                        for (var i = 0; i < callbacks.length; i++) {
                            callbacks[i].call(contexts[i]);
                        }
                        callbacks.length = 0;
                        contexts.length = 0;
                    }
                },

                /**
                 * Resets the internal queue.
                 *
                 * @internal
                 */
                reset: function reset() {
                    this._callbacks = null;
                    this._contexts = null;
                },

                /**
                 * `PooledClass` looks for this.
                 */
                destructor: function destructor() {
                    this.reset();
                }

            });

            PooledClass.addPoolingTo(CallbackQueue);

            module.exports = CallbackQueue;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 130 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule PooledClass
         */

        'use strict';

            var invariant = __webpack_require__(87);

            /**
             * Static poolers. Several custom versions for each potential number of
             * arguments. A completely generic pooler is easy to implement, but would
             * require accessing the `arguments` object. In each of these, `this` refers to
             * the Class itself, not an instance. If any others are needed, simply add them
             * here, or in their own files.
             */
            var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
                var Klass = this;
                if (Klass.instancePool.length) {
                    var instance = Klass.instancePool.pop();
                    Klass.call(instance, copyFieldsFrom);
                    return instance;
                } else {
                    return new Klass(copyFieldsFrom);
                }
            };

            var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
                var Klass = this;
                if (Klass.instancePool.length) {
                    var instance = Klass.instancePool.pop();
                    Klass.call(instance, a1, a2);
                    return instance;
                } else {
                    return new Klass(a1, a2);
                }
            };

            var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
                var Klass = this;
                if (Klass.instancePool.length) {
                    var instance = Klass.instancePool.pop();
                    Klass.call(instance, a1, a2, a3);
                    return instance;
                } else {
                    return new Klass(a1, a2, a3);
                }
            };

            var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
                var Klass = this;
                if (Klass.instancePool.length) {
                    var instance = Klass.instancePool.pop();
                    Klass.call(instance, a1, a2, a3, a4);
                    return instance;
                } else {
                    return new Klass(a1, a2, a3, a4);
                }
            };

            var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
                var Klass = this;
                if (Klass.instancePool.length) {
                    var instance = Klass.instancePool.pop();
                    Klass.call(instance, a1, a2, a3, a4, a5);
                    return instance;
                } else {
                    return new Klass(a1, a2, a3, a4, a5);
                }
            };

            var standardReleaser = function standardReleaser(instance) {
                var Klass = this;
                !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
                instance.destructor();
                if (Klass.instancePool.length < Klass.poolSize) {
                    Klass.instancePool.push(instance);
                }
            };

            var DEFAULT_POOL_SIZE = 10;
            var DEFAULT_POOLER = oneArgumentPooler;

            /**
             * Augments `CopyConstructor` to be a poolable class, augmenting only the class
             * itself (statically) not adding any prototypical fields. Any CopyConstructor
             * you give this may have a `poolSize` property, and will look for a
             * prototypical `destructor` on instances (optional).
             *
             * @param {Function} CopyConstructor Constructor that can be used to reset.
             * @param {Function} pooler Customizable pooler.
             */
            var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
                var NewKlass = CopyConstructor;
                NewKlass.instancePool = [];
                NewKlass.getPooled = pooler || DEFAULT_POOLER;
                if (!NewKlass.poolSize) {
                    NewKlass.poolSize = DEFAULT_POOL_SIZE;
                }
                NewKlass.release = standardReleaser;
                return NewKlass;
            };

            var PooledClass = {
                addPoolingTo: addPoolingTo,
                oneArgumentPooler: oneArgumentPooler,
                twoArgumentPooler: twoArgumentPooler,
                threeArgumentPooler: threeArgumentPooler,
                fourArgumentPooler: fourArgumentPooler,
                fiveArgumentPooler: fiveArgumentPooler
            };

            module.exports = PooledClass;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 131 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule Transaction
         */

        'use strict';

            var invariant = __webpack_require__(87);

            /**
             * `Transaction` creates a black box that is able to wrap any method such that
             * certain invariants are maintained before and after the method is invoked
             * (Even if an exception is thrown while invoking the wrapped method). Whoever
             * instantiates a transaction can provide enforcers of the invariants at
             * creation time. The `Transaction` class itself will supply one additional
             * automatic invariant for you - the invariant that any transaction instance
             * should not be run while it is already being run. You would typically create a
             * single instance of a `Transaction` for reuse multiple times, that potentially
             * is used to wrap several different methods. Wrappers are extremely simple -
             * they only require implementing two methods.
             *
             * <pre>
             *                       wrappers (injected at creation time)
             *                                      +        +
             *                                      |        |
             *                    +-----------------|--------|--------------+
             *                    |                 v        |              |
             *                    |      +---------------+   |              |
             *                    |   +--|    wrapper1   |---|----+         |
             *                    |   |  +---------------+   v    |         |
             *                    |   |          +-------------+  |         |
             *                    |   |     +----|   wrapper2  |--------+   |
             *                    |   |     |    +-------------+  |     |   |
             *                    |   |     |                     |     |   |
             *                    |   v     v                     v     v   | wrapper
             *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
             * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
             * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
             *                    | |   | |   |   |         |   |   | |   | |
             *                    | |   | |   |   |         |   |   | |   | |
             *                    | |   | |   |   |         |   |   | |   | |
             *                    | +---+ +---+   +---------+   +---+ +---+ |
             *                    |  initialize                    close    |
             *                    +-----------------------------------------+
             * </pre>
             *
             * Use cases:
             * - Preserving the input selection ranges before/after reconciliation.
             *   Restoring selection even in the event of an unexpected error.
             * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
             *   while guaranteeing that afterwards, the event system is reactivated.
             * - Flushing a queue of collected DOM mutations to the main UI thread after a
             *   reconciliation takes place in a worker thread.
             * - Invoking any collected `componentDidUpdate` callbacks after rendering new
             *   content.
             * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
             *   to preserve the `scrollTop` (an automatic scroll aware DOM).
             * - (Future use case): Layout calculations before and after DOM updates.
             *
             * Transactional plugin API:
             * - A module that has an `initialize` method that returns any precomputation.
             * - and a `close` method that accepts the precomputation. `close` is invoked
             *   when the wrapped process is completed, or has failed.
             *
             * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
             * that implement `initialize` and `close`.
             * @return {Transaction} Single transaction for reuse in thread.
             *
             * @class Transaction
             */
            var Mixin = {
                /**
                 * Sets up this instance so that it is prepared for collecting metrics. Does
                 * so such that this setup method may be used on an instance that is already
                 * initialized, in a way that does not consume additional memory upon reuse.
                 * That can be useful if you decide to make your subclass of this mixin a
                 * "PooledClass".
                 */
                reinitializeTransaction: function reinitializeTransaction() {
                    this.transactionWrappers = this.getTransactionWrappers();
                    if (this.wrapperInitData) {
                        this.wrapperInitData.length = 0;
                    } else {
                        this.wrapperInitData = [];
                    }
                    this._isInTransaction = false;
                },

                _isInTransaction: false,

                /**
                 * @abstract
                 * @return {Array<TransactionWrapper>} Array of transaction wrappers.
                 */
                getTransactionWrappers: null,

                isInTransaction: function isInTransaction() {
                    return !!this._isInTransaction;
                },

                /**
                 * Executes the function within a safety window. Use this for the top level
                 * methods that result in large amounts of computation/mutations that would
                 * need to be safety checked. The optional arguments helps prevent the need
                 * to bind in many cases.
                 *
                 * @param {function} method Member of scope to call.
                 * @param {Object} scope Scope to invoke from.
                 * @param {Object?=} a Argument to pass to the method.
                 * @param {Object?=} b Argument to pass to the method.
                 * @param {Object?=} c Argument to pass to the method.
                 * @param {Object?=} d Argument to pass to the method.
                 * @param {Object?=} e Argument to pass to the method.
                 * @param {Object?=} f Argument to pass to the method.
                 *
                 * @return {*} Return value from `method`.
                 */
                perform: function perform(method, scope, a, b, c, d, e, f) {
                    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
                    var errorThrown;
                    var ret;
                    try {
                        this._isInTransaction = true;
                        // Catching errors makes debugging more difficult, so we start with
                        // errorThrown set to true before setting it to false after calling
                        // close -- if it's still set to true in the finally block, it means
                        // one of these calls threw.
                        errorThrown = true;
                        this.initializeAll(0);
                        ret = method.call(scope, a, b, c, d, e, f);
                        errorThrown = false;
                    } finally {
                        try {
                            if (errorThrown) {
                                // If `method` throws, prefer to show that stack trace over any thrown
                                // by invoking `closeAll`.
                                try {
                                    this.closeAll(0);
                                } catch (err) {}
                            } else {
                                // Since `method` didn't throw, we don't want to silence the exception
                                // here.
                                this.closeAll(0);
                            }
                        } finally {
                            this._isInTransaction = false;
                        }
                    }
                    return ret;
                },

                initializeAll: function initializeAll(startIndex) {
                    var transactionWrappers = this.transactionWrappers;
                    for (var i = startIndex; i < transactionWrappers.length; i++) {
                        var wrapper = transactionWrappers[i];
                        try {
                            // Catching errors makes debugging more difficult, so we start with the
                            // OBSERVED_ERROR state before overwriting it with the real return value
                            // of initialize -- if it's still set to OBSERVED_ERROR in the finally
                            // block, it means wrapper.initialize threw.
                            this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
                            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
                        } finally {
                            if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
                                // The initializer for wrapper i threw an error; initialize the
                                // remaining wrappers but silence any exceptions from them to ensure
                                // that the first error is the one to bubble up.
                                try {
                                    this.initializeAll(i + 1);
                                } catch (err) {}
                            }
                        }
                    }
                },

                /**
                 * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
                 * them the respective return values of `this.transactionWrappers.init[i]`
                 * (`close`rs that correspond to initializers that failed will not be
                 * invoked).
                 */
                closeAll: function closeAll(startIndex) {
                    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
                    var transactionWrappers = this.transactionWrappers;
                    for (var i = startIndex; i < transactionWrappers.length; i++) {
                        var wrapper = transactionWrappers[i];
                        var initData = this.wrapperInitData[i];
                        var errorThrown;
                        try {
                            // Catching errors makes debugging more difficult, so we start with
                            // errorThrown set to true before setting it to false after calling
                            // close -- if it's still set to true in the finally block, it means
                            // wrapper.close threw.
                            errorThrown = true;
                            if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
                                wrapper.close.call(this, initData);
                            }
                            errorThrown = false;
                        } finally {
                            if (errorThrown) {
                                // The closer for wrapper i threw an error; close the remaining
                                // wrappers but silence any exceptions from them to ensure that the
                                // first error is the one to bubble up.
                                try {
                                    this.closeAll(i + 1);
                                } catch (e) {}
                            }
                        }
                    }
                    this.wrapperInitData.length = 0;
                }
            };

            var Transaction = {

                Mixin: Mixin,

                /**
                 * Token to look for to determine if an error occurred.
                 */
                OBSERVED_ERROR: {}

            };

            module.exports = Transaction;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 132 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule emptyObject
         */

        'use strict';

            var emptyObject = {};

            if (process.env.NODE_ENV !== 'production') {
                Object.freeze(emptyObject);
            }

            module.exports = emptyObject;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 133 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule containsNode
         * @typechecks
         */

        'use strict';

        var isTextNode = __webpack_require__(134);

        /*eslint-disable no-bitwise */

        /**
         * Checks if a given DOM node contains or is another DOM node.
         *
         * @param {?DOMNode} outerNode Outer DOM node.
         * @param {?DOMNode} innerNode Inner DOM node.
         * @return {boolean} True if `outerNode` contains or is `innerNode`.
         */
        function containsNode(_x, _x2) {
            var _again = true;

            _function: while (_again) {
                var outerNode = _x,
                    innerNode = _x2;
                _again = false;

                if (!outerNode || !innerNode) {
                    return false;
                } else if (outerNode === innerNode) {
                    return true;
                } else if (isTextNode(outerNode)) {
                    return false;
                } else if (isTextNode(innerNode)) {
                    _x = outerNode;
                    _x2 = innerNode.parentNode;
                    _again = true;
                    continue _function;
                } else if (outerNode.contains) {
                    return outerNode.contains(innerNode);
                } else if (outerNode.compareDocumentPosition) {
                    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
                } else {
                    return false;
                }
            }
        }

        module.exports = containsNode;

        /***/ },
    /* 134 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule isTextNode
         * @typechecks
         */

        'use strict';

        var isNode = __webpack_require__(135);

        /**
         * @param {*} object The object to check.
         * @return {boolean} Whether or not the object is a DOM text node.
         */
        function isTextNode(object) {
            return isNode(object) && object.nodeType == 3;
        }

        module.exports = isTextNode;

        /***/ },
    /* 135 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule isNode
         * @typechecks
         */

        /**
         * @param {*} object The object to check.
         * @return {boolean} Whether or not the object is a DOM node.
         */
        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        function isNode(object) {
            return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
        }

        module.exports = isNode;

        /***/ },
    /* 136 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule instantiateReactComponent
         * @typechecks static-only
         */

        'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var ReactCompositeComponent = __webpack_require__(137);
            var ReactEmptyComponent = __webpack_require__(142);
            var ReactNativeComponent = __webpack_require__(143);

            var assign = __webpack_require__(113);
            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            // To avoid a cyclic dependency, we create the final class in this module
            var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper() {};
            assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
                _instantiateReactComponent: instantiateReactComponent
            });

            function getDeclarationErrorAddendum(owner) {
                if (owner) {
                    var name = owner.getName();
                    if (name) {
                        return ' Check the render method of `' + name + '`.';
                    }
                }
                return '';
            }

            /**
             * Check if the type reference is a known internal type. I.e. not a user
             * provided composite type.
             *
             * @param {function} type
             * @return {boolean} Returns true if this is a valid internal type.
             */
            function isInternalComponentType(type) {
                return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
            }

            /**
             * Given a ReactNode, create an instance that will actually be mounted.
             *
             * @param {ReactNode} node
             * @return {object} A new instance of the element's constructor.
             * @protected
             */
            function instantiateReactComponent(node) {
                var instance;

                if (node === null || node === false) {
                    instance = new ReactEmptyComponent(instantiateReactComponent);
                } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
                    var element = node;
                    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;

                    // Special case string values
                    if (typeof element.type === 'string') {
                        instance = ReactNativeComponent.createInternalComponent(element);
                    } else if (isInternalComponentType(element.type)) {
                        // This is temporarily available for custom components that are not string
                        // representations. I.e. ART. Once those are updated to use the string
                        // representation, we can drop this code path.
                        instance = new element.type(element);
                    } else {
                        instance = new ReactCompositeComponentWrapper();
                    }
                } else if (typeof node === 'string' || typeof node === 'number') {
                    instance = ReactNativeComponent.createInstanceForText(node);
                } else {
                    true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : invariant(false) : undefined;
                }

                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
                }

                // Sets up the instance. This can probably just move into the constructor now.
                instance.construct(node);

                // These two fields are used by the DOM and ART diffing algorithms
                // respectively. Instead of using expandos on components, we should be
                // storing the state needed by the diffing algorithms elsewhere.
                instance._mountIndex = 0;
                instance._mountImage = null;

                if (process.env.NODE_ENV !== 'production') {
                    instance._isOwnerNecessary = false;
                    instance._warnedAboutRefsInRender = false;
                }

                // Internal instances should fully constructed at this point, so they should
                // not get any new fields added to them at this point.
                if (process.env.NODE_ENV !== 'production') {
                    if (Object.preventExtensions) {
                        Object.preventExtensions(instance);
                    }
                }

                return instance;
            }

            module.exports = instantiateReactComponent;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 137 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactCompositeComponent
         */

        'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var ReactComponentEnvironment = __webpack_require__(138);
            var ReactCurrentOwner = __webpack_require__(79);
            var ReactElement = __webpack_require__(116);
            var ReactInstanceMap = __webpack_require__(121);
            var ReactPerf = __webpack_require__(92);
            var ReactPropTypeLocations = __webpack_require__(139);
            var ReactPropTypeLocationNames = __webpack_require__(140);
            var ReactReconciler = __webpack_require__(124);
            var ReactUpdateQueue = __webpack_require__(127);

            var assign = __webpack_require__(113);
            var emptyObject = __webpack_require__(132);
            var invariant = __webpack_require__(87);
            var shouldUpdateReactComponent = __webpack_require__(141);
            var warning = __webpack_require__(99);

            function getDeclarationErrorAddendum(component) {
                var owner = component._currentElement._owner || null;
                if (owner) {
                    var name = owner.getName();
                    if (name) {
                        return ' Check the render method of `' + name + '`.';
                    }
                }
                return '';
            }

            function StatelessComponent(Component) {}
            StatelessComponent.prototype.render = function () {
                var Component = ReactInstanceMap.get(this)._currentElement.type;
                return Component(this.props, this.context, this.updater);
            };

            /**
             * ------------------ The Life-Cycle of a Composite Component ------------------
             *
             * - constructor: Initialization of state. The instance is now retained.
             *   - componentWillMount
             *   - render
             *   - [children's constructors]
             *     - [children's componentWillMount and render]
             *     - [children's componentDidMount]
             *     - componentDidMount
             *
             *       Update Phases:
             *       - componentWillReceiveProps (only called if parent updated)
             *       - shouldComponentUpdate
             *         - componentWillUpdate
             *           - render
             *           - [children's constructors or receive props phases]
             *         - componentDidUpdate
             *
             *     - componentWillUnmount
             *     - [children's componentWillUnmount]
             *   - [children destroyed]
             * - (destroyed): The instance is now blank, released by React and ready for GC.
             *
             * -----------------------------------------------------------------------------
             */

            /**
             * An incrementing ID assigned to each component when it is mounted. This is
             * used to enforce the order in which `ReactUpdates` updates dirty components.
             *
             * @private
             */
            var nextMountID = 1;

            /**
             * @lends {ReactCompositeComponent.prototype}
             */
            var ReactCompositeComponentMixin = {

                /**
                 * Base constructor for all composite component.
                 *
                 * @param {ReactElement} element
                 * @final
                 * @internal
                 */
                construct: function construct(element) {
                    this._currentElement = element;
                    this._rootNodeID = null;
                    this._instance = null;

                    // See ReactUpdateQueue
                    this._pendingElement = null;
                    this._pendingStateQueue = null;
                    this._pendingReplaceState = false;
                    this._pendingForceUpdate = false;

                    this._renderedComponent = null;

                    this._context = null;
                    this._mountOrder = 0;
                    this._topLevelWrapper = null;

                    // See ReactUpdates and ReactUpdateQueue.
                    this._pendingCallbacks = null;
                },

                /**
                 * Initializes the component, renders markup, and registers event listeners.
                 *
                 * @param {string} rootID DOM ID of the root node.
                 * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
                 * @return {?string} Rendered markup to be inserted into the DOM.
                 * @final
                 * @internal
                 */
                mountComponent: function mountComponent(rootID, transaction, context) {
                    this._context = context;
                    this._mountOrder = nextMountID++;
                    this._rootNodeID = rootID;

                    var publicProps = this._processProps(this._currentElement.props);
                    var publicContext = this._processContext(context);

                    var Component = this._currentElement.type;

                    // Initialize the public class
                    var inst;
                    var renderedElement;

                    // This is a way to detect if Component is a stateless arrow function
                    // component, which is not newable. It might not be 100% reliable but is
                    // something we can do until we start detecting that Component extends
                    // React.Component. We already assume that typeof Component === 'function'.
                    var canInstantiate = 'prototype' in Component;

                    if (canInstantiate) {
                        if (process.env.NODE_ENV !== 'production') {
                            ReactCurrentOwner.current = this;
                            try {
                                inst = new Component(publicProps, publicContext, ReactUpdateQueue);
                            } finally {
                                ReactCurrentOwner.current = null;
                            }
                        } else {
                            inst = new Component(publicProps, publicContext, ReactUpdateQueue);
                        }
                    }

                    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
                        renderedElement = inst;
                        inst = new StatelessComponent(Component);
                    }

                    if (process.env.NODE_ENV !== 'production') {
                        // This will throw later in _renderValidatedComponent, but add an early
                        // warning now to help debugging
                        if (inst.render == null) {
                            process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
                        } else {
                            // We support ES6 inheriting from React.Component, the module pattern,
                            // and stateless components, but not ES6 classes that don't extend
                            process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
                        }
                    }

                    // These should be set up in the constructor, but as a convenience for
                    // simpler class abstractions, we set them up after the fact.
                    inst.props = publicProps;
                    inst.context = publicContext;
                    inst.refs = emptyObject;
                    inst.updater = ReactUpdateQueue;

                    this._instance = inst;

                    // Store a reference from the instance back to the internal representation
                    ReactInstanceMap.set(inst, this);

                    if (process.env.NODE_ENV !== 'production') {
                        // Since plain JS classes are defined without any special initialization
                        // logic, we can not catch common errors early. Therefore, we have to
                        // catch them here, at initialization time, instead.
                        process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
                        process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
                        process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
                        process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
                        process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
                        process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
                        process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
                    }

                    var initialState = inst.state;
                    if (initialState === undefined) {
                        inst.state = initialState = null;
                    }
                    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;

                    this._pendingStateQueue = null;
                    this._pendingReplaceState = false;
                    this._pendingForceUpdate = false;

                    if (inst.componentWillMount) {
                        inst.componentWillMount();
                        // When mounting, calls to `setState` by `componentWillMount` will set
                        // `this._pendingStateQueue` without triggering a re-render.
                        if (this._pendingStateQueue) {
                            inst.state = this._processPendingState(inst.props, inst.context);
                        }
                    }

                    // If not a stateless component, we now render
                    if (renderedElement === undefined) {
                        renderedElement = this._renderValidatedComponent();
                    }

                    this._renderedComponent = this._instantiateReactComponent(renderedElement);

                    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
                    if (inst.componentDidMount) {
                        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
                    }

                    return markup;
                },

                /**
                 * Releases any resources allocated by `mountComponent`.
                 *
                 * @final
                 * @internal
                 */
                unmountComponent: function unmountComponent() {
                    var inst = this._instance;

                    if (inst.componentWillUnmount) {
                        inst.componentWillUnmount();
                    }

                    ReactReconciler.unmountComponent(this._renderedComponent);
                    this._renderedComponent = null;
                    this._instance = null;

                    // Reset pending fields
                    // Even if this component is scheduled for another update in ReactUpdates,
                    // it would still be ignored because these fields are reset.
                    this._pendingStateQueue = null;
                    this._pendingReplaceState = false;
                    this._pendingForceUpdate = false;
                    this._pendingCallbacks = null;
                    this._pendingElement = null;

                    // These fields do not really need to be reset since this object is no
                    // longer accessible.
                    this._context = null;
                    this._rootNodeID = null;
                    this._topLevelWrapper = null;

                    // Delete the reference from the instance to this internal representation
                    // which allow the internals to be properly cleaned up even if the user
                    // leaks a reference to the public instance.
                    ReactInstanceMap.remove(inst);

                    // Some existing components rely on inst.props even after they've been
                    // destroyed (in event handlers).
                    // TODO: inst.props = null;
                    // TODO: inst.state = null;
                    // TODO: inst.context = null;
                },

                /**
                 * Filters the context object to only contain keys specified in
                 * `contextTypes`
                 *
                 * @param {object} context
                 * @return {?object}
                 * @private
                 */
                _maskContext: function _maskContext(context) {
                    var maskedContext = null;
                    var Component = this._currentElement.type;
                    var contextTypes = Component.contextTypes;
                    if (!contextTypes) {
                        return emptyObject;
                    }
                    maskedContext = {};
                    for (var contextName in contextTypes) {
                        maskedContext[contextName] = context[contextName];
                    }
                    return maskedContext;
                },

                /**
                 * Filters the context object to only contain keys specified in
                 * `contextTypes`, and asserts that they are valid.
                 *
                 * @param {object} context
                 * @return {?object}
                 * @private
                 */
                _processContext: function _processContext(context) {
                    var maskedContext = this._maskContext(context);
                    if (process.env.NODE_ENV !== 'production') {
                        var Component = this._currentElement.type;
                        if (Component.contextTypes) {
                            this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
                        }
                    }
                    return maskedContext;
                },

                /**
                 * @param {object} currentContext
                 * @return {object}
                 * @private
                 */
                _processChildContext: function _processChildContext(currentContext) {
                    var Component = this._currentElement.type;
                    var inst = this._instance;
                    var childContext = inst.getChildContext && inst.getChildContext();
                    if (childContext) {
                        !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
                        if (process.env.NODE_ENV !== 'production') {
                            this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
                        }
                        for (var name in childContext) {
                            !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
                        }
                        return assign({}, currentContext, childContext);
                    }
                    return currentContext;
                },

                /**
                 * Processes props by setting default values for unspecified props and
                 * asserting that the props are valid. Does not mutate its argument; returns
                 * a new props object with defaults merged in.
                 *
                 * @param {object} newProps
                 * @return {object}
                 * @private
                 */
                _processProps: function _processProps(newProps) {
                    if (process.env.NODE_ENV !== 'production') {
                        var Component = this._currentElement.type;
                        if (Component.propTypes) {
                            this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
                        }
                    }
                    return newProps;
                },

                /**
                 * Assert that the props are valid
                 *
                 * @param {object} propTypes Map of prop name to a ReactPropType
                 * @param {object} props
                 * @param {string} location e.g. "prop", "context", "child context"
                 * @private
                 */
                _checkPropTypes: function _checkPropTypes(propTypes, props, location) {
                    // TODO: Stop validating prop types here and only use the element
                    // validation.
                    var componentName = this.getName();
                    for (var propName in propTypes) {
                        if (propTypes.hasOwnProperty(propName)) {
                            var error;
                            try {
                                // This is intentionally an invariant that gets caught. It's the same
                                // behavior as without this statement except with a better message.
                                !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
                                error = propTypes[propName](props, propName, componentName, location);
                            } catch (ex) {
                                error = ex;
                            }
                            if (error instanceof Error) {
                                // We may want to extend this logic for similar errors in
                                // top-level render calls, so I'm abstracting it away into
                                // a function to minimize refactoring in the future
                                var addendum = getDeclarationErrorAddendum(this);

                                if (location === ReactPropTypeLocations.prop) {
                                    // Preface gives us something to blacklist in warning module
                                    process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
                                } else {
                                    process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
                                }
                            }
                        }
                    }
                },

                receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
                    var prevElement = this._currentElement;
                    var prevContext = this._context;

                    this._pendingElement = null;

                    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
                },

                /**
                 * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
                 * is set, update the component.
                 *
                 * @param {ReactReconcileTransaction} transaction
                 * @internal
                 */
                performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
                    if (this._pendingElement != null) {
                        ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
                    }

                    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
                        this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
                    }
                },

                /**
                 * Perform an update to a mounted component. The componentWillReceiveProps and
                 * shouldComponentUpdate methods are called, then (assuming the update isn't
                 * skipped) the remaining update lifecycle methods are called and the DOM
                 * representation is updated.
                 *
                 * By default, this implements React's rendering and reconciliation algorithm.
                 * Sophisticated clients may wish to override this.
                 *
                 * @param {ReactReconcileTransaction} transaction
                 * @param {ReactElement} prevParentElement
                 * @param {ReactElement} nextParentElement
                 * @internal
                 * @overridable
                 */
                updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
                    var inst = this._instance;

                    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
                    var nextProps;

                    // Distinguish between a props update versus a simple state update
                    if (prevParentElement === nextParentElement) {
                        // Skip checking prop types again -- we don't read inst.props to avoid
                        // warning for DOM component props in this upgrade
                        nextProps = nextParentElement.props;
                    } else {
                        nextProps = this._processProps(nextParentElement.props);
                        // An update here will schedule an update but immediately set
                        // _pendingStateQueue which will ensure that any state updates gets
                        // immediately reconciled instead of waiting for the next batch.

                        if (inst.componentWillReceiveProps) {
                            inst.componentWillReceiveProps(nextProps, nextContext);
                        }
                    }

                    var nextState = this._processPendingState(nextProps, nextContext);

                    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);

                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
                    }

                    if (shouldUpdate) {
                        this._pendingForceUpdate = false;
                        // Will set `this.props`, `this.state` and `this.context`.
                        this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
                    } else {
                        // If it's determined that a component should not update, we still want
                        // to set props and state but we shortcut the rest of the update.
                        this._currentElement = nextParentElement;
                        this._context = nextUnmaskedContext;
                        inst.props = nextProps;
                        inst.state = nextState;
                        inst.context = nextContext;
                    }
                },

                _processPendingState: function _processPendingState(props, context) {
                    var inst = this._instance;
                    var queue = this._pendingStateQueue;
                    var replace = this._pendingReplaceState;
                    this._pendingReplaceState = false;
                    this._pendingStateQueue = null;

                    if (!queue) {
                        return inst.state;
                    }

                    if (replace && queue.length === 1) {
                        return queue[0];
                    }

                    var nextState = assign({}, replace ? queue[0] : inst.state);
                    for (var i = replace ? 1 : 0; i < queue.length; i++) {
                        var partial = queue[i];
                        assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
                    }

                    return nextState;
                },

                /**
                 * Merges new props and state, notifies delegate methods of update and
                 * performs update.
                 *
                 * @param {ReactElement} nextElement Next element
                 * @param {object} nextProps Next public object to set as properties.
                 * @param {?object} nextState Next object to set as state.
                 * @param {?object} nextContext Next public object to set as context.
                 * @param {ReactReconcileTransaction} transaction
                 * @param {?object} unmaskedContext
                 * @private
                 */
                _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
                    var inst = this._instance;

                    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
                    var prevProps;
                    var prevState;
                    var prevContext;
                    if (hasComponentDidUpdate) {
                        prevProps = inst.props;
                        prevState = inst.state;
                        prevContext = inst.context;
                    }

                    if (inst.componentWillUpdate) {
                        inst.componentWillUpdate(nextProps, nextState, nextContext);
                    }

                    this._currentElement = nextElement;
                    this._context = unmaskedContext;
                    inst.props = nextProps;
                    inst.state = nextState;
                    inst.context = nextContext;

                    this._updateRenderedComponent(transaction, unmaskedContext);

                    if (hasComponentDidUpdate) {
                        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
                    }
                },

                /**
                 * Call the component's `render` method and update the DOM accordingly.
                 *
                 * @param {ReactReconcileTransaction} transaction
                 * @internal
                 */
                _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
                    var prevComponentInstance = this._renderedComponent;
                    var prevRenderedElement = prevComponentInstance._currentElement;
                    var nextRenderedElement = this._renderValidatedComponent();
                    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
                        ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
                    } else {
                        // These two IDs are actually the same! But nothing should rely on that.
                        var thisID = this._rootNodeID;
                        var prevComponentID = prevComponentInstance._rootNodeID;
                        ReactReconciler.unmountComponent(prevComponentInstance);

                        this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
                        var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
                        this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
                    }
                },

                /**
                 * @protected
                 */
                _replaceNodeWithMarkupByID: function _replaceNodeWithMarkupByID(prevComponentID, nextMarkup) {
                    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
                },

                /**
                 * @protected
                 */
                _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
                    var inst = this._instance;
                    var renderedComponent = inst.render();
                    if (process.env.NODE_ENV !== 'production') {
                        // We allow auto-mocks to proceed as if they're returning null.
                        if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
                            // This is probably bad practice. Consider warning here and
                            // deprecating this convenience.
                            renderedComponent = null;
                        }
                    }

                    return renderedComponent;
                },

                /**
                 * @private
                 */
                _renderValidatedComponent: function _renderValidatedComponent() {
                    var renderedComponent;
                    ReactCurrentOwner.current = this;
                    try {
                        renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
                    } finally {
                        ReactCurrentOwner.current = null;
                    }
                    !(
                        // TODO: An `isValidNode` function would probably be more appropriate
                    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
                    return renderedComponent;
                },

                /**
                 * Lazily allocates the refs object and stores `component` as `ref`.
                 *
                 * @param {string} ref Reference name.
                 * @param {component} component Component to store as `ref`.
                 * @final
                 * @private
                 */
                attachRef: function attachRef(ref, component) {
                    var inst = this.getPublicInstance();
                    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
                    var publicComponentInstance = component.getPublicInstance();
                    if (process.env.NODE_ENV !== 'production') {
                        var componentName = component && component.getName ? component.getName() : 'a component';
                        process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
                    }
                    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
                    refs[ref] = publicComponentInstance;
                },

                /**
                 * Detaches a reference name.
                 *
                 * @param {string} ref Name to dereference.
                 * @final
                 * @private
                 */
                detachRef: function detachRef(ref) {
                    var refs = this.getPublicInstance().refs;
                    delete refs[ref];
                },

                /**
                 * Get a text description of the component that can be used to identify it
                 * in error messages.
                 * @return {string} The name or null.
                 * @internal
                 */
                getName: function getName() {
                    var type = this._currentElement.type;
                    var constructor = this._instance && this._instance.constructor;
                    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
                },

                /**
                 * Get the publicly accessible representation of this component - i.e. what
                 * is exposed by refs and returned by render. Can be null for stateless
                 * components.
                 *
                 * @return {ReactComponent} the public component instance.
                 * @internal
                 */
                getPublicInstance: function getPublicInstance() {
                    var inst = this._instance;
                    if (inst instanceof StatelessComponent) {
                        return null;
                    }
                    return inst;
                },

                // Stub
                _instantiateReactComponent: null

            };

            ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
                mountComponent: 'mountComponent',
                updateComponent: 'updateComponent',
                _renderValidatedComponent: '_renderValidatedComponent'
            });

            var ReactCompositeComponent = {

                Mixin: ReactCompositeComponentMixin

            };

            module.exports = ReactCompositeComponent;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 138 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactComponentEnvironment
         */

        'use strict';

            var invariant = __webpack_require__(87);

            var injected = false;

            var ReactComponentEnvironment = {

                /**
                 * Optionally injectable environment dependent cleanup hook. (server vs.
                 * browser etc). Example: A browser system caches DOM nodes based on component
                 * ID and must remove that cache entry when this instance is unmounted.
                 */
                unmountIDFromEnvironment: null,

                /**
                 * Optionally injectable hook for swapping out mount images in the middle of
                 * the tree.
                 */
                replaceNodeWithMarkupByID: null,

                /**
                 * Optionally injectable hook for processing a queue of child updates. Will
                 * later move into MultiChildComponents.
                 */
                processChildrenUpdates: null,

                injection: {
                    injectEnvironment: function injectEnvironment(environment) {
                        !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
                        ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
                        ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
                        ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
                        injected = true;
                    }
                }

            };

            module.exports = ReactComponentEnvironment;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 139 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactPropTypeLocations
         */

        'use strict';

        var keyMirror = __webpack_require__(91);

        var ReactPropTypeLocations = keyMirror({
            prop: null,
            context: null,
            childContext: null
        });

        module.exports = ReactPropTypeLocations;

        /***/ },
    /* 140 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactPropTypeLocationNames
         */

        'use strict';

            var ReactPropTypeLocationNames = {};

            if (process.env.NODE_ENV !== 'production') {
                ReactPropTypeLocationNames = {
                    prop: 'prop',
                    context: 'context',
                    childContext: 'child context'
                };
            }

            module.exports = ReactPropTypeLocationNames;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 141 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule shouldUpdateReactComponent
         * @typechecks static-only
         */

        'use strict';

        /**
         * Given a `prevElement` and `nextElement`, determines if the existing
         * instance should be updated as opposed to being destroyed or replaced by a new
         * instance. Both arguments are elements. This ensures that this logic can
         * operate on stateless trees without any backing instance.
         *
         * @param {?object} prevElement
         * @param {?object} nextElement
         * @return {boolean} True if the existing instance should be updated.
         * @protected
         */

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        function shouldUpdateReactComponent(prevElement, nextElement) {
            var prevEmpty = prevElement === null || prevElement === false;
            var nextEmpty = nextElement === null || nextElement === false;
            if (prevEmpty || nextEmpty) {
                return prevEmpty === nextEmpty;
            }

            var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
            var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
            if (prevType === 'string' || prevType === 'number') {
                return nextType === 'string' || nextType === 'number';
            } else {
                return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
            }
            return false;
        }

        module.exports = shouldUpdateReactComponent;

        /***/ },
    /* 142 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactEmptyComponent
         */

        'use strict';

        var ReactElement = __webpack_require__(116);
        var ReactEmptyComponentRegistry = __webpack_require__(118);
        var ReactReconciler = __webpack_require__(124);

        var assign = __webpack_require__(113);

        var placeholderElement;

        var ReactEmptyComponentInjection = {
            injectEmptyComponent: function injectEmptyComponent(component) {
                placeholderElement = ReactElement.createElement(component);
            }
        };

        var ReactEmptyComponent = function ReactEmptyComponent(instantiate) {
            this._currentElement = null;
            this._rootNodeID = null;
            this._renderedComponent = instantiate(placeholderElement);
        };
        assign(ReactEmptyComponent.prototype, {
            construct: function construct(element) {},
            mountComponent: function mountComponent(rootID, transaction, context) {
                ReactEmptyComponentRegistry.registerNullComponentID(rootID);
                this._rootNodeID = rootID;
                return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
            },
            receiveComponent: function receiveComponent() {},
            unmountComponent: function unmountComponent(rootID, transaction, context) {
                ReactReconciler.unmountComponent(this._renderedComponent);
                ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
                this._rootNodeID = null;
                this._renderedComponent = null;
            }
        });

        ReactEmptyComponent.injection = ReactEmptyComponentInjection;

        module.exports = ReactEmptyComponent;

        /***/ },
    /* 143 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactNativeComponent
         */

        'use strict';

            var assign = __webpack_require__(113);
            var invariant = __webpack_require__(87);

            var autoGenerateWrapperClass = null;
            var genericComponentClass = null;
            // This registry keeps track of wrapper classes around native tags.
            var tagToComponentClass = {};
            var textComponentClass = null;

            var ReactNativeComponentInjection = {
                // This accepts a class that receives the tag string. This is a catch all
                // that can render any kind of tag.
                injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
                    genericComponentClass = componentClass;
                },
                // This accepts a text component class that takes the text string to be
                // rendered as props.
                injectTextComponentClass: function injectTextComponentClass(componentClass) {
                    textComponentClass = componentClass;
                },
                // This accepts a keyed object with classes as values. Each key represents a
                // tag. That particular tag will use this class instead of the generic one.
                injectComponentClasses: function injectComponentClasses(componentClasses) {
                    assign(tagToComponentClass, componentClasses);
                }
            };

            /**
             * Get a composite component wrapper class for a specific tag.
             *
             * @param {ReactElement} element The tag for which to get the class.
             * @return {function} The React class constructor function.
             */
            function getComponentClassForElement(element) {
                if (typeof element.type === 'function') {
                    return element.type;
                }
                var tag = element.type;
                var componentClass = tagToComponentClass[tag];
                if (componentClass == null) {
                    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
                }
                return componentClass;
            }

            /**
             * Get a native internal component class for a specific tag.
             *
             * @param {ReactElement} element The element to create.
             * @return {function} The internal class constructor function.
             */
            function createInternalComponent(element) {
                !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
                return new genericComponentClass(element.type, element.props);
            }

            /**
             * @param {ReactText} text
             * @return {ReactComponent}
             */
            function createInstanceForText(text) {
                return new textComponentClass(text);
            }

            /**
             * @param {ReactComponent} component
             * @return {boolean}
             */
            function isTextComponent(component) {
                return component instanceof textComponentClass;
            }

            var ReactNativeComponent = {
                getComponentClassForElement: getComponentClassForElement,
                createInternalComponent: createInternalComponent,
                createInstanceForText: createInstanceForText,
                isTextComponent: isTextComponent,
                injection: ReactNativeComponentInjection
            };

            module.exports = ReactNativeComponent;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 144 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule validateDOMNesting
         */

        'use strict';

            var assign = __webpack_require__(113);
            var emptyFunction = __webpack_require__(89);
            var warning = __webpack_require__(99);

            var validateDOMNesting = emptyFunction;

            if (process.env.NODE_ENV !== 'production') {
                // This validation code was written based on the HTML5 parsing spec:
                // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
                //
                // Note: this does not catch all invalid nesting, nor does it try to (as it's
                // not clear what practical benefit doing so provides); instead, we warn only
                // for cases where the parser will give a parse tree differing from what React
                // intended. For example, <b><div></div></b> is invalid but we don't warn
                // because it still parses correctly; we do warn for other cases like nested
                // <p> tags where the beginning of the second element implicitly closes the
                // first, causing a confusing mess.

                // https://html.spec.whatwg.org/multipage/syntax.html#special
                var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

                // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
                var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

                    // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
                    // TODO: Distinguish by namespace here -- for <title>, including it here
                    // errs on the side of fewer warnings
                    'foreignObject', 'desc', 'title'];

                // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
                var buttonScopeTags = inScopeTags.concat(['button']);

                // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
                var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

                var emptyAncestorInfo = {
                    parentTag: null,

                    formTag: null,
                    aTagInScope: null,
                    buttonTagInScope: null,
                    nobrTagInScope: null,
                    pTagInButtonScope: null,

                    listItemTagAutoclosing: null,
                    dlItemTagAutoclosing: null
                };

                var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
                    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
                    var info = { tag: tag, instance: instance };

                    if (inScopeTags.indexOf(tag) !== -1) {
                        ancestorInfo.aTagInScope = null;
                        ancestorInfo.buttonTagInScope = null;
                        ancestorInfo.nobrTagInScope = null;
                    }
                    if (buttonScopeTags.indexOf(tag) !== -1) {
                        ancestorInfo.pTagInButtonScope = null;
                    }

                    // See rules for 'li', 'dd', 'dt' start tags in
                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
                    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
                        ancestorInfo.listItemTagAutoclosing = null;
                        ancestorInfo.dlItemTagAutoclosing = null;
                    }

                    ancestorInfo.parentTag = info;

                    if (tag === 'form') {
                        ancestorInfo.formTag = info;
                    }
                    if (tag === 'a') {
                        ancestorInfo.aTagInScope = info;
                    }
                    if (tag === 'button') {
                        ancestorInfo.buttonTagInScope = info;
                    }
                    if (tag === 'nobr') {
                        ancestorInfo.nobrTagInScope = info;
                    }
                    if (tag === 'p') {
                        ancestorInfo.pTagInButtonScope = info;
                    }
                    if (tag === 'li') {
                        ancestorInfo.listItemTagAutoclosing = info;
                    }
                    if (tag === 'dd' || tag === 'dt') {
                        ancestorInfo.dlItemTagAutoclosing = info;
                    }

                    return ancestorInfo;
                };

                /**
                 * Returns whether
                 */
                var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
                    // First, let's check if we're in an unusual parsing mode...
                    switch (parentTag) {
                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
                        case 'select':
                            return tag === 'option' || tag === 'optgroup' || tag === '#text';
                        case 'optgroup':
                            return tag === 'option' || tag === '#text';
                        // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
                        // but
                        case 'option':
                            return tag === '#text';

                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
                        // No special behavior since these rules fall back to "in body" mode for
                        // all except special table nodes which cause bad parsing behavior anyway.

                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
                        case 'tr':
                            return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
                        case 'tbody':
                        case 'thead':
                        case 'tfoot':
                            return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
                        case 'colgroup':
                            return tag === 'col' || tag === 'template';

                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
                        case 'table':
                            return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

                        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
                        case 'head':
                            return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

                        // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
                        case 'html':
                            return tag === 'head' || tag === 'body';
                    }

                    // Probably in the "in body" parsing mode, so we outlaw only tag combos
                    // where the parsing rules cause implicit opens or closes to be added.
                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
                    switch (tag) {
                        case 'h1':
                        case 'h2':
                        case 'h3':
                        case 'h4':
                        case 'h5':
                        case 'h6':
                            return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

                        case 'rp':
                        case 'rt':
                            return impliedEndTags.indexOf(parentTag) === -1;

                        case 'caption':
                        case 'col':
                        case 'colgroup':
                        case 'frame':
                        case 'head':
                        case 'tbody':
                        case 'td':
                        case 'tfoot':
                        case 'th':
                        case 'thead':
                        case 'tr':
                            // These tags are only valid with a few parents that have special child
                            // parsing rules -- if we're down here, then none of those matched and
                            // so we allow it only if we don't know what the parent is, as all other
                            // cases are invalid.
                            return parentTag == null;
                    }

                    return true;
                };

                /**
                 * Returns whether
                 */
                var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
                    switch (tag) {
                        case 'address':
                        case 'article':
                        case 'aside':
                        case 'blockquote':
                        case 'center':
                        case 'details':
                        case 'dialog':
                        case 'dir':
                        case 'div':
                        case 'dl':
                        case 'fieldset':
                        case 'figcaption':
                        case 'figure':
                        case 'footer':
                        case 'header':
                        case 'hgroup':
                        case 'main':
                        case 'menu':
                        case 'nav':
                        case 'ol':
                        case 'p':
                        case 'section':
                        case 'summary':
                        case 'ul':

                        case 'pre':
                        case 'listing':

                        case 'table':

                        case 'hr':

                        case 'xmp':

                        case 'h1':
                        case 'h2':
                        case 'h3':
                        case 'h4':
                        case 'h5':
                        case 'h6':
                            return ancestorInfo.pTagInButtonScope;

                        case 'form':
                            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

                        case 'li':
                            return ancestorInfo.listItemTagAutoclosing;

                        case 'dd':
                        case 'dt':
                            return ancestorInfo.dlItemTagAutoclosing;

                        case 'button':
                            return ancestorInfo.buttonTagInScope;

                        case 'a':
                            // Spec says something about storing a list of markers, but it sounds
                            // equivalent to this check.
                            return ancestorInfo.aTagInScope;

                        case 'nobr':
                            return ancestorInfo.nobrTagInScope;
                    }

                    return null;
                };

                /**
                 * Given a ReactCompositeComponent instance, return a list of its recursive
                 * owners, starting at the root and ending with the instance itself.
                 */
                var findOwnerStack = function findOwnerStack(instance) {
                    if (!instance) {
                        return [];
                    }

                    var stack = [];
                    /*eslint-disable space-after-keywords */
                    do {
                        /*eslint-enable space-after-keywords */
                        stack.push(instance);
                    } while (instance = instance._currentElement._owner);
                    stack.reverse();
                    return stack;
                };

                var didWarn = {};

                validateDOMNesting = function validateDOMNesting(childTag, childInstance, ancestorInfo) {
                    ancestorInfo = ancestorInfo || emptyAncestorInfo;
                    var parentInfo = ancestorInfo.parentTag;
                    var parentTag = parentInfo && parentInfo.tag;

                    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
                    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
                    var problematic = invalidParent || invalidAncestor;

                    if (problematic) {
                        var ancestorTag = problematic.tag;
                        var ancestorInstance = problematic.instance;

                        var childOwner = childInstance && childInstance._currentElement._owner;
                        var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

                        var childOwners = findOwnerStack(childOwner);
                        var ancestorOwners = findOwnerStack(ancestorOwner);

                        var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
                        var i;

                        var deepestCommon = -1;
                        for (i = 0; i < minStackLen; i++) {
                            if (childOwners[i] === ancestorOwners[i]) {
                                deepestCommon = i;
                            } else {
                                break;
                            }
                        }

                        var UNKNOWN = '(unknown)';
                        var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
                            return inst.getName() || UNKNOWN;
                        });
                        var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
                            return inst.getName() || UNKNOWN;
                        });
                        var ownerInfo = [].concat(
                            // If the parent and child instances have a common owner ancestor, start
                            // with that -- otherwise we just start with the parent's owners.
                            deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
                            // If we're warning about an invalid (non-parent) ancestry, add '...'
                            invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

                        var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
                        if (didWarn[warnKey]) {
                            return;
                        }
                        didWarn[warnKey] = true;

                        if (invalidParent) {
                            var info = '';
                            if (ancestorTag === 'table' && childTag === 'tr') {
                                info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
                            }
                            process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
                        } else {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
                        }
                    }
                };

                validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);

                validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

                // For testing
                validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
                    ancestorInfo = ancestorInfo || emptyAncestorInfo;
                    var parentInfo = ancestorInfo.parentTag;
                    var parentTag = parentInfo && parentInfo.tag;
                    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
                };
            }

            module.exports = validateDOMNesting;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 145 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDefaultInjection
         */

        'use strict';

            var BeforeInputEventPlugin = __webpack_require__(146);
            var ChangeEventPlugin = __webpack_require__(154);
            var ClientReactRootIndex = __webpack_require__(157);
            var DefaultEventPluginOrder = __webpack_require__(158);
            var EnterLeaveEventPlugin = __webpack_require__(159);
            var ExecutionEnvironment = __webpack_require__(83);
            var HTMLDOMPropertyConfig = __webpack_require__(163);
            var ReactBrowserComponentMixin = __webpack_require__(164);
            var ReactComponentBrowserEnvironment = __webpack_require__(100);
            var ReactDefaultBatchingStrategy = __webpack_require__(166);
            var ReactDOMComponent = __webpack_require__(167);
            var ReactDOMTextComponent = __webpack_require__(80);
            var ReactEventListener = __webpack_require__(192);
            var ReactInjection = __webpack_require__(195);
            var ReactInstanceHandles = __webpack_require__(119);
            var ReactMount = __webpack_require__(102);
            var ReactReconcileTransaction = __webpack_require__(199);
            var SelectEventPlugin = __webpack_require__(204);
            var ServerReactRootIndex = __webpack_require__(205);
            var SimpleEventPlugin = __webpack_require__(206);
            var SVGDOMPropertyConfig = __webpack_require__(215);

            var alreadyInjected = false;

            function inject() {
                if (alreadyInjected) {
                    // TODO: This is currently true because these injections are shared between
                    // the client and the server package. They should be built independently
                    // and not share any injection state. Then this problem will be solved.
                    return;
                }
                alreadyInjected = true;

                ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

                /**
                 * Inject modules for resolving DOM hierarchy and plugin ordering.
                 */
                ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
                ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
                ReactInjection.EventPluginHub.injectMount(ReactMount);

                /**
                 * Some important event plugins included by default (without having to require
                 * them).
                 */
                ReactInjection.EventPluginHub.injectEventPluginsByName({
                    SimpleEventPlugin: SimpleEventPlugin,
                    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
                    ChangeEventPlugin: ChangeEventPlugin,
                    SelectEventPlugin: SelectEventPlugin,
                    BeforeInputEventPlugin: BeforeInputEventPlugin
                });

                ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

                ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

                ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);

                ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
                ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

                ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

                ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
                ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

                ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);

                ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

                if (process.env.NODE_ENV !== 'production') {
                    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
                    if (/[?&]react_perf\b/.test(url)) {
                        var ReactDefaultPerf = __webpack_require__(216);
                        ReactDefaultPerf.start();
                    }
                }
            }

            module.exports = {
                inject: inject
            };
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 146 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015 Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule BeforeInputEventPlugin
         * @typechecks static-only
         */

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        var EventConstants = __webpack_require__(104);
        var EventPropagators = __webpack_require__(147);
        var ExecutionEnvironment = __webpack_require__(83);
        var FallbackCompositionState = __webpack_require__(148);
        var SyntheticCompositionEvent = __webpack_require__(150);
        var SyntheticInputEvent = __webpack_require__(152);

        var keyOf = __webpack_require__(153);

        var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
        var START_KEYCODE = 229;

        var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

        var documentMode = null;
        if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
            documentMode = document.documentMode;
        }

        // Webkit offers a very useful `textInput` event that can be used to
        // directly represent `beforeInput`. The IE `textinput` event is not as
        // useful, so we don't use it.
        var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

        // In IE9+, we have access to composition events, but the data supplied
        // by the native compositionend event may be incorrect. Japanese ideographic
        // spaces, for instance (\u3000) are not recorded correctly.
        var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

        /**
         * Opera <= 12 includes TextEvent in window, but does not fire
         * text input events. Rely on keypress instead.
         */
        function isPresto() {
            var opera = window.opera;
            return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
        }

        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

        var topLevelTypes = EventConstants.topLevelTypes;

        // Events and their corresponding property names.
        var eventTypes = {
            beforeInput: {
                phasedRegistrationNames: {
                    bubbled: keyOf({ onBeforeInput: null }),
                    captured: keyOf({ onBeforeInputCapture: null })
                },
                dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
            },
            compositionEnd: {
                phasedRegistrationNames: {
                    bubbled: keyOf({ onCompositionEnd: null }),
                    captured: keyOf({ onCompositionEndCapture: null })
                },
                dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
            },
            compositionStart: {
                phasedRegistrationNames: {
                    bubbled: keyOf({ onCompositionStart: null }),
                    captured: keyOf({ onCompositionStartCapture: null })
                },
                dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
            },
            compositionUpdate: {
                phasedRegistrationNames: {
                    bubbled: keyOf({ onCompositionUpdate: null }),
                    captured: keyOf({ onCompositionUpdateCapture: null })
                },
                dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
            }
        };

        // Track whether we've ever handled a keypress on the space key.
        var hasSpaceKeypress = false;

        /**
         * Return whether a native keypress event is assumed to be a command.
         * This is required because Firefox fires `keypress` events for key commands
         * (cut, copy, select-all, etc.) even though no character is inserted.
         */
        function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
                // ctrlKey && altKey is equivalent to AltGr, and is not a command.
                !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }

        /**
         * Translate native top level events into event types.
         *
         * @param {string} topLevelType
         * @return {object}
         */
        function getCompositionEventType(topLevelType) {
            switch (topLevelType) {
                case topLevelTypes.topCompositionStart:
                    return eventTypes.compositionStart;
                case topLevelTypes.topCompositionEnd:
                    return eventTypes.compositionEnd;
                case topLevelTypes.topCompositionUpdate:
                    return eventTypes.compositionUpdate;
            }
        }

        /**
         * Does our fallback best-guess model think this event signifies that
         * composition has begun?
         *
         * @param {string} topLevelType
         * @param {object} nativeEvent
         * @return {boolean}
         */
        function isFallbackCompositionStart(topLevelType, nativeEvent) {
            return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
        }

        /**
         * Does our fallback mode think that this event is the end of composition?
         *
         * @param {string} topLevelType
         * @param {object} nativeEvent
         * @return {boolean}
         */
        function isFallbackCompositionEnd(topLevelType, nativeEvent) {
            switch (topLevelType) {
                case topLevelTypes.topKeyUp:
                    // Command keys insert or clear IME input.
                    return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
                case topLevelTypes.topKeyDown:
                    // Expect IME keyCode on each keydown. If we get any other
                    // code we must have exited earlier.
                    return nativeEvent.keyCode !== START_KEYCODE;
                case topLevelTypes.topKeyPress:
                case topLevelTypes.topMouseDown:
                case topLevelTypes.topBlur:
                    // Events are not possible without cancelling IME.
                    return true;
                default:
                    return false;
            }
        }

        /**
         * Google Input Tools provides composition data via a CustomEvent,
         * with the `data` property populated in the `detail` object. If this
         * is available on the event object, use it. If not, this is a plain
         * composition event and we have nothing special to extract.
         *
         * @param {object} nativeEvent
         * @return {?string}
         */
        function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
                return detail.data;
            }
            return null;
        }

        // Track the current IME composition fallback object, if any.
        var currentComposition = null;

        /**
         * @param {string} topLevelType Record from `EventConstants`.
         * @param {DOMEventTarget} topLevelTarget The listening component root node.
         * @param {string} topLevelTargetID ID of `topLevelTarget`.
         * @param {object} nativeEvent Native browser event.
         * @return {?object} A SyntheticCompositionEvent.
         */
        function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;

            if (canUseCompositionEvent) {
                eventType = getCompositionEventType(topLevelType);
            } else if (!currentComposition) {
                if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
                    eventType = eventTypes.compositionStart;
                }
            } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                eventType = eventTypes.compositionEnd;
            }

            if (!eventType) {
                return null;
            }

            if (useFallbackCompositionData) {
                // The current composition is stored statically and must not be
                // overwritten while composition continues.
                if (!currentComposition && eventType === eventTypes.compositionStart) {
                    currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
                } else if (eventType === eventTypes.compositionEnd) {
                    if (currentComposition) {
                        fallbackData = currentComposition.getData();
                    }
                }
            }

            var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);

            if (fallbackData) {
                // Inject data generated from fallback path into the synthetic event.
                // This matches the property of native CompositionEventInterface.
                event.data = fallbackData;
            } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                    event.data = customData;
                }
            }

            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
        }

        /**
         * @param {string} topLevelType Record from `EventConstants`.
         * @param {object} nativeEvent Native browser event.
         * @return {?string} The string corresponding to this `beforeInput` event.
         */
        function getNativeBeforeInputChars(topLevelType, nativeEvent) {
            switch (topLevelType) {
                case topLevelTypes.topCompositionEnd:
                    return getDataFromCustomEvent(nativeEvent);
                case topLevelTypes.topKeyPress:
                    /**
                     * If native `textInput` events are available, our goal is to make
                     * use of them. However, there is a special case: the spacebar key.
                     * In Webkit, preventing default on a spacebar `textInput` event
                     * cancels character insertion, but it *also* causes the browser
                     * to fall back to its default spacebar behavior of scrolling the
                     * page.
                     *
                     * Tracking at:
                     * https://code.google.com/p/chromium/issues/detail?id=355103
                     *
                     * To avoid this issue, use the keypress event as if no `textInput`
                     * event is available.
                     */
                    var which = nativeEvent.which;
                    if (which !== SPACEBAR_CODE) {
                        return null;
                    }

                    hasSpaceKeypress = true;
                    return SPACEBAR_CHAR;

                case topLevelTypes.topTextInput:
                    // Record the characters to be added to the DOM.
                    var chars = nativeEvent.data;

                    // If it's a spacebar character, assume that we have already handled
                    // it at the keypress level and bail immediately. Android Chrome
                    // doesn't give us keycodes, so we need to blacklist it.
                    if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                        return null;
                    }

                    return chars;

                default:
                    // For other native event types, do nothing.
                    return null;
            }
        }

        /**
         * For browsers that do not provide the `textInput` event, extract the
         * appropriate string to use for SyntheticInputEvent.
         *
         * @param {string} topLevelType Record from `EventConstants`.
         * @param {object} nativeEvent Native browser event.
         * @return {?string} The fallback string for this `beforeInput` event.
         */
        function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
            // If we are currently composing (IME) and using a fallback to do so,
            // try to extract the composed characters from the fallback object.
            if (currentComposition) {
                if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                    var chars = currentComposition.getData();
                    FallbackCompositionState.release(currentComposition);
                    currentComposition = null;
                    return chars;
                }
                return null;
            }

            switch (topLevelType) {
                case topLevelTypes.topPaste:
                    // If a paste event occurs after a keypress, throw out the input
                    // chars. Paste events should not lead to BeforeInput events.
                    return null;
                case topLevelTypes.topKeyPress:
                    /**
                     * As of v27, Firefox may fire keypress events even when no character
                     * will be inserted. A few possibilities:
                     *
                     * - `which` is `0`. Arrow keys, Esc key, etc.
                     *
                     * - `which` is the pressed key code, but no char is available.
                     *   Ex: 'AltGr + d` in Polish. There is no modified character for
                     *   this key combination and no character is inserted into the
                     *   document, but FF fires the keypress for char code `100` anyway.
                     *   No `input` event will occur.
                     *
                     * - `which` is the pressed key code, but a command combination is
                     *   being used. Ex: `Cmd+C`. No character is inserted, and no
                     *   `input` event will occur.
                     */
                    if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
                        return String.fromCharCode(nativeEvent.which);
                    }
                    return null;
                case topLevelTypes.topCompositionEnd:
                    return useFallbackCompositionData ? null : nativeEvent.data;
                default:
                    return null;
            }
        }

        /**
         * Extract a SyntheticInputEvent for `beforeInput`, based on either native
         * `textInput` or fallback behavior.
         *
         * @param {string} topLevelType Record from `EventConstants`.
         * @param {DOMEventTarget} topLevelTarget The listening component root node.
         * @param {string} topLevelTargetID ID of `topLevelTarget`.
         * @param {object} nativeEvent Native browser event.
         * @return {?object} A SyntheticInputEvent.
         */
        function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
            var chars;

            if (canUseTextInputEvent) {
                chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
            } else {
                chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
            }

            // If no characters are being inserted, no BeforeInput event should
            // be fired.
            if (!chars) {
                return null;
            }

            var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);

            event.data = chars;
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
        }

        /**
         * Create an `onBeforeInput` event to match
         * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
         *
         * This event plugin is based on the native `textInput` event
         * available in Chrome, Safari, Opera, and IE. This event fires after
         * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
         *
         * `beforeInput` is spec'd but not implemented in any browsers, and
         * the `input` event does not provide any useful information about what has
         * actually been added, contrary to the spec. Thus, `textInput` is the best
         * available event to identify the characters that have actually been inserted
         * into the target node.
         *
         * This plugin is also responsible for emitting `composition` events, thus
         * allowing us to share composition fallback code for both `beforeInput` and
         * `composition` event types.
         */
        var BeforeInputEventPlugin = {

            eventTypes: eventTypes,

            /**
             * @param {string} topLevelType Record from `EventConstants`.
             * @param {DOMEventTarget} topLevelTarget The listening component root node.
             * @param {string} topLevelTargetID ID of `topLevelTarget`.
             * @param {object} nativeEvent Native browser event.
             * @return {*} An accumulation of synthetic events.
             * @see {EventPluginHub.extractEvents}
             */
            extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
                return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
            }
        };

        module.exports = BeforeInputEventPlugin;

        /***/ },
    /* 147 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule EventPropagators
         */

        'use strict';

            var EventConstants = __webpack_require__(104);
            var EventPluginHub = __webpack_require__(105);

            var warning = __webpack_require__(99);

            var accumulateInto = __webpack_require__(109);
            var forEachAccumulated = __webpack_require__(110);

            var PropagationPhases = EventConstants.PropagationPhases;
            var getListener = EventPluginHub.getListener;

            /**
             * Some event types have a notion of different registration names for different
             * "phases" of propagation. This finds listeners by a given phase.
             */
            function listenerAtPhase(id, event, propagationPhase) {
                var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
                return getListener(id, registrationName);
            }

            /**
             * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
             * here, allows us to not have to bind or create functions for each event.
             * Mutating the event's members allows us to not have to create a wrapping
             * "dispatch" object that pairs the event with the listener.
             */
            function accumulateDirectionalDispatches(domID, upwards, event) {
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
                }
                var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
                var listener = listenerAtPhase(domID, event, phase);
                if (listener) {
                    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
                }
            }

            /**
             * Collect dispatches (must be entirely collected before dispatching - see unit
             * tests). Lazily allocate the array to conserve memory.  We must loop through
             * each event and perform the traversal for each one. We cannot perform a
             * single traversal for the entire collection of events because each event may
             * have a different target.
             */
            function accumulateTwoPhaseDispatchesSingle(event) {
                if (event && event.dispatchConfig.phasedRegistrationNames) {
                    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
                }
            }

            /**
             * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
             */
            function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
                if (event && event.dispatchConfig.phasedRegistrationNames) {
                    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
                }
            }

            /**
             * Accumulates without regard to direction, does not look for phased
             * registration names. Same as `accumulateDirectDispatchesSingle` but without
             * requiring that the `dispatchMarker` be the same as the dispatched ID.
             */
            function accumulateDispatches(id, ignoredDirection, event) {
                if (event && event.dispatchConfig.registrationName) {
                    var registrationName = event.dispatchConfig.registrationName;
                    var listener = getListener(id, registrationName);
                    if (listener) {
                        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                        event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
                    }
                }
            }

            /**
             * Accumulates dispatches on an `SyntheticEvent`, but only for the
             * `dispatchMarker`.
             * @param {SyntheticEvent} event
             */
            function accumulateDirectDispatchesSingle(event) {
                if (event && event.dispatchConfig.registrationName) {
                    accumulateDispatches(event.dispatchMarker, null, event);
                }
            }

            function accumulateTwoPhaseDispatches(events) {
                forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
            }

            function accumulateTwoPhaseDispatchesSkipTarget(events) {
                forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
            }

            function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
                EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
            }

            function accumulateDirectDispatches(events) {
                forEachAccumulated(events, accumulateDirectDispatchesSingle);
            }

            /**
             * A small set of propagation patterns, each of which will accept a small amount
             * of information, and generate a set of "dispatch ready event objects" - which
             * are sets of events that have already been annotated with a set of dispatched
             * listener functions/ids. The API is designed this way to discourage these
             * propagation strategies from actually executing the dispatches, since we
             * always want to collect the entire set of dispatches before executing event a
             * single one.
             *
             * @constructor EventPropagators
             */
            var EventPropagators = {
                accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
                accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
                accumulateDirectDispatches: accumulateDirectDispatches,
                accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
            };

            module.exports = EventPropagators;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 148 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule FallbackCompositionState
         * @typechecks static-only
         */

        'use strict';

        var PooledClass = __webpack_require__(130);

        var assign = __webpack_require__(113);
        var getTextContentAccessor = __webpack_require__(149);

        /**
         * This helper class stores information about text content of a target node,
         * allowing comparison of content before and after a given event.
         *
         * Identify the node where selection currently begins, then observe
         * both its text content and its current position in the DOM. Since the
         * browser may natively replace the target node during composition, we can
         * use its position to find its replacement.
         *
         * @param {DOMEventTarget} root
         */
        function FallbackCompositionState(root) {
            this._root = root;
            this._startText = this.getText();
            this._fallbackText = null;
        }

        assign(FallbackCompositionState.prototype, {
            destructor: function destructor() {
                this._root = null;
                this._startText = null;
                this._fallbackText = null;
            },

            /**
             * Get current text of input.
             *
             * @return {string}
             */
            getText: function getText() {
                if ('value' in this._root) {
                    return this._root.value;
                }
                return this._root[getTextContentAccessor()];
            },

            /**
             * Determine the differing substring between the initially stored
             * text content and the current content.
             *
             * @return {string}
             */
            getData: function getData() {
                if (this._fallbackText) {
                    return this._fallbackText;
                }

                var start;
                var startValue = this._startText;
                var startLength = startValue.length;
                var end;
                var endValue = this.getText();
                var endLength = endValue.length;

                for (start = 0; start < startLength; start++) {
                    if (startValue[start] !== endValue[start]) {
                        break;
                    }
                }

                var minEnd = startLength - start;
                for (end = 1; end <= minEnd; end++) {
                    if (startValue[startLength - end] !== endValue[endLength - end]) {
                        break;
                    }
                }

                var sliceTail = end > 1 ? 1 - end : undefined;
                this._fallbackText = endValue.slice(start, sliceTail);
                return this._fallbackText;
            }
        });

        PooledClass.addPoolingTo(FallbackCompositionState);

        module.exports = FallbackCompositionState;

        /***/ },
    /* 149 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getTextContentAccessor
         */

        'use strict';

        var ExecutionEnvironment = __webpack_require__(83);

        var contentKey = null;

        /**
         * Gets the key used to access text content on a DOM node.
         *
         * @return {?string} Key used to access text content.
         * @internal
         */
        function getTextContentAccessor() {
            if (!contentKey && ExecutionEnvironment.canUseDOM) {
                // Prefer textContent to innerText because many browsers support both but
                // SVG <text> elements don't support innerText even when <div> does.
                contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
            }
            return contentKey;
        }

        module.exports = getTextContentAccessor;

        /***/ },
    /* 150 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticCompositionEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticEvent = __webpack_require__(151);

        /**
         * @interface Event
         * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
         */
        var CompositionEventInterface = {
            data: null
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticUIEvent}
         */
        function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

        module.exports = SyntheticCompositionEvent;

        /***/ },
    /* 151 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticEvent
         * @typechecks static-only
         */

        'use strict';

            var PooledClass = __webpack_require__(130);

            var assign = __webpack_require__(113);
            var emptyFunction = __webpack_require__(89);
            var warning = __webpack_require__(99);

            /**
             * @interface Event
             * @see http://www.w3.org/TR/DOM-Level-3-Events/
             */
            var EventInterface = {
                type: null,
                // currentTarget is set when dispatching; no use in copying it here
                currentTarget: emptyFunction.thatReturnsNull,
                eventPhase: null,
                bubbles: null,
                cancelable: null,
                timeStamp: function timeStamp(event) {
                    return event.timeStamp || Date.now();
                },
                defaultPrevented: null,
                isTrusted: null
            };

            /**
             * Synthetic events are dispatched by event plugins, typically in response to a
             * top-level event delegation handler.
             *
             * These systems should generally use pooling to reduce the frequency of garbage
             * collection. The system should check `isPersistent` to determine whether the
             * event should be released into the pool after being dispatched. Users that
             * need a persisted event should invoke `persist`.
             *
             * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
             * normalizing browser quirks. Subclasses do not necessarily have to implement a
             * DOM interface; custom application-specific events can also subclass this.
             *
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             */
            function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
                this.dispatchConfig = dispatchConfig;
                this.dispatchMarker = dispatchMarker;
                this.nativeEvent = nativeEvent;
                this.target = nativeEventTarget;
                this.currentTarget = nativeEventTarget;

                var Interface = this.constructor.Interface;
                for (var propName in Interface) {
                    if (!Interface.hasOwnProperty(propName)) {
                        continue;
                    }
                    var normalize = Interface[propName];
                    if (normalize) {
                        this[propName] = normalize(nativeEvent);
                    } else {
                        this[propName] = nativeEvent[propName];
                    }
                }

                var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
                if (defaultPrevented) {
                    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
                } else {
                    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
                }
                this.isPropagationStopped = emptyFunction.thatReturnsFalse;
            }

            assign(SyntheticEvent.prototype, {

                preventDefault: function preventDefault() {
                    this.defaultPrevented = true;
                    var event = this.nativeEvent;
                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
                    }
                    if (!event) {
                        return;
                    }

                    if (event.preventDefault) {
                        event.preventDefault();
                    } else {
                        event.returnValue = false;
                    }
                    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
                },

                stopPropagation: function stopPropagation() {
                    var event = this.nativeEvent;
                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
                    }
                    if (!event) {
                        return;
                    }

                    if (event.stopPropagation) {
                        event.stopPropagation();
                    } else {
                        event.cancelBubble = true;
                    }
                    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
                },

                /**
                 * We release all dispatched `SyntheticEvent`s after each event loop, adding
                 * them back into the pool. This allows a way to hold onto a reference that
                 * won't be added back into the pool.
                 */
                persist: function persist() {
                    this.isPersistent = emptyFunction.thatReturnsTrue;
                },

                /**
                 * Checks if this event should be released back into the pool.
                 *
                 * @return {boolean} True if this should not be released, false otherwise.
                 */
                isPersistent: emptyFunction.thatReturnsFalse,

                /**
                 * `PooledClass` looks for `destructor` on each instance it releases.
                 */
                destructor: function destructor() {
                    var Interface = this.constructor.Interface;
                    for (var propName in Interface) {
                        this[propName] = null;
                    }
                    this.dispatchConfig = null;
                    this.dispatchMarker = null;
                    this.nativeEvent = null;
                }

            });

            SyntheticEvent.Interface = EventInterface;

            /**
             * Helper to reduce boilerplate when creating subclasses.
             *
             * @param {function} Class
             * @param {?object} Interface
             */
            SyntheticEvent.augmentClass = function (Class, Interface) {
                var Super = this;

                var prototype = Object.create(Super.prototype);
                assign(prototype, Class.prototype);
                Class.prototype = prototype;
                Class.prototype.constructor = Class;

                Class.Interface = assign({}, Super.Interface, Interface);
                Class.augmentClass = Super.augmentClass;

                PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
            };

            PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

            module.exports = SyntheticEvent;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 152 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticInputEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticEvent = __webpack_require__(151);

        /**
         * @interface Event
         * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
         *      /#events-inputevents
         */
        var InputEventInterface = {
            data: null
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticUIEvent}
         */
        function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

        module.exports = SyntheticInputEvent;

        /***/ },
    /* 153 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule keyOf
         */

        /**
         * Allows extraction of a minified key. Let's the build system minify keys
         * without losing the ability to dynamically use key strings as values
         * themselves. Pass in an object with a single key/val pair and it will return
         * you the string key of that single record. Suppose you want to grab the
         * value for a key 'className' inside of an object. Key/val minification may
         * have aliased that key to be 'xa12'. keyOf({className: null}) will return
         * 'xa12' in that case. Resolve keys you want to use once at startup time, then
         * reuse those resolutions.
         */
        "use strict";

        var keyOf = function keyOf(oneKeyObj) {
            var key;
            for (key in oneKeyObj) {
                if (!oneKeyObj.hasOwnProperty(key)) {
                    continue;
                }
                return key;
            }
            return null;
        };

        module.exports = keyOf;

        /***/ },
    /* 154 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ChangeEventPlugin
         */

        'use strict';

        var EventConstants = __webpack_require__(104);
        var EventPluginHub = __webpack_require__(105);
        var EventPropagators = __webpack_require__(147);
        var ExecutionEnvironment = __webpack_require__(83);
        var ReactUpdates = __webpack_require__(128);
        var SyntheticEvent = __webpack_require__(151);

        var getEventTarget = __webpack_require__(155);
        var isEventSupported = __webpack_require__(114);
        var isTextInputElement = __webpack_require__(156);
        var keyOf = __webpack_require__(153);

        var topLevelTypes = EventConstants.topLevelTypes;

        var eventTypes = {
            change: {
                phasedRegistrationNames: {
                    bubbled: keyOf({ onChange: null }),
                    captured: keyOf({ onChangeCapture: null })
                },
                dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
            }
        };

        /**
         * For IE shims
         */
        var activeElement = null;
        var activeElementID = null;
        var activeElementValue = null;
        var activeElementValueProp = null;

        /**
         * SECTION: handle `change` event
         */
        function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
        }

        var doesChangeEventBubble = false;
        if (ExecutionEnvironment.canUseDOM) {
            // See `handleChange` comment below
            doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
        }

        function manualDispatchChangeEvent(nativeEvent) {
            var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
            EventPropagators.accumulateTwoPhaseDispatches(event);

            // If change and propertychange bubbled, we'd just bind to it like all the
            // other events and have it go through ReactBrowserEventEmitter. Since it
            // doesn't, we manually listen for the events and so we have to enqueue and
            // process the abstract event manually.
            //
            // Batching is necessary here in order to ensure that all event handlers run
            // before the next rerender (including event handlers attached to ancestor
            // elements instead of directly on the input). Without this, controlled
            // components don't work properly in conjunction with event bubbling because
            // the component is rerendered and the value reverted before all the event
            // handlers can run. See https://github.com/facebook/react/issues/708.
            ReactUpdates.batchedUpdates(runEventInBatch, event);
        }

        function runEventInBatch(event) {
            EventPluginHub.enqueueEvents(event);
            EventPluginHub.processEventQueue(false);
        }

        function startWatchingForChangeEventIE8(target, targetID) {
            activeElement = target;
            activeElementID = targetID;
            activeElement.attachEvent('onchange', manualDispatchChangeEvent);
        }

        function stopWatchingForChangeEventIE8() {
            if (!activeElement) {
                return;
            }
            activeElement.detachEvent('onchange', manualDispatchChangeEvent);
            activeElement = null;
            activeElementID = null;
        }

        function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topChange) {
                return topLevelTargetID;
            }
        }
        function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topFocus) {
                // stopWatching() should be a noop here but we call it just in case we
                // missed a blur event somehow.
                stopWatchingForChangeEventIE8();
                startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
            } else if (topLevelType === topLevelTypes.topBlur) {
                stopWatchingForChangeEventIE8();
            }
        }

        /**
         * SECTION: handle `input` event
         */
        var isInputEventSupported = false;
        if (ExecutionEnvironment.canUseDOM) {
            // IE9 claims to support the input event but fails to trigger it when
            // deleting text, so we ignore its input events
            isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
        }

        /**
         * (For old IE.) Replacement getter/setter for the `value` property that gets
         * set on the active element.
         */
        var newValueProp = {
            get: function get() {
                return activeElementValueProp.get.call(this);
            },
            set: function set(val) {
                // Cast to a string so we can do equality checks.
                activeElementValue = '' + val;
                activeElementValueProp.set.call(this, val);
            }
        };

        /**
         * (For old IE.) Starts tracking propertychange events on the passed-in element
         * and override the value property so that we can distinguish user events from
         * value changes in JS.
         */
        function startWatchingForValueChange(target, targetID) {
            activeElement = target;
            activeElementID = targetID;
            activeElementValue = target.value;
            activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

            // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
            // on DOM elements
            Object.defineProperty(activeElement, 'value', newValueProp);
            activeElement.attachEvent('onpropertychange', handlePropertyChange);
        }

        /**
         * (For old IE.) Removes the event listeners from the currently-tracked element,
         * if any exists.
         */
        function stopWatchingForValueChange() {
            if (!activeElement) {
                return;
            }

            // delete restores the original property definition
            delete activeElement.value;
            activeElement.detachEvent('onpropertychange', handlePropertyChange);

            activeElement = null;
            activeElementID = null;
            activeElementValue = null;
            activeElementValueProp = null;
        }

        /**
         * (For old IE.) Handles a propertychange event, sending a `change` event if
         * the value of the active element has changed.
         */
        function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== 'value') {
                return;
            }
            var value = nativeEvent.srcElement.value;
            if (value === activeElementValue) {
                return;
            }
            activeElementValue = value;

            manualDispatchChangeEvent(nativeEvent);
        }

        /**
         * If a `change` event should be fired, returns the target's ID.
         */
        function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topInput) {
                // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
                // what we want so fall through here and trigger an abstract event
                return topLevelTargetID;
            }
        }

        // For IE8 and IE9.
        function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topFocus) {
                // In IE8, we can capture almost all .value changes by adding a
                // propertychange handler and looking for events with propertyName
                // equal to 'value'
                // In IE9, propertychange fires for most input events but is buggy and
                // doesn't fire when text is deleted, but conveniently, selectionchange
                // appears to fire in all of the remaining cases so we catch those and
                // forward the event if the value has changed
                // In either case, we don't want to call the event handler if the value
                // is changed from JS so we redefine a setter for `.value` that updates
                // our activeElementValue variable, allowing us to ignore those changes
                //
                // stopWatching() should be a noop here but we call it just in case we
                // missed a blur event somehow.
                stopWatchingForValueChange();
                startWatchingForValueChange(topLevelTarget, topLevelTargetID);
            } else if (topLevelType === topLevelTypes.topBlur) {
                stopWatchingForValueChange();
            }
        }

        // For IE8 and IE9.
        function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
                // On the selectionchange event, the target is just document which isn't
                // helpful for us so just check activeElement instead.
                //
                // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
                // propertychange on the first input event after setting `value` from a
                // script and fires only keydown, keypress, keyup. Catching keyup usually
                // gets it and catching keydown lets us fire an event for the first
                // keystroke if user does a key repeat (it'll be a little delayed: right
                // before the second keystroke). Other input methods (e.g., paste) seem to
                // fire selectionchange normally.
                if (activeElement && activeElement.value !== activeElementValue) {
                    activeElementValue = activeElement.value;
                    return activeElementID;
                }
            }
        }

        /**
         * SECTION: handle `click` event
         */
        function shouldUseClickEvent(elem) {
            // Use the `click` event to detect changes to checkbox and radio inputs.
            // This approach works across all browsers, whereas `change` does not fire
            // until `blur` in IE8.
            return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
        }

        function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
            if (topLevelType === topLevelTypes.topClick) {
                return topLevelTargetID;
            }
        }

        /**
         * This plugin creates an `onChange` event that normalizes change events
         * across form elements. This event fires at a time when it's possible to
         * change the element's value without seeing a flicker.
         *
         * Supported elements are:
         * - input (see `isTextInputElement`)
         * - textarea
         * - select
         */
        var ChangeEventPlugin = {

            eventTypes: eventTypes,

            /**
             * @param {string} topLevelType Record from `EventConstants`.
             * @param {DOMEventTarget} topLevelTarget The listening component root node.
             * @param {string} topLevelTargetID ID of `topLevelTarget`.
             * @param {object} nativeEvent Native browser event.
             * @return {*} An accumulation of synthetic events.
             * @see {EventPluginHub.extractEvents}
             */
            extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {

                var getTargetIDFunc, handleEventFunc;
                if (shouldUseChangeEvent(topLevelTarget)) {
                    if (doesChangeEventBubble) {
                        getTargetIDFunc = getTargetIDForChangeEvent;
                    } else {
                        handleEventFunc = handleEventsForChangeEventIE8;
                    }
                } else if (isTextInputElement(topLevelTarget)) {
                    if (isInputEventSupported) {
                        getTargetIDFunc = getTargetIDForInputEvent;
                    } else {
                        getTargetIDFunc = getTargetIDForInputEventIE;
                        handleEventFunc = handleEventsForInputEventIE;
                    }
                } else if (shouldUseClickEvent(topLevelTarget)) {
                    getTargetIDFunc = getTargetIDForClickEvent;
                }

                if (getTargetIDFunc) {
                    var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
                    if (targetID) {
                        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
                        event.type = 'change';
                        EventPropagators.accumulateTwoPhaseDispatches(event);
                        return event;
                    }
                }

                if (handleEventFunc) {
                    handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
                }
            }

        };

        module.exports = ChangeEventPlugin;

        /***/ },
    /* 155 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getEventTarget
         * @typechecks static-only
         */

        'use strict';

        /**
         * Gets the target node from a native browser event by accounting for
         * inconsistencies in browser DOM APIs.
         *
         * @param {object} nativeEvent Native browser event.
         * @return {DOMEventTarget} Target node.
         */

        function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
            // @see http://www.quirksmode.org/js/events_properties.html
            return target.nodeType === 3 ? target.parentNode : target;
        }

        module.exports = getEventTarget;

        /***/ },
    /* 156 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule isTextInputElement
         */

        'use strict';

        /**
         * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
         */

        var supportedInputTypes = {
            'color': true,
            'date': true,
            'datetime': true,
            'datetime-local': true,
            'email': true,
            'month': true,
            'number': true,
            'password': true,
            'range': true,
            'search': true,
            'tel': true,
            'text': true,
            'time': true,
            'url': true,
            'week': true
        };

        function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
        }

        module.exports = isTextInputElement;

        /***/ },
    /* 157 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ClientReactRootIndex
         * @typechecks
         */

        'use strict';

        var nextReactRootIndex = 0;

        var ClientReactRootIndex = {
            createReactRootIndex: function createReactRootIndex() {
                return nextReactRootIndex++;
            }
        };

        module.exports = ClientReactRootIndex;

        /***/ },
    /* 158 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule DefaultEventPluginOrder
         */

        'use strict';

        var keyOf = __webpack_require__(153);

        /**
         * Module that is injectable into `EventPluginHub`, that specifies a
         * deterministic ordering of `EventPlugin`s. A convenient way to reason about
         * plugins, without having to package every one of them. This is better than
         * having plugins be ordered in the same order that they are injected because
         * that ordering would be influenced by the packaging order.
         * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
         * preventing default on events is convenient in `SimpleEventPlugin` handlers.
         */
        var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];

        module.exports = DefaultEventPluginOrder;

        /***/ },
    /* 159 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule EnterLeaveEventPlugin
         * @typechecks static-only
         */

        'use strict';

        var EventConstants = __webpack_require__(104);
        var EventPropagators = __webpack_require__(147);
        var SyntheticMouseEvent = __webpack_require__(160);

        var ReactMount = __webpack_require__(102);
        var keyOf = __webpack_require__(153);

        var topLevelTypes = EventConstants.topLevelTypes;
        var getFirstReactDOM = ReactMount.getFirstReactDOM;

        var eventTypes = {
            mouseEnter: {
                registrationName: keyOf({ onMouseEnter: null }),
                dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
            },
            mouseLeave: {
                registrationName: keyOf({ onMouseLeave: null }),
                dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
            }
        };

        var extractedEvents = [null, null];

        var EnterLeaveEventPlugin = {

            eventTypes: eventTypes,

            /**
             * For almost every interaction we care about, there will be both a top-level
             * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
             * we do not extract duplicate events. However, moving the mouse into the
             * browser from outside will not fire a `mouseout` event. In this case, we use
             * the `mouseover` top-level event.
             *
             * @param {string} topLevelType Record from `EventConstants`.
             * @param {DOMEventTarget} topLevelTarget The listening component root node.
             * @param {string} topLevelTargetID ID of `topLevelTarget`.
             * @param {object} nativeEvent Native browser event.
             * @return {*} An accumulation of synthetic events.
             * @see {EventPluginHub.extractEvents}
             */
            extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
                if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
                    return null;
                }
                if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
                    // Must not be a mouse in or mouse out - ignoring.
                    return null;
                }

                var win;
                if (topLevelTarget.window === topLevelTarget) {
                    // `topLevelTarget` is probably a window object.
                    win = topLevelTarget;
                } else {
                    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
                    var doc = topLevelTarget.ownerDocument;
                    if (doc) {
                        win = doc.defaultView || doc.parentWindow;
                    } else {
                        win = window;
                    }
                }

                var from;
                var to;
                var fromID = '';
                var toID = '';
                if (topLevelType === topLevelTypes.topMouseOut) {
                    from = topLevelTarget;
                    fromID = topLevelTargetID;
                    to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
                    if (to) {
                        toID = ReactMount.getID(to);
                    } else {
                        to = win;
                    }
                    to = to || win;
                } else {
                    from = win;
                    to = topLevelTarget;
                    toID = topLevelTargetID;
                }

                if (from === to) {
                    // Nothing pertains to our managed components.
                    return null;
                }

                var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
                leave.type = 'mouseleave';
                leave.target = from;
                leave.relatedTarget = to;

                var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
                enter.type = 'mouseenter';
                enter.target = to;
                enter.relatedTarget = from;

                EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

                extractedEvents[0] = leave;
                extractedEvents[1] = enter;

                return extractedEvents;
            }

        };

        module.exports = EnterLeaveEventPlugin;

        /***/ },
    /* 160 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticMouseEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticUIEvent = __webpack_require__(161);
        var ViewportMetrics = __webpack_require__(112);

        var getEventModifierState = __webpack_require__(162);

        /**
         * @interface MouseEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var MouseEventInterface = {
            screenX: null,
            screenY: null,
            clientX: null,
            clientY: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            getModifierState: getEventModifierState,
            button: function button(event) {
                // Webkit, Firefox, IE9+
                // which:  1 2 3
                // button: 0 1 2 (standard)
                var button = event.button;
                if ('which' in event) {
                    return button;
                }
                // IE<9
                // which:  undefined
                // button: 0 0 0
                // button: 1 4 2 (onmouseup)
                return button === 2 ? 2 : button === 4 ? 1 : 0;
            },
            buttons: null,
            relatedTarget: function relatedTarget(event) {
                return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
            },
            // "Proprietary" Interface.
            pageX: function pageX(event) {
                return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
            },
            pageY: function pageY(event) {
                return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
            }
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticUIEvent}
         */
        function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

        module.exports = SyntheticMouseEvent;

        /***/ },
    /* 161 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticUIEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticEvent = __webpack_require__(151);

        var getEventTarget = __webpack_require__(155);

        /**
         * @interface UIEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var UIEventInterface = {
            view: function view(event) {
                if (event.view) {
                    return event.view;
                }

                var target = getEventTarget(event);
                if (target != null && target.window === target) {
                    // target is a window object
                    return target;
                }

                var doc = target.ownerDocument;
                // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
                if (doc) {
                    return doc.defaultView || doc.parentWindow;
                } else {
                    return window;
                }
            },
            detail: function detail(event) {
                return event.detail || 0;
            }
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticEvent}
         */
        function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

        module.exports = SyntheticUIEvent;

        /***/ },
    /* 162 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getEventModifierState
         * @typechecks static-only
         */

        'use strict';

        /**
         * Translation from modifier key to the associated property in the event.
         * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
         */

        var modifierKeyToProp = {
            'Alt': 'altKey',
            'Control': 'ctrlKey',
            'Meta': 'metaKey',
            'Shift': 'shiftKey'
        };

        // IE8 does not implement getModifierState so we simply map it to the only
        // modifier keys exposed by the event itself, does not support Lock-keys.
        // Currently, all major browsers except Chrome seems to support Lock-keys.
        function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
                return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
        }

        function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
        }

        module.exports = getEventModifierState;

        /***/ },
    /* 163 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule HTMLDOMPropertyConfig
         */

        'use strict';

        var DOMProperty = __webpack_require__(97);
        var ExecutionEnvironment = __webpack_require__(83);

        var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
        var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
        var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
        var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
        var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
        var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
        var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

        var hasSVG;
        if (ExecutionEnvironment.canUseDOM) {
            var implementation = document.implementation;
            hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
        }

        var HTMLDOMPropertyConfig = {
            isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
            Properties: {
                /**
                 * Standard Properties
                 */
                accept: null,
                acceptCharset: null,
                accessKey: null,
                action: null,
                allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                allowTransparency: MUST_USE_ATTRIBUTE,
                alt: null,
                async: HAS_BOOLEAN_VALUE,
                autoComplete: null,
                // autoFocus is polyfilled/normalized by AutoFocusUtils
                // autoFocus: HAS_BOOLEAN_VALUE,
                autoPlay: HAS_BOOLEAN_VALUE,
                capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                cellPadding: null,
                cellSpacing: null,
                charSet: MUST_USE_ATTRIBUTE,
                challenge: MUST_USE_ATTRIBUTE,
                checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                classID: MUST_USE_ATTRIBUTE,
                // To set className on SVG elements, it's necessary to use .setAttribute;
                // this works on HTML elements too in all browsers except IE8. Conveniently,
                // IE8 doesn't support SVG and so we can simply use the attribute in
                // browsers that support SVG and the property in browsers that don't,
                // regardless of whether the element is HTML or SVG.
                className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
                cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
                colSpan: null,
                content: null,
                contentEditable: null,
                contextMenu: MUST_USE_ATTRIBUTE,
                controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                coords: null,
                crossOrigin: null,
                data: null, // For `<object />` acts as `src`.
                dateTime: MUST_USE_ATTRIBUTE,
                'default': HAS_BOOLEAN_VALUE,
                defer: HAS_BOOLEAN_VALUE,
                dir: null,
                disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                download: HAS_OVERLOADED_BOOLEAN_VALUE,
                draggable: null,
                encType: null,
                form: MUST_USE_ATTRIBUTE,
                formAction: MUST_USE_ATTRIBUTE,
                formEncType: MUST_USE_ATTRIBUTE,
                formMethod: MUST_USE_ATTRIBUTE,
                formNoValidate: HAS_BOOLEAN_VALUE,
                formTarget: MUST_USE_ATTRIBUTE,
                frameBorder: MUST_USE_ATTRIBUTE,
                headers: null,
                height: MUST_USE_ATTRIBUTE,
                hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                high: null,
                href: null,
                hrefLang: null,
                htmlFor: null,
                httpEquiv: null,
                icon: null,
                id: MUST_USE_PROPERTY,
                inputMode: MUST_USE_ATTRIBUTE,
                integrity: null,
                is: MUST_USE_ATTRIBUTE,
                keyParams: MUST_USE_ATTRIBUTE,
                keyType: MUST_USE_ATTRIBUTE,
                kind: null,
                label: null,
                lang: null,
                list: MUST_USE_ATTRIBUTE,
                loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                low: null,
                manifest: MUST_USE_ATTRIBUTE,
                marginHeight: null,
                marginWidth: null,
                max: null,
                maxLength: MUST_USE_ATTRIBUTE,
                media: MUST_USE_ATTRIBUTE,
                mediaGroup: null,
                method: null,
                min: null,
                minLength: MUST_USE_ATTRIBUTE,
                multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                name: null,
                nonce: MUST_USE_ATTRIBUTE,
                noValidate: HAS_BOOLEAN_VALUE,
                open: HAS_BOOLEAN_VALUE,
                optimum: null,
                pattern: null,
                placeholder: null,
                poster: null,
                preload: null,
                radioGroup: null,
                readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                rel: null,
                required: HAS_BOOLEAN_VALUE,
                reversed: HAS_BOOLEAN_VALUE,
                role: MUST_USE_ATTRIBUTE,
                rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
                rowSpan: null,
                sandbox: null,
                scope: null,
                scoped: HAS_BOOLEAN_VALUE,
                scrolling: null,
                seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                shape: null,
                size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
                sizes: MUST_USE_ATTRIBUTE,
                span: HAS_POSITIVE_NUMERIC_VALUE,
                spellCheck: null,
                src: null,
                srcDoc: MUST_USE_PROPERTY,
                srcLang: null,
                srcSet: MUST_USE_ATTRIBUTE,
                start: HAS_NUMERIC_VALUE,
                step: null,
                style: null,
                summary: null,
                tabIndex: null,
                target: null,
                title: null,
                type: null,
                useMap: null,
                value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
                width: MUST_USE_ATTRIBUTE,
                wmode: MUST_USE_ATTRIBUTE,
                wrap: null,

                /**
                 * RDFa Properties
                 */
                about: MUST_USE_ATTRIBUTE,
                datatype: MUST_USE_ATTRIBUTE,
                inlist: MUST_USE_ATTRIBUTE,
                prefix: MUST_USE_ATTRIBUTE,
                // property is also supported for OpenGraph in meta tags.
                property: MUST_USE_ATTRIBUTE,
                resource: MUST_USE_ATTRIBUTE,
                'typeof': MUST_USE_ATTRIBUTE,
                vocab: MUST_USE_ATTRIBUTE,

                /**
                 * Non-standard Properties
                 */
                // autoCapitalize and autoCorrect are supported in Mobile Safari for
                // keyboard hints.
                autoCapitalize: MUST_USE_ATTRIBUTE,
                autoCorrect: MUST_USE_ATTRIBUTE,
                // autoSave allows WebKit/Blink to persist values of input fields on page reloads
                autoSave: null,
                // color is for Safari mask-icon link
                color: null,
                // itemProp, itemScope, itemType are for
                // Microdata support. See http://schema.org/docs/gs.html
                itemProp: MUST_USE_ATTRIBUTE,
                itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
                itemType: MUST_USE_ATTRIBUTE,
                // itemID and itemRef are for Microdata support as well but
                // only specified in the the WHATWG spec document. See
                // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
                itemID: MUST_USE_ATTRIBUTE,
                itemRef: MUST_USE_ATTRIBUTE,
                // results show looking glass icon and recent searches on input
                // search fields in WebKit/Blink
                results: null,
                // IE-only attribute that specifies security restrictions on an iframe
                // as an alternative to the sandbox attribute on IE<10
                security: MUST_USE_ATTRIBUTE,
                // IE-only attribute that controls focus behavior
                unselectable: MUST_USE_ATTRIBUTE
            },
            DOMAttributeNames: {
                acceptCharset: 'accept-charset',
                className: 'class',
                htmlFor: 'for',
                httpEquiv: 'http-equiv'
            },
            DOMPropertyNames: {
                autoComplete: 'autocomplete',
                autoFocus: 'autofocus',
                autoPlay: 'autoplay',
                autoSave: 'autosave',
                // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
                // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
                encType: 'encoding',
                hrefLang: 'hreflang',
                radioGroup: 'radiogroup',
                spellCheck: 'spellcheck',
                srcDoc: 'srcdoc',
                srcSet: 'srcset'
            }
        };

        module.exports = HTMLDOMPropertyConfig;

        /***/ },
    /* 164 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactBrowserComponentMixin
         */

        'use strict';

            var ReactInstanceMap = __webpack_require__(121);

            var findDOMNode = __webpack_require__(165);
            var warning = __webpack_require__(99);

            var didWarnKey = '_getDOMNodeDidWarn';

            var ReactBrowserComponentMixin = {
                /**
                 * Returns the DOM node rendered by this component.
                 *
                 * @return {DOMElement} The root node of this component.
                 * @final
                 * @protected
                 */
                getDOMNode: function getDOMNode() {
                    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
                    this.constructor[didWarnKey] = true;
                    return findDOMNode(this);
                }
            };

            module.exports = ReactBrowserComponentMixin;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 165 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule findDOMNode
         * @typechecks static-only
         */

        'use strict';

            var ReactCurrentOwner = __webpack_require__(79);
            var ReactInstanceMap = __webpack_require__(121);
            var ReactMount = __webpack_require__(102);

            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            /**
             * Returns the DOM node rendered by this element.
             *
             * @param {ReactComponent|DOMElement} componentOrElement
             * @return {?DOMElement} The root node of this element.
             */
            function findDOMNode(componentOrElement) {
                if (process.env.NODE_ENV !== 'production') {
                    var owner = ReactCurrentOwner.current;
                    if (owner !== null) {
                        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
                        owner._warnedAboutRefsInRender = true;
                    }
                }
                if (componentOrElement == null) {
                    return null;
                }
                if (componentOrElement.nodeType === 1) {
                    return componentOrElement;
                }
                if (ReactInstanceMap.has(componentOrElement)) {
                    return ReactMount.getNodeFromInstance(componentOrElement);
                }
                !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
                true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
            }

            module.exports = findDOMNode;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 166 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDefaultBatchingStrategy
         */

        'use strict';

        var ReactUpdates = __webpack_require__(128);
        var Transaction = __webpack_require__(131);

        var assign = __webpack_require__(113);
        var emptyFunction = __webpack_require__(89);

        var RESET_BATCHED_UPDATES = {
            initialize: emptyFunction,
            close: function close() {
                ReactDefaultBatchingStrategy.isBatchingUpdates = false;
            }
        };

        var FLUSH_BATCHED_UPDATES = {
            initialize: emptyFunction,
            close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
        };

        var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

        function ReactDefaultBatchingStrategyTransaction() {
            this.reinitializeTransaction();
        }

        assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
            getTransactionWrappers: function getTransactionWrappers() {
                return TRANSACTION_WRAPPERS;
            }
        });

        var transaction = new ReactDefaultBatchingStrategyTransaction();

        var ReactDefaultBatchingStrategy = {
            isBatchingUpdates: false,

            /**
             * Call the provided function in a context within which calls to `setState`
             * and friends are batched such that components aren't updated unnecessarily.
             */
            batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
                var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

                ReactDefaultBatchingStrategy.isBatchingUpdates = true;

                // The code is written this way to avoid extra allocations
                if (alreadyBatchingUpdates) {
                    callback(a, b, c, d, e);
                } else {
                    transaction.perform(callback, null, a, b, c, d, e);
                }
            }
        };

        module.exports = ReactDefaultBatchingStrategy;

        /***/ },
    /* 167 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMComponent
         * @typechecks static-only
         */

            /* global hasOwnProperty:true */

            'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var AutoFocusUtils = __webpack_require__(168);
            var CSSPropertyOperations = __webpack_require__(170);
            var DOMProperty = __webpack_require__(97);
            var DOMPropertyOperations = __webpack_require__(96);
            var EventConstants = __webpack_require__(104);
            var ReactBrowserEventEmitter = __webpack_require__(103);
            var ReactComponentBrowserEnvironment = __webpack_require__(100);
            var ReactDOMButton = __webpack_require__(178);
            var ReactDOMInput = __webpack_require__(179);
            var ReactDOMOption = __webpack_require__(183);
            var ReactDOMSelect = __webpack_require__(186);
            var ReactDOMTextarea = __webpack_require__(187);
            var ReactMount = __webpack_require__(102);
            var ReactMultiChild = __webpack_require__(188);
            var ReactPerf = __webpack_require__(92);
            var ReactUpdateQueue = __webpack_require__(127);

            var assign = __webpack_require__(113);
            var canDefineProperty = __webpack_require__(117);
            var escapeTextContentForBrowser = __webpack_require__(95);
            var invariant = __webpack_require__(87);
            var isEventSupported = __webpack_require__(114);
            var keyOf = __webpack_require__(153);
            var setInnerHTML = __webpack_require__(93);
            var setTextContent = __webpack_require__(94);
            var shallowEqual = __webpack_require__(191);
            var validateDOMNesting = __webpack_require__(144);
            var warning = __webpack_require__(99);

            var deleteListener = ReactBrowserEventEmitter.deleteListener;
            var listenTo = ReactBrowserEventEmitter.listenTo;
            var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

            // For quickly matching children type, to test if can be treated as content.
            var CONTENT_TYPES = { 'string': true, 'number': true };

            var CHILDREN = keyOf({ children: null });
            var STYLE = keyOf({ style: null });
            var HTML = keyOf({ __html: null });

            var ELEMENT_NODE_TYPE = 1;

            function getDeclarationErrorAddendum(internalInstance) {
                if (internalInstance) {
                    var owner = internalInstance._currentElement._owner || null;
                    if (owner) {
                        var name = owner.getName();
                        if (name) {
                            return ' This DOM node was rendered by `' + name + '`.';
                        }
                    }
                }
                return '';
            }

            var legacyPropsDescriptor;
            if (process.env.NODE_ENV !== 'production') {
                legacyPropsDescriptor = {
                    props: {
                        enumerable: false,
                        get: function get() {
                            var component = this._reactInternalComponent;
                            process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
                            return component._currentElement.props;
                        }
                    }
                };
            }

            function legacyGetDOMNode() {
                if (process.env.NODE_ENV !== 'production') {
                    var component = this._reactInternalComponent;
                    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
                }
                return this;
            }

            function legacyIsMounted() {
                var component = this._reactInternalComponent;
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
                }
                return !!component;
            }

            function legacySetStateEtc() {
                if (process.env.NODE_ENV !== 'production') {
                    var component = this._reactInternalComponent;
                    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
                }
            }

            function legacySetProps(partialProps, callback) {
                var component = this._reactInternalComponent;
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
                }
                if (!component) {
                    return;
                }
                ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
                if (callback) {
                    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
                }
            }

            function legacyReplaceProps(partialProps, callback) {
                var component = this._reactInternalComponent;
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
                }
                if (!component) {
                    return;
                }
                ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
                if (callback) {
                    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
                }
            }

            function friendlyStringify(obj) {
                if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
                    if (Array.isArray(obj)) {
                        return '[' + obj.map(friendlyStringify).join(', ') + ']';
                    } else {
                        var pairs = [];
                        for (var key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
                                pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
                            }
                        }
                        return '{' + pairs.join(', ') + '}';
                    }
                } else if (typeof obj === 'string') {
                    return JSON.stringify(obj);
                } else if (typeof obj === 'function') {
                    return '[function object]';
                }
                // Differs from JSON.stringify in that undefined becauses undefined and that
                // inf and nan don't become null
                return String(obj);
            }

            var styleMutationWarning = {};

            function checkAndWarnForMutatedStyle(style1, style2, component) {
                if (style1 == null || style2 == null) {
                    return;
                }
                if (shallowEqual(style1, style2)) {
                    return;
                }

                var componentName = component._tag;
                var owner = component._currentElement._owner;
                var ownerName;
                if (owner) {
                    ownerName = owner.getName();
                }

                var hash = ownerName + '|' + componentName;

                if (styleMutationWarning.hasOwnProperty(hash)) {
                    return;
                }

                styleMutationWarning[hash] = true;

                process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
            }

            /**
             * @param {object} component
             * @param {?object} props
             */
            function assertValidProps(component, props) {
                if (!props) {
                    return;
                }
                // Note the use of `==` which checks for null or undefined.
                if (process.env.NODE_ENV !== 'production') {
                    if (voidElementTags[component._tag]) {
                        process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
                    }
                }
                if (props.dangerouslySetInnerHTML != null) {
                    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
                    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
                }
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
                    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
                }
                !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
            }

            function enqueuePutListener(id, registrationName, listener, transaction) {
                if (process.env.NODE_ENV !== 'production') {
                    // IE8 has no API for event capturing and the `onScroll` event doesn't
                    // bubble.
                    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
                }
                var container = ReactMount.findReactContainerForID(id);
                if (container) {
                    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
                    listenTo(registrationName, doc);
                }
                transaction.getReactMountReady().enqueue(putListener, {
                    id: id,
                    registrationName: registrationName,
                    listener: listener
                });
            }

            function putListener() {
                var listenerToPut = this;
                ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
            }

            // There are so many media events, it makes sense to just
            // maintain a list rather than create a `trapBubbledEvent` for each
            var mediaEvents = {
                topAbort: 'abort',
                topCanPlay: 'canplay',
                topCanPlayThrough: 'canplaythrough',
                topDurationChange: 'durationchange',
                topEmptied: 'emptied',
                topEncrypted: 'encrypted',
                topEnded: 'ended',
                topError: 'error',
                topLoadedData: 'loadeddata',
                topLoadedMetadata: 'loadedmetadata',
                topLoadStart: 'loadstart',
                topPause: 'pause',
                topPlay: 'play',
                topPlaying: 'playing',
                topProgress: 'progress',
                topRateChange: 'ratechange',
                topSeeked: 'seeked',
                topSeeking: 'seeking',
                topStalled: 'stalled',
                topSuspend: 'suspend',
                topTimeUpdate: 'timeupdate',
                topVolumeChange: 'volumechange',
                topWaiting: 'waiting'
            };

            function trapBubbledEventsLocal() {
                var inst = this;
                // If a component renders to null or if another component fatals and causes
                // the state of the tree to be corrupted, `node` here can be null.
                !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
                var node = ReactMount.getNode(inst._rootNodeID);
                !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;

                switch (inst._tag) {
                    case 'iframe':
                        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
                        break;
                    case 'video':
                    case 'audio':

                        inst._wrapperState.listeners = [];
                        // create listener for each media event
                        for (var event in mediaEvents) {
                            if (mediaEvents.hasOwnProperty(event)) {
                                inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
                            }
                        }

                        break;
                    case 'img':
                        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
                        break;
                    case 'form':
                        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
                        break;
                }
            }

            function mountReadyInputWrapper() {
                ReactDOMInput.mountReadyWrapper(this);
            }

            function postUpdateSelectWrapper() {
                ReactDOMSelect.postUpdateWrapper(this);
            }

            // For HTML, certain tags should omit their close tag. We keep a whitelist for
            // those special cased tags.

            var omittedCloseTags = {
                'area': true,
                'base': true,
                'br': true,
                'col': true,
                'embed': true,
                'hr': true,
                'img': true,
                'input': true,
                'keygen': true,
                'link': true,
                'meta': true,
                'param': true,
                'source': true,
                'track': true,
                'wbr': true
            };

            // NOTE: menuitem's close tag should be omitted, but that causes problems.
            var newlineEatingTags = {
                'listing': true,
                'pre': true,
                'textarea': true
            };

            // For HTML, certain tags cannot have children. This has the same purpose as
            // `omittedCloseTags` except that `menuitem` should still have its closing tag.

            var voidElementTags = assign({
                'menuitem': true
            }, omittedCloseTags);

            // We accept any tag to be rendered but since this gets injected into arbitrary
            // HTML, we want to make sure that it's a safe tag.
            // http://www.w3.org/TR/REC-xml/#NT-Name

            var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
            var validatedTagCache = {};
            var hasOwnProperty = {}.hasOwnProperty;

            function validateDangerousTag(tag) {
                if (!hasOwnProperty.call(validatedTagCache, tag)) {
                    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
                    validatedTagCache[tag] = true;
                }
            }

            function processChildContextDev(context, inst) {
                // Pass down our tag name to child components for validation purposes
                context = assign({}, context);
                var info = context[validateDOMNesting.ancestorInfoContextKey];
                context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
                return context;
            }

            function isCustomComponent(tagName, props) {
                return tagName.indexOf('-') >= 0 || props.is != null;
            }

            /**
             * Creates a new React class that is idempotent and capable of containing other
             * React components. It accepts event listeners and DOM properties that are
             * valid according to `DOMProperty`.
             *
             *  - Event listeners: `onClick`, `onMouseDown`, etc.
             *  - DOM properties: `className`, `name`, `title`, etc.
             *
             * The `style` property functions differently from the DOM API. It accepts an
             * object mapping of style properties to values.
             *
             * @constructor ReactDOMComponent
             * @extends ReactMultiChild
             */
            function ReactDOMComponent(tag) {
                validateDangerousTag(tag);
                this._tag = tag.toLowerCase();
                this._renderedChildren = null;
                this._previousStyle = null;
                this._previousStyleCopy = null;
                this._rootNodeID = null;
                this._wrapperState = null;
                this._topLevelWrapper = null;
                this._nodeWithLegacyProperties = null;
                if (process.env.NODE_ENV !== 'production') {
                    this._unprocessedContextDev = null;
                    this._processedContextDev = null;
                }
            }

            ReactDOMComponent.displayName = 'ReactDOMComponent';

            ReactDOMComponent.Mixin = {

                construct: function construct(element) {
                    this._currentElement = element;
                },

                /**
                 * Generates root tag markup then recurses. This method has side effects and
                 * is not idempotent.
                 *
                 * @internal
                 * @param {string} rootID The root DOM ID for this node.
                 * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
                 * @param {object} context
                 * @return {string} The computed markup.
                 */
                mountComponent: function mountComponent(rootID, transaction, context) {
                    this._rootNodeID = rootID;

                    var props = this._currentElement.props;

                    switch (this._tag) {
                        case 'iframe':
                        case 'img':
                        case 'form':
                        case 'video':
                        case 'audio':
                            this._wrapperState = {
                                listeners: null
                            };
                            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
                            break;
                        case 'button':
                            props = ReactDOMButton.getNativeProps(this, props, context);
                            break;
                        case 'input':
                            ReactDOMInput.mountWrapper(this, props, context);
                            props = ReactDOMInput.getNativeProps(this, props, context);
                            break;
                        case 'option':
                            ReactDOMOption.mountWrapper(this, props, context);
                            props = ReactDOMOption.getNativeProps(this, props, context);
                            break;
                        case 'select':
                            ReactDOMSelect.mountWrapper(this, props, context);
                            props = ReactDOMSelect.getNativeProps(this, props, context);
                            context = ReactDOMSelect.processChildContext(this, props, context);
                            break;
                        case 'textarea':
                            ReactDOMTextarea.mountWrapper(this, props, context);
                            props = ReactDOMTextarea.getNativeProps(this, props, context);
                            break;
                    }

                    assertValidProps(this, props);
                    if (process.env.NODE_ENV !== 'production') {
                        if (context[validateDOMNesting.ancestorInfoContextKey]) {
                            validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
                        }
                    }

                    if (process.env.NODE_ENV !== 'production') {
                        this._unprocessedContextDev = context;
                        this._processedContextDev = processChildContextDev(context, this);
                        context = this._processedContextDev;
                    }

                    var mountImage;
                    if (transaction.useCreateElement) {
                        var ownerDocument = context[ReactMount.ownerDocumentContextKey];
                        var el = ownerDocument.createElement(this._currentElement.type);
                        DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
                        // Populate node cache
                        ReactMount.getID(el);
                        this._updateDOMProperties({}, props, transaction, el);
                        this._createInitialChildren(transaction, props, context, el);
                        mountImage = el;
                    } else {
                        var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
                        var tagContent = this._createContentMarkup(transaction, props, context);
                        if (!tagContent && omittedCloseTags[this._tag]) {
                            mountImage = tagOpen + '/>';
                        } else {
                            mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
                        }
                    }

                    switch (this._tag) {
                        case 'input':
                            transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
                        // falls through
                        case 'button':
                        case 'select':
                        case 'textarea':
                            if (props.autoFocus) {
                                transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
                            }
                            break;
                    }

                    return mountImage;
                },

                /**
                 * Creates markup for the open tag and all attributes.
                 *
                 * This method has side effects because events get registered.
                 *
                 * Iterating over object properties is faster than iterating over arrays.
                 * @see http://jsperf.com/obj-vs-arr-iteration
                 *
                 * @private
                 * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
                 * @param {object} props
                 * @return {string} Markup of opening tag.
                 */
                _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
                    var ret = '<' + this._currentElement.type;

                    for (var propKey in props) {
                        if (!props.hasOwnProperty(propKey)) {
                            continue;
                        }
                        var propValue = props[propKey];
                        if (propValue == null) {
                            continue;
                        }
                        if (registrationNameModules.hasOwnProperty(propKey)) {
                            if (propValue) {
                                enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
                            }
                        } else {
                            if (propKey === STYLE) {
                                if (propValue) {
                                    if (process.env.NODE_ENV !== 'production') {
                                        // See `_updateDOMProperties`. style block
                                        this._previousStyle = propValue;
                                    }
                                    propValue = this._previousStyleCopy = assign({}, props.style);
                                }
                                propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
                            }
                            var markup = null;
                            if (this._tag != null && isCustomComponent(this._tag, props)) {
                                if (propKey !== CHILDREN) {
                                    markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
                                }
                            } else {
                                markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
                            }
                            if (markup) {
                                ret += ' ' + markup;
                            }
                        }
                    }

                    // For static pages, no need to put React ID and checksum. Saves lots of
                    // bytes.
                    if (transaction.renderToStaticMarkup) {
                        return ret;
                    }

                    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
                    return ret + ' ' + markupForID;
                },

                /**
                 * Creates markup for the content between the tags.
                 *
                 * @private
                 * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
                 * @param {object} props
                 * @param {object} context
                 * @return {string} Content markup.
                 */
                _createContentMarkup: function _createContentMarkup(transaction, props, context) {
                    var ret = '';

                    // Intentional use of != to avoid catching zero/false.
                    var innerHTML = props.dangerouslySetInnerHTML;
                    if (innerHTML != null) {
                        if (innerHTML.__html != null) {
                            ret = innerHTML.__html;
                        }
                    } else {
                        var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
                        var childrenToUse = contentToUse != null ? null : props.children;
                        if (contentToUse != null) {
                            // TODO: Validate that text is allowed as a child of this node
                            ret = escapeTextContentForBrowser(contentToUse);
                        } else if (childrenToUse != null) {
                            var mountImages = this.mountChildren(childrenToUse, transaction, context);
                            ret = mountImages.join('');
                        }
                    }
                    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
                        // text/html ignores the first character in these tags if it's a newline
                        // Prefer to break application/xml over text/html (for now) by adding
                        // a newline specifically to get eaten by the parser. (Alternately for
                        // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
                        // \r is normalized out by HTMLTextAreaElement#value.)
                        // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
                        // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
                        // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
                        // See: Parsing of "textarea" "listing" and "pre" elements
                        //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
                        return '\n' + ret;
                    } else {
                        return ret;
                    }
                },

                _createInitialChildren: function _createInitialChildren(transaction, props, context, el) {
                    // Intentional use of != to avoid catching zero/false.
                    var innerHTML = props.dangerouslySetInnerHTML;
                    if (innerHTML != null) {
                        if (innerHTML.__html != null) {
                            setInnerHTML(el, innerHTML.__html);
                        }
                    } else {
                        var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
                        var childrenToUse = contentToUse != null ? null : props.children;
                        if (contentToUse != null) {
                            // TODO: Validate that text is allowed as a child of this node
                            setTextContent(el, contentToUse);
                        } else if (childrenToUse != null) {
                            var mountImages = this.mountChildren(childrenToUse, transaction, context);
                            for (var i = 0; i < mountImages.length; i++) {
                                el.appendChild(mountImages[i]);
                            }
                        }
                    }
                },

                /**
                 * Receives a next element and updates the component.
                 *
                 * @internal
                 * @param {ReactElement} nextElement
                 * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
                 * @param {object} context
                 */
                receiveComponent: function receiveComponent(nextElement, transaction, context) {
                    var prevElement = this._currentElement;
                    this._currentElement = nextElement;
                    this.updateComponent(transaction, prevElement, nextElement, context);
                },

                /**
                 * Updates a native DOM component after it has already been allocated and
                 * attached to the DOM. Reconciles the root DOM node, then recurses.
                 *
                 * @param {ReactReconcileTransaction} transaction
                 * @param {ReactElement} prevElement
                 * @param {ReactElement} nextElement
                 * @internal
                 * @overridable
                 */
                updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
                    var lastProps = prevElement.props;
                    var nextProps = this._currentElement.props;

                    switch (this._tag) {
                        case 'button':
                            lastProps = ReactDOMButton.getNativeProps(this, lastProps);
                            nextProps = ReactDOMButton.getNativeProps(this, nextProps);
                            break;
                        case 'input':
                            ReactDOMInput.updateWrapper(this);
                            lastProps = ReactDOMInput.getNativeProps(this, lastProps);
                            nextProps = ReactDOMInput.getNativeProps(this, nextProps);
                            break;
                        case 'option':
                            lastProps = ReactDOMOption.getNativeProps(this, lastProps);
                            nextProps = ReactDOMOption.getNativeProps(this, nextProps);
                            break;
                        case 'select':
                            lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
                            nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
                            break;
                        case 'textarea':
                            ReactDOMTextarea.updateWrapper(this);
                            lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
                            nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
                            break;
                    }

                    if (process.env.NODE_ENV !== 'production') {
                        // If the context is reference-equal to the old one, pass down the same
                        // processed object so the update bailout in ReactReconciler behaves
                        // correctly (and identically in dev and prod). See #5005.
                        if (this._unprocessedContextDev !== context) {
                            this._unprocessedContextDev = context;
                            this._processedContextDev = processChildContextDev(context, this);
                        }
                        context = this._processedContextDev;
                    }

                    assertValidProps(this, nextProps);
                    this._updateDOMProperties(lastProps, nextProps, transaction, null);
                    this._updateDOMChildren(lastProps, nextProps, transaction, context);

                    if (!canDefineProperty && this._nodeWithLegacyProperties) {
                        this._nodeWithLegacyProperties.props = nextProps;
                    }

                    if (this._tag === 'select') {
                        // <select> value update needs to occur after <option> children
                        // reconciliation
                        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
                    }
                },

                /**
                 * Reconciles the properties by detecting differences in property values and
                 * updating the DOM as necessary. This function is probably the single most
                 * critical path for performance optimization.
                 *
                 * TODO: Benchmark whether checking for changed values in memory actually
                 *       improves performance (especially statically positioned elements).
                 * TODO: Benchmark the effects of putting this at the top since 99% of props
                 *       do not change for a given reconciliation.
                 * TODO: Benchmark areas that can be improved with caching.
                 *
                 * @private
                 * @param {object} lastProps
                 * @param {object} nextProps
                 * @param {ReactReconcileTransaction} transaction
                 * @param {?DOMElement} node
                 */
                _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction, node) {
                    var propKey;
                    var styleName;
                    var styleUpdates;
                    for (propKey in lastProps) {
                        if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
                            continue;
                        }
                        if (propKey === STYLE) {
                            var lastStyle = this._previousStyleCopy;
                            for (styleName in lastStyle) {
                                if (lastStyle.hasOwnProperty(styleName)) {
                                    styleUpdates = styleUpdates || {};
                                    styleUpdates[styleName] = '';
                                }
                            }
                            this._previousStyleCopy = null;
                        } else if (registrationNameModules.hasOwnProperty(propKey)) {
                            if (lastProps[propKey]) {
                                // Only call deleteListener if there was a listener previously or
                                // else willDeleteListener gets called when there wasn't actually a
                                // listener (e.g., onClick={null})
                                deleteListener(this._rootNodeID, propKey);
                            }
                        } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                            if (!node) {
                                node = ReactMount.getNode(this._rootNodeID);
                            }
                            DOMPropertyOperations.deleteValueForProperty(node, propKey);
                        }
                    }
                    for (propKey in nextProps) {
                        var nextProp = nextProps[propKey];
                        var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
                        if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
                            continue;
                        }
                        if (propKey === STYLE) {
                            if (nextProp) {
                                if (process.env.NODE_ENV !== 'production') {
                                    checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
                                    this._previousStyle = nextProp;
                                }
                                nextProp = this._previousStyleCopy = assign({}, nextProp);
                            } else {
                                this._previousStyleCopy = null;
                            }
                            if (lastProp) {
                                // Unset styles on `lastProp` but not on `nextProp`.
                                for (styleName in lastProp) {
                                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                                        styleUpdates = styleUpdates || {};
                                        styleUpdates[styleName] = '';
                                    }
                                }
                                // Update styles that changed since `lastProp`.
                                for (styleName in nextProp) {
                                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                                        styleUpdates = styleUpdates || {};
                                        styleUpdates[styleName] = nextProp[styleName];
                                    }
                                }
                            } else {
                                // Relies on `updateStylesByID` not mutating `styleUpdates`.
                                styleUpdates = nextProp;
                            }
                        } else if (registrationNameModules.hasOwnProperty(propKey)) {
                            if (nextProp) {
                                enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
                            } else if (lastProp) {
                                deleteListener(this._rootNodeID, propKey);
                            }
                        } else if (isCustomComponent(this._tag, nextProps)) {
                            if (!node) {
                                node = ReactMount.getNode(this._rootNodeID);
                            }
                            if (propKey === CHILDREN) {
                                nextProp = null;
                            }
                            DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
                        } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
                            if (!node) {
                                node = ReactMount.getNode(this._rootNodeID);
                            }
                            // If we're updating to null or undefined, we should remove the property
                            // from the DOM node instead of inadvertantly setting to a string. This
                            // brings us in line with the same behavior we have on initial render.
                            if (nextProp != null) {
                                DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
                            } else {
                                DOMPropertyOperations.deleteValueForProperty(node, propKey);
                            }
                        }
                    }
                    if (styleUpdates) {
                        if (!node) {
                            node = ReactMount.getNode(this._rootNodeID);
                        }
                        CSSPropertyOperations.setValueForStyles(node, styleUpdates);
                    }
                },

                /**
                 * Reconciles the children with the various properties that affect the
                 * children content.
                 *
                 * @param {object} lastProps
                 * @param {object} nextProps
                 * @param {ReactReconcileTransaction} transaction
                 * @param {object} context
                 */
                _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
                    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
                    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;

                    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
                    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

                    // Note the use of `!=` which checks for null or undefined.
                    var lastChildren = lastContent != null ? null : lastProps.children;
                    var nextChildren = nextContent != null ? null : nextProps.children;

                    // If we're switching from children to content/html or vice versa, remove
                    // the old content
                    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
                    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
                    if (lastChildren != null && nextChildren == null) {
                        this.updateChildren(null, transaction, context);
                    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
                        this.updateTextContent('');
                    }

                    if (nextContent != null) {
                        if (lastContent !== nextContent) {
                            this.updateTextContent('' + nextContent);
                        }
                    } else if (nextHtml != null) {
                        if (lastHtml !== nextHtml) {
                            this.updateMarkup('' + nextHtml);
                        }
                    } else if (nextChildren != null) {
                        this.updateChildren(nextChildren, transaction, context);
                    }
                },

                /**
                 * Destroys all event registrations for this instance. Does not remove from
                 * the DOM. That must be done by the parent.
                 *
                 * @internal
                 */
                unmountComponent: function unmountComponent() {
                    switch (this._tag) {
                        case 'iframe':
                        case 'img':
                        case 'form':
                        case 'video':
                        case 'audio':
                            var listeners = this._wrapperState.listeners;
                            if (listeners) {
                                for (var i = 0; i < listeners.length; i++) {
                                    listeners[i].remove();
                                }
                            }
                            break;
                        case 'input':
                            ReactDOMInput.unmountWrapper(this);
                            break;
                        case 'html':
                        case 'head':
                        case 'body':
                            /**
                             * Components like <html> <head> and <body> can't be removed or added
                             * easily in a cross-browser way, however it's valuable to be able to
                             * take advantage of React's reconciliation for styling and <title>
                             * management. So we just document it and throw in dangerous cases.
                             */
                            true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
                            break;
                    }

                    this.unmountChildren();
                    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
                    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
                    this._rootNodeID = null;
                    this._wrapperState = null;
                    if (this._nodeWithLegacyProperties) {
                        var node = this._nodeWithLegacyProperties;
                        node._reactInternalComponent = null;
                        this._nodeWithLegacyProperties = null;
                    }
                },

                getPublicInstance: function getPublicInstance() {
                    if (!this._nodeWithLegacyProperties) {
                        var node = ReactMount.getNode(this._rootNodeID);

                        node._reactInternalComponent = this;
                        node.getDOMNode = legacyGetDOMNode;
                        node.isMounted = legacyIsMounted;
                        node.setState = legacySetStateEtc;
                        node.replaceState = legacySetStateEtc;
                        node.forceUpdate = legacySetStateEtc;
                        node.setProps = legacySetProps;
                        node.replaceProps = legacyReplaceProps;

                        if (process.env.NODE_ENV !== 'production') {
                            if (canDefineProperty) {
                                Object.defineProperties(node, legacyPropsDescriptor);
                            } else {
                                // updateComponent will update this property on subsequent renders
                                node.props = this._currentElement.props;
                            }
                        } else {
                            // updateComponent will update this property on subsequent renders
                            node.props = this._currentElement.props;
                        }

                        this._nodeWithLegacyProperties = node;
                    }
                    return this._nodeWithLegacyProperties;
                }

            };

            ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
                mountComponent: 'mountComponent',
                updateComponent: 'updateComponent'
            });

            assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

            module.exports = ReactDOMComponent;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 168 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule AutoFocusUtils
         * @typechecks static-only
         */

        'use strict';

        var ReactMount = __webpack_require__(102);

        var findDOMNode = __webpack_require__(165);
        var focusNode = __webpack_require__(169);

        var Mixin = {
            componentDidMount: function componentDidMount() {
                if (this.props.autoFocus) {
                    focusNode(findDOMNode(this));
                }
            }
        };

        var AutoFocusUtils = {
            Mixin: Mixin,

            focusDOMComponent: function focusDOMComponent() {
                focusNode(ReactMount.getNode(this._rootNodeID));
            }
        };

        module.exports = AutoFocusUtils;

        /***/ },
    /* 169 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule focusNode
         */

        'use strict';

        /**
         * @param {DOMElement} node input/textarea to focus
         */

        function focusNode(node) {
            // IE8 can throw "Can't move focus to the control because it is invisible,
            // not enabled, or of a type that does not accept the focus." for all kinds of
            // reasons that are too expensive and fragile to test.
            try {
                node.focus();
            } catch (e) {}
        }

        module.exports = focusNode;

        /***/ },
    /* 170 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule CSSPropertyOperations
         * @typechecks static-only
         */

        'use strict';

            var CSSProperty = __webpack_require__(171);
            var ExecutionEnvironment = __webpack_require__(83);
            var ReactPerf = __webpack_require__(92);

            var camelizeStyleName = __webpack_require__(172);
            var dangerousStyleValue = __webpack_require__(174);
            var hyphenateStyleName = __webpack_require__(175);
            var memoizeStringOnly = __webpack_require__(177);
            var warning = __webpack_require__(99);

            var processStyleName = memoizeStringOnly(function (styleName) {
                return hyphenateStyleName(styleName);
            });

            var hasShorthandPropertyBug = false;
            var styleFloatAccessor = 'cssFloat';
            if (ExecutionEnvironment.canUseDOM) {
                var tempStyle = document.createElement('div').style;
                try {
                    // IE8 throws "Invalid argument." if resetting shorthand style properties.
                    tempStyle.font = '';
                } catch (e) {
                    hasShorthandPropertyBug = true;
                }
                // IE8 only supports accessing cssFloat (standard) as styleFloat
                if (document.documentElement.style.cssFloat === undefined) {
                    styleFloatAccessor = 'styleFloat';
                }
            }

            if (process.env.NODE_ENV !== 'production') {
                // 'msTransform' is correct, but the other prefixes should be capitalized
                var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

                // style values shouldn't contain a semicolon
                var badStyleValueWithSemicolonPattern = /;\s*$/;

                var warnedStyleNames = {};
                var warnedStyleValues = {};

                var warnHyphenatedStyleName = function warnHyphenatedStyleName(name) {
                    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                        return;
                    }

                    warnedStyleNames[name] = true;
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
                };

                var warnBadVendoredStyleName = function warnBadVendoredStyleName(name) {
                    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                        return;
                    }

                    warnedStyleNames[name] = true;
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
                };

                var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value) {
                    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                        return;
                    }

                    warnedStyleValues[value] = true;
                    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
                };

                /**
                 * @param {string} name
                 * @param {*} value
                 */
                var warnValidStyle = function warnValidStyle(name, value) {
                    if (name.indexOf('-') > -1) {
                        warnHyphenatedStyleName(name);
                    } else if (badVendoredStyleNamePattern.test(name)) {
                        warnBadVendoredStyleName(name);
                    } else if (badStyleValueWithSemicolonPattern.test(value)) {
                        warnStyleValueWithSemicolon(name, value);
                    }
                };
            }

            /**
             * Operations for dealing with CSS properties.
             */
            var CSSPropertyOperations = {

                /**
                 * Serializes a mapping of style properties for use as inline styles:
                 *
                 *   > createMarkupForStyles({width: '200px', height: 0})
                 *   "width:200px;height:0;"
                 *
                 * Undefined values are ignored so that declarative programming is easier.
                 * The result should be HTML-escaped before insertion into the DOM.
                 *
                 * @param {object} styles
                 * @return {?string}
                 */
                createMarkupForStyles: function createMarkupForStyles(styles) {
                    var serialized = '';
                    for (var styleName in styles) {
                        if (!styles.hasOwnProperty(styleName)) {
                            continue;
                        }
                        var styleValue = styles[styleName];
                        if (process.env.NODE_ENV !== 'production') {
                            warnValidStyle(styleName, styleValue);
                        }
                        if (styleValue != null) {
                            serialized += processStyleName(styleName) + ':';
                            serialized += dangerousStyleValue(styleName, styleValue) + ';';
                        }
                    }
                    return serialized || null;
                },

                /**
                 * Sets the value for multiple styles on a node.  If a value is specified as
                 * '' (empty string), the corresponding style property will be unset.
                 *
                 * @param {DOMElement} node
                 * @param {object} styles
                 */
                setValueForStyles: function setValueForStyles(node, styles) {
                    var style = node.style;
                    for (var styleName in styles) {
                        if (!styles.hasOwnProperty(styleName)) {
                            continue;
                        }
                        if (process.env.NODE_ENV !== 'production') {
                            warnValidStyle(styleName, styles[styleName]);
                        }
                        var styleValue = dangerousStyleValue(styleName, styles[styleName]);
                        if (styleName === 'float') {
                            styleName = styleFloatAccessor;
                        }
                        if (styleValue) {
                            style[styleName] = styleValue;
                        } else {
                            var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
                            if (expansion) {
                                // Shorthand property that IE8 won't like unsetting, so unset each
                                // component to placate it
                                for (var individualStyleName in expansion) {
                                    style[individualStyleName] = '';
                                }
                            } else {
                                style[styleName] = '';
                            }
                        }
                    }
                }

            };

            ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
                setValueForStyles: 'setValueForStyles'
            });

            module.exports = CSSPropertyOperations;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 171 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule CSSProperty
         */

        'use strict';

        /**
         * CSS properties which accept numbers but are not in units of "px".
         */

        var isUnitlessNumber = {
            animationIterationCount: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,

            // SVG-related properties
            fillOpacity: true,
            stopOpacity: true,
            strokeDashoffset: true,
            strokeOpacity: true,
            strokeWidth: true
        };

        /**
         * @param {string} prefix vendor-specific prefix, eg: Webkit
         * @param {string} key style name, eg: transitionDuration
         * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
         * WebkitTransitionDuration
         */
        function prefixKey(prefix, key) {
            return prefix + key.charAt(0).toUpperCase() + key.substring(1);
        }

        /**
         * Support style names that may come passed in prefixed by adding permutations
         * of vendor prefixes.
         */
        var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

        // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
        // infinite loop, because it iterates over the newly added props too.
        Object.keys(isUnitlessNumber).forEach(function (prop) {
            prefixes.forEach(function (prefix) {
                isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
            });
        });

        /**
         * Most style properties can be unset by doing .style[prop] = '' but IE8
         * doesn't like doing that with shorthand properties so for the properties that
         * IE8 breaks on, which are listed here, we instead unset each of the
         * individual properties. See http://bugs.jquery.com/ticket/12385.
         * The 4-value 'clock' properties like margin, padding, border-width seem to
         * behave without any problems. Curiously, list-style works too without any
         * special prodding.
         */
        var shorthandPropertyExpansions = {
            background: {
                backgroundAttachment: true,
                backgroundColor: true,
                backgroundImage: true,
                backgroundPositionX: true,
                backgroundPositionY: true,
                backgroundRepeat: true
            },
            backgroundPosition: {
                backgroundPositionX: true,
                backgroundPositionY: true
            },
            border: {
                borderWidth: true,
                borderStyle: true,
                borderColor: true
            },
            borderBottom: {
                borderBottomWidth: true,
                borderBottomStyle: true,
                borderBottomColor: true
            },
            borderLeft: {
                borderLeftWidth: true,
                borderLeftStyle: true,
                borderLeftColor: true
            },
            borderRight: {
                borderRightWidth: true,
                borderRightStyle: true,
                borderRightColor: true
            },
            borderTop: {
                borderTopWidth: true,
                borderTopStyle: true,
                borderTopColor: true
            },
            font: {
                fontStyle: true,
                fontVariant: true,
                fontWeight: true,
                fontSize: true,
                lineHeight: true,
                fontFamily: true
            },
            outline: {
                outlineWidth: true,
                outlineStyle: true,
                outlineColor: true
            }
        };

        var CSSProperty = {
            isUnitlessNumber: isUnitlessNumber,
            shorthandPropertyExpansions: shorthandPropertyExpansions
        };

        module.exports = CSSProperty;

        /***/ },
    /* 172 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule camelizeStyleName
         * @typechecks
         */

        'use strict';

        var camelize = __webpack_require__(173);

        var msPattern = /^-ms-/;

        /**
         * Camelcases a hyphenated CSS property name, for example:
         *
         *   > camelizeStyleName('background-color')
         *   < "backgroundColor"
         *   > camelizeStyleName('-moz-transition')
         *   < "MozTransition"
         *   > camelizeStyleName('-ms-transition')
         *   < "msTransition"
         *
         * As Andi Smith suggests
         * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
         * is converted to lowercase `ms`.
         *
         * @param {string} string
         * @return {string}
         */
        function camelizeStyleName(string) {
            return camelize(string.replace(msPattern, 'ms-'));
        }

        module.exports = camelizeStyleName;

        /***/ },
    /* 173 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule camelize
         * @typechecks
         */

        "use strict";

        var _hyphenPattern = /-(.)/g;

        /**
         * Camelcases a hyphenated string, for example:
         *
         *   > camelize('background-color')
         *   < "backgroundColor"
         *
         * @param {string} string
         * @return {string}
         */
        function camelize(string) {
            return string.replace(_hyphenPattern, function (_, character) {
                return character.toUpperCase();
            });
        }

        module.exports = camelize;

        /***/ },
    /* 174 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule dangerousStyleValue
         * @typechecks static-only
         */

        'use strict';

        var CSSProperty = __webpack_require__(171);

        var isUnitlessNumber = CSSProperty.isUnitlessNumber;

        /**
         * Convert a value into the proper css writable value. The style name `name`
         * should be logical (no hyphens), as specified
         * in `CSSProperty.isUnitlessNumber`.
         *
         * @param {string} name CSS property name such as `topMargin`.
         * @param {*} value CSS property value such as `10px`.
         * @return {string} Normalized style value with dimensions applied.
         */
        function dangerousStyleValue(name, value) {
            // Note that we've removed escapeTextForBrowser() calls here since the
            // whole string will be escaped when the attribute is injected into
            // the markup. If you provide unsafe user data here they can inject
            // arbitrary CSS which may be problematic (I couldn't repro this):
            // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
            // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
            // This is not an XSS hole but instead a potential CSS injection issue
            // which has lead to a greater discussion about how we're going to
            // trust URLs moving forward. See #2115901

            var isEmpty = value == null || typeof value === 'boolean' || value === '';
            if (isEmpty) {
                return '';
            }

            var isNonNumeric = isNaN(value);
            if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
                return '' + value; // cast to string
            }

            if (typeof value === 'string') {
                value = value.trim();
            }
            return value + 'px';
        }

        module.exports = dangerousStyleValue;

        /***/ },
    /* 175 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule hyphenateStyleName
         * @typechecks
         */

        'use strict';

        var hyphenate = __webpack_require__(176);

        var msPattern = /^ms-/;

        /**
         * Hyphenates a camelcased CSS property name, for example:
         *
         *   > hyphenateStyleName('backgroundColor')
         *   < "background-color"
         *   > hyphenateStyleName('MozTransition')
         *   < "-moz-transition"
         *   > hyphenateStyleName('msTransition')
         *   < "-ms-transition"
         *
         * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
         * is converted to `-ms-`.
         *
         * @param {string} string
         * @return {string}
         */
        function hyphenateStyleName(string) {
            return hyphenate(string).replace(msPattern, '-ms-');
        }

        module.exports = hyphenateStyleName;

        /***/ },
    /* 176 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule hyphenate
         * @typechecks
         */

        'use strict';

        var _uppercasePattern = /([A-Z])/g;

        /**
         * Hyphenates a camelcased string, for example:
         *
         *   > hyphenate('backgroundColor')
         *   < "background-color"
         *
         * For CSS style names, use `hyphenateStyleName` instead which works properly
         * with all vendor prefixes, including `ms`.
         *
         * @param {string} string
         * @return {string}
         */
        function hyphenate(string) {
            return string.replace(_uppercasePattern, '-$1').toLowerCase();
        }

        module.exports = hyphenate;

        /***/ },
    /* 177 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule memoizeStringOnly
         * @typechecks static-only
         */

        'use strict';

        /**
         * Memoizes the return value of a function that accepts one string argument.
         *
         * @param {function} callback
         * @return {function}
         */

        function memoizeStringOnly(callback) {
            var cache = {};
            return function (string) {
                if (!cache.hasOwnProperty(string)) {
                    cache[string] = callback.call(this, string);
                }
                return cache[string];
            };
        }

        module.exports = memoizeStringOnly;

        /***/ },
    /* 178 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMButton
         */

        'use strict';

        var mouseListenerNames = {
            onClick: true,
            onDoubleClick: true,
            onMouseDown: true,
            onMouseMove: true,
            onMouseUp: true,

            onClickCapture: true,
            onDoubleClickCapture: true,
            onMouseDownCapture: true,
            onMouseMoveCapture: true,
            onMouseUpCapture: true
        };

        /**
         * Implements a <button> native component that does not receive mouse events
         * when `disabled` is set.
         */
        var ReactDOMButton = {
            getNativeProps: function getNativeProps(inst, props, context) {
                if (!props.disabled) {
                    return props;
                }

                // Copy the props, except the mouse listeners
                var nativeProps = {};
                for (var key in props) {
                    if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
                        nativeProps[key] = props[key];
                    }
                }

                return nativeProps;
            }
        };

        module.exports = ReactDOMButton;

        /***/ },
    /* 179 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMInput
         */

        'use strict';

            var ReactDOMIDOperations = __webpack_require__(101);
            var LinkedValueUtils = __webpack_require__(180);
            var ReactMount = __webpack_require__(102);
            var ReactUpdates = __webpack_require__(128);

            var assign = __webpack_require__(113);
            var invariant = __webpack_require__(87);

            var instancesByReactID = {};

            function forceUpdateIfMounted() {
                if (this._rootNodeID) {
                    // DOM component is still mounted; update
                    ReactDOMInput.updateWrapper(this);
                }
            }

            /**
             * Implements an <input> native component that allows setting these optional
             * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
             *
             * If `checked` or `value` are not supplied (or null/undefined), user actions
             * that affect the checked state or value will trigger updates to the element.
             *
             * If they are supplied (and not null/undefined), the rendered element will not
             * trigger updates to the element. Instead, the props must change in order for
             * the rendered element to be updated.
             *
             * The rendered element will be initialized as unchecked (or `defaultChecked`)
             * with an empty value (or `defaultValue`).
             *
             * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
             */
            var ReactDOMInput = {
                getNativeProps: function getNativeProps(inst, props, context) {
                    var value = LinkedValueUtils.getValue(props);
                    var checked = LinkedValueUtils.getChecked(props);

                    var nativeProps = assign({}, props, {
                        defaultChecked: undefined,
                        defaultValue: undefined,
                        value: value != null ? value : inst._wrapperState.initialValue,
                        checked: checked != null ? checked : inst._wrapperState.initialChecked,
                        onChange: inst._wrapperState.onChange
                    });

                    return nativeProps;
                },

                mountWrapper: function mountWrapper(inst, props) {
                    if (process.env.NODE_ENV !== 'production') {
                        LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
                    }

                    var defaultValue = props.defaultValue;
                    inst._wrapperState = {
                        initialChecked: props.defaultChecked || false,
                        initialValue: defaultValue != null ? defaultValue : null,
                        onChange: _handleChange.bind(inst)
                    };
                },

                mountReadyWrapper: function mountReadyWrapper(inst) {
                    // Can't be in mountWrapper or else server rendering leaks.
                    instancesByReactID[inst._rootNodeID] = inst;
                },

                unmountWrapper: function unmountWrapper(inst) {
                    delete instancesByReactID[inst._rootNodeID];
                },

                updateWrapper: function updateWrapper(inst) {
                    var props = inst._currentElement.props;

                    // TODO: Shouldn't this be getChecked(props)?
                    var checked = props.checked;
                    if (checked != null) {
                        ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
                    }

                    var value = LinkedValueUtils.getValue(props);
                    if (value != null) {
                        // Cast `value` to a string to ensure the value is set correctly. While
                        // browsers typically do this as necessary, jsdom doesn't.
                        ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
                    }
                }
            };

            function _handleChange(event) {
                var props = this._currentElement.props;

                var returnValue = LinkedValueUtils.executeOnChange(props, event);

                // Here we use asap to wait until all updates have propagated, which
                // is important when using controlled components within layers:
                // https://github.com/facebook/react/issues/1698
                ReactUpdates.asap(forceUpdateIfMounted, this);

                var name = props.name;
                if (props.type === 'radio' && name != null) {
                    var rootNode = ReactMount.getNode(this._rootNodeID);
                    var queryRoot = rootNode;

                    while (queryRoot.parentNode) {
                        queryRoot = queryRoot.parentNode;
                    }

                    // If `rootNode.form` was non-null, then we could try `form.elements`,
                    // but that sometimes behaves strangely in IE8. We could also try using
                    // `form.getElementsByName`, but that will only return direct children
                    // and won't include inputs that use the HTML5 `form=` attribute. Since
                    // the input might not even be in a form, let's just use the global
                    // `querySelectorAll` to ensure we don't miss anything.
                    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

                    for (var i = 0; i < group.length; i++) {
                        var otherNode = group[i];
                        if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                            continue;
                        }
                        // This will throw if radio buttons rendered by different copies of React
                        // and the same name are rendered into the same form (same as #1939).
                        // That's probably okay; we don't support it just as we don't support
                        // mixing React with non-React.
                        var otherID = ReactMount.getID(otherNode);
                        !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
                        var otherInstance = instancesByReactID[otherID];
                        !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
                        // If this is a controlled radio button group, forcing the input that
                        // was previously checked to update will cause it to be come re-checked
                        // as appropriate.
                        ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
                    }
                }

                return returnValue;
            }

            module.exports = ReactDOMInput;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 180 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule LinkedValueUtils
         * @typechecks static-only
         */

        'use strict';

            var ReactPropTypes = __webpack_require__(181);
            var ReactPropTypeLocations = __webpack_require__(139);

            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            var hasReadOnlyValue = {
                'button': true,
                'checkbox': true,
                'image': true,
                'hidden': true,
                'radio': true,
                'reset': true,
                'submit': true
            };

            function _assertSingleLink(inputProps) {
                !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
            }
            function _assertValueLink(inputProps) {
                _assertSingleLink(inputProps);
                !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
            }

            function _assertCheckedLink(inputProps) {
                _assertSingleLink(inputProps);
                !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
            }

            var propTypes = {
                value: function value(props, propName, componentName) {
                    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
                        return null;
                    }
                    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
                },
                checked: function checked(props, propName, componentName) {
                    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
                        return null;
                    }
                    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
                },
                onChange: ReactPropTypes.func
            };

            var loggedTypeFailures = {};
            function getDeclarationErrorAddendum(owner) {
                if (owner) {
                    var name = owner.getName();
                    if (name) {
                        return ' Check the render method of `' + name + '`.';
                    }
                }
                return '';
            }

            /**
             * Provide a linked `value` attribute for controlled forms. You should not use
             * this outside of the ReactDOM controlled form components.
             */
            var LinkedValueUtils = {
                checkPropTypes: function checkPropTypes(tagName, props, owner) {
                    for (var propName in propTypes) {
                        if (propTypes.hasOwnProperty(propName)) {
                            var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
                        }
                        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                            // Only monitor this failure once because there tends to be a lot of the
                            // same error.
                            loggedTypeFailures[error.message] = true;

                            var addendum = getDeclarationErrorAddendum(owner);
                            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
                        }
                    }
                },

                /**
                 * @param {object} inputProps Props for form component
                 * @return {*} current value of the input either from value prop or link.
                 */
                getValue: function getValue(inputProps) {
                    if (inputProps.valueLink) {
                        _assertValueLink(inputProps);
                        return inputProps.valueLink.value;
                    }
                    return inputProps.value;
                },

                /**
                 * @param {object} inputProps Props for form component
                 * @return {*} current checked status of the input either from checked prop
                 *             or link.
                 */
                getChecked: function getChecked(inputProps) {
                    if (inputProps.checkedLink) {
                        _assertCheckedLink(inputProps);
                        return inputProps.checkedLink.value;
                    }
                    return inputProps.checked;
                },

                /**
                 * @param {object} inputProps Props for form component
                 * @param {SyntheticEvent} event change event to handle
                 */
                executeOnChange: function executeOnChange(inputProps, event) {
                    if (inputProps.valueLink) {
                        _assertValueLink(inputProps);
                        return inputProps.valueLink.requestChange(event.target.value);
                    } else if (inputProps.checkedLink) {
                        _assertCheckedLink(inputProps);
                        return inputProps.checkedLink.requestChange(event.target.checked);
                    } else if (inputProps.onChange) {
                        return inputProps.onChange.call(undefined, event);
                    }
                }
            };

            module.exports = LinkedValueUtils;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 181 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactPropTypes
         */

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        var ReactElement = __webpack_require__(116);
        var ReactPropTypeLocationNames = __webpack_require__(140);

        var emptyFunction = __webpack_require__(89);
        var getIteratorFn = __webpack_require__(182);

        /**
         * Collection of methods that allow declaration and validation of props that are
         * supplied to React components. Example usage:
         *
         *   var Props = require('ReactPropTypes');
         *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
         *
         * A more formal specification of how these methods are used:
         *
         *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
         *   decl := ReactPropTypes.{type}(.isRequired)?
         *
         * Each and every declaration produces a function with the same signature. This
         * allows the creation of custom validation functions. For example:
         *
         *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
         *
         * @internal
         */

        var ANONYMOUS = '<<anonymous>>';

        var ReactPropTypes = {
            array: createPrimitiveTypeChecker('array'),
            bool: createPrimitiveTypeChecker('boolean'),
            func: createPrimitiveTypeChecker('function'),
            number: createPrimitiveTypeChecker('number'),
            object: createPrimitiveTypeChecker('object'),
            string: createPrimitiveTypeChecker('string'),

            any: createAnyTypeChecker(),
            arrayOf: createArrayOfTypeChecker,
            element: createElementTypeChecker(),
            instanceOf: createInstanceTypeChecker,
            node: createNodeChecker(),
            objectOf: createObjectOfTypeChecker,
            oneOf: createEnumTypeChecker,
            oneOfType: createUnionTypeChecker,
            shape: createShapeTypeChecker
        };

        function createChainableTypeChecker(validate) {
            function checkType(isRequired, props, propName, componentName, location, propFullName) {
                componentName = componentName || ANONYMOUS;
                propFullName = propFullName || propName;
                if (props[propName] == null) {
                    var locationName = ReactPropTypeLocationNames[location];
                    if (isRequired) {
                        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
                    }
                    return null;
                } else {
                    return validate(props, propName, componentName, location, propFullName);
                }
            }

            var chainedCheckType = checkType.bind(null, false);
            chainedCheckType.isRequired = checkType.bind(null, true);

            return chainedCheckType;
        }

        function createPrimitiveTypeChecker(expectedType) {
            function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== expectedType) {
                    var locationName = ReactPropTypeLocationNames[location];
                    // `propValue` being instance of, say, date/regexp, pass the 'object'
                    // check, but we can offer a more precise error message here rather than
                    // 'of type `object`'.
                    var preciseType = getPreciseType(propValue);

                    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }

        function createAnyTypeChecker() {
            return createChainableTypeChecker(emptyFunction.thatReturns(null));
        }

        function createArrayOfTypeChecker(typeChecker) {
            function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                if (!Array.isArray(propValue)) {
                    var locationName = ReactPropTypeLocationNames[location];
                    var propType = getPropType(propValue);
                    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
                }
                for (var i = 0; i < propValue.length; i++) {
                    var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
                    if (error instanceof Error) {
                        return error;
                    }
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }

        function createElementTypeChecker() {
            function validate(props, propName, componentName, location, propFullName) {
                if (!ReactElement.isValidElement(props[propName])) {
                    var locationName = ReactPropTypeLocationNames[location];
                    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }

        function createInstanceTypeChecker(expectedClass) {
            function validate(props, propName, componentName, location, propFullName) {
                if (!(props[propName] instanceof expectedClass)) {
                    var locationName = ReactPropTypeLocationNames[location];
                    var expectedClassName = expectedClass.name || ANONYMOUS;
                    var actualClassName = getClassName(props[propName]);
                    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }

        function createEnumTypeChecker(expectedValues) {
            if (!Array.isArray(expectedValues)) {
                return createChainableTypeChecker(function () {
                    return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
                });
            }

            function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                for (var i = 0; i < expectedValues.length; i++) {
                    if (propValue === expectedValues[i]) {
                        return null;
                    }
                }

                var locationName = ReactPropTypeLocationNames[location];
                var valuesString = JSON.stringify(expectedValues);
                return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
            }
            return createChainableTypeChecker(validate);
        }

        function createObjectOfTypeChecker(typeChecker) {
            function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== 'object') {
                    var locationName = ReactPropTypeLocationNames[location];
                    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
                }
                for (var key in propValue) {
                    if (propValue.hasOwnProperty(key)) {
                        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
                        if (error instanceof Error) {
                            return error;
                        }
                    }
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }

        function createUnionTypeChecker(arrayOfTypeCheckers) {
            if (!Array.isArray(arrayOfTypeCheckers)) {
                return createChainableTypeChecker(function () {
                    return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
                });
            }

            function validate(props, propName, componentName, location, propFullName) {
                for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                    var checker = arrayOfTypeCheckers[i];
                    if (checker(props, propName, componentName, location, propFullName) == null) {
                        return null;
                    }
                }

                var locationName = ReactPropTypeLocationNames[location];
                return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
            }
            return createChainableTypeChecker(validate);
        }

        function createNodeChecker() {
            function validate(props, propName, componentName, location, propFullName) {
                if (!isNode(props[propName])) {
                    var locationName = ReactPropTypeLocationNames[location];
                    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }

        function createShapeTypeChecker(shapeTypes) {
            function validate(props, propName, componentName, location, propFullName) {
                var propValue = props[propName];
                var propType = getPropType(propValue);
                if (propType !== 'object') {
                    var locationName = ReactPropTypeLocationNames[location];
                    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
                }
                for (var key in shapeTypes) {
                    var checker = shapeTypes[key];
                    if (!checker) {
                        continue;
                    }
                    var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
                    if (error) {
                        return error;
                    }
                }
                return null;
            }
            return createChainableTypeChecker(validate);
        }

        function isNode(propValue) {
            switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
                case 'number':
                case 'string':
                case 'undefined':
                    return true;
                case 'boolean':
                    return !propValue;
                case 'object':
                    if (Array.isArray(propValue)) {
                        return propValue.every(isNode);
                    }
                    if (propValue === null || ReactElement.isValidElement(propValue)) {
                        return true;
                    }

                    var iteratorFn = getIteratorFn(propValue);
                    if (iteratorFn) {
                        var iterator = iteratorFn.call(propValue);
                        var step;
                        if (iteratorFn !== propValue.entries) {
                            while (!(step = iterator.next()).done) {
                                if (!isNode(step.value)) {
                                    return false;
                                }
                            }
                        } else {
                            // Iterator will provide entry [k,v] tuples rather than values.
                            while (!(step = iterator.next()).done) {
                                var entry = step.value;
                                if (entry) {
                                    if (!isNode(entry[1])) {
                                        return false;
                                    }
                                }
                            }
                        }
                    } else {
                        return false;
                    }

                    return true;
                default:
                    return false;
            }
        }

        // Equivalent of `typeof` but with special handling for array and regexp.
        function getPropType(propValue) {
            var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
            if (Array.isArray(propValue)) {
                return 'array';
            }
            if (propValue instanceof RegExp) {
                // Old webkits (at least until Android 4.0) return 'function' rather than
                // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
                // passes PropTypes.object.
                return 'object';
            }
            return propType;
        }

        // This handles more types than `getPropType`. Only used for error messages.
        // See `createPrimitiveTypeChecker`.
        function getPreciseType(propValue) {
            var propType = getPropType(propValue);
            if (propType === 'object') {
                if (propValue instanceof Date) {
                    return 'date';
                } else if (propValue instanceof RegExp) {
                    return 'regexp';
                }
            }
            return propType;
        }

        // Returns class name of the object, if any.
        function getClassName(propValue) {
            if (!propValue.constructor || !propValue.constructor.name) {
                return '<<anonymous>>';
            }
            return propValue.constructor.name;
        }

        module.exports = ReactPropTypes;

        /***/ },
    /* 182 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getIteratorFn
         * @typechecks static-only
         */

        'use strict';

        /* global Symbol */

        var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

        /**
         * Returns the iterator method function contained on the iterable object.
         *
         * Be sure to invoke the function with the iterable as context:
         *
         *     var iteratorFn = getIteratorFn(myIterable);
         *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
         *
         * @param {?object} maybeIterable
         * @return {?function}
         */
        function getIteratorFn(maybeIterable) {
            var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
            if (typeof iteratorFn === 'function') {
                return iteratorFn;
            }
        }

        module.exports = getIteratorFn;

        /***/ },
    /* 183 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMOption
         */

        'use strict';

            var ReactChildren = __webpack_require__(184);
            var ReactDOMSelect = __webpack_require__(186);

            var assign = __webpack_require__(113);
            var warning = __webpack_require__(99);

            var valueContextKey = ReactDOMSelect.valueContextKey;

            /**
             * Implements an <option> native component that warns when `selected` is set.
             */
            var ReactDOMOption = {
                mountWrapper: function mountWrapper(inst, props, context) {
                    // TODO (yungsters): Remove support for `selected` in <option>.
                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
                    }

                    // Look up whether this option is 'selected' via context
                    var selectValue = context[valueContextKey];

                    // If context key is null (e.g., no specified value or after initial mount)
                    // or missing (e.g., for <datalist>), we don't change props.selected
                    var selected = null;
                    if (selectValue != null) {
                        selected = false;
                        if (Array.isArray(selectValue)) {
                            // multiple
                            for (var i = 0; i < selectValue.length; i++) {
                                if ('' + selectValue[i] === '' + props.value) {
                                    selected = true;
                                    break;
                                }
                            }
                        } else {
                            selected = '' + selectValue === '' + props.value;
                        }
                    }

                    inst._wrapperState = { selected: selected };
                },

                getNativeProps: function getNativeProps(inst, props, context) {
                    var nativeProps = assign({ selected: undefined, children: undefined }, props);

                    // Read state only from initial mount because <select> updates value
                    // manually; we need the initial state only for server rendering
                    if (inst._wrapperState.selected != null) {
                        nativeProps.selected = inst._wrapperState.selected;
                    }

                    var content = '';

                    // Flatten children and warn if they aren't strings or numbers;
                    // invalid types are ignored.
                    ReactChildren.forEach(props.children, function (child) {
                        if (child == null) {
                            return;
                        }
                        if (typeof child === 'string' || typeof child === 'number') {
                            content += child;
                        } else {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
                        }
                    });

                    nativeProps.children = content;
                    return nativeProps;
                }

            };

            module.exports = ReactDOMOption;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 184 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactChildren
         */

        'use strict';

        var PooledClass = __webpack_require__(130);
        var ReactElement = __webpack_require__(116);

        var emptyFunction = __webpack_require__(89);
        var traverseAllChildren = __webpack_require__(185);

        var twoArgumentPooler = PooledClass.twoArgumentPooler;
        var fourArgumentPooler = PooledClass.fourArgumentPooler;

        var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
        function escapeUserProvidedKey(text) {
            return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
        }

        /**
         * PooledClass representing the bookkeeping associated with performing a child
         * traversal. Allows avoiding binding callbacks.
         *
         * @constructor ForEachBookKeeping
         * @param {!function} forEachFunction Function to perform traversal with.
         * @param {?*} forEachContext Context to perform context with.
         */
        function ForEachBookKeeping(forEachFunction, forEachContext) {
            this.func = forEachFunction;
            this.context = forEachContext;
            this.count = 0;
        }
        ForEachBookKeeping.prototype.destructor = function () {
            this.func = null;
            this.context = null;
            this.count = 0;
        };
        PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

        function forEachSingleChild(bookKeeping, child, name) {
            var func = bookKeeping.func;
            var context = bookKeeping.context;

            func.call(context, child, bookKeeping.count++);
        }

        /**
         * Iterates through children that are typically specified as `props.children`.
         *
         * The provided forEachFunc(child, index) will be called for each
         * leaf child.
         *
         * @param {?*} children Children tree container.
         * @param {function(*, int)} forEachFunc
         * @param {*} forEachContext Context for forEachContext.
         */
        function forEachChildren(children, forEachFunc, forEachContext) {
            if (children == null) {
                return children;
            }
            var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
            traverseAllChildren(children, forEachSingleChild, traverseContext);
            ForEachBookKeeping.release(traverseContext);
        }

        /**
         * PooledClass representing the bookkeeping associated with performing a child
         * mapping. Allows avoiding binding callbacks.
         *
         * @constructor MapBookKeeping
         * @param {!*} mapResult Object containing the ordered map of results.
         * @param {!function} mapFunction Function to perform mapping with.
         * @param {?*} mapContext Context to perform mapping with.
         */
        function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
            this.result = mapResult;
            this.keyPrefix = keyPrefix;
            this.func = mapFunction;
            this.context = mapContext;
            this.count = 0;
        }
        MapBookKeeping.prototype.destructor = function () {
            this.result = null;
            this.keyPrefix = null;
            this.func = null;
            this.context = null;
            this.count = 0;
        };
        PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

        function mapSingleChildIntoContext(bookKeeping, child, childKey) {
            var result = bookKeeping.result;
            var keyPrefix = bookKeeping.keyPrefix;
            var func = bookKeeping.func;
            var context = bookKeeping.context;

            var mappedChild = func.call(context, child, bookKeeping.count++);
            if (Array.isArray(mappedChild)) {
                mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
            } else if (mappedChild != null) {
                if (ReactElement.isValidElement(mappedChild)) {
                    mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
                        // Keep both the (mapped) and old keys if they differ, just as
                        // traverseAllChildren used to do for objects as children
                        keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
                }
                result.push(mappedChild);
            }
        }

        function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
            var escapedPrefix = '';
            if (prefix != null) {
                escapedPrefix = escapeUserProvidedKey(prefix) + '/';
            }
            var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
            traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
            MapBookKeeping.release(traverseContext);
        }

        /**
         * Maps children that are typically specified as `props.children`.
         *
         * The provided mapFunction(child, key, index) will be called for each
         * leaf child.
         *
         * @param {?*} children Children tree container.
         * @param {function(*, int)} func The map function.
         * @param {*} context Context for mapFunction.
         * @return {object} Object containing the ordered map of results.
         */
        function mapChildren(children, func, context) {
            if (children == null) {
                return children;
            }
            var result = [];
            mapIntoWithKeyPrefixInternal(children, result, null, func, context);
            return result;
        }

        function forEachSingleChildDummy(traverseContext, child, name) {
            return null;
        }

        /**
         * Count the number of children that are typically specified as
         * `props.children`.
         *
         * @param {?*} children Children tree container.
         * @return {number} The number of children.
         */
        function countChildren(children, context) {
            return traverseAllChildren(children, forEachSingleChildDummy, null);
        }

        /**
         * Flatten a children object (typically specified as `props.children`) and
         * return an array with appropriately re-keyed children.
         */
        function toArray(children) {
            var result = [];
            mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
            return result;
        }

        var ReactChildren = {
            forEach: forEachChildren,
            map: mapChildren,
            mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
            count: countChildren,
            toArray: toArray
        };

        module.exports = ReactChildren;

        /***/ },
    /* 185 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule traverseAllChildren
         */

        'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var ReactCurrentOwner = __webpack_require__(79);
            var ReactElement = __webpack_require__(116);
            var ReactInstanceHandles = __webpack_require__(119);

            var getIteratorFn = __webpack_require__(182);
            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            var SEPARATOR = ReactInstanceHandles.SEPARATOR;
            var SUBSEPARATOR = ':';

            /**
             * TODO: Test that a single child and an array with one item have the same key
             * pattern.
             */

            var userProvidedKeyEscaperLookup = {
                '=': '=0',
                '.': '=1',
                ':': '=2'
            };

            var userProvidedKeyEscapeRegex = /[=.:]/g;

            var didWarnAboutMaps = false;

            function userProvidedKeyEscaper(match) {
                return userProvidedKeyEscaperLookup[match];
            }

            /**
             * Generate a key string that identifies a component within a set.
             *
             * @param {*} component A component that could contain a manual key.
             * @param {number} index Index that is used if a manual key is not provided.
             * @return {string}
             */
            function getComponentKey(component, index) {
                if (component && component.key != null) {
                    // Explicit key
                    return wrapUserProvidedKey(component.key);
                }
                // Implicit key determined by the index in the set
                return index.toString(36);
            }

            /**
             * Escape a component key so that it is safe to use in a reactid.
             *
             * @param {*} text Component key to be escaped.
             * @return {string} An escaped string.
             */
            function escapeUserProvidedKey(text) {
                return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
            }

            /**
             * Wrap a `key` value explicitly provided by the user to distinguish it from
             * implicitly-generated keys generated by a component's index in its parent.
             *
             * @param {string} key Value of a user-provided `key` attribute
             * @return {string}
             */
            function wrapUserProvidedKey(key) {
                return '$' + escapeUserProvidedKey(key);
            }

            /**
             * @param {?*} children Children tree container.
             * @param {!string} nameSoFar Name of the key path so far.
             * @param {!function} callback Callback to invoke with each child found.
             * @param {?*} traverseContext Used to pass information throughout the traversal
             * process.
             * @return {!number} The number of children in this subtree.
             */
            function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
                var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

                if (type === 'undefined' || type === 'boolean') {
                    // All of the above are perceived as null.
                    children = null;
                }

                if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
                    callback(traverseContext, children,
                        // If it's the only child, treat the name as if it was wrapped in an array
                        // so that it's consistent if the number of children grows.
                        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
                    return 1;
                }

                var child;
                var nextName;
                var subtreeCount = 0; // Count of children found in the current subtree.
                var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

                if (Array.isArray(children)) {
                    for (var i = 0; i < children.length; i++) {
                        child = children[i];
                        nextName = nextNamePrefix + getComponentKey(child, i);
                        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                    }
                } else {
                    var iteratorFn = getIteratorFn(children);
                    if (iteratorFn) {
                        var iterator = iteratorFn.call(children);
                        var step;
                        if (iteratorFn !== children.entries) {
                            var ii = 0;
                            while (!(step = iterator.next()).done) {
                                child = step.value;
                                nextName = nextNamePrefix + getComponentKey(child, ii++);
                                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                            }
                        } else {
                            if (process.env.NODE_ENV !== 'production') {
                                process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
                                didWarnAboutMaps = true;
                            }
                            // Iterator will provide entry [k,v] tuples rather than values.
                            while (!(step = iterator.next()).done) {
                                var entry = step.value;
                                if (entry) {
                                    child = entry[1];
                                    nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                                    subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                                }
                            }
                        }
                    } else if (type === 'object') {
                        var addendum = '';
                        if (process.env.NODE_ENV !== 'production') {
                            addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
                            if (children._isReactElement) {
                                addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
                            }
                            if (ReactCurrentOwner.current) {
                                var name = ReactCurrentOwner.current.getName();
                                if (name) {
                                    addendum += ' Check the render method of `' + name + '`.';
                                }
                            }
                        }
                        var childrenString = String(children);
                        true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
                    }
                }

                return subtreeCount;
            }

            /**
             * Traverses children that are typically specified as `props.children`, but
             * might also be specified through attributes:
             *
             * - `traverseAllChildren(this.props.children, ...)`
             * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
             *
             * The `traverseContext` is an optional argument that is passed through the
             * entire traversal. It can be used to store accumulations or anything else that
             * the callback might find relevant.
             *
             * @param {?*} children Children tree object.
             * @param {!function} callback To invoke upon traversing each child.
             * @param {?*} traverseContext Context for traversal.
             * @return {!number} The number of children in this subtree.
             */
            function traverseAllChildren(children, callback, traverseContext) {
                if (children == null) {
                    return 0;
                }

                return traverseAllChildrenImpl(children, '', callback, traverseContext);
            }

            module.exports = traverseAllChildren;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 186 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMSelect
         */

        'use strict';

            var LinkedValueUtils = __webpack_require__(180);
            var ReactMount = __webpack_require__(102);
            var ReactUpdates = __webpack_require__(128);

            var assign = __webpack_require__(113);
            var warning = __webpack_require__(99);

            var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);

            function updateOptionsIfPendingUpdateAndMounted() {
                if (this._rootNodeID && this._wrapperState.pendingUpdate) {
                    this._wrapperState.pendingUpdate = false;

                    var props = this._currentElement.props;
                    var value = LinkedValueUtils.getValue(props);

                    if (value != null) {
                        updateOptions(this, Boolean(props.multiple), value);
                    }
                }
            }

            function getDeclarationErrorAddendum(owner) {
                if (owner) {
                    var name = owner.getName();
                    if (name) {
                        return ' Check the render method of `' + name + '`.';
                    }
                }
                return '';
            }

            var valuePropNames = ['value', 'defaultValue'];

            /**
             * Validation function for `value` and `defaultValue`.
             * @private
             */
            function checkSelectPropTypes(inst, props) {
                var owner = inst._currentElement._owner;
                LinkedValueUtils.checkPropTypes('select', props, owner);

                for (var i = 0; i < valuePropNames.length; i++) {
                    var propName = valuePropNames[i];
                    if (props[propName] == null) {
                        continue;
                    }
                    if (props.multiple) {
                        process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
                    } else {
                        process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
                    }
                }
            }

            /**
             * @param {ReactDOMComponent} inst
             * @param {boolean} multiple
             * @param {*} propValue A stringable (with `multiple`, a list of stringables).
             * @private
             */
            function updateOptions(inst, multiple, propValue) {
                var selectedValue, i;
                var options = ReactMount.getNode(inst._rootNodeID).options;

                if (multiple) {
                    selectedValue = {};
                    for (i = 0; i < propValue.length; i++) {
                        selectedValue['' + propValue[i]] = true;
                    }
                    for (i = 0; i < options.length; i++) {
                        var selected = selectedValue.hasOwnProperty(options[i].value);
                        if (options[i].selected !== selected) {
                            options[i].selected = selected;
                        }
                    }
                } else {
                    // Do not set `select.value` as exact behavior isn't consistent across all
                    // browsers for all cases.
                    selectedValue = '' + propValue;
                    for (i = 0; i < options.length; i++) {
                        if (options[i].value === selectedValue) {
                            options[i].selected = true;
                            return;
                        }
                    }
                    if (options.length) {
                        options[0].selected = true;
                    }
                }
            }

            /**
             * Implements a <select> native component that allows optionally setting the
             * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
             * stringable. If `multiple` is true, the prop must be an array of stringables.
             *
             * If `value` is not supplied (or null/undefined), user actions that change the
             * selected option will trigger updates to the rendered options.
             *
             * If it is supplied (and not null/undefined), the rendered options will not
             * update in response to user actions. Instead, the `value` prop must change in
             * order for the rendered options to update.
             *
             * If `defaultValue` is provided, any options with the supplied values will be
             * selected.
             */
            var ReactDOMSelect = {
                valueContextKey: valueContextKey,

                getNativeProps: function getNativeProps(inst, props, context) {
                    return assign({}, props, {
                        onChange: inst._wrapperState.onChange,
                        value: undefined
                    });
                },

                mountWrapper: function mountWrapper(inst, props) {
                    if (process.env.NODE_ENV !== 'production') {
                        checkSelectPropTypes(inst, props);
                    }

                    var value = LinkedValueUtils.getValue(props);
                    inst._wrapperState = {
                        pendingUpdate: false,
                        initialValue: value != null ? value : props.defaultValue,
                        onChange: _handleChange.bind(inst),
                        wasMultiple: Boolean(props.multiple)
                    };
                },

                processChildContext: function processChildContext(inst, props, context) {
                    // Pass down initial value so initial generated markup has correct
                    // `selected` attributes
                    var childContext = assign({}, context);
                    childContext[valueContextKey] = inst._wrapperState.initialValue;
                    return childContext;
                },

                postUpdateWrapper: function postUpdateWrapper(inst) {
                    var props = inst._currentElement.props;

                    // After the initial mount, we control selected-ness manually so don't pass
                    // the context value down
                    inst._wrapperState.initialValue = undefined;

                    var wasMultiple = inst._wrapperState.wasMultiple;
                    inst._wrapperState.wasMultiple = Boolean(props.multiple);

                    var value = LinkedValueUtils.getValue(props);
                    if (value != null) {
                        inst._wrapperState.pendingUpdate = false;
                        updateOptions(inst, Boolean(props.multiple), value);
                    } else if (wasMultiple !== Boolean(props.multiple)) {
                        // For simplicity, reapply `defaultValue` if `multiple` is toggled.
                        if (props.defaultValue != null) {
                            updateOptions(inst, Boolean(props.multiple), props.defaultValue);
                        } else {
                            // Revert the select back to its default unselected state.
                            updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
                        }
                    }
                }
            };

            function _handleChange(event) {
                var props = this._currentElement.props;
                var returnValue = LinkedValueUtils.executeOnChange(props, event);

                this._wrapperState.pendingUpdate = true;
                ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
                return returnValue;
            }

            module.exports = ReactDOMSelect;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 187 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMTextarea
         */

        'use strict';

            var LinkedValueUtils = __webpack_require__(180);
            var ReactDOMIDOperations = __webpack_require__(101);
            var ReactUpdates = __webpack_require__(128);

            var assign = __webpack_require__(113);
            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            function forceUpdateIfMounted() {
                if (this._rootNodeID) {
                    // DOM component is still mounted; update
                    ReactDOMTextarea.updateWrapper(this);
                }
            }

            /**
             * Implements a <textarea> native component that allows setting `value`, and
             * `defaultValue`. This differs from the traditional DOM API because value is
             * usually set as PCDATA children.
             *
             * If `value` is not supplied (or null/undefined), user actions that affect the
             * value will trigger updates to the element.
             *
             * If `value` is supplied (and not null/undefined), the rendered element will
             * not trigger updates to the element. Instead, the `value` prop must change in
             * order for the rendered element to be updated.
             *
             * The rendered element will be initialized with an empty value, the prop
             * `defaultValue` if specified, or the children content (deprecated).
             */
            var ReactDOMTextarea = {
                getNativeProps: function getNativeProps(inst, props, context) {
                    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;

                    // Always set children to the same thing. In IE9, the selection range will
                    // get reset if `textContent` is mutated.
                    var nativeProps = assign({}, props, {
                        defaultValue: undefined,
                        value: undefined,
                        children: inst._wrapperState.initialValue,
                        onChange: inst._wrapperState.onChange
                    });

                    return nativeProps;
                },

                mountWrapper: function mountWrapper(inst, props) {
                    if (process.env.NODE_ENV !== 'production') {
                        LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
                    }

                    var defaultValue = props.defaultValue;
                    // TODO (yungsters): Remove support for children content in <textarea>.
                    var children = props.children;
                    if (children != null) {
                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
                        }
                        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
                        if (Array.isArray(children)) {
                            !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
                            children = children[0];
                        }

                        defaultValue = '' + children;
                    }
                    if (defaultValue == null) {
                        defaultValue = '';
                    }
                    var value = LinkedValueUtils.getValue(props);

                    inst._wrapperState = {
                        // We save the initial value so that `ReactDOMComponent` doesn't update
                        // `textContent` (unnecessary since we update value).
                        // The initial value can be a boolean or object so that's why it's
                        // forced to be a string.
                        initialValue: '' + (value != null ? value : defaultValue),
                        onChange: _handleChange.bind(inst)
                    };
                },

                updateWrapper: function updateWrapper(inst) {
                    var props = inst._currentElement.props;
                    var value = LinkedValueUtils.getValue(props);
                    if (value != null) {
                        // Cast `value` to a string to ensure the value is set correctly. While
                        // browsers typically do this as necessary, jsdom doesn't.
                        ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
                    }
                }
            };

            function _handleChange(event) {
                var props = this._currentElement.props;
                var returnValue = LinkedValueUtils.executeOnChange(props, event);
                ReactUpdates.asap(forceUpdateIfMounted, this);
                return returnValue;
            }

            module.exports = ReactDOMTextarea;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 188 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactMultiChild
         * @typechecks static-only
         */

        'use strict';

            var ReactComponentEnvironment = __webpack_require__(138);
            var ReactMultiChildUpdateTypes = __webpack_require__(90);

            var ReactCurrentOwner = __webpack_require__(79);
            var ReactReconciler = __webpack_require__(124);
            var ReactChildReconciler = __webpack_require__(189);

            var flattenChildren = __webpack_require__(190);

            /**
             * Updating children of a component may trigger recursive updates. The depth is
             * used to batch recursive updates to render markup more efficiently.
             *
             * @type {number}
             * @private
             */
            var updateDepth = 0;

            /**
             * Queue of update configuration objects.
             *
             * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
             *
             * @type {array<object>}
             * @private
             */
            var updateQueue = [];

            /**
             * Queue of markup to be rendered.
             *
             * @type {array<string>}
             * @private
             */
            var markupQueue = [];

            /**
             * Enqueues markup to be rendered and inserted at a supplied index.
             *
             * @param {string} parentID ID of the parent component.
             * @param {string} markup Markup that renders into an element.
             * @param {number} toIndex Destination index.
             * @private
             */
            function enqueueInsertMarkup(parentID, markup, toIndex) {
                // NOTE: Null values reduce hidden classes.
                updateQueue.push({
                    parentID: parentID,
                    parentNode: null,
                    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
                    markupIndex: markupQueue.push(markup) - 1,
                    content: null,
                    fromIndex: null,
                    toIndex: toIndex
                });
            }

            /**
             * Enqueues moving an existing element to another index.
             *
             * @param {string} parentID ID of the parent component.
             * @param {number} fromIndex Source index of the existing element.
             * @param {number} toIndex Destination index of the element.
             * @private
             */
            function enqueueMove(parentID, fromIndex, toIndex) {
                // NOTE: Null values reduce hidden classes.
                updateQueue.push({
                    parentID: parentID,
                    parentNode: null,
                    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
                    markupIndex: null,
                    content: null,
                    fromIndex: fromIndex,
                    toIndex: toIndex
                });
            }

            /**
             * Enqueues removing an element at an index.
             *
             * @param {string} parentID ID of the parent component.
             * @param {number} fromIndex Index of the element to remove.
             * @private
             */
            function enqueueRemove(parentID, fromIndex) {
                // NOTE: Null values reduce hidden classes.
                updateQueue.push({
                    parentID: parentID,
                    parentNode: null,
                    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
                    markupIndex: null,
                    content: null,
                    fromIndex: fromIndex,
                    toIndex: null
                });
            }

            /**
             * Enqueues setting the markup of a node.
             *
             * @param {string} parentID ID of the parent component.
             * @param {string} markup Markup that renders into an element.
             * @private
             */
            function enqueueSetMarkup(parentID, markup) {
                // NOTE: Null values reduce hidden classes.
                updateQueue.push({
                    parentID: parentID,
                    parentNode: null,
                    type: ReactMultiChildUpdateTypes.SET_MARKUP,
                    markupIndex: null,
                    content: markup,
                    fromIndex: null,
                    toIndex: null
                });
            }

            /**
             * Enqueues setting the text content.
             *
             * @param {string} parentID ID of the parent component.
             * @param {string} textContent Text content to set.
             * @private
             */
            function enqueueTextContent(parentID, textContent) {
                // NOTE: Null values reduce hidden classes.
                updateQueue.push({
                    parentID: parentID,
                    parentNode: null,
                    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
                    markupIndex: null,
                    content: textContent,
                    fromIndex: null,
                    toIndex: null
                });
            }

            /**
             * Processes any enqueued updates.
             *
             * @private
             */
            function processQueue() {
                if (updateQueue.length) {
                    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
                    clearQueue();
                }
            }

            /**
             * Clears any enqueued updates.
             *
             * @private
             */
            function clearQueue() {
                updateQueue.length = 0;
                markupQueue.length = 0;
            }

            /**
             * ReactMultiChild are capable of reconciling multiple children.
             *
             * @class ReactMultiChild
             * @internal
             */
            var ReactMultiChild = {

                /**
                 * Provides common functionality for components that must reconcile multiple
                 * children. This is used by `ReactDOMComponent` to mount, update, and
                 * unmount child components.
                 *
                 * @lends {ReactMultiChild.prototype}
                 */
                Mixin: {

                    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
                        if (process.env.NODE_ENV !== 'production') {
                            if (this._currentElement) {
                                try {
                                    ReactCurrentOwner.current = this._currentElement._owner;
                                    return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
                                } finally {
                                    ReactCurrentOwner.current = null;
                                }
                            }
                        }
                        return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
                    },

                    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context) {
                        var nextChildren;
                        if (process.env.NODE_ENV !== 'production') {
                            if (this._currentElement) {
                                try {
                                    ReactCurrentOwner.current = this._currentElement._owner;
                                    nextChildren = flattenChildren(nextNestedChildrenElements);
                                } finally {
                                    ReactCurrentOwner.current = null;
                                }
                                return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
                            }
                        }
                        nextChildren = flattenChildren(nextNestedChildrenElements);
                        return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
                    },

                    /**
                     * Generates a "mount image" for each of the supplied children. In the case
                     * of `ReactDOMComponent`, a mount image is a string of markup.
                     *
                     * @param {?object} nestedChildren Nested child maps.
                     * @return {array} An array of mounted representations.
                     * @internal
                     */
                    mountChildren: function mountChildren(nestedChildren, transaction, context) {
                        var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
                        this._renderedChildren = children;
                        var mountImages = [];
                        var index = 0;
                        for (var name in children) {
                            if (children.hasOwnProperty(name)) {
                                var child = children[name];
                                // Inlined for performance, see `ReactInstanceHandles.createReactID`.
                                var rootID = this._rootNodeID + name;
                                var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
                                child._mountIndex = index++;
                                mountImages.push(mountImage);
                            }
                        }
                        return mountImages;
                    },

                    /**
                     * Replaces any rendered children with a text content string.
                     *
                     * @param {string} nextContent String of content.
                     * @internal
                     */
                    updateTextContent: function updateTextContent(nextContent) {
                        updateDepth++;
                        var errorThrown = true;
                        try {
                            var prevChildren = this._renderedChildren;
                            // Remove any rendered children.
                            ReactChildReconciler.unmountChildren(prevChildren);
                            // TODO: The setTextContent operation should be enough
                            for (var name in prevChildren) {
                                if (prevChildren.hasOwnProperty(name)) {
                                    this._unmountChild(prevChildren[name]);
                                }
                            }
                            // Set new text content.
                            this.setTextContent(nextContent);
                            errorThrown = false;
                        } finally {
                            updateDepth--;
                            if (!updateDepth) {
                                if (errorThrown) {
                                    clearQueue();
                                } else {
                                    processQueue();
                                }
                            }
                        }
                    },

                    /**
                     * Replaces any rendered children with a markup string.
                     *
                     * @param {string} nextMarkup String of markup.
                     * @internal
                     */
                    updateMarkup: function updateMarkup(nextMarkup) {
                        updateDepth++;
                        var errorThrown = true;
                        try {
                            var prevChildren = this._renderedChildren;
                            // Remove any rendered children.
                            ReactChildReconciler.unmountChildren(prevChildren);
                            for (var name in prevChildren) {
                                if (prevChildren.hasOwnProperty(name)) {
                                    this._unmountChildByName(prevChildren[name], name);
                                }
                            }
                            this.setMarkup(nextMarkup);
                            errorThrown = false;
                        } finally {
                            updateDepth--;
                            if (!updateDepth) {
                                if (errorThrown) {
                                    clearQueue();
                                } else {
                                    processQueue();
                                }
                            }
                        }
                    },

                    /**
                     * Updates the rendered children with new children.
                     *
                     * @param {?object} nextNestedChildrenElements Nested child element maps.
                     * @param {ReactReconcileTransaction} transaction
                     * @internal
                     */
                    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
                        updateDepth++;
                        var errorThrown = true;
                        try {
                            this._updateChildren(nextNestedChildrenElements, transaction, context);
                            errorThrown = false;
                        } finally {
                            updateDepth--;
                            if (!updateDepth) {
                                if (errorThrown) {
                                    clearQueue();
                                } else {
                                    processQueue();
                                }
                            }
                        }
                    },

                    /**
                     * Improve performance by isolating this hot code path from the try/catch
                     * block in `updateChildren`.
                     *
                     * @param {?object} nextNestedChildrenElements Nested child element maps.
                     * @param {ReactReconcileTransaction} transaction
                     * @final
                     * @protected
                     */
                    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
                        var prevChildren = this._renderedChildren;
                        var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
                        this._renderedChildren = nextChildren;
                        if (!nextChildren && !prevChildren) {
                            return;
                        }
                        var name;
                        // `nextIndex` will increment for each child in `nextChildren`, but
                        // `lastIndex` will be the last index visited in `prevChildren`.
                        var lastIndex = 0;
                        var nextIndex = 0;
                        for (name in nextChildren) {
                            if (!nextChildren.hasOwnProperty(name)) {
                                continue;
                            }
                            var prevChild = prevChildren && prevChildren[name];
                            var nextChild = nextChildren[name];
                            if (prevChild === nextChild) {
                                this.moveChild(prevChild, nextIndex, lastIndex);
                                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                                prevChild._mountIndex = nextIndex;
                            } else {
                                if (prevChild) {
                                    // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
                                    lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                                    this._unmountChild(prevChild);
                                }
                                // The child must be instantiated before it's mounted.
                                this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
                            }
                            nextIndex++;
                        }
                        // Remove children that are no longer present.
                        for (name in prevChildren) {
                            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
                                this._unmountChild(prevChildren[name]);
                            }
                        }
                    },

                    /**
                     * Unmounts all rendered children. This should be used to clean up children
                     * when this component is unmounted.
                     *
                     * @internal
                     */
                    unmountChildren: function unmountChildren() {
                        var renderedChildren = this._renderedChildren;
                        ReactChildReconciler.unmountChildren(renderedChildren);
                        this._renderedChildren = null;
                    },

                    /**
                     * Moves a child component to the supplied index.
                     *
                     * @param {ReactComponent} child Component to move.
                     * @param {number} toIndex Destination index of the element.
                     * @param {number} lastIndex Last index visited of the siblings of `child`.
                     * @protected
                     */
                    moveChild: function moveChild(child, toIndex, lastIndex) {
                        // If the index of `child` is less than `lastIndex`, then it needs to
                        // be moved. Otherwise, we do not need to move it because a child will be
                        // inserted or moved before `child`.
                        if (child._mountIndex < lastIndex) {
                            enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
                        }
                    },

                    /**
                     * Creates a child component.
                     *
                     * @param {ReactComponent} child Component to create.
                     * @param {string} mountImage Markup to insert.
                     * @protected
                     */
                    createChild: function createChild(child, mountImage) {
                        enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
                    },

                    /**
                     * Removes a child component.
                     *
                     * @param {ReactComponent} child Child to remove.
                     * @protected
                     */
                    removeChild: function removeChild(child) {
                        enqueueRemove(this._rootNodeID, child._mountIndex);
                    },

                    /**
                     * Sets this text content string.
                     *
                     * @param {string} textContent Text content to set.
                     * @protected
                     */
                    setTextContent: function setTextContent(textContent) {
                        enqueueTextContent(this._rootNodeID, textContent);
                    },

                    /**
                     * Sets this markup string.
                     *
                     * @param {string} markup Markup to set.
                     * @protected
                     */
                    setMarkup: function setMarkup(markup) {
                        enqueueSetMarkup(this._rootNodeID, markup);
                    },

                    /**
                     * Mounts a child with the supplied name.
                     *
                     * NOTE: This is part of `updateChildren` and is here for readability.
                     *
                     * @param {ReactComponent} child Component to mount.
                     * @param {string} name Name of the child.
                     * @param {number} index Index at which to insert the child.
                     * @param {ReactReconcileTransaction} transaction
                     * @private
                     */
                    _mountChildByNameAtIndex: function _mountChildByNameAtIndex(child, name, index, transaction, context) {
                        // Inlined for performance, see `ReactInstanceHandles.createReactID`.
                        var rootID = this._rootNodeID + name;
                        var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
                        child._mountIndex = index;
                        this.createChild(child, mountImage);
                    },

                    /**
                     * Unmounts a rendered child.
                     *
                     * NOTE: This is part of `updateChildren` and is here for readability.
                     *
                     * @param {ReactComponent} child Component to unmount.
                     * @private
                     */
                    _unmountChild: function _unmountChild(child) {
                        this.removeChild(child);
                        child._mountIndex = null;
                    }

                }

            };

            module.exports = ReactMultiChild;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 189 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactChildReconciler
         * @typechecks static-only
         */

        'use strict';

            var ReactReconciler = __webpack_require__(124);

            var instantiateReactComponent = __webpack_require__(136);
            var shouldUpdateReactComponent = __webpack_require__(141);
            var traverseAllChildren = __webpack_require__(185);
            var warning = __webpack_require__(99);

            function instantiateChild(childInstances, child, name) {
                // We found a component instance.
                var keyUnique = childInstances[name] === undefined;
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
                }
                if (child != null && keyUnique) {
                    childInstances[name] = instantiateReactComponent(child, null);
                }
            }

            /**
             * ReactChildReconciler provides helpers for initializing or updating a set of
             * children. Its output is suitable for passing it onto ReactMultiChild which
             * does diffed reordering and insertion.
             */
            var ReactChildReconciler = {
                /**
                 * Generates a "mount image" for each of the supplied children. In the case
                 * of `ReactDOMComponent`, a mount image is a string of markup.
                 *
                 * @param {?object} nestedChildNodes Nested child maps.
                 * @return {?object} A set of child instances.
                 * @internal
                 */
                instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context) {
                    if (nestedChildNodes == null) {
                        return null;
                    }
                    var childInstances = {};
                    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
                    return childInstances;
                },

                /**
                 * Updates the rendered children and returns a new set of children.
                 *
                 * @param {?object} prevChildren Previously initialized set of children.
                 * @param {?object} nextChildren Flat child element maps.
                 * @param {ReactReconcileTransaction} transaction
                 * @param {object} context
                 * @return {?object} A new set of child instances.
                 * @internal
                 */
                updateChildren: function updateChildren(prevChildren, nextChildren, transaction, context) {
                    // We currently don't have a way to track moves here but if we use iterators
                    // instead of for..in we can zip the iterators and check if an item has
                    // moved.
                    // TODO: If nothing has changed, return the prevChildren object so that we
                    // can quickly bailout if nothing has changed.
                    if (!nextChildren && !prevChildren) {
                        return null;
                    }
                    var name;
                    for (name in nextChildren) {
                        if (!nextChildren.hasOwnProperty(name)) {
                            continue;
                        }
                        var prevChild = prevChildren && prevChildren[name];
                        var prevElement = prevChild && prevChild._currentElement;
                        var nextElement = nextChildren[name];
                        if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
                            ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
                            nextChildren[name] = prevChild;
                        } else {
                            if (prevChild) {
                                ReactReconciler.unmountComponent(prevChild, name);
                            }
                            // The child must be instantiated before it's mounted.
                            var nextChildInstance = instantiateReactComponent(nextElement, null);
                            nextChildren[name] = nextChildInstance;
                        }
                    }
                    // Unmount children that are no longer present.
                    for (name in prevChildren) {
                        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
                            ReactReconciler.unmountComponent(prevChildren[name]);
                        }
                    }
                    return nextChildren;
                },

                /**
                 * Unmounts all rendered children. This should be used to clean up children
                 * when this component is unmounted.
                 *
                 * @param {?object} renderedChildren Previously initialized set of children.
                 * @internal
                 */
                unmountChildren: function unmountChildren(renderedChildren) {
                    for (var name in renderedChildren) {
                        if (renderedChildren.hasOwnProperty(name)) {
                            var renderedChild = renderedChildren[name];
                            ReactReconciler.unmountComponent(renderedChild);
                        }
                    }
                }

            };

            module.exports = ReactChildReconciler;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 190 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule flattenChildren
         */

        'use strict';

            var traverseAllChildren = __webpack_require__(185);
            var warning = __webpack_require__(99);

            /**
             * @param {function} traverseContext Context passed through traversal.
             * @param {?ReactComponent} child React child component.
             * @param {!string} name String name of key path to child.
             */
            function flattenSingleChildIntoContext(traverseContext, child, name) {
                // We found a component instance.
                var result = traverseContext;
                var keyUnique = result[name] === undefined;
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
                }
                if (keyUnique && child != null) {
                    result[name] = child;
                }
            }

            /**
             * Flattens children that are typically specified as `props.children`. Any null
             * children will not be included in the resulting object.
             * @return {!object} flattened children keyed by name.
             */
            function flattenChildren(children) {
                if (children == null) {
                    return children;
                }
                var result = {};
                traverseAllChildren(children, flattenSingleChildIntoContext, result);
                return result;
            }

            module.exports = flattenChildren;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 191 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule shallowEqual
         * @typechecks
         *
         */

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        var hasOwnProperty = Object.prototype.hasOwnProperty;

        /**
         * Performs equality by iterating through keys on an object and returning false
         * when any key has values which are not strictly equal between the arguments.
         * Returns true when the values of all keys are strictly equal.
         */
        function shallowEqual(objA, objB) {
            if (objA === objB) {
                return true;
            }

            if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
                return false;
            }

            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);

            if (keysA.length !== keysB.length) {
                return false;
            }

            // Test for A's keys different from B.
            var bHasOwnProperty = hasOwnProperty.bind(objB);
            for (var i = 0; i < keysA.length; i++) {
                if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
                    return false;
                }
            }

            return true;
        }

        module.exports = shallowEqual;

        /***/ },
    /* 192 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactEventListener
         * @typechecks static-only
         */

        'use strict';

        var EventListener = __webpack_require__(193);
        var ExecutionEnvironment = __webpack_require__(83);
        var PooledClass = __webpack_require__(130);
        var ReactInstanceHandles = __webpack_require__(119);
        var ReactMount = __webpack_require__(102);
        var ReactUpdates = __webpack_require__(128);

        var assign = __webpack_require__(113);
        var getEventTarget = __webpack_require__(155);
        var getUnboundedScrollPosition = __webpack_require__(194);

        var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

        /**
         * Finds the parent React component of `node`.
         *
         * @param {*} node
         * @return {?DOMEventTarget} Parent container, or `null` if the specified node
         *                           is not nested.
         */
        function findParent(node) {
            // TODO: It may be a good idea to cache this to prevent unnecessary DOM
            // traversal, but caching is difficult to do correctly without using a
            // mutation observer to listen for all DOM changes.
            var nodeID = ReactMount.getID(node);
            var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
            var container = ReactMount.findReactContainerForID(rootID);
            var parent = ReactMount.getFirstReactDOM(container);
            return parent;
        }

        // Used to store ancestor hierarchy in top level callback
        function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
            this.topLevelType = topLevelType;
            this.nativeEvent = nativeEvent;
            this.ancestors = [];
        }
        assign(TopLevelCallbackBookKeeping.prototype, {
            destructor: function destructor() {
                this.topLevelType = null;
                this.nativeEvent = null;
                this.ancestors.length = 0;
            }
        });
        PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

        function handleTopLevelImpl(bookKeeping) {
            // TODO: Re-enable event.path handling
            //
            // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
            //   // New browsers have a path attribute on native events
            //   handleTopLevelWithPath(bookKeeping);
            // } else {
            //   // Legacy browsers don't have a path attribute on native events
            //   handleTopLevelWithoutPath(bookKeeping);
            // }

            void handleTopLevelWithPath; // temporarily unused
            handleTopLevelWithoutPath(bookKeeping);
        }

        // Legacy browsers don't have a path attribute on native events
        function handleTopLevelWithoutPath(bookKeeping) {
            var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;

            // Loop through the hierarchy, in case there's any nested components.
            // It's important that we build the array of ancestors before calling any
            // event handlers, because event handlers can modify the DOM, leading to
            // inconsistencies with ReactMount's node cache. See #1105.
            var ancestor = topLevelTarget;
            while (ancestor) {
                bookKeeping.ancestors.push(ancestor);
                ancestor = findParent(ancestor);
            }

            for (var i = 0; i < bookKeeping.ancestors.length; i++) {
                topLevelTarget = bookKeeping.ancestors[i];
                var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
                ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
            }
        }

        // New browsers have a path attribute on native events
        function handleTopLevelWithPath(bookKeeping) {
            var path = bookKeeping.nativeEvent.path;
            var currentNativeTarget = path[0];
            var eventsFired = 0;
            for (var i = 0; i < path.length; i++) {
                var currentPathElement = path[i];
                if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
                    currentNativeTarget = path[i + 1];
                }
                // TODO: slow
                var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
                if (reactParent === currentPathElement) {
                    var currentPathElementID = ReactMount.getID(currentPathElement);
                    var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
                    bookKeeping.ancestors.push(currentPathElement);

                    var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
                    eventsFired++;
                    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);

                    // Jump to the root of this React render tree
                    while (currentPathElementID !== newRootID) {
                        i++;
                        currentPathElement = path[i];
                        currentPathElementID = ReactMount.getID(currentPathElement);
                    }
                }
            }
            if (eventsFired === 0) {
                ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
            }
        }

        function scrollValueMonitor(cb) {
            var scrollPosition = getUnboundedScrollPosition(window);
            cb(scrollPosition);
        }

        var ReactEventListener = {
            _enabled: true,
            _handleTopLevel: null,

            WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

            setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
                ReactEventListener._handleTopLevel = handleTopLevel;
            },

            setEnabled: function setEnabled(enabled) {
                ReactEventListener._enabled = !!enabled;
            },

            isEnabled: function isEnabled() {
                return ReactEventListener._enabled;
            },

            /**
             * Traps top-level events by using event bubbling.
             *
             * @param {string} topLevelType Record from `EventConstants`.
             * @param {string} handlerBaseName Event name (e.g. "click").
             * @param {object} handle Element on which to attach listener.
             * @return {?object} An object with a remove function which will forcefully
             *                  remove the listener.
             * @internal
             */
            trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
                var element = handle;
                if (!element) {
                    return null;
                }
                return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
            },

            /**
             * Traps a top-level event by using event capturing.
             *
             * @param {string} topLevelType Record from `EventConstants`.
             * @param {string} handlerBaseName Event name (e.g. "click").
             * @param {object} handle Element on which to attach listener.
             * @return {?object} An object with a remove function which will forcefully
             *                  remove the listener.
             * @internal
             */
            trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
                var element = handle;
                if (!element) {
                    return null;
                }
                return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
            },

            monitorScrollValue: function monitorScrollValue(refresh) {
                var callback = scrollValueMonitor.bind(null, refresh);
                EventListener.listen(window, 'scroll', callback);
            },

            dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
                if (!ReactEventListener._enabled) {
                    return;
                }

                var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
                try {
                    // Event queue being processed in the same cycle allows
                    // `preventDefault`.
                    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
                } finally {
                    TopLevelCallbackBookKeeping.release(bookKeeping);
                }
            }
        };

        module.exports = ReactEventListener;

        /***/ },
    /* 193 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * @providesModule EventListener
         * @typechecks
         */

        'use strict';

            var emptyFunction = __webpack_require__(89);

            /**
             * Upstream version of event listener. Does not take into account specific
             * nature of platform.
             */
            var EventListener = {
                /**
                 * Listen to DOM events during the bubble phase.
                 *
                 * @param {DOMEventTarget} target DOM element to register listener on.
                 * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
                 * @param {function} callback Callback function.
                 * @return {object} Object with a `remove` method.
                 */
                listen: function listen(target, eventType, callback) {
                    if (target.addEventListener) {
                        target.addEventListener(eventType, callback, false);
                        return {
                            remove: function remove() {
                                target.removeEventListener(eventType, callback, false);
                            }
                        };
                    } else if (target.attachEvent) {
                        target.attachEvent('on' + eventType, callback);
                        return {
                            remove: function remove() {
                                target.detachEvent('on' + eventType, callback);
                            }
                        };
                    }
                },

                /**
                 * Listen to DOM events during the capture phase.
                 *
                 * @param {DOMEventTarget} target DOM element to register listener on.
                 * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
                 * @param {function} callback Callback function.
                 * @return {object} Object with a `remove` method.
                 */
                capture: function capture(target, eventType, callback) {
                    if (target.addEventListener) {
                        target.addEventListener(eventType, callback, true);
                        return {
                            remove: function remove() {
                                target.removeEventListener(eventType, callback, true);
                            }
                        };
                    } else {
                        if (process.env.NODE_ENV !== 'production') {
                            console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
                        }
                        return {
                            remove: emptyFunction
                        };
                    }
                },

                registerDefault: function registerDefault() {}
            };

            module.exports = EventListener;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 194 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getUnboundedScrollPosition
         * @typechecks
         */

        'use strict';

        /**
         * Gets the scroll position of the supplied element or window.
         *
         * The return values are unbounded, unlike `getScrollPosition`. This means they
         * may be negative or exceed the element boundaries (which is possible using
         * inertial scrolling).
         *
         * @param {DOMWindow|DOMElement} scrollable
         * @return {object} Map with `x` and `y` keys.
         */

        function getUnboundedScrollPosition(scrollable) {
            if (scrollable === window) {
                return {
                    x: window.pageXOffset || document.documentElement.scrollLeft,
                    y: window.pageYOffset || document.documentElement.scrollTop
                };
            }
            return {
                x: scrollable.scrollLeft,
                y: scrollable.scrollTop
            };
        }

        module.exports = getUnboundedScrollPosition;

        /***/ },
    /* 195 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactInjection
         */

        'use strict';

        var DOMProperty = __webpack_require__(97);
        var EventPluginHub = __webpack_require__(105);
        var ReactComponentEnvironment = __webpack_require__(138);
        var ReactClass = __webpack_require__(196);
        var ReactEmptyComponent = __webpack_require__(142);
        var ReactBrowserEventEmitter = __webpack_require__(103);
        var ReactNativeComponent = __webpack_require__(143);
        var ReactPerf = __webpack_require__(92);
        var ReactRootIndex = __webpack_require__(120);
        var ReactUpdates = __webpack_require__(128);

        var ReactInjection = {
            Component: ReactComponentEnvironment.injection,
            Class: ReactClass.injection,
            DOMProperty: DOMProperty.injection,
            EmptyComponent: ReactEmptyComponent.injection,
            EventPluginHub: EventPluginHub.injection,
            EventEmitter: ReactBrowserEventEmitter.injection,
            NativeComponent: ReactNativeComponent.injection,
            Perf: ReactPerf.injection,
            RootIndex: ReactRootIndex.injection,
            Updates: ReactUpdates.injection
        };

        module.exports = ReactInjection;

        /***/ },
    /* 196 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactClass
         */

        'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var ReactComponent = __webpack_require__(197);
            var ReactElement = __webpack_require__(116);
            var ReactPropTypeLocations = __webpack_require__(139);
            var ReactPropTypeLocationNames = __webpack_require__(140);
            var ReactNoopUpdateQueue = __webpack_require__(198);

            var assign = __webpack_require__(113);
            var emptyObject = __webpack_require__(132);
            var invariant = __webpack_require__(87);
            var keyMirror = __webpack_require__(91);
            var keyOf = __webpack_require__(153);
            var warning = __webpack_require__(99);

            var MIXINS_KEY = keyOf({ mixins: null });

            /**
             * Policies that describe methods in `ReactClassInterface`.
             */
            var SpecPolicy = keyMirror({
                /**
                 * These methods may be defined only once by the class specification or mixin.
                 */
                DEFINE_ONCE: null,
                /**
                 * These methods may be defined by both the class specification and mixins.
                 * Subsequent definitions will be chained. These methods must return void.
                 */
                DEFINE_MANY: null,
                /**
                 * These methods are overriding the base class.
                 */
                OVERRIDE_BASE: null,
                /**
                 * These methods are similar to DEFINE_MANY, except we assume they return
                 * objects. We try to merge the keys of the return values of all the mixed in
                 * functions. If there is a key conflict we throw.
                 */
                DEFINE_MANY_MERGED: null
            });

            var injectedMixins = [];

            var warnedSetProps = false;
            function warnSetProps() {
                if (!warnedSetProps) {
                    warnedSetProps = true;
                    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
                }
            }

            /**
             * Composite components are higher-level components that compose other composite
             * or native components.
             *
             * To create a new type of `ReactClass`, pass a specification of
             * your new class to `React.createClass`. The only requirement of your class
             * specification is that you implement a `render` method.
             *
             *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
             *
             * The class specification supports a specific protocol of methods that have
             * special meaning (e.g. `render`). See `ReactClassInterface` for
             * more the comprehensive protocol. Any other properties and methods in the
             * class specification will be available on the prototype.
             *
             * @interface ReactClassInterface
             * @internal
             */
            var ReactClassInterface = {

                /**
                 * An array of Mixin objects to include when defining your component.
                 *
                 * @type {array}
                 * @optional
                 */
                mixins: SpecPolicy.DEFINE_MANY,

                /**
                 * An object containing properties and methods that should be defined on
                 * the component's constructor instead of its prototype (static methods).
                 *
                 * @type {object}
                 * @optional
                 */
                statics: SpecPolicy.DEFINE_MANY,

                /**
                 * Definition of prop types for this component.
                 *
                 * @type {object}
                 * @optional
                 */
                propTypes: SpecPolicy.DEFINE_MANY,

                /**
                 * Definition of context types for this component.
                 *
                 * @type {object}
                 * @optional
                 */
                contextTypes: SpecPolicy.DEFINE_MANY,

                /**
                 * Definition of context types this component sets for its children.
                 *
                 * @type {object}
                 * @optional
                 */
                childContextTypes: SpecPolicy.DEFINE_MANY,

                // ==== Definition methods ====

                /**
                 * Invoked when the component is mounted. Values in the mapping will be set on
                 * `this.props` if that prop is not specified (i.e. using an `in` check).
                 *
                 * This method is invoked before `getInitialState` and therefore cannot rely
                 * on `this.state` or use `this.setState`.
                 *
                 * @return {object}
                 * @optional
                 */
                getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

                /**
                 * Invoked once before the component is mounted. The return value will be used
                 * as the initial value of `this.state`.
                 *
                 *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
                 *
                 * @return {object}
                 * @optional
                 */
                getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

                /**
                 * @return {object}
                 * @optional
                 */
                getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

                /**
                 * Uses props from `this.props` and state from `this.state` to render the
                 * structure of the component.
                 *
                 * No guarantees are made about when or how often this method is invoked, so
                 * it must not have side effects.
                 *
                 *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
                 *
                 * @return {ReactComponent}
                 * @nosideeffects
                 * @required
                 */
                render: SpecPolicy.DEFINE_ONCE,

                // ==== Delegate methods ====

                /**
                 * Invoked when the component is initially created and about to be mounted.
                 * This may have side effects, but any external subscriptions or data created
                 * by this method must be cleaned up in `componentWillUnmount`.
                 *
                 * @optional
                 */
                componentWillMount: SpecPolicy.DEFINE_MANY,

                /**
                 * Invoked when the component has been mounted and has a DOM representation.
                 * However, there is no guarantee that the DOM node is in the document.
                 *
                 * Use this as an opportunity to operate on the DOM when the component has
                 * been mounted (initialized and rendered) for the first time.
                 *
                 * @param {DOMElement} rootNode DOM element representing the component.
                 * @optional
                 */
                componentDidMount: SpecPolicy.DEFINE_MANY,

                /**
                 * Invoked before the component receives new props.
                 *
                 * Use this as an opportunity to react to a prop transition by updating the
                 * state using `this.setState`. Current props are accessed via `this.props`.
                 *
                 *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
                 *
                 * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
                 * transition may cause a state change, but the opposite is not true. If you
                 * need it, you are probably looking for `componentWillUpdate`.
                 *
                 * @param {object} nextProps
                 * @optional
                 */
                componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

                /**
                 * Invoked while deciding if the component should be updated as a result of
                 * receiving new props, state and/or context.
                 *
                 * Use this as an opportunity to `return false` when you're certain that the
                 * transition to the new props/state/context will not require a component
                 * update.
                 *
                 *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
                 *
                 * @param {object} nextProps
                 * @param {?object} nextState
                 * @param {?object} nextContext
                 * @return {boolean} True if the component should update.
                 * @optional
                 */
                shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

                /**
                 * Invoked when the component is about to update due to a transition from
                 * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
                 * and `nextContext`.
                 *
                 * Use this as an opportunity to perform preparation before an update occurs.
                 *
                 * NOTE: You **cannot** use `this.setState()` in this method.
                 *
                 * @param {object} nextProps
                 * @param {?object} nextState
                 * @param {?object} nextContext
                 * @param {ReactReconcileTransaction} transaction
                 * @optional
                 */
                componentWillUpdate: SpecPolicy.DEFINE_MANY,

                /**
                 * Invoked when the component's DOM representation has been updated.
                 *
                 * Use this as an opportunity to operate on the DOM when the component has
                 * been updated.
                 *
                 * @param {object} prevProps
                 * @param {?object} prevState
                 * @param {?object} prevContext
                 * @param {DOMElement} rootNode DOM element representing the component.
                 * @optional
                 */
                componentDidUpdate: SpecPolicy.DEFINE_MANY,

                /**
                 * Invoked when the component is about to be removed from its parent and have
                 * its DOM representation destroyed.
                 *
                 * Use this as an opportunity to deallocate any external resources.
                 *
                 * NOTE: There is no `componentDidUnmount` since your component will have been
                 * destroyed by that point.
                 *
                 * @optional
                 */
                componentWillUnmount: SpecPolicy.DEFINE_MANY,

                // ==== Advanced methods ====

                /**
                 * Updates the component's currently mounted DOM representation.
                 *
                 * By default, this implements React's rendering and reconciliation algorithm.
                 * Sophisticated clients may wish to override this.
                 *
                 * @param {ReactReconcileTransaction} transaction
                 * @internal
                 * @overridable
                 */
                updateComponent: SpecPolicy.OVERRIDE_BASE

            };

            /**
             * Mapping from class specification keys to special processing functions.
             *
             * Although these are declared like instance properties in the specification
             * when defining classes using `React.createClass`, they are actually static
             * and are accessible on the constructor instead of the prototype. Despite
             * being static, they must be defined outside of the "statics" key under
             * which all other static methods are defined.
             */
            var RESERVED_SPEC_KEYS = {
                displayName: function displayName(Constructor, _displayName) {
                    Constructor.displayName = _displayName;
                },
                mixins: function mixins(Constructor, _mixins) {
                    if (_mixins) {
                        for (var i = 0; i < _mixins.length; i++) {
                            mixSpecIntoComponent(Constructor, _mixins[i]);
                        }
                    }
                },
                childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
                    if (process.env.NODE_ENV !== 'production') {
                        validateTypeDef(Constructor, _childContextTypes, ReactPropTypeLocations.childContext);
                    }
                    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, _childContextTypes);
                },
                contextTypes: function contextTypes(Constructor, _contextTypes) {
                    if (process.env.NODE_ENV !== 'production') {
                        validateTypeDef(Constructor, _contextTypes, ReactPropTypeLocations.context);
                    }
                    Constructor.contextTypes = assign({}, Constructor.contextTypes, _contextTypes);
                },
                /**
                 * Special case getDefaultProps which should move into statics but requires
                 * automatic merging.
                 */
                getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
                    if (Constructor.getDefaultProps) {
                        Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
                    } else {
                        Constructor.getDefaultProps = _getDefaultProps;
                    }
                },
                propTypes: function propTypes(Constructor, _propTypes) {
                    if (process.env.NODE_ENV !== 'production') {
                        validateTypeDef(Constructor, _propTypes, ReactPropTypeLocations.prop);
                    }
                    Constructor.propTypes = assign({}, Constructor.propTypes, _propTypes);
                },
                statics: function statics(Constructor, _statics) {
                    mixStaticSpecIntoComponent(Constructor, _statics);
                },
                autobind: function autobind() {} };

            // noop
            function validateTypeDef(Constructor, typeDef, location) {
                for (var propName in typeDef) {
                    if (typeDef.hasOwnProperty(propName)) {
                        // use a warning instead of an invariant so components
                        // don't show up in prod but not in __DEV__
                        process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
                    }
                }
            }

            function validateMethodOverride(proto, name) {
                var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

                // Disallow overriding of base class methods unless explicitly allowed.
                if (ReactClassMixin.hasOwnProperty(name)) {
                    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
                }

                // Disallow defining methods more than once unless explicitly allowed.
                if (proto.hasOwnProperty(name)) {
                    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
                }
            }

            /**
             * Mixin helper which handles policy validation and reserved
             * specification keys when building React classses.
             */
            function mixSpecIntoComponent(Constructor, spec) {
                if (!spec) {
                    return;
                }

                !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
                !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;

                var proto = Constructor.prototype;

                // By handling mixins before any other properties, we ensure the same
                // chaining order is applied to methods with DEFINE_MANY policy, whether
                // mixins are listed before or after these methods in the spec.
                if (spec.hasOwnProperty(MIXINS_KEY)) {
                    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
                }

                for (var name in spec) {
                    if (!spec.hasOwnProperty(name)) {
                        continue;
                    }

                    if (name === MIXINS_KEY) {
                        // We have already handled mixins in a special case above.
                        continue;
                    }

                    var property = spec[name];
                    validateMethodOverride(proto, name);

                    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
                        RESERVED_SPEC_KEYS[name](Constructor, property);
                    } else {
                        // Setup methods on prototype:
                        // The following member methods should not be automatically bound:
                        // 1. Expected ReactClass methods (in the "interface").
                        // 2. Overridden methods (that were mixed in).
                        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
                        var isAlreadyDefined = proto.hasOwnProperty(name);
                        var isFunction = typeof property === 'function';
                        var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

                        if (shouldAutoBind) {
                            if (!proto.__reactAutoBindMap) {
                                proto.__reactAutoBindMap = {};
                            }
                            proto.__reactAutoBindMap[name] = property;
                            proto[name] = property;
                        } else {
                            if (isAlreadyDefined) {
                                var specPolicy = ReactClassInterface[name];

                                // These cases should already be caught by validateMethodOverride.
                                !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;

                                // For methods which are defined more than once, call the existing
                                // methods before calling the new property, merging if appropriate.
                                if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
                                    proto[name] = createMergedResultFunction(proto[name], property);
                                } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
                                    proto[name] = createChainedFunction(proto[name], property);
                                }
                            } else {
                                proto[name] = property;
                                if (process.env.NODE_ENV !== 'production') {
                                    // Add verbose displayName to the function, which helps when looking
                                    // at profiling tools.
                                    if (typeof property === 'function' && spec.displayName) {
                                        proto[name].displayName = spec.displayName + '_' + name;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function mixStaticSpecIntoComponent(Constructor, statics) {
                if (!statics) {
                    return;
                }
                for (var name in statics) {
                    var property = statics[name];
                    if (!statics.hasOwnProperty(name)) {
                        continue;
                    }

                    var isReserved = name in RESERVED_SPEC_KEYS;
                    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;

                    var isInherited = name in Constructor;
                    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
                    Constructor[name] = property;
                }
            }

            /**
             * Merge two objects, but throw if both contain the same key.
             *
             * @param {object} one The first object, which is mutated.
             * @param {object} two The second object
             * @return {object} one after it has been mutated to contain everything in two.
             */
            function mergeIntoWithNoDuplicateKeys(one, two) {
                !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;

                for (var key in two) {
                    if (two.hasOwnProperty(key)) {
                        !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
                        one[key] = two[key];
                    }
                }
                return one;
            }

            /**
             * Creates a function that invokes two functions and merges their return values.
             *
             * @param {function} one Function to invoke first.
             * @param {function} two Function to invoke second.
             * @return {function} Function that invokes the two argument functions.
             * @private
             */
            function createMergedResultFunction(one, two) {
                return function mergedResult() {
                    var a = one.apply(this, arguments);
                    var b = two.apply(this, arguments);
                    if (a == null) {
                        return b;
                    } else if (b == null) {
                        return a;
                    }
                    var c = {};
                    mergeIntoWithNoDuplicateKeys(c, a);
                    mergeIntoWithNoDuplicateKeys(c, b);
                    return c;
                };
            }

            /**
             * Creates a function that invokes two functions and ignores their return vales.
             *
             * @param {function} one Function to invoke first.
             * @param {function} two Function to invoke second.
             * @return {function} Function that invokes the two argument functions.
             * @private
             */
            function createChainedFunction(one, two) {
                return function chainedFunction() {
                    one.apply(this, arguments);
                    two.apply(this, arguments);
                };
            }

            /**
             * Binds a method to the component.
             *
             * @param {object} component Component whose method is going to be bound.
             * @param {function} method Method to be bound.
             * @return {function} The bound method.
             */
            function bindAutoBindMethod(component, method) {
                var boundMethod = method.bind(component);
                if (process.env.NODE_ENV !== 'production') {
                    boundMethod.__reactBoundContext = component;
                    boundMethod.__reactBoundMethod = method;
                    boundMethod.__reactBoundArguments = null;
                    var componentName = component.constructor.displayName;
                    var _bind = boundMethod.bind;
                    /* eslint-disable block-scoped-var, no-undef */
                    boundMethod.bind = function (newThis) {
                        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            args[_key - 1] = arguments[_key];
                        }

                        // User is trying to bind() an autobound method; we effectively will
                        // ignore the value of "this" that the user is trying to use, so
                        // let's warn.
                        if (newThis !== component && newThis !== null) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
                        } else if (!args.length) {
                            process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
                            return boundMethod;
                        }
                        var reboundMethod = _bind.apply(boundMethod, arguments);
                        reboundMethod.__reactBoundContext = component;
                        reboundMethod.__reactBoundMethod = method;
                        reboundMethod.__reactBoundArguments = args;
                        return reboundMethod;
                        /* eslint-enable */
                    };
                }
                return boundMethod;
            }

            /**
             * Binds all auto-bound methods in a component.
             *
             * @param {object} component Component whose method is going to be bound.
             */
            function bindAutoBindMethods(component) {
                for (var autoBindKey in component.__reactAutoBindMap) {
                    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
                        var method = component.__reactAutoBindMap[autoBindKey];
                        component[autoBindKey] = bindAutoBindMethod(component, method);
                    }
                }
            }

            /**
             * Add more to the ReactClass base class. These are all legacy features and
             * therefore not already part of the modern ReactComponent.
             */
            var ReactClassMixin = {

                /**
                 * TODO: This will be deprecated because state should always keep a consistent
                 * type signature and the only use case for this, is to avoid that.
                 */
                replaceState: function replaceState(newState, callback) {
                    this.updater.enqueueReplaceState(this, newState);
                    if (callback) {
                        this.updater.enqueueCallback(this, callback);
                    }
                },

                /**
                 * Checks whether or not this composite component is mounted.
                 * @return {boolean} True if mounted, false otherwise.
                 * @protected
                 * @final
                 */
                isMounted: function isMounted() {
                    return this.updater.isMounted(this);
                },

                /**
                 * Sets a subset of the props.
                 *
                 * @param {object} partialProps Subset of the next props.
                 * @param {?function} callback Called after props are updated.
                 * @final
                 * @public
                 * @deprecated
                 */
                setProps: function setProps(partialProps, callback) {
                    if (process.env.NODE_ENV !== 'production') {
                        warnSetProps();
                    }
                    this.updater.enqueueSetProps(this, partialProps);
                    if (callback) {
                        this.updater.enqueueCallback(this, callback);
                    }
                },

                /**
                 * Replace all the props.
                 *
                 * @param {object} newProps Subset of the next props.
                 * @param {?function} callback Called after props are updated.
                 * @final
                 * @public
                 * @deprecated
                 */
                replaceProps: function replaceProps(newProps, callback) {
                    if (process.env.NODE_ENV !== 'production') {
                        warnSetProps();
                    }
                    this.updater.enqueueReplaceProps(this, newProps);
                    if (callback) {
                        this.updater.enqueueCallback(this, callback);
                    }
                }
            };

            var ReactClassComponent = function ReactClassComponent() {};
            assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

            /**
             * Module for creating composite components.
             *
             * @class ReactClass
             */
            var ReactClass = {

                /**
                 * Creates a composite component class given a class specification.
                 *
                 * @param {object} spec Class specification (which must define `render`).
                 * @return {function} Component constructor function.
                 * @public
                 */
                createClass: function createClass(spec) {
                    var Constructor = function Constructor(props, context, updater) {
                        // This constructor is overridden by mocks. The argument is used
                        // by mocks to assert on what gets mounted.

                        if (process.env.NODE_ENV !== 'production') {
                            process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
                        }

                        // Wire up auto-binding
                        if (this.__reactAutoBindMap) {
                            bindAutoBindMethods(this);
                        }

                        this.props = props;
                        this.context = context;
                        this.refs = emptyObject;
                        this.updater = updater || ReactNoopUpdateQueue;

                        this.state = null;

                        // ReactClasses doesn't have constructors. Instead, they use the
                        // getInitialState and componentWillMount methods for initialization.

                        var initialState = this.getInitialState ? this.getInitialState() : null;
                        if (process.env.NODE_ENV !== 'production') {
                            // We allow auto-mocks to proceed as if they're returning null.
                            if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
                                // This is probably bad practice. Consider warning here and
                                // deprecating this convenience.
                                initialState = null;
                            }
                        }
                        !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;

                        this.state = initialState;
                    };
                    Constructor.prototype = new ReactClassComponent();
                    Constructor.prototype.constructor = Constructor;

                    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

                    mixSpecIntoComponent(Constructor, spec);

                    // Initialize the defaultProps property after all mixins have been merged.
                    if (Constructor.getDefaultProps) {
                        Constructor.defaultProps = Constructor.getDefaultProps();
                    }

                    if (process.env.NODE_ENV !== 'production') {
                        // This is a tag to indicate that the use of these method names is ok,
                        // since it's used with createClass. If it's not, then it's likely a
                        // mistake so we'll warn you to use the static property, property
                        // initializer or constructor respectively.
                        if (Constructor.getDefaultProps) {
                            Constructor.getDefaultProps.isReactClassApproved = {};
                        }
                        if (Constructor.prototype.getInitialState) {
                            Constructor.prototype.getInitialState.isReactClassApproved = {};
                        }
                    }

                    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;

                    if (process.env.NODE_ENV !== 'production') {
                        process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
                        process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
                    }

                    // Reduce time spent doing lookups by setting these on the prototype.
                    for (var methodName in ReactClassInterface) {
                        if (!Constructor.prototype[methodName]) {
                            Constructor.prototype[methodName] = null;
                        }
                    }

                    return Constructor;
                },

                injection: {
                    injectMixin: function injectMixin(mixin) {
                        injectedMixins.push(mixin);
                    }
                }

            };

            module.exports = ReactClass;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 197 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactComponent
         */

        'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var ReactNoopUpdateQueue = __webpack_require__(198);

            var canDefineProperty = __webpack_require__(117);
            var emptyObject = __webpack_require__(132);
            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            /**
             * Base class helpers for the updating state of a component.
             */
            function ReactComponent(props, context, updater) {
                this.props = props;
                this.context = context;
                this.refs = emptyObject;
                // We initialize the default updater but the real one gets injected by the
                // renderer.
                this.updater = updater || ReactNoopUpdateQueue;
            }

            ReactComponent.prototype.isReactComponent = {};

            /**
             * Sets a subset of the state. Always use this to mutate
             * state. You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * There is no guarantee that calls to `setState` will run synchronously,
             * as they may eventually be batched together.  You can provide an optional
             * callback that will be executed when the call to setState is actually
             * completed.
             *
             * When a function is provided to setState, it will be called at some point in
             * the future (not synchronously). It will be called with the up to date
             * component arguments (state, props, context). These values can be different
             * from this.* because your function may be called after receiveProps but before
             * shouldComponentUpdate, and this new state, props, and context will not yet be
             * assigned to this.
             *
             * @param {object|function} partialState Next partial state or function to
             *        produce next partial state to be merged with current state.
             * @param {?function} callback Called after state is updated.
             * @final
             * @protected
             */
            ReactComponent.prototype.setState = function (partialState, callback) {
                !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
                }
                this.updater.enqueueSetState(this, partialState);
                if (callback) {
                    this.updater.enqueueCallback(this, callback);
                }
            };

            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {?function} callback Called after update is complete.
             * @final
             * @protected
             */
            ReactComponent.prototype.forceUpdate = function (callback) {
                this.updater.enqueueForceUpdate(this);
                if (callback) {
                    this.updater.enqueueCallback(this, callback);
                }
            };

            /**
             * Deprecated APIs. These APIs used to exist on classic React classes but since
             * we would like to deprecate them, we're not going to move them over to this
             * modern base class. Instead, we define a getter that warns if it's accessed.
             */
            if (process.env.NODE_ENV !== 'production') {
                var deprecatedAPIs = {
                    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
                    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
                    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
                    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
                    setProps: ['setProps', 'Instead, call render again at the top level.']
                };
                var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
                    if (canDefineProperty) {
                        Object.defineProperty(ReactComponent.prototype, methodName, {
                            get: function get() {
                                process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
                                return undefined;
                            }
                        });
                    }
                };
                for (var fnName in deprecatedAPIs) {
                    if (deprecatedAPIs.hasOwnProperty(fnName)) {
                        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                    }
                }
            }

            module.exports = ReactComponent;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 198 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactNoopUpdateQueue
         */

        'use strict';

            var warning = __webpack_require__(99);

            function warnTDZ(publicInstance, callerName) {
                if (process.env.NODE_ENV !== 'production') {
                    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
                }
            }

            /**
             * This is the abstract API for an update queue.
             */
            var ReactNoopUpdateQueue = {

                /**
                 * Checks whether or not this composite component is mounted.
                 * @param {ReactClass} publicInstance The instance we want to test.
                 * @return {boolean} True if mounted, false otherwise.
                 * @protected
                 * @final
                 */
                isMounted: function isMounted(publicInstance) {
                    return false;
                },

                /**
                 * Enqueue a callback that will be executed after all the pending updates
                 * have processed.
                 *
                 * @param {ReactClass} publicInstance The instance to use as `this` context.
                 * @param {?function} callback Called after state is updated.
                 * @internal
                 */
                enqueueCallback: function enqueueCallback(publicInstance, callback) {},

                /**
                 * Forces an update. This should only be invoked when it is known with
                 * certainty that we are **not** in a DOM transaction.
                 *
                 * You may want to call this when you know that some deeper aspect of the
                 * component's state has changed but `setState` was not called.
                 *
                 * This will not invoke `shouldComponentUpdate`, but it will invoke
                 * `componentWillUpdate` and `componentDidUpdate`.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @internal
                 */
                enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
                    warnTDZ(publicInstance, 'forceUpdate');
                },

                /**
                 * Replaces all of the state. Always use this or `setState` to mutate state.
                 * You should treat `this.state` as immutable.
                 *
                 * There is no guarantee that `this.state` will be immediately updated, so
                 * accessing `this.state` after calling this method may return the old value.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} completeState Next state.
                 * @internal
                 */
                enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
                    warnTDZ(publicInstance, 'replaceState');
                },

                /**
                 * Sets a subset of the state. This only exists because _pendingState is
                 * internal. This provides a merging strategy that is not available to deep
                 * properties which is confusing. TODO: Expose pendingState or don't use it
                 * during the merge.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} partialState Next partial state to be merged with state.
                 * @internal
                 */
                enqueueSetState: function enqueueSetState(publicInstance, partialState) {
                    warnTDZ(publicInstance, 'setState');
                },

                /**
                 * Sets a subset of the props.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} partialProps Subset of the next props.
                 * @internal
                 */
                enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
                    warnTDZ(publicInstance, 'setProps');
                },

                /**
                 * Replaces all of the props.
                 *
                 * @param {ReactClass} publicInstance The instance that should rerender.
                 * @param {object} props New props.
                 * @internal
                 */
                enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
                    warnTDZ(publicInstance, 'replaceProps');
                }

            };

            module.exports = ReactNoopUpdateQueue;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 199 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactReconcileTransaction
         * @typechecks static-only
         */

        'use strict';

        var CallbackQueue = __webpack_require__(129);
        var PooledClass = __webpack_require__(130);
        var ReactBrowserEventEmitter = __webpack_require__(103);
        var ReactDOMFeatureFlags = __webpack_require__(115);
        var ReactInputSelection = __webpack_require__(200);
        var Transaction = __webpack_require__(131);

        var assign = __webpack_require__(113);

        /**
         * Ensures that, when possible, the selection range (currently selected text
         * input) is not disturbed by performing the transaction.
         */
        var SELECTION_RESTORATION = {
            /**
             * @return {Selection} Selection information.
             */
            initialize: ReactInputSelection.getSelectionInformation,
            /**
             * @param {Selection} sel Selection information returned from `initialize`.
             */
            close: ReactInputSelection.restoreSelection
        };

        /**
         * Suppresses events (blur/focus) that could be inadvertently dispatched due to
         * high level DOM manipulations (like temporarily removing a text input from the
         * DOM).
         */
        var EVENT_SUPPRESSION = {
            /**
             * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
             * the reconciliation.
             */
            initialize: function initialize() {
                var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
                ReactBrowserEventEmitter.setEnabled(false);
                return currentlyEnabled;
            },

            /**
             * @param {boolean} previouslyEnabled Enabled status of
             *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
             *   restores the previous value.
             */
            close: function close(previouslyEnabled) {
                ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
            }
        };

        /**
         * Provides a queue for collecting `componentDidMount` and
         * `componentDidUpdate` callbacks during the the transaction.
         */
        var ON_DOM_READY_QUEUEING = {
            /**
             * Initializes the internal `onDOMReady` queue.
             */
            initialize: function initialize() {
                this.reactMountReady.reset();
            },

            /**
             * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
             */
            close: function close() {
                this.reactMountReady.notifyAll();
            }
        };

        /**
         * Executed within the scope of the `Transaction` instance. Consider these as
         * being member methods, but with an implied ordering while being isolated from
         * each other.
         */
        var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

        /**
         * Currently:
         * - The order that these are listed in the transaction is critical:
         * - Suppresses events.
         * - Restores selection range.
         *
         * Future:
         * - Restore document/overflow scroll positions that were unintentionally
         *   modified via DOM insertions above the top viewport boundary.
         * - Implement/integrate with customized constraint based layout system and keep
         *   track of which dimensions must be remeasured.
         *
         * @class ReactReconcileTransaction
         */
        function ReactReconcileTransaction(forceHTML) {
            this.reinitializeTransaction();
            // Only server-side rendering really needs this option (see
            // `ReactServerRendering`), but server-side uses
            // `ReactServerRenderingTransaction` instead. This option is here so that it's
            // accessible and defaults to false when `ReactDOMComponent` and
            // `ReactTextComponent` checks it in `mountComponent`.`
            this.renderToStaticMarkup = false;
            this.reactMountReady = CallbackQueue.getPooled(null);
            this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
        }

        var Mixin = {
            /**
             * @see Transaction
             * @abstract
             * @final
             * @return {array<object>} List of operation wrap procedures.
             *   TODO: convert to array<TransactionWrapper>
             */
            getTransactionWrappers: function getTransactionWrappers() {
                return TRANSACTION_WRAPPERS;
            },

            /**
             * @return {object} The queue to collect `onDOMReady` callbacks with.
             */
            getReactMountReady: function getReactMountReady() {
                return this.reactMountReady;
            },

            /**
             * `PooledClass` looks for this, and will invoke this before allowing this
             * instance to be reused.
             */
            destructor: function destructor() {
                CallbackQueue.release(this.reactMountReady);
                this.reactMountReady = null;
            }
        };

        assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

        PooledClass.addPoolingTo(ReactReconcileTransaction);

        module.exports = ReactReconcileTransaction;

        /***/ },
    /* 200 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactInputSelection
         */

        'use strict';

        var ReactDOMSelection = __webpack_require__(201);

        var containsNode = __webpack_require__(133);
        var focusNode = __webpack_require__(169);
        var getActiveElement = __webpack_require__(203);

        function isInDocument(node) {
            return containsNode(document.documentElement, node);
        }

        /**
         * @ReactInputSelection: React input selection module. Based on Selection.js,
         * but modified to be suitable for react and has a couple of bug fixes (doesn't
         * assume buttons have range selections allowed).
         * Input selection module for React.
         */
        var ReactInputSelection = {

            hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
                var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
                return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
            },

            getSelectionInformation: function getSelectionInformation() {
                var focusedElem = getActiveElement();
                return {
                    focusedElem: focusedElem,
                    selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
                };
            },

            /**
             * @restoreSelection: If any selection information was potentially lost,
             * restore it. This is useful when performing operations that could remove dom
             * nodes and place them back in, resulting in focus being lost.
             */
            restoreSelection: function restoreSelection(priorSelectionInformation) {
                var curFocusedElem = getActiveElement();
                var priorFocusedElem = priorSelectionInformation.focusedElem;
                var priorSelectionRange = priorSelectionInformation.selectionRange;
                if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
                    if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
                        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
                    }
                    focusNode(priorFocusedElem);
                }
            },

            /**
             * @getSelection: Gets the selection bounds of a focused textarea, input or
             * contentEditable node.
             * -@input: Look up selection bounds of this input
             * -@return {start: selectionStart, end: selectionEnd}
             */
            getSelection: function getSelection(input) {
                var selection;

                if ('selectionStart' in input) {
                    // Modern browser with input or textarea.
                    selection = {
                        start: input.selectionStart,
                        end: input.selectionEnd
                    };
                } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
                    // IE8 input.
                    var range = document.selection.createRange();
                    // There can only be one selection per document in IE, so it must
                    // be in our element.
                    if (range.parentElement() === input) {
                        selection = {
                            start: -range.moveStart('character', -input.value.length),
                            end: -range.moveEnd('character', -input.value.length)
                        };
                    }
                } else {
                    // Content editable or old IE textarea.
                    selection = ReactDOMSelection.getOffsets(input);
                }

                return selection || { start: 0, end: 0 };
            },

            /**
             * @setSelection: Sets the selection bounds of a textarea or input and focuses
             * the input.
             * -@input     Set selection bounds of this input or textarea
             * -@offsets   Object of same form that is returned from get*
             */
            setSelection: function setSelection(input, offsets) {
                var start = offsets.start;
                var end = offsets.end;
                if (typeof end === 'undefined') {
                    end = start;
                }

                if ('selectionStart' in input) {
                    input.selectionStart = start;
                    input.selectionEnd = Math.min(end, input.value.length);
                } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
                    var range = input.createTextRange();
                    range.collapse(true);
                    range.moveStart('character', start);
                    range.moveEnd('character', end - start);
                    range.select();
                } else {
                    ReactDOMSelection.setOffsets(input, offsets);
                }
            }
        };

        module.exports = ReactInputSelection;

        /***/ },
    /* 201 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMSelection
         */

        'use strict';

        var ExecutionEnvironment = __webpack_require__(83);

        var getNodeForCharacterOffset = __webpack_require__(202);
        var getTextContentAccessor = __webpack_require__(149);

        /**
         * While `isCollapsed` is available on the Selection object and `collapsed`
         * is available on the Range object, IE11 sometimes gets them wrong.
         * If the anchor/focus nodes and offsets are the same, the range is collapsed.
         */
        function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
            return anchorNode === focusNode && anchorOffset === focusOffset;
        }

        /**
         * Get the appropriate anchor and focus node/offset pairs for IE.
         *
         * The catch here is that IE's selection API doesn't provide information
         * about whether the selection is forward or backward, so we have to
         * behave as though it's always forward.
         *
         * IE text differs from modern selection in that it behaves as though
         * block elements end with a new line. This means character offsets will
         * differ between the two APIs.
         *
         * @param {DOMElement} node
         * @return {object}
         */
        function getIEOffsets(node) {
            var selection = document.selection;
            var selectedRange = selection.createRange();
            var selectedLength = selectedRange.text.length;

            // Duplicate selection so we can move range without breaking user selection.
            var fromStart = selectedRange.duplicate();
            fromStart.moveToElementText(node);
            fromStart.setEndPoint('EndToStart', selectedRange);

            var startOffset = fromStart.text.length;
            var endOffset = startOffset + selectedLength;

            return {
                start: startOffset,
                end: endOffset
            };
        }

        /**
         * @param {DOMElement} node
         * @return {?object}
         */
        function getModernOffsets(node) {
            var selection = window.getSelection && window.getSelection();

            if (!selection || selection.rangeCount === 0) {
                return null;
            }

            var anchorNode = selection.anchorNode;
            var anchorOffset = selection.anchorOffset;
            var focusNode = selection.focusNode;
            var focusOffset = selection.focusOffset;

            var currentRange = selection.getRangeAt(0);

            // In Firefox, range.startContainer and range.endContainer can be "anonymous
            // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
            // divs do not seem to expose properties, triggering a "Permission denied
            // error" if any of its properties are accessed. The only seemingly possible
            // way to avoid erroring is to access a property that typically works for
            // non-anonymous divs and catch any error that may otherwise arise. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
            try {
                /* eslint-disable no-unused-expressions */
                currentRange.startContainer.nodeType;
                currentRange.endContainer.nodeType;
                /* eslint-enable no-unused-expressions */
            } catch (e) {
                return null;
            }

            // If the node and offset values are the same, the selection is collapsed.
            // `Selection.isCollapsed` is available natively, but IE sometimes gets
            // this value wrong.
            var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

            var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

            var tempRange = currentRange.cloneRange();
            tempRange.selectNodeContents(node);
            tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

            var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

            var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
            var end = start + rangeLength;

            // Detect whether the selection is backward.
            var detectionRange = document.createRange();
            detectionRange.setStart(anchorNode, anchorOffset);
            detectionRange.setEnd(focusNode, focusOffset);
            var isBackward = detectionRange.collapsed;

            return {
                start: isBackward ? end : start,
                end: isBackward ? start : end
            };
        }

        /**
         * @param {DOMElement|DOMTextNode} node
         * @param {object} offsets
         */
        function setIEOffsets(node, offsets) {
            var range = document.selection.createRange().duplicate();
            var start, end;

            if (typeof offsets.end === 'undefined') {
                start = offsets.start;
                end = start;
            } else if (offsets.start > offsets.end) {
                start = offsets.end;
                end = offsets.start;
            } else {
                start = offsets.start;
                end = offsets.end;
            }

            range.moveToElementText(node);
            range.moveStart('character', start);
            range.setEndPoint('EndToStart', range);
            range.moveEnd('character', end - start);
            range.select();
        }

        /**
         * In modern non-IE browsers, we can support both forward and backward
         * selections.
         *
         * Note: IE10+ supports the Selection object, but it does not support
         * the `extend` method, which means that even in modern IE, it's not possible
         * to programatically create a backward selection. Thus, for all IE
         * versions, we use the old IE API to create our selections.
         *
         * @param {DOMElement|DOMTextNode} node
         * @param {object} offsets
         */
        function setModernOffsets(node, offsets) {
            if (!window.getSelection) {
                return;
            }

            var selection = window.getSelection();
            var length = node[getTextContentAccessor()].length;
            var start = Math.min(offsets.start, length);
            var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);

            // IE 11 uses modern selection, but doesn't support the extend method.
            // Flip backward selections, so we can set with a single range.
            if (!selection.extend && start > end) {
                var temp = end;
                end = start;
                start = temp;
            }

            var startMarker = getNodeForCharacterOffset(node, start);
            var endMarker = getNodeForCharacterOffset(node, end);

            if (startMarker && endMarker) {
                var range = document.createRange();
                range.setStart(startMarker.node, startMarker.offset);
                selection.removeAllRanges();

                if (start > end) {
                    selection.addRange(range);
                    selection.extend(endMarker.node, endMarker.offset);
                } else {
                    range.setEnd(endMarker.node, endMarker.offset);
                    selection.addRange(range);
                }
            }
        }

        var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

        var ReactDOMSelection = {
            /**
             * @param {DOMElement} node
             */
            getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

            /**
             * @param {DOMElement|DOMTextNode} node
             * @param {object} offsets
             */
            setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
        };

        module.exports = ReactDOMSelection;

        /***/ },
    /* 202 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getNodeForCharacterOffset
         */

        'use strict';

        /**
         * Given any node return the first leaf node without children.
         *
         * @param {DOMElement|DOMTextNode} node
         * @return {DOMElement|DOMTextNode}
         */

        function getLeafNode(node) {
            while (node && node.firstChild) {
                node = node.firstChild;
            }
            return node;
        }

        /**
         * Get the next sibling within a container. This will walk up the
         * DOM if a node's siblings have been exhausted.
         *
         * @param {DOMElement|DOMTextNode} node
         * @return {?DOMElement|DOMTextNode}
         */
        function getSiblingNode(node) {
            while (node) {
                if (node.nextSibling) {
                    return node.nextSibling;
                }
                node = node.parentNode;
            }
        }

        /**
         * Get object describing the nodes which contain characters at offset.
         *
         * @param {DOMElement|DOMTextNode} root
         * @param {number} offset
         * @return {?object}
         */
        function getNodeForCharacterOffset(root, offset) {
            var node = getLeafNode(root);
            var nodeStart = 0;
            var nodeEnd = 0;

            while (node) {
                if (node.nodeType === 3) {
                    nodeEnd = nodeStart + node.textContent.length;

                    if (nodeStart <= offset && nodeEnd >= offset) {
                        return {
                            node: node,
                            offset: offset - nodeStart
                        };
                    }

                    nodeStart = nodeEnd;
                }

                node = getLeafNode(getSiblingNode(node));
            }
        }

        module.exports = getNodeForCharacterOffset;

        /***/ },
    /* 203 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getActiveElement
         * @typechecks
         */

        /* eslint-disable fb-www/typeof-undefined */

        /**
         * Same as document.activeElement but wraps in a try-catch block. In IE it is
         * not safe to call document.activeElement if there is nothing focused.
         *
         * The activeElement will be null only if the document or document body is not
         * yet defined.
         */
        'use strict';

        function getActiveElement() /*?DOMElement*/{
            if (typeof document === 'undefined') {
                return null;
            }
            try {
                return document.activeElement || document.body;
            } catch (e) {
                return document.body;
            }
        }

        module.exports = getActiveElement;

        /***/ },
    /* 204 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SelectEventPlugin
         */

        'use strict';

        var EventConstants = __webpack_require__(104);
        var EventPropagators = __webpack_require__(147);
        var ExecutionEnvironment = __webpack_require__(83);
        var ReactInputSelection = __webpack_require__(200);
        var SyntheticEvent = __webpack_require__(151);

        var getActiveElement = __webpack_require__(203);
        var isTextInputElement = __webpack_require__(156);
        var keyOf = __webpack_require__(153);
        var shallowEqual = __webpack_require__(191);

        var topLevelTypes = EventConstants.topLevelTypes;

        var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

        var eventTypes = {
            select: {
                phasedRegistrationNames: {
                    bubbled: keyOf({ onSelect: null }),
                    captured: keyOf({ onSelectCapture: null })
                },
                dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
            }
        };

        var activeElement = null;
        var activeElementID = null;
        var lastSelection = null;
        var mouseDown = false;

        // Track whether a listener exists for this plugin. If none exist, we do
        // not extract events.
        var hasListener = false;
        var ON_SELECT_KEY = keyOf({ onSelect: null });

        /**
         * Get an object which is a unique representation of the current selection.
         *
         * The return value will not be consistent across nodes or browsers, but
         * two identical selections on the same node will return identical objects.
         *
         * @param {DOMElement} node
         * @return {object}
         */
        function getSelection(node) {
            if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
                return {
                    start: node.selectionStart,
                    end: node.selectionEnd
                };
            } else if (window.getSelection) {
                var selection = window.getSelection();
                return {
                    anchorNode: selection.anchorNode,
                    anchorOffset: selection.anchorOffset,
                    focusNode: selection.focusNode,
                    focusOffset: selection.focusOffset
                };
            } else if (document.selection) {
                var range = document.selection.createRange();
                return {
                    parentElement: range.parentElement(),
                    text: range.text,
                    top: range.boundingTop,
                    left: range.boundingLeft
                };
            }
        }

        /**
         * Poll selection to see whether it's changed.
         *
         * @param {object} nativeEvent
         * @return {?SyntheticEvent}
         */
        function constructSelectEvent(nativeEvent, nativeEventTarget) {
            // Ensure we have the right element, and that the user is not dragging a
            // selection (this matches native `select` event behavior). In HTML5, select
            // fires only on input and textarea thus if there's no focused element we
            // won't dispatch.
            if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
                return null;
            }

            // Only fire when selection has actually changed.
            var currentSelection = getSelection(activeElement);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
                lastSelection = currentSelection;

                var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);

                syntheticEvent.type = 'select';
                syntheticEvent.target = activeElement;

                EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

                return syntheticEvent;
            }

            return null;
        }

        /**
         * This plugin creates an `onSelect` event that normalizes select events
         * across form elements.
         *
         * Supported elements are:
         * - input (see `isTextInputElement`)
         * - textarea
         * - contentEditable
         *
         * This differs from native browser implementations in the following ways:
         * - Fires on contentEditable fields as well as inputs.
         * - Fires for collapsed selection.
         * - Fires after user input.
         */
        var SelectEventPlugin = {

            eventTypes: eventTypes,

            /**
             * @param {string} topLevelType Record from `EventConstants`.
             * @param {DOMEventTarget} topLevelTarget The listening component root node.
             * @param {string} topLevelTargetID ID of `topLevelTarget`.
             * @param {object} nativeEvent Native browser event.
             * @return {*} An accumulation of synthetic events.
             * @see {EventPluginHub.extractEvents}
             */
            extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
                if (!hasListener) {
                    return null;
                }

                switch (topLevelType) {
                    // Track the input node that has focus.
                    case topLevelTypes.topFocus:
                        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
                            activeElement = topLevelTarget;
                            activeElementID = topLevelTargetID;
                            lastSelection = null;
                        }
                        break;
                    case topLevelTypes.topBlur:
                        activeElement = null;
                        activeElementID = null;
                        lastSelection = null;
                        break;

                    // Don't fire the event while the user is dragging. This matches the
                    // semantics of the native select event.
                    case topLevelTypes.topMouseDown:
                        mouseDown = true;
                        break;
                    case topLevelTypes.topContextMenu:
                    case topLevelTypes.topMouseUp:
                        mouseDown = false;
                        return constructSelectEvent(nativeEvent, nativeEventTarget);

                    // Chrome and IE fire non-standard event when selection is changed (and
                    // sometimes when it hasn't). IE's event fires out of order with respect
                    // to key and input events on deletion, so we discard it.
                    //
                    // Firefox doesn't support selectionchange, so check selection status
                    // after each key entry. The selection changes after keydown and before
                    // keyup, but we check on keydown as well in the case of holding down a
                    // key, when multiple keydown events are fired but only one keyup is.
                    // This is also our approach for IE handling, for the reason above.
                    case topLevelTypes.topSelectionChange:
                        if (skipSelectionChangeEvent) {
                            break;
                        }
                    // falls through
                    case topLevelTypes.topKeyDown:
                    case topLevelTypes.topKeyUp:
                        return constructSelectEvent(nativeEvent, nativeEventTarget);
                }

                return null;
            },

            didPutListener: function didPutListener(id, registrationName, listener) {
                if (registrationName === ON_SELECT_KEY) {
                    hasListener = true;
                }
            }
        };

        module.exports = SelectEventPlugin;

        /***/ },
    /* 205 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ServerReactRootIndex
         * @typechecks
         */

        'use strict';

        /**
         * Size of the reactRoot ID space. We generate random numbers for React root
         * IDs and if there's a collision the events and DOM update system will
         * get confused. In the future we need a way to generate GUIDs but for
         * now this will work on a smaller scale.
         */

        var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

        var ServerReactRootIndex = {
            createReactRootIndex: function createReactRootIndex() {
                return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
            }
        };

        module.exports = ServerReactRootIndex;

        /***/ },
    /* 206 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SimpleEventPlugin
         */

        'use strict';

            var EventConstants = __webpack_require__(104);
            var EventListener = __webpack_require__(193);
            var EventPropagators = __webpack_require__(147);
            var ReactMount = __webpack_require__(102);
            var SyntheticClipboardEvent = __webpack_require__(207);
            var SyntheticEvent = __webpack_require__(151);
            var SyntheticFocusEvent = __webpack_require__(208);
            var SyntheticKeyboardEvent = __webpack_require__(209);
            var SyntheticMouseEvent = __webpack_require__(160);
            var SyntheticDragEvent = __webpack_require__(212);
            var SyntheticTouchEvent = __webpack_require__(213);
            var SyntheticUIEvent = __webpack_require__(161);
            var SyntheticWheelEvent = __webpack_require__(214);

            var emptyFunction = __webpack_require__(89);
            var getEventCharCode = __webpack_require__(210);
            var invariant = __webpack_require__(87);
            var keyOf = __webpack_require__(153);

            var topLevelTypes = EventConstants.topLevelTypes;

            var eventTypes = {
                abort: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onAbort: true }),
                        captured: keyOf({ onAbortCapture: true })
                    }
                },
                blur: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onBlur: true }),
                        captured: keyOf({ onBlurCapture: true })
                    }
                },
                canPlay: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onCanPlay: true }),
                        captured: keyOf({ onCanPlayCapture: true })
                    }
                },
                canPlayThrough: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onCanPlayThrough: true }),
                        captured: keyOf({ onCanPlayThroughCapture: true })
                    }
                },
                click: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onClick: true }),
                        captured: keyOf({ onClickCapture: true })
                    }
                },
                contextMenu: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onContextMenu: true }),
                        captured: keyOf({ onContextMenuCapture: true })
                    }
                },
                copy: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onCopy: true }),
                        captured: keyOf({ onCopyCapture: true })
                    }
                },
                cut: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onCut: true }),
                        captured: keyOf({ onCutCapture: true })
                    }
                },
                doubleClick: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDoubleClick: true }),
                        captured: keyOf({ onDoubleClickCapture: true })
                    }
                },
                drag: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDrag: true }),
                        captured: keyOf({ onDragCapture: true })
                    }
                },
                dragEnd: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDragEnd: true }),
                        captured: keyOf({ onDragEndCapture: true })
                    }
                },
                dragEnter: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDragEnter: true }),
                        captured: keyOf({ onDragEnterCapture: true })
                    }
                },
                dragExit: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDragExit: true }),
                        captured: keyOf({ onDragExitCapture: true })
                    }
                },
                dragLeave: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDragLeave: true }),
                        captured: keyOf({ onDragLeaveCapture: true })
                    }
                },
                dragOver: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDragOver: true }),
                        captured: keyOf({ onDragOverCapture: true })
                    }
                },
                dragStart: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDragStart: true }),
                        captured: keyOf({ onDragStartCapture: true })
                    }
                },
                drop: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDrop: true }),
                        captured: keyOf({ onDropCapture: true })
                    }
                },
                durationChange: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onDurationChange: true }),
                        captured: keyOf({ onDurationChangeCapture: true })
                    }
                },
                emptied: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onEmptied: true }),
                        captured: keyOf({ onEmptiedCapture: true })
                    }
                },
                encrypted: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onEncrypted: true }),
                        captured: keyOf({ onEncryptedCapture: true })
                    }
                },
                ended: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onEnded: true }),
                        captured: keyOf({ onEndedCapture: true })
                    }
                },
                error: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onError: true }),
                        captured: keyOf({ onErrorCapture: true })
                    }
                },
                focus: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onFocus: true }),
                        captured: keyOf({ onFocusCapture: true })
                    }
                },
                input: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onInput: true }),
                        captured: keyOf({ onInputCapture: true })
                    }
                },
                keyDown: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onKeyDown: true }),
                        captured: keyOf({ onKeyDownCapture: true })
                    }
                },
                keyPress: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onKeyPress: true }),
                        captured: keyOf({ onKeyPressCapture: true })
                    }
                },
                keyUp: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onKeyUp: true }),
                        captured: keyOf({ onKeyUpCapture: true })
                    }
                },
                load: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onLoad: true }),
                        captured: keyOf({ onLoadCapture: true })
                    }
                },
                loadedData: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onLoadedData: true }),
                        captured: keyOf({ onLoadedDataCapture: true })
                    }
                },
                loadedMetadata: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onLoadedMetadata: true }),
                        captured: keyOf({ onLoadedMetadataCapture: true })
                    }
                },
                loadStart: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onLoadStart: true }),
                        captured: keyOf({ onLoadStartCapture: true })
                    }
                },
                // Note: We do not allow listening to mouseOver events. Instead, use the
                // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
                mouseDown: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onMouseDown: true }),
                        captured: keyOf({ onMouseDownCapture: true })
                    }
                },
                mouseMove: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onMouseMove: true }),
                        captured: keyOf({ onMouseMoveCapture: true })
                    }
                },
                mouseOut: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onMouseOut: true }),
                        captured: keyOf({ onMouseOutCapture: true })
                    }
                },
                mouseOver: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onMouseOver: true }),
                        captured: keyOf({ onMouseOverCapture: true })
                    }
                },
                mouseUp: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onMouseUp: true }),
                        captured: keyOf({ onMouseUpCapture: true })
                    }
                },
                paste: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onPaste: true }),
                        captured: keyOf({ onPasteCapture: true })
                    }
                },
                pause: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onPause: true }),
                        captured: keyOf({ onPauseCapture: true })
                    }
                },
                play: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onPlay: true }),
                        captured: keyOf({ onPlayCapture: true })
                    }
                },
                playing: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onPlaying: true }),
                        captured: keyOf({ onPlayingCapture: true })
                    }
                },
                progress: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onProgress: true }),
                        captured: keyOf({ onProgressCapture: true })
                    }
                },
                rateChange: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onRateChange: true }),
                        captured: keyOf({ onRateChangeCapture: true })
                    }
                },
                reset: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onReset: true }),
                        captured: keyOf({ onResetCapture: true })
                    }
                },
                scroll: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onScroll: true }),
                        captured: keyOf({ onScrollCapture: true })
                    }
                },
                seeked: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onSeeked: true }),
                        captured: keyOf({ onSeekedCapture: true })
                    }
                },
                seeking: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onSeeking: true }),
                        captured: keyOf({ onSeekingCapture: true })
                    }
                },
                stalled: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onStalled: true }),
                        captured: keyOf({ onStalledCapture: true })
                    }
                },
                submit: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onSubmit: true }),
                        captured: keyOf({ onSubmitCapture: true })
                    }
                },
                suspend: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onSuspend: true }),
                        captured: keyOf({ onSuspendCapture: true })
                    }
                },
                timeUpdate: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onTimeUpdate: true }),
                        captured: keyOf({ onTimeUpdateCapture: true })
                    }
                },
                touchCancel: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onTouchCancel: true }),
                        captured: keyOf({ onTouchCancelCapture: true })
                    }
                },
                touchEnd: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onTouchEnd: true }),
                        captured: keyOf({ onTouchEndCapture: true })
                    }
                },
                touchMove: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onTouchMove: true }),
                        captured: keyOf({ onTouchMoveCapture: true })
                    }
                },
                touchStart: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onTouchStart: true }),
                        captured: keyOf({ onTouchStartCapture: true })
                    }
                },
                volumeChange: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onVolumeChange: true }),
                        captured: keyOf({ onVolumeChangeCapture: true })
                    }
                },
                waiting: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onWaiting: true }),
                        captured: keyOf({ onWaitingCapture: true })
                    }
                },
                wheel: {
                    phasedRegistrationNames: {
                        bubbled: keyOf({ onWheel: true }),
                        captured: keyOf({ onWheelCapture: true })
                    }
                }
            };

            var topLevelEventsToDispatchConfig = {
                topAbort: eventTypes.abort,
                topBlur: eventTypes.blur,
                topCanPlay: eventTypes.canPlay,
                topCanPlayThrough: eventTypes.canPlayThrough,
                topClick: eventTypes.click,
                topContextMenu: eventTypes.contextMenu,
                topCopy: eventTypes.copy,
                topCut: eventTypes.cut,
                topDoubleClick: eventTypes.doubleClick,
                topDrag: eventTypes.drag,
                topDragEnd: eventTypes.dragEnd,
                topDragEnter: eventTypes.dragEnter,
                topDragExit: eventTypes.dragExit,
                topDragLeave: eventTypes.dragLeave,
                topDragOver: eventTypes.dragOver,
                topDragStart: eventTypes.dragStart,
                topDrop: eventTypes.drop,
                topDurationChange: eventTypes.durationChange,
                topEmptied: eventTypes.emptied,
                topEncrypted: eventTypes.encrypted,
                topEnded: eventTypes.ended,
                topError: eventTypes.error,
                topFocus: eventTypes.focus,
                topInput: eventTypes.input,
                topKeyDown: eventTypes.keyDown,
                topKeyPress: eventTypes.keyPress,
                topKeyUp: eventTypes.keyUp,
                topLoad: eventTypes.load,
                topLoadedData: eventTypes.loadedData,
                topLoadedMetadata: eventTypes.loadedMetadata,
                topLoadStart: eventTypes.loadStart,
                topMouseDown: eventTypes.mouseDown,
                topMouseMove: eventTypes.mouseMove,
                topMouseOut: eventTypes.mouseOut,
                topMouseOver: eventTypes.mouseOver,
                topMouseUp: eventTypes.mouseUp,
                topPaste: eventTypes.paste,
                topPause: eventTypes.pause,
                topPlay: eventTypes.play,
                topPlaying: eventTypes.playing,
                topProgress: eventTypes.progress,
                topRateChange: eventTypes.rateChange,
                topReset: eventTypes.reset,
                topScroll: eventTypes.scroll,
                topSeeked: eventTypes.seeked,
                topSeeking: eventTypes.seeking,
                topStalled: eventTypes.stalled,
                topSubmit: eventTypes.submit,
                topSuspend: eventTypes.suspend,
                topTimeUpdate: eventTypes.timeUpdate,
                topTouchCancel: eventTypes.touchCancel,
                topTouchEnd: eventTypes.touchEnd,
                topTouchMove: eventTypes.touchMove,
                topTouchStart: eventTypes.touchStart,
                topVolumeChange: eventTypes.volumeChange,
                topWaiting: eventTypes.waiting,
                topWheel: eventTypes.wheel
            };

            for (var type in topLevelEventsToDispatchConfig) {
                topLevelEventsToDispatchConfig[type].dependencies = [type];
            }

            var ON_CLICK_KEY = keyOf({ onClick: null });
            var onClickListeners = {};

            var SimpleEventPlugin = {

                eventTypes: eventTypes,

                /**
                 * @param {string} topLevelType Record from `EventConstants`.
                 * @param {DOMEventTarget} topLevelTarget The listening component root node.
                 * @param {string} topLevelTargetID ID of `topLevelTarget`.
                 * @param {object} nativeEvent Native browser event.
                 * @return {*} An accumulation of synthetic events.
                 * @see {EventPluginHub.extractEvents}
                 */
                extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
                    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
                    if (!dispatchConfig) {
                        return null;
                    }
                    var EventConstructor;
                    switch (topLevelType) {
                        case topLevelTypes.topAbort:
                        case topLevelTypes.topCanPlay:
                        case topLevelTypes.topCanPlayThrough:
                        case topLevelTypes.topDurationChange:
                        case topLevelTypes.topEmptied:
                        case topLevelTypes.topEncrypted:
                        case topLevelTypes.topEnded:
                        case topLevelTypes.topError:
                        case topLevelTypes.topInput:
                        case topLevelTypes.topLoad:
                        case topLevelTypes.topLoadedData:
                        case topLevelTypes.topLoadedMetadata:
                        case topLevelTypes.topLoadStart:
                        case topLevelTypes.topPause:
                        case topLevelTypes.topPlay:
                        case topLevelTypes.topPlaying:
                        case topLevelTypes.topProgress:
                        case topLevelTypes.topRateChange:
                        case topLevelTypes.topReset:
                        case topLevelTypes.topSeeked:
                        case topLevelTypes.topSeeking:
                        case topLevelTypes.topStalled:
                        case topLevelTypes.topSubmit:
                        case topLevelTypes.topSuspend:
                        case topLevelTypes.topTimeUpdate:
                        case topLevelTypes.topVolumeChange:
                        case topLevelTypes.topWaiting:
                            // HTML Events
                            // @see http://www.w3.org/TR/html5/index.html#events-0
                            EventConstructor = SyntheticEvent;
                            break;
                        case topLevelTypes.topKeyPress:
                            // FireFox creates a keypress event for function keys too. This removes
                            // the unwanted keypress events. Enter is however both printable and
                            // non-printable. One would expect Tab to be as well (but it isn't).
                            if (getEventCharCode(nativeEvent) === 0) {
                                return null;
                            }
                        /* falls through */
                        case topLevelTypes.topKeyDown:
                        case topLevelTypes.topKeyUp:
                            EventConstructor = SyntheticKeyboardEvent;
                            break;
                        case topLevelTypes.topBlur:
                        case topLevelTypes.topFocus:
                            EventConstructor = SyntheticFocusEvent;
                            break;
                        case topLevelTypes.topClick:
                            // Firefox creates a click event on right mouse clicks. This removes the
                            // unwanted click events.
                            if (nativeEvent.button === 2) {
                                return null;
                            }
                        /* falls through */
                        case topLevelTypes.topContextMenu:
                        case topLevelTypes.topDoubleClick:
                        case topLevelTypes.topMouseDown:
                        case topLevelTypes.topMouseMove:
                        case topLevelTypes.topMouseOut:
                        case topLevelTypes.topMouseOver:
                        case topLevelTypes.topMouseUp:
                            EventConstructor = SyntheticMouseEvent;
                            break;
                        case topLevelTypes.topDrag:
                        case topLevelTypes.topDragEnd:
                        case topLevelTypes.topDragEnter:
                        case topLevelTypes.topDragExit:
                        case topLevelTypes.topDragLeave:
                        case topLevelTypes.topDragOver:
                        case topLevelTypes.topDragStart:
                        case topLevelTypes.topDrop:
                            EventConstructor = SyntheticDragEvent;
                            break;
                        case topLevelTypes.topTouchCancel:
                        case topLevelTypes.topTouchEnd:
                        case topLevelTypes.topTouchMove:
                        case topLevelTypes.topTouchStart:
                            EventConstructor = SyntheticTouchEvent;
                            break;
                        case topLevelTypes.topScroll:
                            EventConstructor = SyntheticUIEvent;
                            break;
                        case topLevelTypes.topWheel:
                            EventConstructor = SyntheticWheelEvent;
                            break;
                        case topLevelTypes.topCopy:
                        case topLevelTypes.topCut:
                        case topLevelTypes.topPaste:
                            EventConstructor = SyntheticClipboardEvent;
                            break;
                    }
                    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
                    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
                    EventPropagators.accumulateTwoPhaseDispatches(event);
                    return event;
                },

                didPutListener: function didPutListener(id, registrationName, listener) {
                    // Mobile Safari does not fire properly bubble click events on
                    // non-interactive elements, which means delegated click listeners do not
                    // fire. The workaround for this bug involves attaching an empty click
                    // listener on the target node.
                    if (registrationName === ON_CLICK_KEY) {
                        var node = ReactMount.getNode(id);
                        if (!onClickListeners[id]) {
                            onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
                        }
                    }
                },

                willDeleteListener: function willDeleteListener(id, registrationName) {
                    if (registrationName === ON_CLICK_KEY) {
                        onClickListeners[id].remove();
                        delete onClickListeners[id];
                    }
                }

            };

            module.exports = SimpleEventPlugin;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 207 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticClipboardEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticEvent = __webpack_require__(151);

        /**
         * @interface Event
         * @see http://www.w3.org/TR/clipboard-apis/
         */
        var ClipboardEventInterface = {
            clipboardData: function clipboardData(event) {
                return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
            }
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticUIEvent}
         */
        function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

        module.exports = SyntheticClipboardEvent;

        /***/ },
    /* 208 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticFocusEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticUIEvent = __webpack_require__(161);

        /**
         * @interface FocusEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var FocusEventInterface = {
            relatedTarget: null
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticUIEvent}
         */
        function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

        module.exports = SyntheticFocusEvent;

        /***/ },
    /* 209 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticKeyboardEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticUIEvent = __webpack_require__(161);

        var getEventCharCode = __webpack_require__(210);
        var getEventKey = __webpack_require__(211);
        var getEventModifierState = __webpack_require__(162);

        /**
         * @interface KeyboardEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var KeyboardEventInterface = {
            key: getEventKey,
            location: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            repeat: null,
            locale: null,
            getModifierState: getEventModifierState,
            // Legacy Interface
            charCode: function charCode(event) {
                // `charCode` is the result of a KeyPress event and represents the value of
                // the actual printable character.

                // KeyPress is deprecated, but its replacement is not yet final and not
                // implemented in any major browser. Only KeyPress has charCode.
                if (event.type === 'keypress') {
                    return getEventCharCode(event);
                }
                return 0;
            },
            keyCode: function keyCode(event) {
                // `keyCode` is the result of a KeyDown/Up event and represents the value of
                // physical keyboard key.

                // The actual meaning of the value depends on the users' keyboard layout
                // which cannot be detected. Assuming that it is a US keyboard layout
                // provides a surprisingly accurate mapping for US and European users.
                // Due to this, it is left to the user to implement at this time.
                if (event.type === 'keydown' || event.type === 'keyup') {
                    return event.keyCode;
                }
                return 0;
            },
            which: function which(event) {
                // `which` is an alias for either `keyCode` or `charCode` depending on the
                // type of the event.
                if (event.type === 'keypress') {
                    return getEventCharCode(event);
                }
                if (event.type === 'keydown' || event.type === 'keyup') {
                    return event.keyCode;
                }
                return 0;
            }
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticUIEvent}
         */
        function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

        module.exports = SyntheticKeyboardEvent;

        /***/ },
    /* 210 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getEventCharCode
         * @typechecks static-only
         */

        'use strict';

        /**
         * `charCode` represents the actual "character code" and is safe to use with
         * `String.fromCharCode`. As such, only keys that correspond to printable
         * characters produce a valid `charCode`, the only exception to this is Enter.
         * The Tab-key is considered non-printable and does not have a `charCode`,
         * presumably because it does not produce a tab-character in browsers.
         *
         * @param {object} nativeEvent Native browser event.
         * @return {number} Normalized `charCode` property.
         */

        function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;

            if ('charCode' in nativeEvent) {
                charCode = nativeEvent.charCode;

                // FF does not set `charCode` for the Enter-key, check against `keyCode`.
                if (charCode === 0 && keyCode === 13) {
                    charCode = 13;
                }
            } else {
                // IE8 does not implement `charCode`, but `keyCode` has the correct value.
                charCode = keyCode;
            }

            // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
            // Must not discard the (non-)printable Enter-key.
            if (charCode >= 32 || charCode === 13) {
                return charCode;
            }

            return 0;
        }

        module.exports = getEventCharCode;

        /***/ },
    /* 211 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule getEventKey
         * @typechecks static-only
         */

        'use strict';

        var getEventCharCode = __webpack_require__(210);

        /**
         * Normalization of deprecated HTML5 `key` values
         * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
         */
        var normalizeKey = {
            'Esc': 'Escape',
            'Spacebar': ' ',
            'Left': 'ArrowLeft',
            'Up': 'ArrowUp',
            'Right': 'ArrowRight',
            'Down': 'ArrowDown',
            'Del': 'Delete',
            'Win': 'OS',
            'Menu': 'ContextMenu',
            'Apps': 'ContextMenu',
            'Scroll': 'ScrollLock',
            'MozPrintableKey': 'Unidentified'
        };

        /**
         * Translation from legacy `keyCode` to HTML5 `key`
         * Only special keys supported, all others depend on keyboard layout or browser
         * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
         */
        var translateToKey = {
            8: 'Backspace',
            9: 'Tab',
            12: 'Clear',
            13: 'Enter',
            16: 'Shift',
            17: 'Control',
            18: 'Alt',
            19: 'Pause',
            20: 'CapsLock',
            27: 'Escape',
            32: ' ',
            33: 'PageUp',
            34: 'PageDown',
            35: 'End',
            36: 'Home',
            37: 'ArrowLeft',
            38: 'ArrowUp',
            39: 'ArrowRight',
            40: 'ArrowDown',
            45: 'Insert',
            46: 'Delete',
            112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
            118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
            144: 'NumLock',
            145: 'ScrollLock',
            224: 'Meta'
        };

        /**
         * @param {object} nativeEvent Native browser event.
         * @return {string} Normalized `key` property.
         */
        function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
                // Normalize inconsistent values reported by browsers due to
                // implementations of a working draft specification.

                // FireFox implements `key` but returns `MozPrintableKey` for all
                // printable characters (normalized to `Unidentified`), ignore it.
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if (key !== 'Unidentified') {
                    return key;
                }
            }

            // Browser does not implement `key`, polyfill as much of it as we can.
            if (nativeEvent.type === 'keypress') {
                var charCode = getEventCharCode(nativeEvent);

                // The enter-key is technically both printable and non-printable and can
                // thus be captured by `keypress`, no other non-printable key should.
                return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
                // While user keyboard layout determines the actual meaning of each
                // `keyCode` value, almost all function keys have a universal value.
                return translateToKey[nativeEvent.keyCode] || 'Unidentified';
            }
            return '';
        }

        module.exports = getEventKey;

        /***/ },
    /* 212 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticDragEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticMouseEvent = __webpack_require__(160);

        /**
         * @interface DragEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var DragEventInterface = {
            dataTransfer: null
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticUIEvent}
         */
        function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

        module.exports = SyntheticDragEvent;

        /***/ },
    /* 213 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticTouchEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticUIEvent = __webpack_require__(161);

        var getEventModifierState = __webpack_require__(162);

        /**
         * @interface TouchEvent
         * @see http://www.w3.org/TR/touch-events/
         */
        var TouchEventInterface = {
            touches: null,
            targetTouches: null,
            changedTouches: null,
            altKey: null,
            metaKey: null,
            ctrlKey: null,
            shiftKey: null,
            getModifierState: getEventModifierState
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticUIEvent}
         */
        function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

        module.exports = SyntheticTouchEvent;

        /***/ },
    /* 214 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SyntheticWheelEvent
         * @typechecks static-only
         */

        'use strict';

        var SyntheticMouseEvent = __webpack_require__(160);

        /**
         * @interface WheelEvent
         * @see http://www.w3.org/TR/DOM-Level-3-Events/
         */
        var WheelEventInterface = {
            deltaX: function deltaX(event) {
                return 'deltaX' in event ? event.deltaX :
                    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
                    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function deltaY(event) {
                return 'deltaY' in event ? event.deltaY :
                    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
                    'wheelDeltaY' in event ? -event.wheelDeltaY :
                        // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                        'wheelDelta' in event ? -event.wheelDelta : 0;
            },
            deltaZ: null,

            // Browsers without "deltaMode" is reporting in raw wheel delta where one
            // notch on the scroll is always +/- 120, roughly equivalent to pixels.
            // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
            // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
            deltaMode: null
        };

        /**
         * @param {object} dispatchConfig Configuration used to dispatch this event.
         * @param {string} dispatchMarker Marker identifying the event target.
         * @param {object} nativeEvent Native browser event.
         * @extends {SyntheticMouseEvent}
         */
        function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
            SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
        }

        SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

        module.exports = SyntheticWheelEvent;

        /***/ },
    /* 215 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule SVGDOMPropertyConfig
         */

        'use strict';

        var DOMProperty = __webpack_require__(97);

        var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

        var NS = {
            xlink: 'http://www.w3.org/1999/xlink',
            xml: 'http://www.w3.org/XML/1998/namespace'
        };

        var SVGDOMPropertyConfig = {
            Properties: {
                clipPath: MUST_USE_ATTRIBUTE,
                cx: MUST_USE_ATTRIBUTE,
                cy: MUST_USE_ATTRIBUTE,
                d: MUST_USE_ATTRIBUTE,
                dx: MUST_USE_ATTRIBUTE,
                dy: MUST_USE_ATTRIBUTE,
                fill: MUST_USE_ATTRIBUTE,
                fillOpacity: MUST_USE_ATTRIBUTE,
                fontFamily: MUST_USE_ATTRIBUTE,
                fontSize: MUST_USE_ATTRIBUTE,
                fx: MUST_USE_ATTRIBUTE,
                fy: MUST_USE_ATTRIBUTE,
                gradientTransform: MUST_USE_ATTRIBUTE,
                gradientUnits: MUST_USE_ATTRIBUTE,
                markerEnd: MUST_USE_ATTRIBUTE,
                markerMid: MUST_USE_ATTRIBUTE,
                markerStart: MUST_USE_ATTRIBUTE,
                offset: MUST_USE_ATTRIBUTE,
                opacity: MUST_USE_ATTRIBUTE,
                patternContentUnits: MUST_USE_ATTRIBUTE,
                patternUnits: MUST_USE_ATTRIBUTE,
                points: MUST_USE_ATTRIBUTE,
                preserveAspectRatio: MUST_USE_ATTRIBUTE,
                r: MUST_USE_ATTRIBUTE,
                rx: MUST_USE_ATTRIBUTE,
                ry: MUST_USE_ATTRIBUTE,
                spreadMethod: MUST_USE_ATTRIBUTE,
                stopColor: MUST_USE_ATTRIBUTE,
                stopOpacity: MUST_USE_ATTRIBUTE,
                stroke: MUST_USE_ATTRIBUTE,
                strokeDasharray: MUST_USE_ATTRIBUTE,
                strokeLinecap: MUST_USE_ATTRIBUTE,
                strokeOpacity: MUST_USE_ATTRIBUTE,
                strokeWidth: MUST_USE_ATTRIBUTE,
                textAnchor: MUST_USE_ATTRIBUTE,
                transform: MUST_USE_ATTRIBUTE,
                version: MUST_USE_ATTRIBUTE,
                viewBox: MUST_USE_ATTRIBUTE,
                x1: MUST_USE_ATTRIBUTE,
                x2: MUST_USE_ATTRIBUTE,
                x: MUST_USE_ATTRIBUTE,
                xlinkActuate: MUST_USE_ATTRIBUTE,
                xlinkArcrole: MUST_USE_ATTRIBUTE,
                xlinkHref: MUST_USE_ATTRIBUTE,
                xlinkRole: MUST_USE_ATTRIBUTE,
                xlinkShow: MUST_USE_ATTRIBUTE,
                xlinkTitle: MUST_USE_ATTRIBUTE,
                xlinkType: MUST_USE_ATTRIBUTE,
                xmlBase: MUST_USE_ATTRIBUTE,
                xmlLang: MUST_USE_ATTRIBUTE,
                xmlSpace: MUST_USE_ATTRIBUTE,
                y1: MUST_USE_ATTRIBUTE,
                y2: MUST_USE_ATTRIBUTE,
                y: MUST_USE_ATTRIBUTE
            },
            DOMAttributeNamespaces: {
                xlinkActuate: NS.xlink,
                xlinkArcrole: NS.xlink,
                xlinkHref: NS.xlink,
                xlinkRole: NS.xlink,
                xlinkShow: NS.xlink,
                xlinkTitle: NS.xlink,
                xlinkType: NS.xlink,
                xmlBase: NS.xml,
                xmlLang: NS.xml,
                xmlSpace: NS.xml
            },
            DOMAttributeNames: {
                clipPath: 'clip-path',
                fillOpacity: 'fill-opacity',
                fontFamily: 'font-family',
                fontSize: 'font-size',
                gradientTransform: 'gradientTransform',
                gradientUnits: 'gradientUnits',
                markerEnd: 'marker-end',
                markerMid: 'marker-mid',
                markerStart: 'marker-start',
                patternContentUnits: 'patternContentUnits',
                patternUnits: 'patternUnits',
                preserveAspectRatio: 'preserveAspectRatio',
                spreadMethod: 'spreadMethod',
                stopColor: 'stop-color',
                stopOpacity: 'stop-opacity',
                strokeDasharray: 'stroke-dasharray',
                strokeLinecap: 'stroke-linecap',
                strokeOpacity: 'stroke-opacity',
                strokeWidth: 'stroke-width',
                textAnchor: 'text-anchor',
                viewBox: 'viewBox',
                xlinkActuate: 'xlink:actuate',
                xlinkArcrole: 'xlink:arcrole',
                xlinkHref: 'xlink:href',
                xlinkRole: 'xlink:role',
                xlinkShow: 'xlink:show',
                xlinkTitle: 'xlink:title',
                xlinkType: 'xlink:type',
                xmlBase: 'xml:base',
                xmlLang: 'xml:lang',
                xmlSpace: 'xml:space'
            }
        };

        module.exports = SVGDOMPropertyConfig;

        /***/ },
    /* 216 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDefaultPerf
         * @typechecks static-only
         */

        'use strict';

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        var DOMProperty = __webpack_require__(97);
        var ReactDefaultPerfAnalysis = __webpack_require__(217);
        var ReactMount = __webpack_require__(102);
        var ReactPerf = __webpack_require__(92);

        var performanceNow = __webpack_require__(218);

        function roundFloat(val) {
            return Math.floor(val * 100) / 100;
        }

        function addValue(obj, key, val) {
            obj[key] = (obj[key] || 0) + val;
        }

        var ReactDefaultPerf = {
            _allMeasurements: [], // last item in the list is the current one
            _mountStack: [0],
            _injected: false,

            start: function start() {
                if (!ReactDefaultPerf._injected) {
                    ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
                }

                ReactDefaultPerf._allMeasurements.length = 0;
                ReactPerf.enableMeasure = true;
            },

            stop: function stop() {
                ReactPerf.enableMeasure = false;
            },

            getLastMeasurements: function getLastMeasurements() {
                return ReactDefaultPerf._allMeasurements;
            },

            printExclusive: function printExclusive(measurements) {
                measurements = measurements || ReactDefaultPerf._allMeasurements;
                var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
                console.table(summary.map(function (item) {
                    return {
                        'Component class name': item.componentName,
                        'Total inclusive time (ms)': roundFloat(item.inclusive),
                        'Exclusive mount time (ms)': roundFloat(item.exclusive),
                        'Exclusive render time (ms)': roundFloat(item.render),
                        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
                        'Render time per instance (ms)': roundFloat(item.render / item.count),
                        'Instances': item.count
                    };
                }));
                // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
                // number.
            },

            printInclusive: function printInclusive(measurements) {
                measurements = measurements || ReactDefaultPerf._allMeasurements;
                var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
                console.table(summary.map(function (item) {
                    return {
                        'Owner > component': item.componentName,
                        'Inclusive time (ms)': roundFloat(item.time),
                        'Instances': item.count
                    };
                }));
                console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
            },

            getMeasurementsSummaryMap: function getMeasurementsSummaryMap(measurements) {
                var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
                return summary.map(function (item) {
                    return {
                        'Owner > component': item.componentName,
                        'Wasted time (ms)': item.time,
                        'Instances': item.count
                    };
                });
            },

            printWasted: function printWasted(measurements) {
                measurements = measurements || ReactDefaultPerf._allMeasurements;
                console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
                console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
            },

            printDOM: function printDOM(measurements) {
                measurements = measurements || ReactDefaultPerf._allMeasurements;
                var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
                console.table(summary.map(function (item) {
                    var result = {};
                    result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
                    result.type = item.type;
                    result.args = JSON.stringify(item.args);
                    return result;
                }));
                console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
            },

            _recordWrite: function _recordWrite(id, fnName, totalTime, args) {
                // TODO: totalTime isn't that useful since it doesn't count paints/reflows
                var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
                writes[id] = writes[id] || [];
                writes[id].push({
                    type: fnName,
                    time: totalTime,
                    args: args
                });
            },

            measure: function measure(moduleName, fnName, func) {
                return function () {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }

                    var totalTime;
                    var rv;
                    var start;

                    if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
                        // A "measurement" is a set of metrics recorded for each flush. We want
                        // to group the metrics for a given flush together so we can look at the
                        // components that rendered and the DOM operations that actually
                        // happened to determine the amount of "wasted work" performed.
                        ReactDefaultPerf._allMeasurements.push({
                            exclusive: {},
                            inclusive: {},
                            render: {},
                            counts: {},
                            writes: {},
                            displayNames: {},
                            totalTime: 0,
                            created: {}
                        });
                        start = performanceNow();
                        rv = func.apply(this, args);
                        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
                        return rv;
                    } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
                        start = performanceNow();
                        rv = func.apply(this, args);
                        totalTime = performanceNow() - start;

                        if (fnName === '_mountImageIntoNode') {
                            var mountID = ReactMount.getID(args[1]);
                            ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
                        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
                            // special format
                            args[0].forEach(function (update) {
                                var writeArgs = {};
                                if (update.fromIndex !== null) {
                                    writeArgs.fromIndex = update.fromIndex;
                                }
                                if (update.toIndex !== null) {
                                    writeArgs.toIndex = update.toIndex;
                                }
                                if (update.textContent !== null) {
                                    writeArgs.textContent = update.textContent;
                                }
                                if (update.markupIndex !== null) {
                                    writeArgs.markup = args[1][update.markupIndex];
                                }
                                ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
                            });
                        } else {
                            // basic format
                            var id = args[0];
                            if ((typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object') {
                                id = ReactMount.getID(args[0]);
                            }
                            ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
                        }
                        return rv;
                    } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
                        fnName === '_renderValidatedComponent')) {

                        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
                            return func.apply(this, args);
                        }

                        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
                        var isRender = fnName === '_renderValidatedComponent';
                        var isMount = fnName === 'mountComponent';

                        var mountStack = ReactDefaultPerf._mountStack;
                        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];

                        if (isRender) {
                            addValue(entry.counts, rootNodeID, 1);
                        } else if (isMount) {
                            entry.created[rootNodeID] = true;
                            mountStack.push(0);
                        }

                        start = performanceNow();
                        rv = func.apply(this, args);
                        totalTime = performanceNow() - start;

                        if (isRender) {
                            addValue(entry.render, rootNodeID, totalTime);
                        } else if (isMount) {
                            var subMountTime = mountStack.pop();
                            mountStack[mountStack.length - 1] += totalTime;
                            addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
                            addValue(entry.inclusive, rootNodeID, totalTime);
                        } else {
                            addValue(entry.inclusive, rootNodeID, totalTime);
                        }

                        entry.displayNames[rootNodeID] = {
                            current: this.getName(),
                            owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
                        };

                        return rv;
                    } else {
                        return func.apply(this, args);
                    }
                };
            }
        };

        module.exports = ReactDefaultPerf;

        /***/ },
    /* 217 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDefaultPerfAnalysis
         */

        'use strict';

        var assign = __webpack_require__(113);

        // Don't try to save users less than 1.2ms (a number I made up)
        var DONT_CARE_THRESHOLD = 1.2;
        var DOM_OPERATION_TYPES = {
            '_mountImageIntoNode': 'set innerHTML',
            INSERT_MARKUP: 'set innerHTML',
            MOVE_EXISTING: 'move',
            REMOVE_NODE: 'remove',
            SET_MARKUP: 'set innerHTML',
            TEXT_CONTENT: 'set textContent',
            'setValueForProperty': 'update attribute',
            'setValueForAttribute': 'update attribute',
            'deleteValueForProperty': 'remove attribute',
            'setValueForStyles': 'update styles',
            'replaceNodeWithMarkup': 'replace',
            'updateTextContent': 'set textContent'
        };

        function getTotalTime(measurements) {
            // TODO: return number of DOM ops? could be misleading.
            // TODO: measure dropped frames after reconcile?
            // TODO: log total time of each reconcile and the top-level component
            // class that triggered it.
            var totalTime = 0;
            for (var i = 0; i < measurements.length; i++) {
                var measurement = measurements[i];
                totalTime += measurement.totalTime;
            }
            return totalTime;
        }

        function getDOMSummary(measurements) {
            var items = [];
            measurements.forEach(function (measurement) {
                Object.keys(measurement.writes).forEach(function (id) {
                    measurement.writes[id].forEach(function (write) {
                        items.push({
                            id: id,
                            type: DOM_OPERATION_TYPES[write.type] || write.type,
                            args: write.args
                        });
                    });
                });
            });
            return items;
        }

        function getExclusiveSummary(measurements) {
            var candidates = {};
            var displayName;

            for (var i = 0; i < measurements.length; i++) {
                var measurement = measurements[i];
                var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

                for (var id in allIDs) {
                    displayName = measurement.displayNames[id].current;

                    candidates[displayName] = candidates[displayName] || {
                            componentName: displayName,
                            inclusive: 0,
                            exclusive: 0,
                            render: 0,
                            count: 0
                        };
                    if (measurement.render[id]) {
                        candidates[displayName].render += measurement.render[id];
                    }
                    if (measurement.exclusive[id]) {
                        candidates[displayName].exclusive += measurement.exclusive[id];
                    }
                    if (measurement.inclusive[id]) {
                        candidates[displayName].inclusive += measurement.inclusive[id];
                    }
                    if (measurement.counts[id]) {
                        candidates[displayName].count += measurement.counts[id];
                    }
                }
            }

            // Now make a sorted array with the results.
            var arr = [];
            for (displayName in candidates) {
                if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
                    arr.push(candidates[displayName]);
                }
            }

            arr.sort(function (a, b) {
                return b.exclusive - a.exclusive;
            });

            return arr;
        }

        function getInclusiveSummary(measurements, onlyClean) {
            var candidates = {};
            var inclusiveKey;

            for (var i = 0; i < measurements.length; i++) {
                var measurement = measurements[i];
                var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
                var cleanComponents;

                if (onlyClean) {
                    cleanComponents = getUnchangedComponents(measurement);
                }

                for (var id in allIDs) {
                    if (onlyClean && !cleanComponents[id]) {
                        continue;
                    }

                    var displayName = measurement.displayNames[id];

                    // Inclusive time is not useful for many components without knowing where
                    // they are instantiated. So we aggregate inclusive time with both the
                    // owner and current displayName as the key.
                    inclusiveKey = displayName.owner + ' > ' + displayName.current;

                    candidates[inclusiveKey] = candidates[inclusiveKey] || {
                            componentName: inclusiveKey,
                            time: 0,
                            count: 0
                        };

                    if (measurement.inclusive[id]) {
                        candidates[inclusiveKey].time += measurement.inclusive[id];
                    }
                    if (measurement.counts[id]) {
                        candidates[inclusiveKey].count += measurement.counts[id];
                    }
                }
            }

            // Now make a sorted array with the results.
            var arr = [];
            for (inclusiveKey in candidates) {
                if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
                    arr.push(candidates[inclusiveKey]);
                }
            }

            arr.sort(function (a, b) {
                return b.time - a.time;
            });

            return arr;
        }

        function getUnchangedComponents(measurement) {
            // For a given reconcile, look at which components did not actually
            // render anything to the DOM and return a mapping of their ID to
            // the amount of time it took to render the entire subtree.
            var cleanComponents = {};
            var dirtyLeafIDs = Object.keys(measurement.writes);
            var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

            for (var id in allIDs) {
                var isDirty = false;
                // For each component that rendered, see if a component that triggered
                // a DOM op is in its subtree.
                for (var i = 0; i < dirtyLeafIDs.length; i++) {
                    if (dirtyLeafIDs[i].indexOf(id) === 0) {
                        isDirty = true;
                        break;
                    }
                }
                // check if component newly created
                if (measurement.created[id]) {
                    isDirty = true;
                }
                if (!isDirty && measurement.counts[id] > 0) {
                    cleanComponents[id] = true;
                }
            }
            return cleanComponents;
        }

        var ReactDefaultPerfAnalysis = {
            getExclusiveSummary: getExclusiveSummary,
            getInclusiveSummary: getInclusiveSummary,
            getDOMSummary: getDOMSummary,
            getTotalTime: getTotalTime
        };

        module.exports = ReactDefaultPerfAnalysis;

        /***/ },
    /* 218 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule performanceNow
         * @typechecks
         */

        'use strict';

        var performance = __webpack_require__(219);

        var performanceNow;

        /**
         * Detect if we can use `window.performance.now()` and gracefully fallback to
         * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
         * because of Facebook's testing infrastructure.
         */
        if (performance.now) {
            performanceNow = function performanceNow() {
                return performance.now();
            };
        } else {
            performanceNow = function performanceNow() {
                return Date.now();
            };
        }

        module.exports = performanceNow;

        /***/ },
    /* 219 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule performance
         * @typechecks
         */

        'use strict';

        var ExecutionEnvironment = __webpack_require__(83);

        var performance;

        if (ExecutionEnvironment.canUseDOM) {
            performance = window.performance || window.msPerformance || window.webkitPerformance;
        }

        module.exports = performance || {};

        /***/ },
    /* 220 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactVersion
         */

        'use strict';

        module.exports = '0.14.6';

        /***/ },
    /* 221 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule renderSubtreeIntoContainer
         */

        'use strict';

        var ReactMount = __webpack_require__(102);

        module.exports = ReactMount.renderSubtreeIntoContainer;

        /***/ },
    /* 222 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        module.exports = __webpack_require__(223);

        /***/ },
    /* 223 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule React
         */

        'use strict';

        var ReactDOM = __webpack_require__(78);
        var ReactDOMServer = __webpack_require__(224);
        var ReactIsomorphic = __webpack_require__(228);

        var assign = __webpack_require__(113);
        var deprecated = __webpack_require__(233);

        // `version` will be added here by ReactIsomorphic.
        var React = {};

        assign(React, ReactIsomorphic);

        assign(React, {
            // ReactDOM
            findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
            render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
            unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),

            // ReactDOMServer
            renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
            renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
        });

        React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
        React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;

        module.exports = React;

        /***/ },
    /* 224 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMServer
         */

        'use strict';

        var ReactDefaultInjection = __webpack_require__(145);
        var ReactServerRendering = __webpack_require__(225);
        var ReactVersion = __webpack_require__(220);

        ReactDefaultInjection.inject();

        var ReactDOMServer = {
            renderToString: ReactServerRendering.renderToString,
            renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
            version: ReactVersion
        };

        module.exports = ReactDOMServer;

        /***/ },
    /* 225 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @typechecks static-only
         * @providesModule ReactServerRendering
         */
        'use strict';

            var ReactDefaultBatchingStrategy = __webpack_require__(166);
            var ReactElement = __webpack_require__(116);
            var ReactInstanceHandles = __webpack_require__(119);
            var ReactMarkupChecksum = __webpack_require__(122);
            var ReactServerBatchingStrategy = __webpack_require__(226);
            var ReactServerRenderingTransaction = __webpack_require__(227);
            var ReactUpdates = __webpack_require__(128);

            var emptyObject = __webpack_require__(132);
            var instantiateReactComponent = __webpack_require__(136);
            var invariant = __webpack_require__(87);

            /**
             * @param {ReactElement} element
             * @return {string} the HTML markup
             */
            function renderToString(element) {
                !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;

                var transaction;
                try {
                    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

                    var id = ReactInstanceHandles.createReactRootID();
                    transaction = ReactServerRenderingTransaction.getPooled(false);

                    return transaction.perform(function () {
                        var componentInstance = instantiateReactComponent(element, null);
                        var markup = componentInstance.mountComponent(id, transaction, emptyObject);
                        return ReactMarkupChecksum.addChecksumToMarkup(markup);
                    }, null);
                } finally {
                    ReactServerRenderingTransaction.release(transaction);
                    // Revert to the DOM batching strategy since these two renderers
                    // currently share these stateful modules.
                    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
                }
            }

            /**
             * @param {ReactElement} element
             * @return {string} the HTML markup, without the extra React ID and checksum
             * (for generating static pages)
             */
            function renderToStaticMarkup(element) {
                !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;

                var transaction;
                try {
                    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

                    var id = ReactInstanceHandles.createReactRootID();
                    transaction = ReactServerRenderingTransaction.getPooled(true);

                    return transaction.perform(function () {
                        var componentInstance = instantiateReactComponent(element, null);
                        return componentInstance.mountComponent(id, transaction, emptyObject);
                    }, null);
                } finally {
                    ReactServerRenderingTransaction.release(transaction);
                    // Revert to the DOM batching strategy since these two renderers
                    // currently share these stateful modules.
                    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
                }
            }

            module.exports = {
                renderToString: renderToString,
                renderToStaticMarkup: renderToStaticMarkup
            };
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 226 */
    /***/ function(module, exports) {

        /**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactServerBatchingStrategy
         * @typechecks
         */

        'use strict';

        var ReactServerBatchingStrategy = {
            isBatchingUpdates: false,
            batchedUpdates: function batchedUpdates(callback) {
                // Don't do anything here. During the server rendering we don't want to
                // schedule any updates. We will simply ignore them.
            }
        };

        module.exports = ReactServerBatchingStrategy;

        /***/ },
    /* 227 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactServerRenderingTransaction
         * @typechecks
         */

        'use strict';

        var PooledClass = __webpack_require__(130);
        var CallbackQueue = __webpack_require__(129);
        var Transaction = __webpack_require__(131);

        var assign = __webpack_require__(113);
        var emptyFunction = __webpack_require__(89);

        /**
         * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
         * during the performing of the transaction.
         */
        var ON_DOM_READY_QUEUEING = {
            /**
             * Initializes the internal `onDOMReady` queue.
             */
            initialize: function initialize() {
                this.reactMountReady.reset();
            },

            close: emptyFunction
        };

        /**
         * Executed within the scope of the `Transaction` instance. Consider these as
         * being member methods, but with an implied ordering while being isolated from
         * each other.
         */
        var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

        /**
         * @class ReactServerRenderingTransaction
         * @param {boolean} renderToStaticMarkup
         */
        function ReactServerRenderingTransaction(renderToStaticMarkup) {
            this.reinitializeTransaction();
            this.renderToStaticMarkup = renderToStaticMarkup;
            this.reactMountReady = CallbackQueue.getPooled(null);
            this.useCreateElement = false;
        }

        var Mixin = {
            /**
             * @see Transaction
             * @abstract
             * @final
             * @return {array} Empty list of operation wrap procedures.
             */
            getTransactionWrappers: function getTransactionWrappers() {
                return TRANSACTION_WRAPPERS;
            },

            /**
             * @return {object} The queue to collect `onDOMReady` callbacks with.
             */
            getReactMountReady: function getReactMountReady() {
                return this.reactMountReady;
            },

            /**
             * `PooledClass` looks for this, and will invoke this before allowing this
             * instance to be reused.
             */
            destructor: function destructor() {
                CallbackQueue.release(this.reactMountReady);
                this.reactMountReady = null;
            }
        };

        assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

        PooledClass.addPoolingTo(ReactServerRenderingTransaction);

        module.exports = ReactServerRenderingTransaction;

        /***/ },
    /* 228 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactIsomorphic
         */

        'use strict';

            var ReactChildren = __webpack_require__(184);
            var ReactComponent = __webpack_require__(197);
            var ReactClass = __webpack_require__(196);
            var ReactDOMFactories = __webpack_require__(229);
            var ReactElement = __webpack_require__(116);
            var ReactElementValidator = __webpack_require__(230);
            var ReactPropTypes = __webpack_require__(181);
            var ReactVersion = __webpack_require__(220);

            var assign = __webpack_require__(113);
            var onlyChild = __webpack_require__(232);

            var createElement = ReactElement.createElement;
            var createFactory = ReactElement.createFactory;
            var cloneElement = ReactElement.cloneElement;

            if (process.env.NODE_ENV !== 'production') {
                createElement = ReactElementValidator.createElement;
                createFactory = ReactElementValidator.createFactory;
                cloneElement = ReactElementValidator.cloneElement;
            }

            var React = {

                // Modern

                Children: {
                    map: ReactChildren.map,
                    forEach: ReactChildren.forEach,
                    count: ReactChildren.count,
                    toArray: ReactChildren.toArray,
                    only: onlyChild
                },

                Component: ReactComponent,

                createElement: createElement,
                cloneElement: cloneElement,
                isValidElement: ReactElement.isValidElement,

                // Classic

                PropTypes: ReactPropTypes,
                createClass: ReactClass.createClass,
                createFactory: createFactory,
                createMixin: function createMixin(mixin) {
                    // Currently a noop. Will be used to validate and trace mixins.
                    return mixin;
                },

                // This looks DOM specific but these are actually isomorphic helpers
                // since they are just generating DOM strings.
                DOM: ReactDOMFactories,

                version: ReactVersion,

                // Hook for JSX spread, don't use this for anything else.
                __spread: assign
            };

            module.exports = React;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 229 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactDOMFactories
         * @typechecks static-only
         */

        'use strict';

            var ReactElement = __webpack_require__(116);
            var ReactElementValidator = __webpack_require__(230);

            var mapObject = __webpack_require__(231);

            /**
             * Create a factory that creates HTML tag elements.
             *
             * @param {string} tag Tag name (e.g. `div`).
             * @private
             */
            function createDOMFactory(tag) {
                if (process.env.NODE_ENV !== 'production') {
                    return ReactElementValidator.createFactory(tag);
                }
                return ReactElement.createFactory(tag);
            }

            /**
             * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
             * This is also accessible via `React.DOM`.
             *
             * @public
             */
            var ReactDOMFactories = mapObject({
                a: 'a',
                abbr: 'abbr',
                address: 'address',
                area: 'area',
                article: 'article',
                aside: 'aside',
                audio: 'audio',
                b: 'b',
                base: 'base',
                bdi: 'bdi',
                bdo: 'bdo',
                big: 'big',
                blockquote: 'blockquote',
                body: 'body',
                br: 'br',
                button: 'button',
                canvas: 'canvas',
                caption: 'caption',
                cite: 'cite',
                code: 'code',
                col: 'col',
                colgroup: 'colgroup',
                data: 'data',
                datalist: 'datalist',
                dd: 'dd',
                del: 'del',
                details: 'details',
                dfn: 'dfn',
                dialog: 'dialog',
                div: 'div',
                dl: 'dl',
                dt: 'dt',
                em: 'em',
                embed: 'embed',
                fieldset: 'fieldset',
                figcaption: 'figcaption',
                figure: 'figure',
                footer: 'footer',
                form: 'form',
                h1: 'h1',
                h2: 'h2',
                h3: 'h3',
                h4: 'h4',
                h5: 'h5',
                h6: 'h6',
                head: 'head',
                header: 'header',
                hgroup: 'hgroup',
                hr: 'hr',
                html: 'html',
                i: 'i',
                iframe: 'iframe',
                img: 'img',
                input: 'input',
                ins: 'ins',
                kbd: 'kbd',
                keygen: 'keygen',
                label: 'label',
                legend: 'legend',
                li: 'li',
                link: 'link',
                main: 'main',
                map: 'map',
                mark: 'mark',
                menu: 'menu',
                menuitem: 'menuitem',
                meta: 'meta',
                meter: 'meter',
                nav: 'nav',
                noscript: 'noscript',
                object: 'object',
                ol: 'ol',
                optgroup: 'optgroup',
                option: 'option',
                output: 'output',
                p: 'p',
                param: 'param',
                picture: 'picture',
                pre: 'pre',
                progress: 'progress',
                q: 'q',
                rp: 'rp',
                rt: 'rt',
                ruby: 'ruby',
                s: 's',
                samp: 'samp',
                script: 'script',
                section: 'section',
                select: 'select',
                small: 'small',
                source: 'source',
                span: 'span',
                strong: 'strong',
                style: 'style',
                sub: 'sub',
                summary: 'summary',
                sup: 'sup',
                table: 'table',
                tbody: 'tbody',
                td: 'td',
                textarea: 'textarea',
                tfoot: 'tfoot',
                th: 'th',
                thead: 'thead',
                time: 'time',
                title: 'title',
                tr: 'tr',
                track: 'track',
                u: 'u',
                ul: 'ul',
                'var': 'var',
                video: 'video',
                wbr: 'wbr',

                // SVG
                circle: 'circle',
                clipPath: 'clipPath',
                defs: 'defs',
                ellipse: 'ellipse',
                g: 'g',
                image: 'image',
                line: 'line',
                linearGradient: 'linearGradient',
                mask: 'mask',
                path: 'path',
                pattern: 'pattern',
                polygon: 'polygon',
                polyline: 'polyline',
                radialGradient: 'radialGradient',
                rect: 'rect',
                stop: 'stop',
                svg: 'svg',
                text: 'text',
                tspan: 'tspan'

            }, createDOMFactory);

            module.exports = ReactDOMFactories;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 230 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2014-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule ReactElementValidator
         */

            /**
             * ReactElementValidator provides a wrapper around a element factory
             * which validates the props passed to the element. This is intended to be
             * used only in DEV and could be replaced by a static type checker for languages
             * that support it.
             */

            'use strict';

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

            var ReactElement = __webpack_require__(116);
            var ReactPropTypeLocations = __webpack_require__(139);
            var ReactPropTypeLocationNames = __webpack_require__(140);
            var ReactCurrentOwner = __webpack_require__(79);

            var canDefineProperty = __webpack_require__(117);
            var getIteratorFn = __webpack_require__(182);
            var invariant = __webpack_require__(87);
            var warning = __webpack_require__(99);

            function getDeclarationErrorAddendum() {
                if (ReactCurrentOwner.current) {
                    var name = ReactCurrentOwner.current.getName();
                    if (name) {
                        return ' Check the render method of `' + name + '`.';
                    }
                }
                return '';
            }

            /**
             * Warn if there's no key explicitly set on dynamic arrays of children or
             * object keys are not valid. This allows us to keep track of children between
             * updates.
             */
            var ownerHasKeyUseWarning = {};

            var loggedTypeFailures = {};

            /**
             * Warn if the element doesn't have an explicit key assigned to it.
             * This element is in an array. The array could grow and shrink or be
             * reordered. All children that haven't already been validated are required to
             * have a "key" property assigned to it.
             *
             * @internal
             * @param {ReactElement} element Element that requires a key.
             * @param {*} parentType element's parent's type.
             */
            function validateExplicitKey(element, parentType) {
                if (!element._store || element._store.validated || element.key != null) {
                    return;
                }
                element._store.validated = true;

                var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
                if (addenda === null) {
                    // we already showed the warning
                    return;
                }
                process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
            }

            /**
             * Shared warning and monitoring code for the key warnings.
             *
             * @internal
             * @param {string} messageType A key used for de-duping warnings.
             * @param {ReactElement} element Component that requires a key.
             * @param {*} parentType element's parent's type.
             * @returns {?object} A set of addenda to use in the warning message, or null
             * if the warning has already been shown before (and shouldn't be shown again).
             */
            function getAddendaForKeyUse(messageType, element, parentType) {
                var addendum = getDeclarationErrorAddendum();
                if (!addendum) {
                    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
                    if (parentName) {
                        addendum = ' Check the top-level render call using <' + parentName + '>.';
                    }
                }

                var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
                if (memoizer[addendum]) {
                    return null;
                }
                memoizer[addendum] = true;

                var addenda = {
                    parentOrOwner: addendum,
                    url: ' See https://fb.me/react-warning-keys for more information.',
                    childOwner: null
                };

                // Usually the current owner is the offender, but if it accepts children as a
                // property, it may be the creator of the child that's responsible for
                // assigning it a key.
                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
                    // Give the component that originally created this child.
                    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
                }

                return addenda;
            }

            /**
             * Ensure that every element either is passed in a static location, in an
             * array with an explicit keys property defined, or in an object literal
             * with valid key property.
             *
             * @internal
             * @param {ReactNode} node Statically passed child of any type.
             * @param {*} parentType node's parent's type.
             */
            function validateChildKeys(node, parentType) {
                if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
                    return;
                }
                if (Array.isArray(node)) {
                    for (var i = 0; i < node.length; i++) {
                        var child = node[i];
                        if (ReactElement.isValidElement(child)) {
                            validateExplicitKey(child, parentType);
                        }
                    }
                } else if (ReactElement.isValidElement(node)) {
                    // This element was passed in a valid location.
                    if (node._store) {
                        node._store.validated = true;
                    }
                } else if (node) {
                    var iteratorFn = getIteratorFn(node);
                    // Entry iterators provide implicit keys.
                    if (iteratorFn) {
                        if (iteratorFn !== node.entries) {
                            var iterator = iteratorFn.call(node);
                            var step;
                            while (!(step = iterator.next()).done) {
                                if (ReactElement.isValidElement(step.value)) {
                                    validateExplicitKey(step.value, parentType);
                                }
                            }
                        }
                    }
                }
            }

            /**
             * Assert that the props are valid
             *
             * @param {string} componentName Name of the component for error messages.
             * @param {object} propTypes Map of prop name to a ReactPropType
             * @param {object} props
             * @param {string} location e.g. "prop", "context", "child context"
             * @private
             */
            function checkPropTypes(componentName, propTypes, props, location) {
                for (var propName in propTypes) {
                    if (propTypes.hasOwnProperty(propName)) {
                        var error;
                        // Prop type validation may throw. In case they do, we don't want to
                        // fail the render phase where it didn't fail before. So we log it.
                        // After these have been cleaned up, we'll let them throw.
                        try {
                            // This is intentionally an invariant that gets caught. It's the same
                            // behavior as without this statement except with a better message.
                            !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
                            error = propTypes[propName](props, propName, componentName, location);
                        } catch (ex) {
                            error = ex;
                        }
                        process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : undefined;
                        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                            // Only monitor this failure once because there tends to be a lot of the
                            // same error.
                            loggedTypeFailures[error.message] = true;

                            var addendum = getDeclarationErrorAddendum();
                            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
                        }
                    }
                }
            }

            /**
             * Given an element, validate that its props follow the propTypes definition,
             * provided by the type.
             *
             * @param {ReactElement} element
             */
            function validatePropTypes(element) {
                var componentClass = element.type;
                if (typeof componentClass !== 'function') {
                    return;
                }
                var name = componentClass.displayName || componentClass.name;
                if (componentClass.propTypes) {
                    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
                }
                if (typeof componentClass.getDefaultProps === 'function') {
                    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
                }
            }

            var ReactElementValidator = {

                createElement: function createElement(type, props, children) {
                    var validType = typeof type === 'string' || typeof type === 'function';
                    // We warn in this case but don't throw. We expect the element creation to
                    // succeed and there will likely be errors in render.
                    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;

                    var element = ReactElement.createElement.apply(this, arguments);

                    // The result can be nullish if a mock or a custom function is used.
                    // TODO: Drop this when these are no longer allowed as the type argument.
                    if (element == null) {
                        return element;
                    }

                    // Skip key warning if the type isn't valid since our key validation logic
                    // doesn't expect a non-string/function type and can throw confusing errors.
                    // We don't want exception behavior to differ between dev and prod.
                    // (Rendering will throw with a helpful message and as soon as the type is
                    // fixed, the key warnings will appear.)
                    if (validType) {
                        for (var i = 2; i < arguments.length; i++) {
                            validateChildKeys(arguments[i], type);
                        }
                    }

                    validatePropTypes(element);

                    return element;
                },

                createFactory: function createFactory(type) {
                    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
                    // Legacy hook TODO: Warn if this is accessed
                    validatedFactory.type = type;

                    if (process.env.NODE_ENV !== 'production') {
                        if (canDefineProperty) {
                            Object.defineProperty(validatedFactory, 'type', {
                                enumerable: false,
                                get: function get() {
                                    process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
                                    Object.defineProperty(this, 'type', {
                                        value: type
                                    });
                                    return type;
                                }
                            });
                        }
                    }

                    return validatedFactory;
                },

                cloneElement: function cloneElement(element, props, children) {
                    var newElement = ReactElement.cloneElement.apply(this, arguments);
                    for (var i = 2; i < arguments.length; i++) {
                        validateChildKeys(arguments[i], newElement.type);
                    }
                    validatePropTypes(newElement);
                    return newElement;
                }

            };

            module.exports = ReactElementValidator;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 231 */
    /***/ function(module, exports) {

        /**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule mapObject
         */

        'use strict';

        var hasOwnProperty = Object.prototype.hasOwnProperty;

        /**
         * Executes the provided `callback` once for each enumerable own property in the
         * object and constructs a new object from the results. The `callback` is
         * invoked with three arguments:
         *
         *  - the property value
         *  - the property name
         *  - the object being traversed
         *
         * Properties that are added after the call to `mapObject` will not be visited
         * by `callback`. If the values of existing properties are changed, the value
         * passed to `callback` will be the value at the time `mapObject` visits them.
         * Properties that are deleted before being visited are not visited.
         *
         * @grep function objectMap()
         * @grep function objMap()
         *
         * @param {?object} object
         * @param {function} callback
         * @param {*} context
         * @return {?object}
         */
        function mapObject(object, callback, context) {
            if (!object) {
                return null;
            }
            var result = {};
            for (var name in object) {
                if (hasOwnProperty.call(object, name)) {
                    result[name] = callback.call(context, object[name], name, object);
                }
            }
            return result;
        }

        module.exports = mapObject;

        /***/ },
    /* 232 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule onlyChild
         */
        'use strict';

            var ReactElement = __webpack_require__(116);

            var invariant = __webpack_require__(87);

            /**
             * Returns the first child in a collection of children and verifies that there
             * is only one child in the collection. The current implementation of this
             * function assumes that a single child gets passed without a wrapper, but the
             * purpose of this helper function is to abstract away the particular structure
             * of children.
             *
             * @param {?object} children Child collection structure.
             * @return {ReactComponent} The first and only `ReactComponent` contained in the
             * structure.
             */
            function onlyChild(children) {
                !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
                return children;
            }

            module.exports = onlyChild;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 233 */
    /***/ function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */(function(process) {/**
         * Copyright 2013-2015, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         *
         * @providesModule deprecated
         */

        'use strict';

            var assign = __webpack_require__(113);
            var warning = __webpack_require__(99);

            /**
             * This will log a single deprecation notice per function and forward the call
             * on to the new API.
             *
             * @param {string} fnName The name of the function
             * @param {string} newModule The module that fn will exist in
             * @param {string} newPackage The module that fn will exist in
             * @param {*} ctx The context this forwarded call should run in
             * @param {function} fn The function to forward on to
             * @return {function} The function that will warn once and then call fn
             */
            function deprecated(fnName, newModule, newPackage, ctx, fn) {
                var warned = false;
                if (process.env.NODE_ENV !== 'production') {
                    var newFn = function newFn() {
                        process.env.NODE_ENV !== 'production' ? warning(warned,
                            // Require examples in this string must be split to prevent React's
                            // build tools from mistaking them for real requires.
                            // Otherwise the build tools will attempt to build a '%s' module.
                            'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
                        warned = true;
                        return fn.apply(ctx, arguments);
                    };
                    // We need to make sure all properties of the original fn are copied over.
                    // In particular, this is needed to support PropTypes
                    return assign(newFn, fn);
                }

                return fn;
            }

            module.exports = deprecated;
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

        /***/ },
    /* 234 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

        var _reactDom = __webpack_require__(77);

        var _reactDom2 = _interopRequireDefault(_reactDom);

        var _react = __webpack_require__(222);

        var _react2 = _interopRequireDefault(_react);

        var _agGridReact = __webpack_require__(235);

        var _RefData = __webpack_require__(342);

        var _RefData2 = _interopRequireDefault(_RefData);

        var _RowDataFactory = __webpack_require__(343);

        var _RowDataFactory2 = _interopRequireDefault(_RowDataFactory);

        var _ColDefFactory = __webpack_require__(344);

        var _ColDefFactory2 = _interopRequireDefault(_ColDefFactory);

        __webpack_require__(350);

        __webpack_require__(354);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

        // take this line out if you do not want to use ag-Grid-Enterprise


        var MyApp = function (_React$Component) {
            _inherits(MyApp, _React$Component);

            function MyApp() {
                _classCallCheck(this, MyApp);

                var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MyApp).call(this));

                _this.state = {
                    quickFilterText: null,
                    showGrid: true,
                    showToolPanel: false,
                    columnDefs: new _ColDefFactory2.default().createColDefs(),
                    rowData: new _RowDataFactory2.default().createRowData(),
                    icons: {
                        columnRemoveFromGroup: '<i class="fa fa-remove"/>',
                        filter: '<i class="fa fa-filter"/>',
                        sortAscending: '<i class="fa fa-long-arrow-down"/>',
                        sortDescending: '<i class="fa fa-long-arrow-up"/>',
                        groupExpanded: '<i class="fa fa-minus-square-o"/>',
                        groupContracted: '<i class="fa fa-plus-square-o"/>',
                        columnGroupOpened: '<i class="fa fa-minus-square-o"/>',
                        columnGroupClosed: '<i class="fa fa-plus-square-o"/>'
                    }
                };

                // the grid options are optional, because you can provide every property
                // to the grid via standard React properties. however, the react interface
                // doesn't block you from using the standard JavaScript interface if you
                // wish. Maybe you have the gridOptions stored as JSON on your server? If
                // you do, the providing the gridOptions as a standalone object is just
                // what you want!
                _this.gridOptions = {
                    // this is how you listen for events using gridOptions
                    onModelUpdated: function onModelUpdated() {
                        console.log('event onModelUpdated received');
                    },
                    // this is a simple property
                    rowBuffer: 10 // no need to set this, the default is fine for almost all scenarios
                };
                return _this;
            }

            _createClass(MyApp, [{
                key: 'onShowGrid',
                value: function onShowGrid(show) {
                    this.setState({
                        showGrid: show
                    });
                }
            }, {
                key: 'onToggleToolPanel',
                value: function onToggleToolPanel(event) {
                    this.setState({ showToolPanel: event.target.checked });
                }
            }, {
                key: 'onGridReady',
                value: function onGridReady(params) {
                    this.api = params.api;
                    this.columnApi = params.columnApi;
                }
            }, {
                key: 'selectAll',
                value: function selectAll() {
                    this.api.selectAll();
                }
            }, {
                key: 'deselectAll',
                value: function deselectAll() {
                    this.api.deselectAll();
                }
            }, {
                key: 'setCountryVisible',
                value: function setCountryVisible(visible) {
                    this.columnApi.setColumnVisible('country', visible);
                }
            }, {
                key: 'onQuickFilterText',
                value: function onQuickFilterText(event) {
                    this.setState({ quickFilterText: event.target.value });
                }
            }, {
                key: 'onCellClicked',
                value: function onCellClicked(event) {
                    console.log('onCellClicked: ' + event.data.name + ', col ' + event.colIndex);
                }
            }, {
                key: 'onRowSelected',
                value: function onRowSelected(event) {
                    console.log('onRowSelected: ' + event.node.data.name);
                }
            }, {
                key: 'onRefreshData',
                value: function onRefreshData() {
                    var newRowData = new _RowDataFactory2.default().createRowData();
                    this.setState({
                        rowData: newRowData
                    });
                }
            }, {
                key: 'render',
                value: function render() {
                    var gridTemplate;
                    var bottomHeaderTemplate;
                    var topHeaderTemplate;

                    topHeaderTemplate = _react2.default.createElement(
                        'div',
                        null,
                        _react2.default.createElement(
                            'div',
                            { style: { float: 'right' } },
                            _react2.default.createElement('input', { type: 'text', onChange: this.onQuickFilterText.bind(this), placeholder: 'Type text to filter...' }),
                            _react2.default.createElement(
                                'button',
                                { id: 'btDestroyGrid', disabled: !this.state.showGrid, onClick: this.onShowGrid.bind(this, false) },
                                'Destroy Grid'
                            ),
                            _react2.default.createElement(
                                'button',
                                { id: 'btCreateGrid', disabled: this.state.showGrid, onClick: this.onShowGrid.bind(this, true) },
                                'Create Grid'
                            )
                        ),
                        _react2.default.createElement(
                            'div',
                            { style: { padding: '4px' } },
                            _react2.default.createElement(
                                'b',
                                null,
                                'Employees Skills and Contact Details'
                            ),
                            ' ',
                            _react2.default.createElement('span', { id: 'rowCount' })
                        )
                    );

                    // showing the bottom header and grid is optional, so we put in a switch
                    if (this.state.showGrid) {
                        bottomHeaderTemplate = _react2.default.createElement(
                            'div',
                            null,
                            _react2.default.createElement(
                                'div',
                                { style: { padding: 4 }, className: 'toolbar' },
                                _react2.default.createElement(
                                    'span',
                                    null,
                                    'Grid API:',
                                    _react2.default.createElement(
                                        'button',
                                        { onClick: this.selectAll.bind(this) },
                                        'Select All'
                                    ),
                                    _react2.default.createElement(
                                        'button',
                                        { onClick: this.deselectAll.bind(this) },
                                        'Clear Selection'
                                    )
                                ),
                                _react2.default.createElement(
                                    'span',
                                    { style: { marginLeft: 20 } },
                                    'Column API:',
                                    _react2.default.createElement(
                                        'button',
                                        { onClick: this.setCountryVisible.bind(this, false) },
                                        'Hide Country Column'
                                    ),
                                    _react2.default.createElement(
                                        'button',
                                        { onClick: this.setCountryVisible.bind(this, true) },
                                        'Show Country Column'
                                    )
                                )
                            ),
                            _react2.default.createElement('div', { style: { clear: 'both' } }),
                            _react2.default.createElement(
                                'div',
                                { style: { padding: 4 }, className: 'toolbar' },
                                _react2.default.createElement(
                                    'label',
                                    null,
                                    _react2.default.createElement('input', { type: 'checkbox', onChange: this.onToggleToolPanel.bind(this) }),
                                    'Show Tool Panel'
                                ),
                                _react2.default.createElement(
                                    'button',
                                    { onClick: this.onRefreshData.bind(this) },
                                    'Refresh Data'
                                )
                            ),
                            _react2.default.createElement('div', { style: { clear: 'both' } })
                        );
                        gridTemplate = _react2.default.createElement(
                            'div',
                            { style: { height: 400 }, className: 'ag-fresh' },
                            _react2.default.createElement(_agGridReact.AgGridReact
                                // gridOptions is optional - it's possible to provide
                                // all values as React props
                                , { gridOptions: this.gridOptions

                                    // listening for events
                                    , onGridReady: this.onGridReady.bind(this),
                                    onRowSelected: this.onRowSelected.bind(this),
                                    onCellClicked: this.onCellClicked.bind(this)

                                    // binding to simple properties
                                    , showToolPanel: this.state.showToolPanel,
                                    quickFilterText: this.state.quickFilterText

                                    // binding to an object property
                                    , icons: this.state.icons

                                    // binding to array properties
                                    , columnDefs: this.state.columnDefs,
                                    rowData: this.state.rowData

                                    // no binding, just providing hard coded strings for the properties
                                    , suppressRowClickSelection: 'true',
                                    rowSelection: 'multiple',
                                    enableColResize: 'true',
                                    enableSorting: 'true',
                                    enableFilter: 'true',
                                    groupHeaders: 'true',
                                    rowHeight: '22',
                                    debug: 'true'
                                })
                        );
                    }

                    return _react2.default.createElement(
                        'div',
                        { style: { width: '800px' } },
                        _react2.default.createElement(
                            'div',
                            { style: { padding: '4px' } },
                            topHeaderTemplate,
                            bottomHeaderTemplate,
                            gridTemplate
                        )
                    );
                }
            }]);

            return MyApp;
        }(_react2.default.Component);

        exports.default = MyApp;

        /***/ },
    /* 235 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        exports.AgGridReact = __webpack_require__(236).AgGridReact;
        exports.reactCellRendererFactory = __webpack_require__(338).reactCellRendererFactory;
        exports.reactFilterFactory = __webpack_require__(341).reactFilterFactory;

        /***/ },
    /* 236 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        // ag-grid-react v5.5.0
        /// <reference path="../typings/tsd"/>
        var reactFrameworkFactory_1 = __webpack_require__(237);
        var React = __webpack_require__(222);
        var ReactDOM = __webpack_require__(77);
        var AgGrid = __webpack_require__(238);
        exports.AgGridReact = React.createClass({
            displayName: 'AgGridReact',

            render: function render() {
                return React.DOM.div({
                    style: this.createStyleForDiv()
                });
            },
            createStyleForDiv: function createStyleForDiv() {
                var style = { height: '100%' };
                // allow user to override styles
                var containerStyle = this.props.containerStyle;
                if (containerStyle) {
                    Object.keys(containerStyle).forEach(function (key) {
                        var value = containerStyle[key];
                        style[key] = value;
                    });
                }
                return style;
            },
            componentDidMount: function componentDidMount() {
                var reactFrameworkFactory = new reactFrameworkFactory_1.ReactFrameworkFactory(this);
                var gridParams = { frameworkFactory: reactFrameworkFactory };
                var domNode = ReactDOM.findDOMNode(this);
                this.gridOptions = AgGrid.ComponentUtil.copyAttributesToGridOptions(this.props.gridOptions, this.props);
                new AgGrid.Grid(domNode, this.gridOptions, gridParams);
                this.api = this.gridOptions.api;
                this.columnApi = this.gridOptions.columnApi;
            },
            shouldComponentUpdate: function shouldComponentUpdate() {
                // we want full control of the dom, as ag-Grid doesn't use React internally,
                // so for performance reasons we tell React we don't need render called after
                // property changes.
                return false;
            },
            componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
                var _this = this;
                // keeping consistent with web components, put changing
                // values in currentValue and previousValue pairs and
                // not include items that have not changed.
                var changes = {};
                AgGrid.ComponentUtil.ALL_PROPERTIES.forEach(function (propKey) {
                    if (_this.props[propKey] !== nextProps[propKey]) {
                        changes[propKey] = {
                            previousValue: _this.props[propKey],
                            currentValue: nextProps[propKey]
                        };
                    }
                });
                AgGrid.ComponentUtil.getEventCallbacks().forEach(function (funcName) {
                    if (_this.props[funcName] !== nextProps[funcName]) {
                        changes[funcName] = {
                            previousValue: _this.props[funcName],
                            currentValue: nextProps[funcName]
                        };
                    }
                });
                AgGrid.ComponentUtil.processOnChange(changes, this.gridOptions, this.api, this.columnApi);
            },
            componentWillUnmount: function componentWillUnmount() {
                this.api.destroy();
            }
        });
        exports.AgGridReact.propTypes = {
            gridOptions: React.PropTypes.object
        };
        addProperties(AgGrid.ComponentUtil.getEventCallbacks(), React.PropTypes.func);
        addProperties(AgGrid.ComponentUtil.BOOLEAN_PROPERTIES, React.PropTypes.bool);
        addProperties(AgGrid.ComponentUtil.STRING_PROPERTIES, React.PropTypes.string);
        addProperties(AgGrid.ComponentUtil.OBJECT_PROPERTIES, React.PropTypes.object);
        addProperties(AgGrid.ComponentUtil.ARRAY_PROPERTIES, React.PropTypes.array);
        addProperties(AgGrid.ComponentUtil.NUMBER_PROPERTIES, React.PropTypes.number);
        addProperties(AgGrid.ComponentUtil.FUNCTION_PROPERTIES, React.PropTypes.func);
        function addProperties(listOfProps, propType) {
            listOfProps.forEach(function (propKey) {
                exports.AgGridReact[propKey] = propType;
            });
        }

        /***/ },
    /* 237 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        // ag-grid-react v5.5.0
        var ag_grid_1 = __webpack_require__(238);
        var reactCellRendererFactory_1 = __webpack_require__(338);
        var reactCellEditorFactory_1 = __webpack_require__(340);
        var reactFilterFactory_1 = __webpack_require__(341);
        var ReactFrameworkFactory = function () {
            function ReactFrameworkFactory(agGridReact) {
                this.baseFrameworkFactory = new ag_grid_1.BaseFrameworkFactory();
                this.agGridReact = agGridReact;
            }
            ReactFrameworkFactory.prototype.colDefFilter = function (colDef) {
                if (ag_grid_1.Utils.exists(colDef.filterFramework)) {
                    return reactFilterFactory_1.reactFilterFactory(colDef.filterFramework, this.agGridReact);
                } else {
                    return this.baseFrameworkFactory.colDefFilter(colDef);
                }
            };
            ReactFrameworkFactory.prototype.colDefFloatingCellRenderer = function (colDef) {
                if (ag_grid_1.Utils.exists(colDef.floatingCellRendererFramework)) {
                    return reactCellRendererFactory_1.reactCellRendererFactory(colDef.floatingCellRendererFramework, this.agGridReact);
                } else {
                    return this.baseFrameworkFactory.colDefFloatingCellRenderer(colDef);
                }
            };
            ReactFrameworkFactory.prototype.colDefCellRenderer = function (colDef) {
                if (ag_grid_1.Utils.exists(colDef.cellRendererFramework)) {
                    return reactCellRendererFactory_1.reactCellRendererFactory(colDef.cellRendererFramework, this.agGridReact);
                } else {
                    return this.baseFrameworkFactory.colDefCellRenderer(colDef);
                }
            };
            ReactFrameworkFactory.prototype.colDefCellEditor = function (colDef) {
                if (ag_grid_1.Utils.exists(colDef.cellEditorFramework)) {
                    return reactCellEditorFactory_1.reactCellEditorFactory(colDef.cellEditorFramework, this.agGridReact);
                } else {
                    return this.baseFrameworkFactory.colDefCellEditor(colDef);
                }
            };
            ReactFrameworkFactory.prototype.gridOptionsFullWidthCellRenderer = function (gridOptions) {
                if (ag_grid_1.Utils.exists(gridOptions.fullWidthCellRendererFramework)) {
                    return reactCellRendererFactory_1.reactCellRendererFactory(gridOptions.fullWidthCellRendererFramework, this.agGridReact);
                } else {
                    return this.baseFrameworkFactory.gridOptionsFullWidthCellRenderer(gridOptions);
                }
            };
            ReactFrameworkFactory.prototype.gridOptionsGroupRowRenderer = function (gridOptions) {
                if (ag_grid_1.Utils.exists(gridOptions.groupRowRendererFramework)) {
                    return reactCellRendererFactory_1.reactCellRendererFactory(gridOptions.groupRowRendererFramework, this.agGridReact);
                } else {
                    return this.baseFrameworkFactory.gridOptionsGroupRowRenderer(gridOptions);
                }
            };
            ReactFrameworkFactory.prototype.gridOptionsGroupRowInnerRenderer = function (gridOptions) {
                if (ag_grid_1.Utils.exists(gridOptions.groupRowInnerRendererFramework)) {
                    return reactCellRendererFactory_1.reactCellRendererFactory(gridOptions.groupRowInnerRendererFramework, this.agGridReact);
                } else {
                    return this.baseFrameworkFactory.gridOptionsGroupRowInnerRenderer(gridOptions);
                }
            };
            return ReactFrameworkFactory;
        }();
        exports.ReactFrameworkFactory = ReactFrameworkFactory;

        /***/ },
    /* 238 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        ////////// MAKE SURE YOU EDIT main-webpack.js IF EDITING THIS FILE!!!

        var populateClientExports = __webpack_require__(239).populateClientExports;
        populateClientExports(exports);

        /***/ },
    /* 239 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var grid_1 = __webpack_require__(240);
        var gridApi_1 = __webpack_require__(249);
        var events_1 = __webpack_require__(248);
        var componentUtil_1 = __webpack_require__(247);
        var columnController_1 = __webpack_require__(251);
        var agGridNg1_1 = __webpack_require__(332);
        var agGridWebComponent_1 = __webpack_require__(333);
        var gridCell_1 = __webpack_require__(271);
        var rowNode_1 = __webpack_require__(265);
        var originalColumnGroup_1 = __webpack_require__(255);
        var columnGroup_1 = __webpack_require__(252);
        var column_1 = __webpack_require__(253);
        var focusedCellController_1 = __webpack_require__(273);
        var functions_1 = __webpack_require__(318);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var balancedColumnTreeBuilder_1 = __webpack_require__(257);
        var columnKeyCreator_1 = __webpack_require__(258);
        var columnUtils_1 = __webpack_require__(254);
        var displayedGroupCreator_1 = __webpack_require__(259);
        var groupInstanceIdCreator_1 = __webpack_require__(317);
        var context_1 = __webpack_require__(244);
        var dragAndDropService_1 = __webpack_require__(306);
        var dragService_1 = __webpack_require__(269);
        var filterManager_1 = __webpack_require__(281);
        var numberFilter_1 = __webpack_require__(284);
        var textFilter_1 = __webpack_require__(283);
        var gridPanel_1 = __webpack_require__(262);
        var mouseEventService_1 = __webpack_require__(270);
        var cssClassApplier_1 = __webpack_require__(310);
        var headerContainer_1 = __webpack_require__(305);
        var headerRenderer_1 = __webpack_require__(304);
        var headerTemplateLoader_1 = __webpack_require__(312);
        var horizontalDragService_1 = __webpack_require__(309);
        var moveColumnController_1 = __webpack_require__(314);
        var renderedHeaderCell_1 = __webpack_require__(311);
        var renderedHeaderGroupCell_1 = __webpack_require__(308);
        var standardMenu_1 = __webpack_require__(320);
        var borderLayout_1 = __webpack_require__(268);
        var tabbedLayout_1 = __webpack_require__(334);
        var verticalStack_1 = __webpack_require__(335);
        var autoWidthCalculator_1 = __webpack_require__(260);
        var renderedRow_1 = __webpack_require__(275);
        var rowRenderer_1 = __webpack_require__(261);
        var filterStage_1 = __webpack_require__(321);
        var flattenStage_1 = __webpack_require__(323);
        var sortStage_1 = __webpack_require__(322);
        var floatingRowModel_1 = __webpack_require__(264);
        var paginationController_1 = __webpack_require__(279);
        var component_1 = __webpack_require__(285);
        var menuList_1 = __webpack_require__(336);
        var cellNavigationService_1 = __webpack_require__(303);
        var columnChangeEvent_1 = __webpack_require__(316);
        var constants_1 = __webpack_require__(246);
        var csvCreator_1 = __webpack_require__(250);
        var eventService_1 = __webpack_require__(242);
        var expressionService_1 = __webpack_require__(256);
        var gridCore_1 = __webpack_require__(278);
        var logger_1 = __webpack_require__(243);
        var masterSlaveService_1 = __webpack_require__(263);
        var selectionController_1 = __webpack_require__(266);
        var sortController_1 = __webpack_require__(280);
        var svgFactory_1 = __webpack_require__(297);
        var templateService_1 = __webpack_require__(274);
        var utils_1 = __webpack_require__(245);
        var valueService_1 = __webpack_require__(267);
        var popupService_1 = __webpack_require__(282);
        var gridRow_1 = __webpack_require__(272);
        var inMemoryRowModel_1 = __webpack_require__(327);
        var virtualPageRowModel_1 = __webpack_require__(324);
        var menuItemComponent_1 = __webpack_require__(337);
        var animateSlideCellRenderer_1 = __webpack_require__(294);
        var cellEditorFactory_1 = __webpack_require__(286);
        var popupEditorWrapper_1 = __webpack_require__(289);
        var popupSelectCellEditor_1 = __webpack_require__(291);
        var popupTextCellEditor_1 = __webpack_require__(290);
        var selectCellEditor_1 = __webpack_require__(288);
        var textCellEditor_1 = __webpack_require__(287);
        var largeTextCellEditor_1 = __webpack_require__(292);
        var cellRendererFactory_1 = __webpack_require__(293);
        var groupCellRenderer_1 = __webpack_require__(296);
        var cellRendererService_1 = __webpack_require__(298);
        var valueFormatterService_1 = __webpack_require__(299);
        var checkboxSelectionComponent_1 = __webpack_require__(300);
        var componentAnnotations_1 = __webpack_require__(330);
        var agCheckbox_1 = __webpack_require__(329);
        var bodyDropPivotTarget_1 = __webpack_require__(315);
        var bodyDropTarget_1 = __webpack_require__(313);
        var focusService_1 = __webpack_require__(277);
        var setLeftFeature_1 = __webpack_require__(301);
        var renderedCell_1 = __webpack_require__(276);
        var headerRowComp_1 = __webpack_require__(307);
        var animateShowChangeCellRenderer_1 = __webpack_require__(295);
        var inMemoryNodeManager_1 = __webpack_require__(328);
        var virtualPageCache_1 = __webpack_require__(325);
        var virtualPage_1 = __webpack_require__(326);
        var baseFrameworkFactory_1 = __webpack_require__(331);
        var methodNotImplementedException_1 = __webpack_require__(302);
        function populateClientExports(exports) {
            // columnController
            exports.BalancedColumnTreeBuilder = balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder;
            exports.ColumnController = columnController_1.ColumnController;
            exports.ColumnKeyCreator = columnKeyCreator_1.ColumnKeyCreator;
            exports.ColumnUtils = columnUtils_1.ColumnUtils;
            exports.DisplayedGroupCreator = displayedGroupCreator_1.DisplayedGroupCreator;
            exports.GroupInstanceIdCreator = groupInstanceIdCreator_1.GroupInstanceIdCreator;
            // components
            exports.ComponentUtil = componentUtil_1.ComponentUtil;
            exports.initialiseAgGridWithAngular1 = agGridNg1_1.initialiseAgGridWithAngular1;
            exports.initialiseAgGridWithWebComponents = agGridWebComponent_1.initialiseAgGridWithWebComponents;
            // context
            exports.Context = context_1.Context;
            exports.Autowired = context_1.Autowired;
            exports.PostConstruct = context_1.PostConstruct;
            exports.PreDestroy = context_1.PreDestroy;
            exports.Optional = context_1.Optional;
            exports.Bean = context_1.Bean;
            exports.Qualifier = context_1.Qualifier;
            exports.Listener = componentAnnotations_1.Listener;
            exports.QuerySelector = componentAnnotations_1.QuerySelector;
            // dragAndDrop
            exports.DragAndDropService = dragAndDropService_1.DragAndDropService;
            exports.DragService = dragService_1.DragService;
            exports.DragSourceType = dragAndDropService_1.DragSourceType;
            // entities
            exports.Column = column_1.Column;
            exports.ColumnGroup = columnGroup_1.ColumnGroup;
            exports.GridCell = gridCell_1.GridCell;
            exports.GridRow = gridRow_1.GridRow;
            exports.OriginalColumnGroup = originalColumnGroup_1.OriginalColumnGroup;
            exports.RowNode = rowNode_1.RowNode;
            // filter
            exports.FilterManager = filterManager_1.FilterManager;
            exports.NumberFilter = numberFilter_1.NumberFilter;
            exports.TextFilter = textFilter_1.TextFilter;
            // gridPanel
            exports.GridPanel = gridPanel_1.GridPanel;
            exports.MouseEventService = mouseEventService_1.MouseEventService;
            // headerRendering
            exports.BodyDropPivotTarget = bodyDropPivotTarget_1.BodyDropPivotTarget;
            exports.BodyDropTarget = bodyDropTarget_1.BodyDropTarget;
            exports.CssClassApplier = cssClassApplier_1.CssClassApplier;
            exports.HeaderContainer = headerContainer_1.HeaderContainer;
            exports.HeaderRenderer = headerRenderer_1.HeaderRenderer;
            exports.HeaderRowComp = headerRowComp_1.HeaderRowComp;
            exports.HeaderTemplateLoader = headerTemplateLoader_1.HeaderTemplateLoader;
            exports.HorizontalDragService = horizontalDragService_1.HorizontalDragService;
            exports.MoveColumnController = moveColumnController_1.MoveColumnController;
            exports.RenderedHeaderCell = renderedHeaderCell_1.RenderedHeaderCell;
            exports.RenderedHeaderGroupCell = renderedHeaderGroupCell_1.RenderedHeaderGroupCell;
            exports.StandardMenuFactory = standardMenu_1.StandardMenuFactory;
            // layout
            exports.BorderLayout = borderLayout_1.BorderLayout;
            exports.TabbedLayout = tabbedLayout_1.TabbedLayout;
            exports.VerticalStack = verticalStack_1.VerticalStack;
            // misc
            exports.FocusService = focusService_1.FocusService;
            exports.MethodNotImplementedException = methodNotImplementedException_1.MethodNotImplementedException;
            // rendering / cellEditors
            exports.LargeTextCellEditor = largeTextCellEditor_1.LargeTextCellEditor;
            exports.PopupEditorWrapper = popupEditorWrapper_1.PopupEditorWrapper;
            exports.PopupSelectCellEditor = popupSelectCellEditor_1.PopupSelectCellEditor;
            exports.PopupTextCellEditor = popupTextCellEditor_1.PopupTextCellEditor;
            exports.SelectCellEditor = selectCellEditor_1.SelectCellEditor;
            exports.TextCellEditor = textCellEditor_1.TextCellEditor;
            // rendering / cellRenderers
            exports.AnimateShowChangeCellRenderer = animateShowChangeCellRenderer_1.AnimateShowChangeCellRenderer;
            exports.AnimateSlideCellRenderer = animateSlideCellRenderer_1.AnimateSlideCellRenderer;
            exports.GroupCellRenderer = groupCellRenderer_1.GroupCellRenderer;
            // features
            exports.SetLeftFeature = setLeftFeature_1.SetLeftFeature;
            // rendering
            exports.AutoWidthCalculator = autoWidthCalculator_1.AutoWidthCalculator;
            exports.CellEditorFactory = cellEditorFactory_1.CellEditorFactory;
            exports.RenderedHeaderCell = renderedHeaderCell_1.RenderedHeaderCell;
            exports.CellRendererFactory = cellRendererFactory_1.CellRendererFactory;
            exports.CellRendererService = cellRendererService_1.CellRendererService;
            exports.CheckboxSelectionComponent = checkboxSelectionComponent_1.CheckboxSelectionComponent;
            exports.RenderedCell = renderedCell_1.RenderedCell;
            exports.RenderedRow = renderedRow_1.RenderedRow;
            exports.RowRenderer = rowRenderer_1.RowRenderer;
            exports.ValueFormatterService = valueFormatterService_1.ValueFormatterService;
            // rowControllers/inMemory
            exports.FilterStage = filterStage_1.FilterStage;
            exports.FlattenStage = flattenStage_1.FlattenStage;
            exports.InMemoryRowModel = inMemoryRowModel_1.InMemoryRowModel;
            exports.SortStage = sortStage_1.SortStage;
            exports.InMemoryNodeManager = inMemoryNodeManager_1.InMemoryNodeManager;
            // rowControllers
            exports.FloatingRowModel = floatingRowModel_1.FloatingRowModel;
            exports.PaginationController = paginationController_1.PaginationController;
            exports.VirtualPageRowModel = virtualPageRowModel_1.VirtualPageRowModel;
            exports.VirtualPageCache = virtualPageCache_1.VirtualPageCache;
            exports.VirtualPage = virtualPage_1.VirtualPage;
            // widgets
            exports.AgCheckbox = agCheckbox_1.AgCheckbox;
            exports.Component = component_1.Component;
            exports.PopupService = popupService_1.PopupService;
            exports.MenuItemComponent = menuItemComponent_1.MenuItemComponent;
            exports.MenuList = menuList_1.MenuList;
            exports.Listener = componentAnnotations_1.Listener;
            exports.QuerySelector = componentAnnotations_1.QuerySelector;
            // root
            exports.BaseFrameworkFactory = baseFrameworkFactory_1.BaseFrameworkFactory;
            exports.CellNavigationService = cellNavigationService_1.CellNavigationService;
            exports.ColumnChangeEvent = columnChangeEvent_1.ColumnChangeEvent;
            exports.Constants = constants_1.Constants;
            exports.CsvCreator = csvCreator_1.CsvCreator;
            exports.Events = events_1.Events;
            exports.EventService = eventService_1.EventService;
            exports.ExpressionService = expressionService_1.ExpressionService;
            exports.FocusedCellController = focusedCellController_1.FocusedCellController;
            exports.defaultGroupComparator = functions_1.defaultGroupComparator;
            exports.Grid = grid_1.Grid;
            exports.GridApi = gridApi_1.GridApi;
            exports.GridCore = gridCore_1.GridCore;
            exports.GridOptionsWrapper = gridOptionsWrapper_1.GridOptionsWrapper;
            exports.Logger = logger_1.Logger;
            exports.MasterSlaveService = masterSlaveService_1.MasterSlaveService;
            exports.SelectionController = selectionController_1.SelectionController;
            exports.CheckboxSelectionComponent = checkboxSelectionComponent_1.CheckboxSelectionComponent;
            exports.SortController = sortController_1.SortController;
            exports.SvgFactory = svgFactory_1.SvgFactory;
            exports.TemplateService = templateService_1.TemplateService;
            exports.Utils = utils_1.Utils;
            exports.NumberSequence = utils_1.NumberSequence;
            exports.ValueService = valueService_1.ValueService;
        }
        exports.populateClientExports = populateClientExports;

        /***/ },
    /* 240 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var paginationController_1 = __webpack_require__(279);
        var floatingRowModel_1 = __webpack_require__(264);
        var selectionController_1 = __webpack_require__(266);
        var columnController_1 = __webpack_require__(251);
        var rowRenderer_1 = __webpack_require__(261);
        var headerRenderer_1 = __webpack_require__(304);
        var filterManager_1 = __webpack_require__(281);
        var valueService_1 = __webpack_require__(267);
        var masterSlaveService_1 = __webpack_require__(263);
        var eventService_1 = __webpack_require__(242);
        var oldToolPanelDragAndDropService_1 = __webpack_require__(319);
        var gridPanel_1 = __webpack_require__(262);
        var gridApi_1 = __webpack_require__(249);
        var headerTemplateLoader_1 = __webpack_require__(312);
        var balancedColumnTreeBuilder_1 = __webpack_require__(257);
        var displayedGroupCreator_1 = __webpack_require__(259);
        var expressionService_1 = __webpack_require__(256);
        var templateService_1 = __webpack_require__(274);
        var popupService_1 = __webpack_require__(282);
        var logger_1 = __webpack_require__(243);
        var columnUtils_1 = __webpack_require__(254);
        var autoWidthCalculator_1 = __webpack_require__(260);
        var horizontalDragService_1 = __webpack_require__(309);
        var context_1 = __webpack_require__(244);
        var csvCreator_1 = __webpack_require__(250);
        var gridCore_1 = __webpack_require__(278);
        var standardMenu_1 = __webpack_require__(320);
        var dragAndDropService_1 = __webpack_require__(306);
        var dragService_1 = __webpack_require__(269);
        var sortController_1 = __webpack_require__(280);
        var focusedCellController_1 = __webpack_require__(273);
        var mouseEventService_1 = __webpack_require__(270);
        var cellNavigationService_1 = __webpack_require__(303);
        var utils_1 = __webpack_require__(245);
        var filterStage_1 = __webpack_require__(321);
        var sortStage_1 = __webpack_require__(322);
        var flattenStage_1 = __webpack_require__(323);
        var focusService_1 = __webpack_require__(277);
        var cellEditorFactory_1 = __webpack_require__(286);
        var events_1 = __webpack_require__(248);
        var virtualPageRowModel_1 = __webpack_require__(324);
        var inMemoryRowModel_1 = __webpack_require__(327);
        var cellRendererFactory_1 = __webpack_require__(293);
        var cellRendererService_1 = __webpack_require__(298);
        var valueFormatterService_1 = __webpack_require__(299);
        var agCheckbox_1 = __webpack_require__(329);
        var baseFrameworkFactory_1 = __webpack_require__(331);
        var Grid = function () {
            function Grid(eGridDiv, gridOptions, params) {
                if (!eGridDiv) {
                    console.error('ag-Grid: no div element provided to the grid');
                }
                if (!gridOptions) {
                    console.error('ag-Grid: no gridOptions provided to the grid');
                }
                var rowModelClass = this.getRowModelClass(gridOptions);
                var enterprise = utils_1.Utils.exists(Grid.enterpriseBeans);
                var frameworkFactory = params ? params.frameworkFactory : null;
                if (utils_1.Utils.missing(frameworkFactory)) {
                    frameworkFactory = new baseFrameworkFactory_1.BaseFrameworkFactory();
                }
                this.context = new context_1.Context({
                    overrideBeans: Grid.enterpriseBeans,
                    seed: {
                        enterprise: enterprise,
                        gridOptions: gridOptions,
                        eGridDiv: eGridDiv,
                        $scope: params ? params.$scope : null,
                        $compile: params ? params.$compile : null,
                        quickFilterOnScope: params ? params.quickFilterOnScope : null,
                        globalEventListener: params ? params.globalEventListener : null,
                        frameworkFactory: frameworkFactory
                    },
                    beans: [rowModelClass, cellRendererFactory_1.CellRendererFactory, horizontalDragService_1.HorizontalDragService, headerTemplateLoader_1.HeaderTemplateLoader, floatingRowModel_1.FloatingRowModel, dragService_1.DragService, displayedGroupCreator_1.DisplayedGroupCreator, eventService_1.EventService, gridOptionsWrapper_1.GridOptionsWrapper, selectionController_1.SelectionController, filterManager_1.FilterManager, columnController_1.ColumnController, rowRenderer_1.RowRenderer, headerRenderer_1.HeaderRenderer, expressionService_1.ExpressionService, balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder, csvCreator_1.CsvCreator, templateService_1.TemplateService, gridPanel_1.GridPanel, popupService_1.PopupService, valueService_1.ValueService, masterSlaveService_1.MasterSlaveService, logger_1.LoggerFactory, oldToolPanelDragAndDropService_1.OldToolPanelDragAndDropService, columnUtils_1.ColumnUtils, autoWidthCalculator_1.AutoWidthCalculator, gridApi_1.GridApi, paginationController_1.PaginationController, popupService_1.PopupService, gridCore_1.GridCore, standardMenu_1.StandardMenuFactory, dragAndDropService_1.DragAndDropService, sortController_1.SortController, columnController_1.ColumnApi, focusedCellController_1.FocusedCellController, mouseEventService_1.MouseEventService, cellNavigationService_1.CellNavigationService, filterStage_1.FilterStage, sortStage_1.SortStage, flattenStage_1.FlattenStage, focusService_1.FocusService, cellEditorFactory_1.CellEditorFactory, cellRendererService_1.CellRendererService, valueFormatterService_1.ValueFormatterService],
                    components: [{ componentName: 'AgCheckbox', theClass: agCheckbox_1.AgCheckbox }],
                    debug: !!gridOptions.debug
                });
                var eventService = this.context.getBean('eventService');
                var readyEvent = {
                    api: gridOptions.api,
                    columnApi: gridOptions.columnApi
                };
                eventService.dispatchEvent(events_1.Events.EVENT_GRID_READY, readyEvent);
                if (gridOptions.debug) {
                    console.log('ag-Grid -> initialised successfully, enterprise = ' + enterprise);
                }
            }
            Grid.setEnterpriseBeans = function (enterpriseBeans, rowModelClasses) {
                this.enterpriseBeans = enterpriseBeans;
                // the enterprise can inject additional row models. this is how it injects the viewportRowModel
                utils_1.Utils.iterateObject(rowModelClasses, function (key, value) {
                    return Grid.RowModelClasses[key] = value;
                });
            };
            Grid.prototype.getRowModelClass = function (gridOptions) {
                var rowModelType = gridOptions.rowModelType;
                if (utils_1.Utils.exists(rowModelType)) {
                    var rowModelClass = Grid.RowModelClasses[rowModelType];
                    if (utils_1.Utils.exists(rowModelClass)) {
                        return rowModelClass;
                    } else {
                        console.error('ag-Grid: count not find matching row model for rowModelType ' + rowModelType);
                        if (rowModelType === 'viewport') {
                            console.error('ag-Grid: rowModelType viewport is only available in ag-Grid Enterprise');
                        }
                    }
                }
                return inMemoryRowModel_1.InMemoryRowModel;
            };
            ;
            Grid.prototype.destroy = function () {
                this.context.destroy();
            };
            // the default is InMemoryRowModel, which is also used for pagination.
            // the enterprise adds viewport to this list.
            Grid.RowModelClasses = {
                virtual: virtualPageRowModel_1.VirtualPageRowModel,
                pagination: inMemoryRowModel_1.InMemoryRowModel
            };
            return Grid;
        }();
        exports.Grid = Grid;

        /***/ },
    /* 241 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var eventService_1 = __webpack_require__(242);
        var constants_1 = __webpack_require__(246);
        var componentUtil_1 = __webpack_require__(247);
        var gridApi_1 = __webpack_require__(249);
        var context_1 = __webpack_require__(244);
        var columnController_1 = __webpack_require__(251);
        var utils_1 = __webpack_require__(245);
        var DEFAULT_ROW_HEIGHT = 25;
        var DEFAULT_VIEWPORT_ROW_MODEL_PAGE_SIZE = 5;
        var DEFAULT_VIEWPORT_ROW_MODEL_BUFFER_SIZE = 5;
        function isTrue(value) {
            return value === true || value === 'true';
        }
        function positiveNumberOrZero(value, defaultValue) {
            if (value > 0) {
                return value;
            } else {
                // zero gets returned if number is missing or the wrong type
                return defaultValue;
            }
        }
        var GridOptionsWrapper = function () {
            function GridOptionsWrapper() {
                this.propertyEventService = new eventService_1.EventService();
            }
            GridOptionsWrapper.prototype.agWire = function (gridApi, columnApi) {
                this.gridOptions.api = gridApi;
                this.gridOptions.columnApi = columnApi;
                this.checkForDeprecated();
            };
            GridOptionsWrapper.prototype.destroy = function () {
                // need to remove these, as we don't own the lifecycle of the gridOptions, we need to
                // remove the references in case the user keeps the grid options, we want the rest
                // of the grid to be picked up by the garbage collector
                this.gridOptions.api = null;
                this.gridOptions.columnApi = null;
            };
            GridOptionsWrapper.prototype.init = function () {
                this.eventService.addGlobalListener(this.globalEventHandler.bind(this));
                this.setupCellRenderers();
                if (this.isGroupSelectsChildren() && this.isSuppressParentsInRowNodes()) {
                    console.warn('ag-Grid: groupSelectsChildren does not work wth suppressParentsInRowNodes, this selection method needs the part in rowNode to work');
                }
                if (this.isGroupSelectsChildren() && !this.isRowSelectionMulti()) {
                    console.warn('ag-Grid: rowSelectionMulti must be true for groupSelectsChildren to make sense');
                }
            };
            GridOptionsWrapper.prototype.setupCellRenderers = function () {
                this.fullWidthCellRenderer = this.frameworkFactory.gridOptionsFullWidthCellRenderer(this.gridOptions);
                this.groupRowRenderer = this.frameworkFactory.gridOptionsGroupRowRenderer(this.gridOptions);
                this.groupRowInnerRenderer = this.frameworkFactory.gridOptionsGroupRowInnerRenderer(this.gridOptions);
            };
            // the cellRenderers come from the instances for this class, not from gridOptions, which allows
            // the baseFrameworkFactory to replace with framework specific ones
            GridOptionsWrapper.prototype.getFullWidthCellRenderer = function () {
                return this.fullWidthCellRenderer;
            };
            GridOptionsWrapper.prototype.getGroupRowRenderer = function () {
                return this.groupRowRenderer;
            };
            GridOptionsWrapper.prototype.getGroupRowInnerRenderer = function () {
                return this.groupRowInnerRenderer;
            };
            GridOptionsWrapper.prototype.isEnterprise = function () {
                return this.enterprise;
            };
            GridOptionsWrapper.prototype.isRowSelection = function () {
                return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
            };
            GridOptionsWrapper.prototype.isRowDeselection = function () {
                return isTrue(this.gridOptions.rowDeselection);
            };
            GridOptionsWrapper.prototype.isRowSelectionMulti = function () {
                return this.gridOptions.rowSelection === 'multiple';
            };
            GridOptionsWrapper.prototype.getContext = function () {
                return this.gridOptions.context;
            };
            GridOptionsWrapper.prototype.isPivotMode = function () {
                return isTrue(this.gridOptions.pivotMode);
            };
            GridOptionsWrapper.prototype.isRowModelPagination = function () {
                return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_PAGINATION;
            };
            GridOptionsWrapper.prototype.isRowModelVirtual = function () {
                return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL;
            };
            GridOptionsWrapper.prototype.isRowModelViewport = function () {
                return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_VIEWPORT;
            };
            GridOptionsWrapper.prototype.isRowModelDefault = function () {
                return !(this.isRowModelPagination() || this.isRowModelVirtual() || this.isRowModelViewport());
            };
            GridOptionsWrapper.prototype.isSuppressFocusAfterRefresh = function () {
                return isTrue(this.gridOptions.suppressFocusAfterRefresh);
            };
            GridOptionsWrapper.prototype.isShowToolPanel = function () {
                return isTrue(this.gridOptions.showToolPanel);
            };
            GridOptionsWrapper.prototype.isToolPanelSuppressRowGroups = function () {
                return isTrue(this.gridOptions.toolPanelSuppressRowGroups);
            };
            GridOptionsWrapper.prototype.isToolPanelSuppressValues = function () {
                return isTrue(this.gridOptions.toolPanelSuppressValues);
            };
            GridOptionsWrapper.prototype.isToolPanelSuppressPivots = function () {
                return isTrue(this.gridOptions.toolPanelSuppressPivots);
            };
            GridOptionsWrapper.prototype.isToolPanelSuppressPivotMode = function () {
                return isTrue(this.gridOptions.toolPanelSuppressPivotMode);
            };
            GridOptionsWrapper.prototype.isEnableCellChangeFlash = function () {
                return isTrue(this.gridOptions.enableCellChangeFlash);
            };
            GridOptionsWrapper.prototype.isGroupSelectsChildren = function () {
                return isTrue(this.gridOptions.groupSelectsChildren);
            };
            GridOptionsWrapper.prototype.isGroupIncludeFooter = function () {
                return isTrue(this.gridOptions.groupIncludeFooter);
            };
            GridOptionsWrapper.prototype.isGroupSuppressBlankHeader = function () {
                return isTrue(this.gridOptions.groupSuppressBlankHeader);
            };
            GridOptionsWrapper.prototype.isSuppressRowClickSelection = function () {
                return isTrue(this.gridOptions.suppressRowClickSelection);
            };
            GridOptionsWrapper.prototype.isSuppressCellSelection = function () {
                return isTrue(this.gridOptions.suppressCellSelection);
            };
            GridOptionsWrapper.prototype.isSuppressMultiSort = function () {
                return isTrue(this.gridOptions.suppressMultiSort);
            };
            GridOptionsWrapper.prototype.isGroupSuppressAutoColumn = function () {
                return isTrue(this.gridOptions.groupSuppressAutoColumn);
            };
            GridOptionsWrapper.prototype.isSuppressDragLeaveHidesColumns = function () {
                return isTrue(this.gridOptions.suppressDragLeaveHidesColumns);
            };
            GridOptionsWrapper.prototype.isForPrint = function () {
                return isTrue(this.gridOptions.forPrint);
            };
            GridOptionsWrapper.prototype.isSuppressHorizontalScroll = function () {
                return isTrue(this.gridOptions.suppressHorizontalScroll);
            };
            GridOptionsWrapper.prototype.isSuppressLoadingOverlay = function () {
                return isTrue(this.gridOptions.suppressLoadingOverlay);
            };
            GridOptionsWrapper.prototype.isSuppressNoRowsOverlay = function () {
                return isTrue(this.gridOptions.suppressNoRowsOverlay);
            };
            GridOptionsWrapper.prototype.isSuppressFieldDotNotation = function () {
                return isTrue(this.gridOptions.suppressFieldDotNotation);
            };
            GridOptionsWrapper.prototype.getFloatingTopRowData = function () {
                return this.gridOptions.floatingTopRowData;
            };
            GridOptionsWrapper.prototype.getFloatingBottomRowData = function () {
                return this.gridOptions.floatingBottomRowData;
            };
            GridOptionsWrapper.prototype.isFunctionsPassive = function () {
                return isTrue(this.gridOptions.functionsPassive);
            };
            GridOptionsWrapper.prototype.getQuickFilterText = function () {
                return this.gridOptions.quickFilterText;
            };
            GridOptionsWrapper.prototype.isUnSortIcon = function () {
                return isTrue(this.gridOptions.unSortIcon);
            };
            GridOptionsWrapper.prototype.isSuppressMenuHide = function () {
                return isTrue(this.gridOptions.suppressMenuHide);
            };
            GridOptionsWrapper.prototype.getRowStyle = function () {
                return this.gridOptions.rowStyle;
            };
            GridOptionsWrapper.prototype.getRowClass = function () {
                return this.gridOptions.rowClass;
            };
            GridOptionsWrapper.prototype.getRowStyleFunc = function () {
                return this.gridOptions.getRowStyle;
            };
            GridOptionsWrapper.prototype.getRowClassFunc = function () {
                return this.gridOptions.getRowClass;
            };
            GridOptionsWrapper.prototype.getDoesDataFlowerFunc = function () {
                return this.gridOptions.doesDataFlower;
            };
            GridOptionsWrapper.prototype.getIsFullWidthCellFunc = function () {
                return this.gridOptions.isFullWidthCell;
            };
            GridOptionsWrapper.prototype.getFullWidthCellRendererParams = function () {
                return this.gridOptions.fullWidthCellRendererParams;
            };
            GridOptionsWrapper.prototype.getBusinessKeyForNodeFunc = function () {
                return this.gridOptions.getBusinessKeyForNode;
            };
            GridOptionsWrapper.prototype.getHeaderCellRenderer = function () {
                return this.gridOptions.headerCellRenderer;
            };
            GridOptionsWrapper.prototype.getApi = function () {
                return this.gridOptions.api;
            };
            GridOptionsWrapper.prototype.getColumnApi = function () {
                return this.gridOptions.columnApi;
            };
            GridOptionsWrapper.prototype.isEnableColResize = function () {
                return isTrue(this.gridOptions.enableColResize);
            };
            GridOptionsWrapper.prototype.isSingleClickEdit = function () {
                return isTrue(this.gridOptions.singleClickEdit);
            };
            GridOptionsWrapper.prototype.getGroupDefaultExpanded = function () {
                return this.gridOptions.groupDefaultExpanded;
            };
            GridOptionsWrapper.prototype.getAutoSizePadding = function () {
                return this.gridOptions.autoSizePadding;
            };
            GridOptionsWrapper.prototype.getMaxConcurrentDatasourceRequests = function () {
                return this.gridOptions.maxConcurrentDatasourceRequests;
            };
            GridOptionsWrapper.prototype.getMaxPagesInCache = function () {
                return this.gridOptions.maxPagesInCache;
            };
            GridOptionsWrapper.prototype.getPaginationOverflowSize = function () {
                return this.gridOptions.paginationOverflowSize;
            };
            GridOptionsWrapper.prototype.getPaginationPageSize = function () {
                return this.gridOptions.paginationPageSize;
            };
            GridOptionsWrapper.prototype.getPaginationInitialRowCount = function () {
                return this.gridOptions.paginationInitialRowCount;
            };
            GridOptionsWrapper.prototype.getRowData = function () {
                return this.gridOptions.rowData;
            };
            GridOptionsWrapper.prototype.isGroupUseEntireRow = function () {
                return isTrue(this.gridOptions.groupUseEntireRow);
            };
            GridOptionsWrapper.prototype.getGroupColumnDef = function () {
                return this.gridOptions.groupColumnDef;
            };
            GridOptionsWrapper.prototype.isGroupSuppressRow = function () {
                return isTrue(this.gridOptions.groupSuppressRow);
            };
            GridOptionsWrapper.prototype.getRowGroupPanelShow = function () {
                return this.gridOptions.rowGroupPanelShow;
            };
            GridOptionsWrapper.prototype.getPivotPanelShow = function () {
                return this.gridOptions.pivotPanelShow;
            };
            GridOptionsWrapper.prototype.isAngularCompileRows = function () {
                return isTrue(this.gridOptions.angularCompileRows);
            };
            GridOptionsWrapper.prototype.isAngularCompileFilters = function () {
                return isTrue(this.gridOptions.angularCompileFilters);
            };
            GridOptionsWrapper.prototype.isAngularCompileHeaders = function () {
                return isTrue(this.gridOptions.angularCompileHeaders);
            };
            GridOptionsWrapper.prototype.isDebug = function () {
                return isTrue(this.gridOptions.debug);
            };
            GridOptionsWrapper.prototype.getColumnDefs = function () {
                return this.gridOptions.columnDefs;
            };
            GridOptionsWrapper.prototype.getDatasource = function () {
                return this.gridOptions.datasource;
            };
            GridOptionsWrapper.prototype.getViewportDatasource = function () {
                return this.gridOptions.viewportDatasource;
            };
            GridOptionsWrapper.prototype.isEnableSorting = function () {
                return isTrue(this.gridOptions.enableSorting) || isTrue(this.gridOptions.enableServerSideSorting);
            };
            GridOptionsWrapper.prototype.isEnableCellExpressions = function () {
                return isTrue(this.gridOptions.enableCellExpressions);
            };
            GridOptionsWrapper.prototype.isSuppressMiddleClickScrolls = function () {
                return isTrue(this.gridOptions.suppressMiddleClickScrolls);
            };
            GridOptionsWrapper.prototype.isSuppressPreventDefaultOnMouseWheel = function () {
                return isTrue(this.gridOptions.suppressPreventDefaultOnMouseWheel);
            };
            GridOptionsWrapper.prototype.isEnableServerSideSorting = function () {
                return isTrue(this.gridOptions.enableServerSideSorting);
            };
            GridOptionsWrapper.prototype.isSuppressColumnVirtualisation = function () {
                return isTrue(this.gridOptions.suppressColumnVirtualisation);
            };
            GridOptionsWrapper.prototype.isSuppressContextMenu = function () {
                return isTrue(this.gridOptions.suppressContextMenu);
            };
            GridOptionsWrapper.prototype.isSuppressCopyRowsToClipboard = function () {
                return isTrue(this.gridOptions.suppressCopyRowsToClipboard);
            };
            GridOptionsWrapper.prototype.isEnableFilter = function () {
                return isTrue(this.gridOptions.enableFilter) || isTrue(this.gridOptions.enableServerSideFilter);
            };
            GridOptionsWrapper.prototype.isEnableServerSideFilter = function () {
                return this.gridOptions.enableServerSideFilter;
            };
            GridOptionsWrapper.prototype.isSuppressScrollLag = function () {
                return isTrue(this.gridOptions.suppressScrollLag);
            };
            GridOptionsWrapper.prototype.isSuppressMovableColumns = function () {
                return isTrue(this.gridOptions.suppressMovableColumns);
            };
            GridOptionsWrapper.prototype.isSuppressColumnMoveAnimation = function () {
                return isTrue(this.gridOptions.suppressColumnMoveAnimation);
            };
            GridOptionsWrapper.prototype.isSuppressMenuColumnPanel = function () {
                return isTrue(this.gridOptions.suppressMenuColumnPanel);
            };
            GridOptionsWrapper.prototype.isSuppressMenuFilterPanel = function () {
                return isTrue(this.gridOptions.suppressMenuFilterPanel);
            };
            GridOptionsWrapper.prototype.isSuppressUseColIdForGroups = function () {
                return isTrue(this.gridOptions.suppressUseColIdForGroups);
            };
            GridOptionsWrapper.prototype.isSuppressAggFuncInHeader = function () {
                return isTrue(this.gridOptions.suppressAggFuncInHeader);
            };
            GridOptionsWrapper.prototype.isSuppressMenuMainPanel = function () {
                return isTrue(this.gridOptions.suppressMenuMainPanel);
            };
            GridOptionsWrapper.prototype.isEnableRangeSelection = function () {
                return isTrue(this.gridOptions.enableRangeSelection);
            };
            GridOptionsWrapper.prototype.isRememberGroupStateWhenNewData = function () {
                return isTrue(this.gridOptions.rememberGroupStateWhenNewData);
            };
            GridOptionsWrapper.prototype.getIcons = function () {
                return this.gridOptions.icons;
            };
            GridOptionsWrapper.prototype.getAggFuncs = function () {
                return this.gridOptions.aggFuncs;
            };
            GridOptionsWrapper.prototype.getIsScrollLag = function () {
                return this.gridOptions.isScrollLag;
            };
            GridOptionsWrapper.prototype.getSortingOrder = function () {
                return this.gridOptions.sortingOrder;
            };
            GridOptionsWrapper.prototype.getSlaveGrids = function () {
                return this.gridOptions.slaveGrids;
            };
            GridOptionsWrapper.prototype.getGroupRowRendererParams = function () {
                return this.gridOptions.groupRowRendererParams;
            };
            GridOptionsWrapper.prototype.getOverlayLoadingTemplate = function () {
                return this.gridOptions.overlayLoadingTemplate;
            };
            GridOptionsWrapper.prototype.getOverlayNoRowsTemplate = function () {
                return this.gridOptions.overlayNoRowsTemplate;
            };
            GridOptionsWrapper.prototype.getCheckboxSelection = function () {
                return this.gridOptions.checkboxSelection;
            };
            GridOptionsWrapper.prototype.isSuppressAutoSize = function () {
                return isTrue(this.gridOptions.suppressAutoSize);
            };
            GridOptionsWrapper.prototype.isSuppressParentsInRowNodes = function () {
                return isTrue(this.gridOptions.suppressParentsInRowNodes);
            };
            GridOptionsWrapper.prototype.isEnableStatusBar = function () {
                return isTrue(this.gridOptions.enableStatusBar);
            };
            GridOptionsWrapper.prototype.isFunctionsReadOnly = function () {
                return isTrue(this.gridOptions.functionsReadOnly);
            };
            GridOptionsWrapper.prototype.getHeaderCellTemplate = function () {
                return this.gridOptions.headerCellTemplate;
            };
            GridOptionsWrapper.prototype.getHeaderCellTemplateFunc = function () {
                return this.gridOptions.getHeaderCellTemplate;
            };
            GridOptionsWrapper.prototype.getNodeChildDetailsFunc = function () {
                return this.gridOptions.getNodeChildDetails;
            };
            GridOptionsWrapper.prototype.getGroupRowAggNodesFunc = function () {
                return this.gridOptions.groupRowAggNodes;
            };
            GridOptionsWrapper.prototype.getContextMenuItemsFunc = function () {
                return this.gridOptions.getContextMenuItems;
            };
            GridOptionsWrapper.prototype.getMainMenuItemsFunc = function () {
                return this.gridOptions.getMainMenuItems;
            };
            GridOptionsWrapper.prototype.getRowNodeIdFunc = function () {
                return this.gridOptions.getRowNodeId;
            };
            GridOptionsWrapper.prototype.getProcessCellForClipboardFunc = function () {
                return this.gridOptions.processCellForClipboard;
            };
            GridOptionsWrapper.prototype.getViewportRowModelPageSize = function () {
                return positiveNumberOrZero(this.gridOptions.viewportRowModelPageSize, DEFAULT_VIEWPORT_ROW_MODEL_PAGE_SIZE);
            };
            GridOptionsWrapper.prototype.getViewportRowModelBufferSize = function () {
                return positiveNumberOrZero(this.gridOptions.viewportRowModelBufferSize, DEFAULT_VIEWPORT_ROW_MODEL_BUFFER_SIZE);
            };
            // public getCellRenderers(): {[key: string]: {new(): ICellRenderer} | ICellRendererFunc} { return this.gridOptions.cellRenderers; }
            // public getCellEditors(): {[key: string]: {new(): ICellEditor}} { return this.gridOptions.cellEditors; }
            GridOptionsWrapper.prototype.setProperty = function (key, value) {
                var gridOptionsNoType = this.gridOptions;
                var previousValue = gridOptionsNoType[key];
                gridOptionsNoType[key] = value;
                this.propertyEventService.dispatchEvent(key, { currentValue: value, previousValue: previousValue });
            };
            GridOptionsWrapper.prototype.addEventListener = function (key, listener) {
                this.propertyEventService.addEventListener(key, listener);
            };
            GridOptionsWrapper.prototype.removeEventListener = function (key, listener) {
                this.propertyEventService.removeEventListener(key, listener);
            };
            GridOptionsWrapper.prototype.executeProcessRowPostCreateFunc = function (params) {
                if (this.gridOptions.processRowPostCreate) {
                    this.gridOptions.processRowPostCreate(params);
                }
            };
            // properties
            GridOptionsWrapper.prototype.getHeaderHeight = function () {
                if (typeof this.gridOptions.headerHeight === 'number') {
                    return this.gridOptions.headerHeight;
                } else {
                    return 25;
                }
            };
            GridOptionsWrapper.prototype.isExternalFilterPresent = function () {
                if (typeof this.gridOptions.isExternalFilterPresent === 'function') {
                    return this.gridOptions.isExternalFilterPresent();
                } else {
                    return false;
                }
            };
            GridOptionsWrapper.prototype.doesExternalFilterPass = function (node) {
                if (typeof this.gridOptions.doesExternalFilterPass === 'function') {
                    return this.gridOptions.doesExternalFilterPass(node);
                } else {
                    return false;
                }
            };
            GridOptionsWrapper.prototype.getLayoutInterval = function () {
                if (typeof this.gridOptions.layoutInterval === 'number') {
                    return this.gridOptions.layoutInterval;
                } else {
                    return constants_1.Constants.LAYOUT_INTERVAL;
                }
            };
            GridOptionsWrapper.prototype.getMinColWidth = function () {
                if (this.gridOptions.minColWidth > GridOptionsWrapper.MIN_COL_WIDTH) {
                    return this.gridOptions.minColWidth;
                } else {
                    return GridOptionsWrapper.MIN_COL_WIDTH;
                }
            };
            GridOptionsWrapper.prototype.getMaxColWidth = function () {
                if (this.gridOptions.maxColWidth > GridOptionsWrapper.MIN_COL_WIDTH) {
                    return this.gridOptions.maxColWidth;
                } else {
                    return null;
                }
            };
            GridOptionsWrapper.prototype.getColWidth = function () {
                if (typeof this.gridOptions.colWidth !== 'number' || this.gridOptions.colWidth < GridOptionsWrapper.MIN_COL_WIDTH) {
                    return 200;
                } else {
                    return this.gridOptions.colWidth;
                }
            };
            GridOptionsWrapper.prototype.getRowBuffer = function () {
                if (typeof this.gridOptions.rowBuffer === 'number') {
                    if (this.gridOptions.rowBuffer < 0) {
                        console.warn('ag-Grid: rowBuffer should not be negative');
                    }
                    return this.gridOptions.rowBuffer;
                } else {
                    return constants_1.Constants.ROW_BUFFER_SIZE;
                }
            };
            GridOptionsWrapper.prototype.checkForDeprecated = function () {
                // casting to generic object, so typescript compiles even though
                // we are looking for attributes that don't exist
                var options = this.gridOptions;
                if (options.suppressUnSort) {
                    console.warn('ag-grid: as of v1.12.4 suppressUnSort is not used. Please use sortOrder instead.');
                }
                if (options.suppressDescSort) {
                    console.warn('ag-grid: as of v1.12.4 suppressDescSort is not used. Please use sortOrder instead.');
                }
                if (options.groupAggFields) {
                    console.warn('ag-grid: as of v3 groupAggFields is not used. Please add appropriate agg fields to your columns.');
                }
                if (options.groupHidePivotColumns) {
                    console.warn('ag-grid: as of v3 groupHidePivotColumns is not used as pivot columns are now called rowGroup columns. Please refer to the documentation');
                }
                if (options.groupKeys) {
                    console.warn('ag-grid: as of v3 groupKeys is not used. You need to set rowGroupIndex on the columns to group. Please refer to the documentation');
                }
                if (options.ready || options.onReady) {
                    console.warn('ag-grid: as of v3.3 ready event is now called gridReady, so the callback should be onGridReady');
                }
                if (typeof options.groupDefaultExpanded === 'boolean') {
                    console.warn('ag-grid: groupDefaultExpanded can no longer be boolean. for groupDefaultExpanded=true, use groupDefaultExpanded=9999 instead, to expand all the groups');
                }
                if (options.onRowDeselected || options.rowDeselected) {
                    console.warn('ag-grid: since version 3.4 event rowDeselected no longer exists, please check the docs');
                }
                if (options.rowsAlreadyGrouped) {
                    console.warn('ag-grid: since version 3.4 rowsAlreadyGrouped no longer exists, please use getNodeChildDetails() instead');
                }
                if (options.groupAggFunction) {
                    console.warn('ag-grid: since version 4.3.x groupAggFunction is now called groupRowAggNodes');
                }
            };
            GridOptionsWrapper.prototype.getLocaleTextFunc = function () {
                if (this.gridOptions.localeTextFunc) {
                    return this.gridOptions.localeTextFunc;
                }
                var that = this;
                return function (key, defaultValue) {
                    var localeText = that.gridOptions.localeText;
                    if (localeText && localeText[key]) {
                        return localeText[key];
                    } else {
                        return defaultValue;
                    }
                };
            };
            // responsible for calling the onXXX functions on gridOptions
            GridOptionsWrapper.prototype.globalEventHandler = function (eventName, event) {
                var callbackMethodName = componentUtil_1.ComponentUtil.getCallbackForEvent(eventName);
                if (typeof this.gridOptions[callbackMethodName] === 'function') {
                    this.gridOptions[callbackMethodName](event);
                }
            };
            // we don't allow dynamic row height for virtual paging
            GridOptionsWrapper.prototype.getRowHeightAsNumber = function () {
                var rowHeight = this.gridOptions.rowHeight;
                if (utils_1.Utils.missing(rowHeight)) {
                    return DEFAULT_ROW_HEIGHT;
                } else if (typeof this.gridOptions.rowHeight === 'number') {
                    return this.gridOptions.rowHeight;
                } else {
                    console.warn('ag-Grid row height must be a number if not using standard row model');
                    return DEFAULT_ROW_HEIGHT;
                }
            };
            GridOptionsWrapper.prototype.getRowHeightForNode = function (rowNode) {
                if (typeof this.gridOptions.rowHeight === 'number') {
                    return this.gridOptions.rowHeight;
                } else if (typeof this.gridOptions.getRowHeight === 'function') {
                    var params = {
                        node: rowNode,
                        data: rowNode.data,
                        api: this.gridOptions.api,
                        context: this.gridOptions.context
                    };
                    return this.gridOptions.getRowHeight(params);
                } else {
                    return DEFAULT_ROW_HEIGHT;
                }
            };
            GridOptionsWrapper.MIN_COL_WIDTH = 10;
            GridOptionsWrapper.PROP_HEADER_HEIGHT = 'headerHeight';
            __decorate([context_1.Autowired('gridOptions'), __metadata('design:type', Object)], GridOptionsWrapper.prototype, "gridOptions", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], GridOptionsWrapper.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], GridOptionsWrapper.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('enterprise'), __metadata('design:type', Boolean)], GridOptionsWrapper.prototype, "enterprise", void 0);
            __decorate([context_1.Autowired('frameworkFactory'), __metadata('design:type', Object)], GridOptionsWrapper.prototype, "frameworkFactory", void 0);
            __decorate([__param(0, context_1.Qualifier('gridApi')), __param(1, context_1.Qualifier('columnApi')), __metadata('design:type', Function), __metadata('design:paramtypes', [gridApi_1.GridApi, columnController_1.ColumnApi]), __metadata('design:returntype', void 0)], GridOptionsWrapper.prototype, "agWire", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], GridOptionsWrapper.prototype, "destroy", null);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], GridOptionsWrapper.prototype, "init", null);
            GridOptionsWrapper = __decorate([context_1.Bean('gridOptionsWrapper'), __metadata('design:paramtypes', [])], GridOptionsWrapper);
            return GridOptionsWrapper;
        }();
        exports.GridOptionsWrapper = GridOptionsWrapper;

        /***/ },
    /* 242 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var logger_1 = __webpack_require__(243);
        var utils_1 = __webpack_require__(245);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var EventService = function () {
            function EventService() {
                this.allListeners = {};
                this.globalListeners = [];
            }
            EventService.prototype.agWire = function (loggerFactory, globalEventListener) {
                if (globalEventListener === void 0) {
                    globalEventListener = null;
                }
                this.logger = loggerFactory.create('EventService');
                if (globalEventListener) {
                    this.addGlobalListener(globalEventListener);
                }
            };
            EventService.prototype.getListenerList = function (eventType) {
                var listenerList = this.allListeners[eventType];
                if (!listenerList) {
                    listenerList = [];
                    this.allListeners[eventType] = listenerList;
                }
                return listenerList;
            };
            EventService.prototype.addEventListener = function (eventType, listener) {
                var listenerList = this.getListenerList(eventType);
                if (listenerList.indexOf(listener) < 0) {
                    listenerList.push(listener);
                }
            };
            // for some events, it's important that the model gets to hear about them before the view,
            // as the model may need to update before the view works on the info. if you register
            // via this method, you get notified before the view parts
            EventService.prototype.addModalPriorityEventListener = function (eventType, listener) {
                this.addEventListener(eventType + EventService.PRIORITY, listener);
            };
            EventService.prototype.addGlobalListener = function (listener) {
                this.globalListeners.push(listener);
            };
            EventService.prototype.removeEventListener = function (eventType, listener) {
                var listenerList = this.getListenerList(eventType);
                utils_1.Utils.removeFromArray(listenerList, listener);
            };
            EventService.prototype.removeGlobalListener = function (listener) {
                utils_1.Utils.removeFromArray(this.globalListeners, listener);
            };
            // why do we pass the type here? the type is in ColumnChangeEvent, so unless the
            // type is not in other types of events???
            EventService.prototype.dispatchEvent = function (eventType, event) {
                if (!event) {
                    event = {};
                }
                // console.log(`dispatching ${eventType}: ${event}`);
                // this allows the columnController to get events before anyone else
                var p1ListenerList = this.getListenerList(eventType + EventService.PRIORITY);
                p1ListenerList.forEach(function (listener) {
                    listener(event);
                });
                var listenerList = this.getListenerList(eventType);
                listenerList.forEach(function (listener) {
                    listener(event);
                });
                this.globalListeners.forEach(function (listener) {
                    listener(eventType, event);
                });
            };
            EventService.PRIORITY = '-P1';
            __decorate([__param(0, context_2.Qualifier('loggerFactory')), __param(1, context_2.Qualifier('globalEventListener')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory, Function]), __metadata('design:returntype', void 0)], EventService.prototype, "agWire", null);
            EventService = __decorate([context_1.Bean('eventService'), __metadata('design:paramtypes', [])], EventService);
            return EventService;
        }();
        exports.EventService = EventService;

        /***/ },
    /* 243 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var LoggerFactory = function () {
            function LoggerFactory() {}
            LoggerFactory.prototype.setBeans = function (gridOptionsWrapper) {
                this.logging = gridOptionsWrapper.isDebug();
            };
            LoggerFactory.prototype.create = function (name) {
                return new Logger(name, this.logging);
            };
            __decorate([__param(0, context_2.Qualifier('gridOptionsWrapper')), __metadata('design:type', Function), __metadata('design:paramtypes', [gridOptionsWrapper_1.GridOptionsWrapper]), __metadata('design:returntype', void 0)], LoggerFactory.prototype, "setBeans", null);
            LoggerFactory = __decorate([context_1.Bean('loggerFactory'), __metadata('design:paramtypes', [])], LoggerFactory);
            return LoggerFactory;
        }();
        exports.LoggerFactory = LoggerFactory;
        var Logger = function () {
            function Logger(name, logging) {
                this.name = name;
                this.logging = logging;
            }
            Logger.prototype.log = function (message) {
                if (this.logging) {
                    console.log('ag-Grid.' + this.name + ': ' + message);
                }
            };
            return Logger;
        }();
        exports.Logger = Logger;

        /***/ },
    /* 244 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var utils_1 = __webpack_require__(245);
        var logger_1 = __webpack_require__(243);
        var Context = function () {
            function Context(params) {
                this.beans = {};
                this.componentsMappedByName = {};
                this.destroyed = false;
                if (!params || !params.beans) {
                    return;
                }
                this.contextParams = params;
                this.logger = new logger_1.Logger('Context', this.contextParams.debug);
                this.logger.log('>> creating ag-Application Context');
                this.setupComponents();
                this.createBeans();
                var beans = utils_1.Utils.mapObject(this.beans, function (beanEntry) {
                    return beanEntry.beanInstance;
                });
                this.wireBeans(beans);
                this.logger.log('>> ag-Application Context ready - component is alive');
            }
            Context.prototype.setupComponents = function () {
                var _this = this;
                if (this.contextParams.components) {
                    this.contextParams.components.forEach(function (componentMeta) {
                        return _this.addComponent(componentMeta);
                    });
                }
            };
            Context.prototype.addComponent = function (componentMeta) {
                // get name of the class as a string
                // var className = _.getNameOfClass(ComponentClass);
                // insert a dash after every capital letter
                // var classEscaped = className.replace(/([A-Z])/g, "-$1").toLowerCase();
                var classEscaped = componentMeta.componentName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
                // put all to upper case
                var classUpperCase = classEscaped.toUpperCase();
                // finally store
                this.componentsMappedByName[classUpperCase] = componentMeta.theClass;
            };
            Context.prototype.createComponent = function (element) {
                var key = element.nodeName;
                if (this.componentsMappedByName && this.componentsMappedByName[key]) {
                    var newComponent = new this.componentsMappedByName[key]();
                    this.copyAttributesFromNode(element, newComponent.getGui());
                    this.wireBean(newComponent);
                    return newComponent;
                } else {
                    return null;
                }
            };
            Context.prototype.copyAttributesFromNode = function (fromNode, toNode) {
                if (fromNode.attributes) {
                    var count = fromNode.attributes.length;
                    for (var i = 0; i < count; i++) {
                        var attr = fromNode.attributes[i];
                        toNode.setAttribute(attr.name, attr.value);
                    }
                }
            };
            Context.prototype.wireBean = function (bean) {
                this.wireBeans([bean]);
            };
            Context.prototype.wireBeans = function (beans) {
                this.autoWireBeans(beans);
                this.methodWireBeans(beans);
                this.postConstruct(beans);
            };
            Context.prototype.createBeans = function () {
                var _this = this;
                // register all normal beans
                this.contextParams.beans.forEach(this.createBeanEntry.bind(this));
                // register override beans, these will overwrite beans above of same name
                if (this.contextParams.overrideBeans) {
                    this.contextParams.overrideBeans.forEach(this.createBeanEntry.bind(this));
                }
                // instantiate all beans - overridden beans will be left out
                utils_1.Utils.iterateObject(this.beans, function (key, beanEntry) {
                    var constructorParamsMeta;
                    if (beanEntry.bean.prototype.__agBeanMetaData && beanEntry.bean.prototype.__agBeanMetaData.autowireMethods && beanEntry.bean.prototype.__agBeanMetaData.autowireMethods.agConstructor) {
                        constructorParamsMeta = beanEntry.bean.prototype.__agBeanMetaData.autowireMethods.agConstructor;
                    }
                    var constructorParams = _this.getBeansForParameters(constructorParamsMeta, beanEntry.beanName);
                    var newInstance = applyToConstructor(beanEntry.bean, constructorParams);
                    beanEntry.beanInstance = newInstance;
                    _this.logger.log('bean ' + _this.getBeanName(newInstance) + ' created');
                });
            };
            Context.prototype.createBeanEntry = function (Bean) {
                var metaData = Bean.prototype.__agBeanMetaData;
                if (!metaData) {
                    var beanName;
                    if (Bean.prototype.constructor) {
                        beanName = Bean.prototype.constructor.name;
                    } else {
                        beanName = '' + Bean;
                    }
                    console.error('context item ' + beanName + ' is not a bean');
                    return;
                }
                var beanEntry = {
                    bean: Bean,
                    beanInstance: null,
                    beanName: metaData.beanName
                };
                this.beans[metaData.beanName] = beanEntry;
            };
            Context.prototype.autoWireBeans = function (beans) {
                var _this = this;
                beans.forEach(function (bean) {
                    return _this.autoWireBean(bean);
                });
            };
            Context.prototype.methodWireBeans = function (beans) {
                var _this = this;
                beans.forEach(function (bean) {
                    return _this.methodWireBean(bean);
                });
            };
            Context.prototype.autoWireBean = function (bean) {
                var _this = this;
                if (!bean || !bean.__agBeanMetaData || !bean.__agBeanMetaData.agClassAttributes) {
                    return;
                }
                var attributes = bean.__agBeanMetaData.agClassAttributes;
                if (!attributes) {
                    return;
                }
                var beanName = this.getBeanName(bean);
                attributes.forEach(function (attribute) {
                    var otherBean = _this.lookupBeanInstance(beanName, attribute.beanName, attribute.optional);
                    bean[attribute.attributeName] = otherBean;
                });
            };
            Context.prototype.getBeanName = function (bean) {
                var constructorString = bean.constructor.toString();
                var beanName = constructorString.substring(9, constructorString.indexOf('('));
                return beanName;
            };
            Context.prototype.methodWireBean = function (bean) {
                var _this = this;
                var autowiredMethods;
                if (bean.__agBeanMetaData) {
                    autowiredMethods = bean.__agBeanMetaData.autowireMethods;
                }
                utils_1.Utils.iterateObject(autowiredMethods, function (methodName, wireParams) {
                    // skip constructor, as this is dealt with elsewhere
                    if (methodName === 'agConstructor') {
                        return;
                    }
                    var beanName = _this.getBeanName(bean);
                    var initParams = _this.getBeansForParameters(wireParams, beanName);
                    bean[methodName].apply(bean, initParams);
                });
            };
            Context.prototype.getBeansForParameters = function (parameters, beanName) {
                var _this = this;
                var beansList = [];
                if (parameters) {
                    utils_1.Utils.iterateObject(parameters, function (paramIndex, otherBeanName) {
                        var otherBean = _this.lookupBeanInstance(beanName, otherBeanName);
                        beansList[Number(paramIndex)] = otherBean;
                    });
                }
                return beansList;
            };
            Context.prototype.lookupBeanInstance = function (wiringBean, beanName, optional) {
                if (optional === void 0) {
                    optional = false;
                }
                if (beanName === 'context') {
                    return this;
                } else if (this.contextParams.seed && this.contextParams.seed.hasOwnProperty(beanName)) {
                    return this.contextParams.seed[beanName];
                } else {
                    var beanEntry = this.beans[beanName];
                    if (beanEntry) {
                        return beanEntry.beanInstance;
                    }
                    if (!optional) {
                        console.error('ag-Grid: unable to find bean reference ' + beanName + ' while initialising ' + wiringBean);
                    }
                    return null;
                }
            };
            Context.prototype.postConstruct = function (beans) {
                beans.forEach(function (bean) {
                    // try calling init methods
                    if (bean.__agBeanMetaData && bean.__agBeanMetaData.postConstructMethods) {
                        bean.__agBeanMetaData.postConstructMethods.forEach(function (methodName) {
                            return bean[methodName]();
                        });
                    }
                });
            };
            Context.prototype.getBean = function (name) {
                return this.lookupBeanInstance('getBean', name, true);
            };
            Context.prototype.destroy = function () {
                // should only be able to destroy once
                if (this.destroyed) {
                    return;
                }
                this.logger.log('>> Shutting down ag-Application Context');
                // try calling destroy methods
                utils_1.Utils.iterateObject(this.beans, function (key, beanEntry) {
                    var bean = beanEntry.beanInstance;
                    if (bean.__agBeanMetaData && bean.__agBeanMetaData.preDestroyMethods) {
                        bean.__agBeanMetaData.preDestroyMethods.forEach(function (methodName) {
                            return bean[methodName]();
                        });
                    }
                });
                this.destroyed = true;
                this.logger.log('>> ag-Application Context shut down - component is dead');
            };
            return Context;
        }();
        exports.Context = Context;
        // taken from: http://stackoverflow.com/questions/3362471/how-can-i-call-a-javascript-constructor-using-call-or-apply
        // allows calling 'apply' on a constructor
        function applyToConstructor(constructor, argArray) {
            var args = [null].concat(argArray);
            var factoryFunction = constructor.bind.apply(constructor, args);
            return new factoryFunction();
        }
        function PostConstruct(target, methodName, descriptor) {
            var props = getOrCreateProps(target);
            if (!props.postConstructMethods) {
                props.postConstructMethods = [];
            }
            props.postConstructMethods.push(methodName);
        }
        exports.PostConstruct = PostConstruct;
        function PreDestroy(target, methodName, descriptor) {
            var props = getOrCreateProps(target);
            if (!props.preDestroyMethods) {
                props.preDestroyMethods = [];
            }
            props.preDestroyMethods.push(methodName);
        }
        exports.PreDestroy = PreDestroy;
        function Bean(beanName) {
            return function (classConstructor) {
                var props = getOrCreateProps(classConstructor.prototype);
                props.beanName = beanName;
            };
        }
        exports.Bean = Bean;
        function Autowired(name) {
            return autowiredFunc.bind(this, name, false);
        }
        exports.Autowired = Autowired;
        function Optional(name) {
            return autowiredFunc.bind(this, name, true);
        }
        exports.Optional = Optional;
        function autowiredFunc(name, optional, classPrototype, methodOrAttributeName, index) {
            if (name === null) {
                console.error('ag-Grid: Autowired name should not be null');
                return;
            }
            if (typeof index === 'number') {
                console.error('ag-Grid: Autowired should be on an attribute');
                return;
            }
            // it's an attribute on the class
            var props = getOrCreateProps(classPrototype);
            if (!props.agClassAttributes) {
                props.agClassAttributes = [];
            }
            props.agClassAttributes.push({
                attributeName: methodOrAttributeName,
                beanName: name,
                optional: optional
            });
        }
        function Qualifier(name) {
            return function (classPrototype, methodOrAttributeName, index) {
                var props;
                if (typeof index === 'number') {
                    // it's a parameter on a method
                    var methodName;
                    if (methodOrAttributeName) {
                        props = getOrCreateProps(classPrototype);
                        methodName = methodOrAttributeName;
                    } else {
                        props = getOrCreateProps(classPrototype.prototype);
                        methodName = 'agConstructor';
                    }
                    if (!props.autowireMethods) {
                        props.autowireMethods = {};
                    }
                    if (!props.autowireMethods[methodName]) {
                        props.autowireMethods[methodName] = {};
                    }
                    props.autowireMethods[methodName][index] = name;
                }
            };
        }
        exports.Qualifier = Qualifier;
        function getOrCreateProps(target) {
            var props = target.__agBeanMetaData;
            if (!props) {
                props = {};
                target.__agBeanMetaData = props;
            }
            return props;
        }

        /***/ },
    /* 245 */
    /***/ function(module, exports) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var FUNCTION_STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
        var FUNCTION_ARGUMENT_NAMES = /([^\s,]+)/g;
        // util class, only used when debugging, for printing time to console
        var Timer = function () {
            function Timer() {
                this.timestamp = new Date().getTime();
            }
            Timer.prototype.print = function (msg) {
                var duration = new Date().getTime() - this.timestamp;
                console.log(msg + " = " + duration);
                this.timestamp = new Date().getTime();
            };
            return Timer;
        }();
        exports.Timer = Timer;
        var Utils = function () {
            function Utils() {}
            Utils.getNameOfClass = function (TheClass) {
                var funcNameRegex = /function (.{1,})\(/;
                var funcAsString = TheClass.toString();
                var results = funcNameRegex.exec(funcAsString);
                return results && results.length > 1 ? results[1] : "";
            };
            Utils.values = function (object) {
                var result = [];
                this.iterateObject(object, function (key, value) {
                    result.push(value);
                });
                return result;
            };
            Utils.getValueUsingField = function (data, field, fieldContainsDots) {
                if (!field || !data) {
                    return;
                }
                // if no '.', then it's not a deep value
                if (!fieldContainsDots) {
                    return data[field];
                } else {
                    // otherwise it is a deep value, so need to dig for it
                    var fields = field.split('.');
                    var currentObject = data;
                    for (var i = 0; i < fields.length; i++) {
                        currentObject = currentObject[fields[i]];
                        if (this.missing(currentObject)) {
                            return null;
                        }
                    }
                    return currentObject;
                }
            };
            Utils.iterateObject = function (object, callback) {
                if (this.missing(object)) {
                    return;
                }
                var keys = Object.keys(object);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var value = object[key];
                    callback(key, value);
                }
            };
            Utils.cloneObject = function (object) {
                var copy = {};
                var keys = Object.keys(object);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var value = object[key];
                    copy[key] = value;
                }
                return copy;
            };
            Utils.map = function (array, callback) {
                var result = [];
                for (var i = 0; i < array.length; i++) {
                    var item = array[i];
                    var mappedItem = callback(item);
                    result.push(mappedItem);
                }
                return result;
            };
            Utils.mapObject = function (object, callback) {
                var result = [];
                Utils.iterateObject(object, function (key, value) {
                    result.push(callback(value));
                });
                return result;
            };
            Utils.forEach = function (array, callback) {
                if (!array) {
                    return;
                }
                for (var i = 0; i < array.length; i++) {
                    var value = array[i];
                    callback(value, i);
                }
            };
            Utils.filter = function (array, callback) {
                var result = [];
                array.forEach(function (item) {
                    if (callback(item)) {
                        result.push(item);
                    }
                });
                return result;
            };
            Utils.assign = function (object, source) {
                if (this.exists(source)) {
                    this.iterateObject(source, function (key, value) {
                        object[key] = value;
                    });
                }
            };
            Utils.getFunctionParameters = function (func) {
                var fnStr = func.toString().replace(FUNCTION_STRIP_COMMENTS, '');
                var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(FUNCTION_ARGUMENT_NAMES);
                if (result === null) {
                    return [];
                } else {
                    return result;
                }
            };
            Utils.find = function (collection, predicate, value) {
                if (collection === null || collection === undefined) {
                    return null;
                }
                var firstMatchingItem;
                for (var i = 0; i < collection.length; i++) {
                    var item = collection[i];
                    if (typeof predicate === 'string') {
                        if (item[predicate] === value) {
                            firstMatchingItem = item;
                            break;
                        }
                    } else {
                        var callback = predicate;
                        if (callback(item)) {
                            firstMatchingItem = item;
                            break;
                        }
                    }
                }
                return firstMatchingItem;
            };
            Utils.toStrings = function (array) {
                return this.map(array, function (item) {
                    if (item === undefined || item === null || !item.toString) {
                        return null;
                    } else {
                        return item.toString();
                    }
                });
            };
            Utils.iterateArray = function (array, callback) {
                for (var index = 0; index < array.length; index++) {
                    var value = array[index];
                    callback(value, index);
                }
            };
            //Returns true if it is a DOM node
            //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
            Utils.isNode = function (o) {
                return typeof Node === "function" ? o instanceof Node : o && (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string";
            };
            //Returns true if it is a DOM element
            //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
            Utils.isElement = function (o) {
                return typeof HTMLElement === "function" ? o instanceof HTMLElement : o && (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
            };
            Utils.isNodeOrElement = function (o) {
                return this.isNode(o) || this.isElement(o);
            };
            //adds all type of change listeners to an element, intended to be a text field
            Utils.addChangeListener = function (element, listener) {
                element.addEventListener("changed", listener);
                element.addEventListener("paste", listener);
                element.addEventListener("input", listener);
                // IE doesn't fire changed for special keys (eg delete, backspace), so need to
                // listen for this further ones
                element.addEventListener("keydown", listener);
                element.addEventListener("keyup", listener);
            };
            //if value is undefined, null or blank, returns null, otherwise returns the value
            Utils.makeNull = function (value) {
                if (value === null || value === undefined || value === "") {
                    return null;
                } else {
                    return value;
                }
            };
            Utils.missing = function (value) {
                return !this.exists(value);
            };
            Utils.missingOrEmpty = function (value) {
                return this.missing(value) || value.length === 0;
            };
            Utils.exists = function (value) {
                if (value === null || value === undefined || value === '') {
                    return false;
                } else {
                    return true;
                }
            };
            Utils.existsAndNotEmpty = function (value) {
                return this.exists(value) && value.length > 0;
            };
            Utils.removeAllChildren = function (node) {
                if (node) {
                    while (node.hasChildNodes()) {
                        node.removeChild(node.lastChild);
                    }
                }
            };
            Utils.removeElement = function (parent, cssSelector) {
                this.removeFromParent(parent.querySelector(cssSelector));
            };
            Utils.removeFromParent = function (node) {
                if (node && node.parentNode) {
                    node.parentNode.removeChild(node);
                }
            };
            Utils.isVisible = function (element) {
                return element.offsetParent !== null;
            };
            /**
             * loads the template and returns it as an element. makes up for no simple way in
             * the dom api to load html directly, eg we cannot do this: document.createElement(template)
             */
            Utils.loadTemplate = function (template) {
                var tempDiv = document.createElement("div");
                tempDiv.innerHTML = template;
                return tempDiv.firstChild;
            };
            Utils.addOrRemoveCssClass = function (element, className, addOrRemove) {
                if (addOrRemove) {
                    this.addCssClass(element, className);
                } else {
                    this.removeCssClass(element, className);
                }
            };
            Utils.callIfPresent = function (func) {
                if (func) {
                    func();
                }
            };
            Utils.addCssClass = function (element, className) {
                var _this = this;
                if (!className || className.length === 0) {
                    return;
                }
                if (className.indexOf(' ') >= 0) {
                    className.split(' ').forEach(function (value) {
                        return _this.addCssClass(element, value);
                    });
                    return;
                }
                if (element.classList) {
                    element.classList.add(className);
                } else {
                    if (element.className && element.className.length > 0) {
                        var cssClasses = element.className.split(' ');
                        if (cssClasses.indexOf(className) < 0) {
                            cssClasses.push(className);
                            element.className = cssClasses.join(' ');
                        }
                    } else {
                        element.className = className;
                    }
                }
            };
            Utils.containsClass = function (element, className) {
                if (element.classList) {
                    // for modern browsers
                    return element.classList.contains(className);
                } else if (element.className) {
                    // for older browsers, check against the string of class names
                    // if only one class, can check for exact match
                    var onlyClass = element.className === className;
                    // if many classes, check for class name, we have to pad with ' ' to stop other
                    // class names that are a substring of this class
                    var contains = element.className.indexOf(' ' + className + ' ') >= 0;
                    // the padding above then breaks when it's the first or last class names
                    var startsWithClass = element.className.indexOf(className + ' ') === 0;
                    var endsWithClass = element.className.lastIndexOf(' ' + className) === element.className.length - className.length - 1;
                    return onlyClass || contains || startsWithClass || endsWithClass;
                } else {
                    // if item is not a node
                    return false;
                }
            };
            Utils.getElementAttribute = function (element, attributeName) {
                if (element.attributes) {
                    if (element.attributes[attributeName]) {
                        var attribute = element.attributes[attributeName];
                        return attribute.value;
                    } else {
                        return null;
                    }
                } else {
                    return null;
                }
            };
            Utils.offsetHeight = function (element) {
                return element && element.clientHeight ? element.clientHeight : 0;
            };
            Utils.offsetWidth = function (element) {
                return element && element.clientWidth ? element.clientWidth : 0;
            };
            Utils.removeCssClass = function (element, className) {
                if (element.className && element.className.length > 0) {
                    var cssClasses = element.className.split(' ');
                    var index = cssClasses.indexOf(className);
                    if (index >= 0) {
                        cssClasses.splice(index, 1);
                        element.className = cssClasses.join(' ');
                    }
                }
            };
            Utils.removeRepeatsFromArray = function (array, object) {
                if (!array) {
                    return;
                }
                for (var index = array.length - 2; index >= 0; index--) {
                    var thisOneMatches = array[index] === object;
                    var nextOneMatches = array[index + 1] === object;
                    if (thisOneMatches && nextOneMatches) {
                        array.splice(index + 1, 1);
                    }
                }
            };
            Utils.removeFromArray = function (array, object) {
                if (array.indexOf(object) >= 0) {
                    array.splice(array.indexOf(object), 1);
                }
            };
            Utils.insertIntoArray = function (array, object, toIndex) {
                array.splice(toIndex, 0, object);
            };
            Utils.moveInArray = function (array, objectsToMove, toIndex) {
                var _this = this;
                // first take out it items from the array
                objectsToMove.forEach(function (obj) {
                    _this.removeFromArray(array, obj);
                });
                // now add the objects, in same order as provided to us, that means we start at the end
                // as the objects will be pushed to the right as they are inserted
                objectsToMove.slice().reverse().forEach(function (obj) {
                    _this.insertIntoArray(array, obj, toIndex);
                });
            };
            Utils.defaultComparator = function (valueA, valueB) {
                var valueAMissing = valueA === null || valueA === undefined;
                var valueBMissing = valueB === null || valueB === undefined;
                if (valueAMissing && valueBMissing) {
                    return 0;
                }
                if (valueAMissing) {
                    return -1;
                }
                if (valueBMissing) {
                    return 1;
                }
                if (typeof valueA === "string") {
                    try {
                        // using local compare also allows chinese comparisons
                        return valueA.localeCompare(valueB);
                    } catch (e) {}
                }
                if (valueA < valueB) {
                    return -1;
                } else if (valueA > valueB) {
                    return 1;
                } else {
                    return 0;
                }
            };
            Utils.compareArrays = function (array1, array2) {
                if (this.missing(array1) && this.missing(array2)) {
                    return true;
                }
                if (this.missing(array1) || this.missing(array2)) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (var i = 0; i < array1.length; i++) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };
            Utils.toStringOrNull = function (value) {
                if (this.exists(value) && value.toString) {
                    return value.toString();
                } else {
                    return null;
                }
            };
            Utils.formatWidth = function (width) {
                if (typeof width === "number") {
                    return width + "px";
                } else {
                    return width;
                }
            };
            Utils.formatNumberTwoDecimalPlacesAndCommas = function (value) {
                // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript
                if (typeof value === 'number') {
                    return (Math.round(value * 100) / 100).toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
                } else {
                    return '';
                }
            };
            /**
             * If icon provided, use this (either a string, or a function callback).
             * if not, then use the second parameter, which is the svgFactory function
             */
            Utils.createIcon = function (iconName, gridOptionsWrapper, column, svgFactoryFunc) {
                var eResult = document.createElement('span');
                eResult.appendChild(this.createIconNoSpan(iconName, gridOptionsWrapper, column, svgFactoryFunc));
                return eResult;
            };
            Utils.createIconNoSpan = function (iconName, gridOptionsWrapper, colDefWrapper, svgFactoryFunc) {
                var userProvidedIcon;
                // check col for icon first
                if (colDefWrapper && colDefWrapper.getColDef().icons) {
                    userProvidedIcon = colDefWrapper.getColDef().icons[iconName];
                }
                // it not in col, try grid options
                if (!userProvidedIcon && gridOptionsWrapper.getIcons()) {
                    userProvidedIcon = gridOptionsWrapper.getIcons()[iconName];
                }
                // now if user provided, use it
                if (userProvidedIcon) {
                    var rendererResult;
                    if (typeof userProvidedIcon === 'function') {
                        rendererResult = userProvidedIcon();
                    } else if (typeof userProvidedIcon === 'string') {
                        rendererResult = userProvidedIcon;
                    } else {
                        throw 'icon from grid options needs to be a string or a function';
                    }
                    if (typeof rendererResult === 'string') {
                        return this.loadTemplate(rendererResult);
                    } else if (this.isNodeOrElement(rendererResult)) {
                        return rendererResult;
                    } else {
                        throw 'iconRenderer should return back a string or a dom object';
                    }
                } else {
                    // otherwise we use the built in icon
                    if (svgFactoryFunc) {
                        return svgFactoryFunc();
                    } else {
                        return null;
                    }
                }
            };
            Utils.addStylesToElement = function (eElement, styles) {
                if (!styles) {
                    return;
                }
                Object.keys(styles).forEach(function (key) {
                    eElement.style[key] = styles[key];
                });
            };
            Utils.isScrollShowing = function (element) {
                return element.clientHeight < element.scrollHeight;
            };
            Utils.getScrollbarWidth = function () {
                var outer = document.createElement("div");
                outer.style.visibility = "hidden";
                outer.style.width = "100px";
                outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps
                document.body.appendChild(outer);
                var widthNoScroll = outer.offsetWidth;
                // force scrollbars
                outer.style.overflow = "scroll";
                // add innerdiv
                var inner = document.createElement("div");
                inner.style.width = "100%";
                outer.appendChild(inner);
                var widthWithScroll = inner.offsetWidth;
                // remove divs
                outer.parentNode.removeChild(outer);
                return widthNoScroll - widthWithScroll;
            };
            Utils.isKeyPressed = function (event, keyToCheck) {
                var pressedKey = event.which || event.keyCode;
                return pressedKey === keyToCheck;
            };
            Utils.setVisible = function (element, visible, visibleStyle) {
                if (visible) {
                    if (this.exists(visibleStyle)) {
                        element.style.display = visibleStyle;
                    } else {
                        element.style.display = 'inline';
                    }
                } else {
                    element.style.display = 'none';
                }
            };
            Utils.isBrowserIE = function () {
                if (this.isIE === undefined) {
                    this.isIE = false || !!document.documentMode; // At least IE6
                }
                return this.isIE;
            };
            Utils.isBrowserSafari = function () {
                if (this.isSafari === undefined) {
                    this.isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
                }
                return this.isSafari;
            };
            // srcElement is only available in IE. In all other browsers it is target
            // http://stackoverflow.com/questions/5301643/how-can-i-make-event-srcelement-work-in-firefox-and-what-does-it-mean
            Utils.getTarget = function (event) {
                var eventNoType = event;
                return eventNoType.target || eventNoType.srcElement;
            };
            // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code
            Utils.getBodyWidth = function () {
                if (document.body) {
                    return document.body.clientWidth;
                }
                if (window.innerHeight) {
                    return window.innerWidth;
                }
                if (document.documentElement && document.documentElement.clientWidth) {
                    return document.documentElement.clientWidth;
                }
                return -1;
            };
            // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code
            Utils.getBodyHeight = function () {
                if (document.body) {
                    return document.body.clientHeight;
                }
                if (window.innerHeight) {
                    return window.innerHeight;
                }
                if (document.documentElement && document.documentElement.clientHeight) {
                    return document.documentElement.clientHeight;
                }
                return -1;
            };
            Utils.setCheckboxState = function (eCheckbox, state) {
                if (typeof state === 'boolean') {
                    eCheckbox.checked = state;
                    eCheckbox.indeterminate = false;
                } else {
                    // isNodeSelected returns back undefined if it's a group and the children
                    // are a mix of selected and unselected
                    eCheckbox.indeterminate = true;
                }
            };
            Utils.traverseNodesWithKey = function (nodes, callback) {
                var keyParts = [];
                recursiveSearchNodes(nodes);
                function recursiveSearchNodes(nodes) {
                    nodes.forEach(function (node) {
                        if (node.group) {
                            keyParts.push(node.key);
                            var key = keyParts.join('|');
                            callback(node, key);
                            recursiveSearchNodes(node.childrenAfterGroup);
                            keyParts.pop();
                        }
                    });
                }
            };
            // Taken from here: https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
            /**
             * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
             * complicated, thus this doc is long and (hopefully) detailed enough to answer
             * your questions.
             *
             * If you need to react to the mouse wheel in a predictable way, this code is
             * like your bestest friend. * hugs *
             *
             * As of today, there are 4 DOM event types you can listen to:
             *
             *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
             *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
             *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
             *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
             *
             * So what to do?  The is the best:
             *
             *   normalizeWheel.getEventType();
             *
             * In your event callback, use this code to get sane interpretation of the
             * deltas.  This code will return an object with properties:
             *
             *   spinX   -- normalized spin speed (use for zoom) - x plane
             *   spinY   -- " - y plane
             *   pixelX  -- normalized distance (to pixels) - x plane
             *   pixelY  -- " - y plane
             *
             * Wheel values are provided by the browser assuming you are using the wheel to
             * scroll a web page by a number of lines or pixels (or pages).  Values can vary
             * significantly on different platforms and browsers, forgetting that you can
             * scroll at different speeds.  Some devices (like trackpads) emit more events
             * at smaller increments with fine granularity, and some emit massive jumps with
             * linear speed or acceleration.
             *
             * This code does its best to normalize the deltas for you:
             *
             *   - spin is trying to normalize how far the wheel was spun (or trackpad
             *     dragged).  This is super useful for zoom support where you want to
             *     throw away the chunky scroll steps on the PC and make those equal to
             *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
             *     resolve a single slow step on a wheel to 1.
             *
             *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
             *     get the crazy differences between browsers, but at least it'll be in
             *     pixels!
             *
             *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
             *     should translate to positive value zooming IN, negative zooming OUT.
             *     This matches the newer 'wheel' event.
             *
             * Why are there spinX, spinY (or pixels)?
             *
             *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
             *     with a mouse.  It results in side-scrolling in the browser by default.
             *
             *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
             *
             *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
             *     probably is by browsers in conjunction with fancy 3D controllers .. but
             *     you know.
             *
             * Implementation info:
             *
             * Examples of 'wheel' event if you scroll slowly (down) by one step with an
             * average mouse:
             *
             *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
             *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
             *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
             *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
             *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
             *
             * On the trackpad:
             *
             *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
             *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
             *
             * On other/older browsers.. it's more complicated as there can be multiple and
             * also missing delta values.
             *
             * The 'wheel' event is more standard:
             *
             * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
             *
             * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
             * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
             * backward compatibility with older events.  Those other values help us
             * better normalize spin speed.  Example of what the browsers provide:
             *
             *                          | event.wheelDelta | event.detail
             *        ------------------+------------------+--------------
             *          Safari v5/OS X  |       -120       |       0
             *          Safari v5/Win7  |       -120       |       0
             *         Chrome v17/OS X  |       -120       |       0
             *         Chrome v17/Win7  |       -120       |       0
             *                IE9/Win7  |       -120       |   undefined
             *         Firefox v4/OS X  |     undefined    |       1
             *         Firefox v4/Win7  |     undefined    |       3
             *
             */
            Utils.normalizeWheel = function (event) {
                var PIXEL_STEP = 10;
                var LINE_HEIGHT = 40;
                var PAGE_HEIGHT = 800;
                // spinX, spinY
                var sX = 0;
                var sY = 0;
                // pixelX, pixelY
                var pX = 0;
                var pY = 0;
                // Legacy
                if ('detail' in event) {
                    sY = event.detail;
                }
                if ('wheelDelta' in event) {
                    sY = -event.wheelDelta / 120;
                }
                if ('wheelDeltaY' in event) {
                    sY = -event.wheelDeltaY / 120;
                }
                if ('wheelDeltaX' in event) {
                    sX = -event.wheelDeltaX / 120;
                }
                // side scrolling on FF with DOMMouseScroll
                if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
                    sX = sY;
                    sY = 0;
                }
                pX = sX * PIXEL_STEP;
                pY = sY * PIXEL_STEP;
                if ('deltaY' in event) {
                    pY = event.deltaY;
                }
                if ('deltaX' in event) {
                    pX = event.deltaX;
                }
                if ((pX || pY) && event.deltaMode) {
                    if (event.deltaMode == 1) {
                        pX *= LINE_HEIGHT;
                        pY *= LINE_HEIGHT;
                    } else {
                        pX *= PAGE_HEIGHT;
                        pY *= PAGE_HEIGHT;
                    }
                }
                // Fall-back if spin cannot be determined
                if (pX && !sX) {
                    sX = pX < 1 ? -1 : 1;
                }
                if (pY && !sY) {
                    sY = pY < 1 ? -1 : 1;
                }
                return { spinX: sX,
                    spinY: sY,
                    pixelX: pX,
                    pixelY: pY };
            };
            return Utils;
        }();
        exports.Utils = Utils;
        var NumberSequence = function () {
            function NumberSequence() {
                this.nextValue = 0;
            }
            NumberSequence.prototype.next = function () {
                var valToReturn = this.nextValue;
                this.nextValue++;
                return valToReturn;
            };
            return NumberSequence;
        }();
        exports.NumberSequence = NumberSequence;

        /***/ },
    /* 246 */
    /***/ function(module, exports) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var Constants = function () {
            function Constants() {}
            Constants.STEP_EVERYTHING = 0;
            Constants.STEP_FILTER = 1;
            Constants.STEP_SORT = 2;
            Constants.STEP_MAP = 3;
            Constants.STEP_AGGREGATE = 4;
            Constants.STEP_PIVOT = 5;
            Constants.ROW_BUFFER_SIZE = 10;
            Constants.LAYOUT_INTERVAL = 500;
            Constants.KEY_BACKSPACE = 8;
            Constants.KEY_TAB = 9;
            Constants.KEY_ENTER = 13;
            Constants.KEY_SHIFT = 16;
            Constants.KEY_ESCAPE = 27;
            Constants.KEY_SPACE = 32;
            Constants.KEY_LEFT = 37;
            Constants.KEY_UP = 38;
            Constants.KEY_RIGHT = 39;
            Constants.KEY_DOWN = 40;
            Constants.KEY_DELETE = 46;
            Constants.KEY_A = 65;
            Constants.KEY_C = 67;
            Constants.KEY_V = 86;
            Constants.KEY_D = 68;
            Constants.KEY_F2 = 113;
            Constants.ROW_MODEL_TYPE_PAGINATION = 'pagination';
            Constants.ROW_MODEL_TYPE_VIRTUAL = 'virtual';
            Constants.ROW_MODEL_TYPE_VIEWPORT = 'viewport';
            Constants.ROW_MODEL_TYPE_NORMAL = 'normal';
            Constants.ALWAYS = 'always';
            Constants.ONLY_WHEN_GROUPING = 'onlyWhenGrouping';
            Constants.FLOATING_TOP = 'top';
            Constants.FLOATING_BOTTOM = 'bottom';
            return Constants;
        }();
        exports.Constants = Constants;

        /***/ },
    /* 247 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var events_1 = __webpack_require__(248);
        var utils_1 = __webpack_require__(245);
        var ComponentUtil = function () {
            function ComponentUtil() {}
            ComponentUtil.getEventCallbacks = function () {
                if (!ComponentUtil.EVENT_CALLBACKS) {
                    ComponentUtil.EVENT_CALLBACKS = [];
                    ComponentUtil.EVENTS.forEach(function (eventName) {
                        ComponentUtil.EVENT_CALLBACKS.push(ComponentUtil.getCallbackForEvent(eventName));
                    });
                }
                return ComponentUtil.EVENT_CALLBACKS;
            };
            ComponentUtil.copyAttributesToGridOptions = function (gridOptions, component) {
                checkForDeprecated(component);
                // create empty grid options if none were passed
                if ((typeof gridOptions === "undefined" ? "undefined" : _typeof(gridOptions)) !== 'object') {
                    gridOptions = {};
                }
                // to allow array style lookup in TypeScript, take type away from 'this' and 'gridOptions'
                var pGridOptions = gridOptions;
                // add in all the simple properties
                ComponentUtil.ARRAY_PROPERTIES.concat(ComponentUtil.STRING_PROPERTIES).concat(ComponentUtil.OBJECT_PROPERTIES).concat(ComponentUtil.FUNCTION_PROPERTIES).forEach(function (key) {
                    if (typeof component[key] !== 'undefined') {
                        pGridOptions[key] = component[key];
                    }
                });
                ComponentUtil.BOOLEAN_PROPERTIES.forEach(function (key) {
                    if (typeof component[key] !== 'undefined') {
                        pGridOptions[key] = ComponentUtil.toBoolean(component[key]);
                    }
                });
                ComponentUtil.NUMBER_PROPERTIES.forEach(function (key) {
                    if (typeof component[key] !== 'undefined') {
                        pGridOptions[key] = ComponentUtil.toNumber(component[key]);
                    }
                });
                ComponentUtil.getEventCallbacks().forEach(function (funcName) {
                    if (typeof component[funcName] !== 'undefined') {
                        pGridOptions[funcName] = component[funcName];
                    }
                });
                return gridOptions;
            };
            ComponentUtil.getCallbackForEvent = function (eventName) {
                if (!eventName || eventName.length < 2) {
                    return eventName;
                } else {
                    return 'on' + eventName[0].toUpperCase() + eventName.substr(1);
                }
            };
            // change this method, the caller should know if it's initialised or not, plus 'initialised'
            // is not relevant for all component types. maybe pass in the api and columnApi instead???
            ComponentUtil.processOnChange = function (changes, gridOptions, api, columnApi) {
                //if (!component._initialised || !changes) { return; }
                if (!changes) {
                    return;
                }
                checkForDeprecated(changes);
                // to allow array style lookup in TypeScript, take type away from 'this' and 'gridOptions'
                var pGridOptions = gridOptions;
                // check if any change for the simple types, and if so, then just copy in the new value
                ComponentUtil.ARRAY_PROPERTIES.concat(ComponentUtil.OBJECT_PROPERTIES).concat(ComponentUtil.STRING_PROPERTIES).forEach(function (key) {
                    if (changes[key]) {
                        pGridOptions[key] = changes[key].currentValue;
                    }
                });
                ComponentUtil.BOOLEAN_PROPERTIES.forEach(function (key) {
                    if (changes[key]) {
                        pGridOptions[key] = ComponentUtil.toBoolean(changes[key].currentValue);
                    }
                });
                ComponentUtil.NUMBER_PROPERTIES.forEach(function (key) {
                    if (changes[key]) {
                        pGridOptions[key] = ComponentUtil.toNumber(changes[key].currentValue);
                    }
                });
                ComponentUtil.getEventCallbacks().forEach(function (funcName) {
                    if (changes[funcName]) {
                        pGridOptions[funcName] = changes[funcName].currentValue;
                    }
                });
                if (changes.showToolPanel) {
                    api.showToolPanel(ComponentUtil.toBoolean(changes.showToolPanel.currentValue));
                }
                if (changes.quickFilterText) {
                    api.setQuickFilter(changes.quickFilterText.currentValue);
                }
                if (changes.rowData) {
                    api.setRowData(changes.rowData.currentValue);
                }
                if (changes.floatingTopRowData) {
                    api.setFloatingTopRowData(changes.floatingTopRowData.currentValue);
                }
                if (changes.floatingBottomRowData) {
                    api.setFloatingBottomRowData(changes.floatingBottomRowData.currentValue);
                }
                if (changes.columnDefs) {
                    api.setColumnDefs(changes.columnDefs.currentValue);
                }
                if (changes.datasource) {
                    api.setDatasource(changes.datasource.currentValue);
                }
                if (changes.headerHeight) {
                    api.setHeaderHeight(ComponentUtil.toNumber(changes.headerHeight.currentValue));
                }
                if (changes.pivotMode) {
                    columnApi.setPivotMode(ComponentUtil.toBoolean(changes.pivotMode.currentValue));
                }
            };
            ComponentUtil.toBoolean = function (value) {
                if (typeof value === 'boolean') {
                    return value;
                } else if (typeof value === 'string') {
                    // for boolean, compare to empty String to allow attributes appearing with
                    // not value to be treated as 'true'
                    return value.toUpperCase() === 'TRUE' || value == '';
                } else {
                    return false;
                }
            };
            ComponentUtil.toNumber = function (value) {
                if (typeof value === 'number') {
                    return value;
                } else if (typeof value === 'string') {
                    return Number(value);
                } else {
                    return undefined;
                }
            };
            // all the events are populated in here AFTER this class (at the bottom of the file).
            ComponentUtil.EVENTS = [];
            ComponentUtil.STRING_PROPERTIES = ['sortingOrder', 'rowClass', 'rowSelection', 'overlayLoadingTemplate', 'overlayNoRowsTemplate', 'headerCellTemplate', 'quickFilterText', 'rowModelType'];
            ComponentUtil.OBJECT_PROPERTIES = ['rowStyle', 'context', 'groupColumnDef', 'localeText', 'icons', 'datasource', 'viewportDatasource', 'groupRowRendererParams', 'aggFuncs', 'fullWidthCellRendererParams'];
            ComponentUtil.ARRAY_PROPERTIES = ['slaveGrids', 'rowData', 'floatingTopRowData', 'floatingBottomRowData', 'columnDefs'];
            ComponentUtil.NUMBER_PROPERTIES = ['rowHeight', 'rowBuffer', 'colWidth', 'headerHeight', 'groupDefaultExpanded', 'minColWidth', 'maxColWidth', 'viewportRowModelPageSize', 'viewportRowModelBufferSize', 'layoutInterval', 'autoSizePadding', 'maxPagesInCache', 'maxConcurrentDatasourceRequests', 'paginationOverflowSize', 'paginationPageSize', 'paginationInitialRowCount'];
            ComponentUtil.BOOLEAN_PROPERTIES = ['toolPanelSuppressRowGroups', 'toolPanelSuppressValues', 'toolPanelSuppressPivots', 'toolPanelSuppressPivotMode', 'suppressRowClickSelection', 'suppressCellSelection', 'suppressHorizontalScroll', 'debug', 'enableColResize', 'enableCellExpressions', 'enableSorting', 'enableServerSideSorting', 'enableFilter', 'enableServerSideFilter', 'angularCompileRows', 'angularCompileFilters', 'angularCompileHeaders', 'groupSuppressAutoColumn', 'groupSelectsChildren', 'groupIncludeFooter', 'groupUseEntireRow', 'groupSuppressRow', 'groupSuppressBlankHeader', 'forPrint', 'suppressMenuHide', 'rowDeselection', 'unSortIcon', 'suppressMultiSort', 'suppressScrollLag', 'singleClickEdit', 'suppressLoadingOverlay', 'suppressNoRowsOverlay', 'suppressAutoSize', 'suppressParentsInRowNodes', 'showToolPanel', 'suppressColumnMoveAnimation', 'suppressMovableColumns', 'suppressFieldDotNotation', 'enableRangeSelection', 'suppressEnterprise', 'rowGroupPanelShow', 'pivotPanelShow', 'suppressContextMenu', 'suppressMenuFilterPanel', 'suppressMenuMainPanel', 'suppressMenuColumnPanel', 'enableStatusBar', 'rememberGroupStateWhenNewData', 'enableCellChangeFlash', 'suppressDragLeaveHidesColumns', 'suppressMiddleClickScrolls', 'suppressPreventDefaultOnMouseWheel', 'suppressUseColIdForGroups', 'suppressCopyRowsToClipboard', 'pivotMode', 'suppressAggFuncInHeader', 'suppressColumnVirtualisation', 'suppressFocusAfterRefresh', 'functionsPassive', 'functionsReadOnly'];
            ComponentUtil.FUNCTION_PROPERTIES = ['headerCellRenderer', 'localeTextFunc', 'groupRowInnerRenderer', 'groupRowRenderer', 'isScrollLag', 'isExternalFilterPresent', 'getRowHeight', 'doesExternalFilterPass', 'getRowClass', 'getRowStyle', 'getHeaderCellTemplate', 'traverseNode', 'getContextMenuItems', 'getMainMenuItems', 'processRowPostCreate', 'processCellForClipboard', 'getNodeChildDetails', 'groupRowAggNodes', 'getRowNodeId', 'isFullWidthCell', 'fullWidthCellRenderer', 'doesDataFlower'];
            ComponentUtil.ALL_PROPERTIES = ComponentUtil.ARRAY_PROPERTIES.concat(ComponentUtil.OBJECT_PROPERTIES).concat(ComponentUtil.STRING_PROPERTIES).concat(ComponentUtil.NUMBER_PROPERTIES).concat(ComponentUtil.FUNCTION_PROPERTIES).concat(ComponentUtil.BOOLEAN_PROPERTIES);
            return ComponentUtil;
        }();
        exports.ComponentUtil = ComponentUtil;
        utils_1.Utils.iterateObject(events_1.Events, function (key, value) {
            ComponentUtil.EVENTS.push(value);
        });
        function checkForDeprecated(changes) {
            if (changes.ready || changes.onReady) {
                console.warn('ag-grid: as of v3.3 ready event is now called gridReady, so the callback should be onGridReady');
            }
            if (changes.rowDeselected || changes.onRowDeselected) {
                console.warn('ag-grid: as of v3.4 rowDeselected no longer exists. Please check the docs.');
            }
        }

        /***/ },
    /* 248 */
    /***/ function(module, exports) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var Events = function () {
            function Events() {}
            /** A new set of columns has been entered, everything has potentially changed. */
            Events.EVENT_COLUMN_EVERYTHING_CHANGED = 'columnEverythingChanged';
            Events.EVENT_NEW_COLUMNS_LOADED = 'newColumnsLoaded';
            /** The reduce flag was changed */
            Events.EVENT_COLUMN_PIVOT_MODE_CHANGED = 'columnPivotModeChanged';
            /** A row group column was added, removed or order changed. */
            Events.EVENT_COLUMN_ROW_GROUP_CHANGED = 'columnRowGroupChanged';
            /** A pivot column was added, removed or order changed. */
            Events.EVENT_COLUMN_PIVOT_CHANGED = 'columnPivotChanged';
            /** The list of grid columns has changed. */
            Events.EVENT_GRID_COLUMNS_CHANGED = 'gridColumnsChanged';
            /** A value column was added, removed or agg function was changed. */
            Events.EVENT_COLUMN_VALUE_CHANGED = 'columnValueChanged';
            /** A column was moved */
            Events.EVENT_COLUMN_MOVED = 'columnMoved';
            /** One or more columns was shown / hidden */
            Events.EVENT_COLUMN_VISIBLE = 'columnVisible';
            /** One or more columns was pinned / unpinned*/
            Events.EVENT_COLUMN_PINNED = 'columnPinned';
            /** A column group was opened / closed */
            Events.EVENT_COLUMN_GROUP_OPENED = 'columnGroupOpened';
            /** One or more columns was resized. If just one, the column in the event is set. */
            Events.EVENT_COLUMN_RESIZED = 'columnResized';
            /** The list of displayed columns has changed, can result from columns open / close, column move, pivot, group, etc */
            Events.EVENT_DISPLAYED_COLUMNS_CHANGED = 'displayedColumnsChanged';
            /** The list of virtual columns has changed, results from viewport changing */
            Events.EVENT_VIRTUAL_COLUMNS_CHANGED = 'virtualColumnsChanged';
            /** A row group was opened / closed */
            Events.EVENT_ROW_GROUP_OPENED = 'rowGroupOpened';
            Events.EVENT_ROW_DATA_CHANGED = 'rowDataChanged';
            Events.EVENT_FLOATING_ROW_DATA_CHANGED = 'floatingRowDataChanged';
            Events.EVENT_RANGE_SELECTION_CHANGED = 'rangeSelectionChanged';
            Events.EVENT_COLUMN_ROW_GROUP_ADD_REQUEST = 'columnRowGroupAddRequest';
            Events.EVENT_COLUMN_ROW_GROUP_REMOVE_REQUEST = 'columnRowGroupRemoveRequest';
            Events.EVENT_COLUMN_PIVOT_ADD_REQUEST = 'columnPivotAddRequest';
            Events.EVENT_COLUMN_PIVOT_REMOVE_REQUEST = 'columnPivotRemoveRequest';
            Events.EVENT_COLUMN_VALUE_ADD_REQUEST = 'columnValueAddRequest';
            Events.EVENT_COLUMN_VALUE_REMOVE_REQUEST = 'columnValueRemoveRequest';
            Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = 'columnAggFuncChangeRequest';
            Events.EVENT_FLASH_CELLS = 'clipboardPaste';
            Events.EVENT_MODEL_UPDATED = 'modelUpdated';
            Events.EVENT_CELL_CLICKED = 'cellClicked';
            Events.EVENT_CELL_DOUBLE_CLICKED = 'cellDoubleClicked';
            Events.EVENT_CELL_CONTEXT_MENU = 'cellContextMenu';
            Events.EVENT_CELL_VALUE_CHANGED = 'cellValueChanged';
            Events.EVENT_CELL_FOCUSED = 'cellFocused';
            Events.EVENT_ROW_SELECTED = 'rowSelected';
            Events.EVENT_SELECTION_CHANGED = 'selectionChanged';
            Events.EVENT_BEFORE_FILTER_CHANGED = 'beforeFilterChanged';
            Events.EVENT_FILTER_CHANGED = 'filterChanged';
            Events.EVENT_AFTER_FILTER_CHANGED = 'afterFilterChanged';
            Events.EVENT_FILTER_MODIFIED = 'filterModified';
            Events.EVENT_BEFORE_SORT_CHANGED = 'beforeSortChanged';
            Events.EVENT_SORT_CHANGED = 'sortChanged';
            Events.EVENT_AFTER_SORT_CHANGED = 'afterSortChanged';
            Events.EVENT_VIRTUAL_ROW_REMOVED = 'virtualRowRemoved';
            Events.EVENT_ROW_CLICKED = 'rowClicked';
            Events.EVENT_ROW_DOUBLE_CLICKED = 'rowDoubleClicked';
            Events.EVENT_GRID_READY = 'gridReady';
            Events.EVENT_GRID_SIZE_CHANGED = 'gridSizeChanged';
            Events.EVENT_VIEWPORT_CHANGED = 'viewportChanged';
            Events.EVENT_DRAG_STARTED = 'dragStarted';
            Events.EVENT_DRAG_STOPPED = 'dragStopped';
            Events.EVENT_ITEMS_ADDED = 'itemsAdded';
            Events.EVENT_ITEMS_REMOVED = 'itemsRemoved';
            return Events;
        }();
        exports.Events = Events;

        /***/ },
    /* 249 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var csvCreator_1 = __webpack_require__(250);
        var rowRenderer_1 = __webpack_require__(261);
        var headerRenderer_1 = __webpack_require__(304);
        var filterManager_1 = __webpack_require__(281);
        var columnController_1 = __webpack_require__(251);
        var selectionController_1 = __webpack_require__(266);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var gridPanel_1 = __webpack_require__(262);
        var valueService_1 = __webpack_require__(267);
        var masterSlaveService_1 = __webpack_require__(263);
        var eventService_1 = __webpack_require__(242);
        var floatingRowModel_1 = __webpack_require__(264);
        var constants_1 = __webpack_require__(246);
        var context_1 = __webpack_require__(244);
        var gridCore_1 = __webpack_require__(278);
        var sortController_1 = __webpack_require__(280);
        var paginationController_1 = __webpack_require__(279);
        var focusedCellController_1 = __webpack_require__(273);
        var gridCell_1 = __webpack_require__(271);
        var utils_1 = __webpack_require__(245);
        var cellRendererFactory_1 = __webpack_require__(293);
        var cellEditorFactory_1 = __webpack_require__(286);
        var GridApi = function () {
            function GridApi() {}
            GridApi.prototype.init = function () {
                switch (this.rowModel.getType()) {
                    case constants_1.Constants.ROW_MODEL_TYPE_NORMAL:
                    case constants_1.Constants.ROW_MODEL_TYPE_PAGINATION:
                        this.inMemoryRowModel = this.rowModel;
                        break;
                    case constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL:
                        this.virtualPageRowModel = this.rowModel;
                        break;
                }
            };
            /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
            GridApi.prototype.__getMasterSlaveService = function () {
                return this.masterSlaveService;
            };
            GridApi.prototype.getFirstRenderedRow = function () {
                return this.rowRenderer.getFirstVirtualRenderedRow();
            };
            GridApi.prototype.getLastRenderedRow = function () {
                return this.rowRenderer.getLastVirtualRenderedRow();
            };
            GridApi.prototype.getDataAsCsv = function (params) {
                return this.csvCreator.getDataAsCsv(params);
            };
            GridApi.prototype.exportDataAsCsv = function (params) {
                this.csvCreator.exportDataAsCsv(params);
            };
            GridApi.prototype.setDatasource = function (datasource) {
                if (this.gridOptionsWrapper.isRowModelPagination()) {
                    this.paginationController.setDatasource(datasource);
                } else if (this.gridOptionsWrapper.isRowModelVirtual()) {
                    this.rowModel.setDatasource(datasource);
                } else {
                    console.warn("ag-Grid: you can only use a datasource when gridOptions.rowModelType is '" + constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL + "' or '" + constants_1.Constants.ROW_MODEL_TYPE_PAGINATION + "'");
                }
            };
            GridApi.prototype.setViewportDatasource = function (viewportDatasource) {
                if (this.gridOptionsWrapper.isRowModelViewport()) {
                    // this is bad coding, because it's using an interface that's exposed in the enterprise.
                    // really we should create an interface in the core for viewportDatasource and let
                    // the enterprise implement it, rather than casting to 'any' here
                    this.rowModel.setViewportDatasource(viewportDatasource);
                } else {
                    console.warn("ag-Grid: you can only use a datasource when gridOptions.rowModelType is '" + constants_1.Constants.ROW_MODEL_TYPE_VIEWPORT + "'");
                }
            };
            GridApi.prototype.setRowData = function (rowData) {
                if (this.gridOptionsWrapper.isRowModelDefault()) {
                    this.selectionController.reset();
                    this.inMemoryRowModel.setRowData(rowData, true);
                } else {
                    console.log('cannot call setRowData unless using normal row model');
                }
            };
            GridApi.prototype.setFloatingTopRowData = function (rows) {
                this.floatingRowModel.setFloatingTopRowData(rows);
            };
            GridApi.prototype.setFloatingBottomRowData = function (rows) {
                this.floatingRowModel.setFloatingBottomRowData(rows);
            };
            GridApi.prototype.setColumnDefs = function (colDefs) {
                this.columnController.setColumnDefs(colDefs);
            };
            GridApi.prototype.refreshRows = function (rowNodes) {
                this.rowRenderer.refreshRows(rowNodes);
            };
            GridApi.prototype.refreshCells = function (rowNodes, colIds, animate) {
                if (animate === void 0) {
                    animate = false;
                }
                this.rowRenderer.refreshCells(rowNodes, colIds, animate);
            };
            GridApi.prototype.rowDataChanged = function (rows) {
                this.rowRenderer.rowDataChanged(rows);
            };
            GridApi.prototype.refreshView = function () {
                this.rowRenderer.refreshView();
            };
            GridApi.prototype.setFunctionsReadOnly = function (readOnly) {
                this.gridOptionsWrapper.setProperty('functionsReadOnly', readOnly);
            };
            GridApi.prototype.softRefreshView = function () {
                this.rowRenderer.softRefreshView();
            };
            GridApi.prototype.refreshGroupRows = function () {
                this.rowRenderer.refreshGroupRows();
            };
            GridApi.prototype.refreshHeader = function () {
                // need to review this - the refreshHeader should also refresh all icons in the header
                this.headerRenderer.refreshHeader();
            };
            GridApi.prototype.isAnyFilterPresent = function () {
                return this.filterManager.isAnyFilterPresent();
            };
            GridApi.prototype.isAdvancedFilterPresent = function () {
                return this.filterManager.isAdvancedFilterPresent();
            };
            GridApi.prototype.isQuickFilterPresent = function () {
                return this.filterManager.isQuickFilterPresent();
            };
            GridApi.prototype.getModel = function () {
                return this.rowModel;
            };
            GridApi.prototype.onGroupExpandedOrCollapsed = function (refreshFromIndex) {
                if (utils_1.Utils.missing(this.inMemoryRowModel)) {
                    console.log('cannot call onGroupExpandedOrCollapsed unless using normal row model');
                }
                this.inMemoryRowModel.refreshModel(constants_1.Constants.STEP_MAP, refreshFromIndex);
            };
            GridApi.prototype.refreshInMemoryRowModel = function () {
                if (utils_1.Utils.missing(this.inMemoryRowModel)) {
                    console.log('cannot call refreshInMemoryRowModel unless using normal row model');
                }
                this.inMemoryRowModel.refreshModel(constants_1.Constants.STEP_EVERYTHING);
            };
            GridApi.prototype.expandAll = function () {
                if (utils_1.Utils.missing(this.inMemoryRowModel)) {
                    console.log('cannot call expandAll unless using normal row model');
                }
                this.inMemoryRowModel.expandOrCollapseAll(true);
            };
            GridApi.prototype.collapseAll = function () {
                if (utils_1.Utils.missing(this.inMemoryRowModel)) {
                    console.log('cannot call collapseAll unless using normal row model');
                }
                this.inMemoryRowModel.expandOrCollapseAll(false);
            };
            GridApi.prototype.addVirtualRowListener = function (eventName, rowIndex, callback) {
                if (typeof eventName !== 'string') {
                    console.log('ag-Grid: addVirtualRowListener is deprecated, please use addRenderedRowListener.');
                }
                this.addRenderedRowListener(eventName, rowIndex, callback);
            };
            GridApi.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {
                if (eventName === 'virtualRowRemoved') {
                    console.log('ag-Grid: event virtualRowRemoved is deprecated, now called renderedRowRemoved');
                    eventName = '' + '';
                }
                if (eventName === 'virtualRowSelected') {
                    console.log('ag-Grid: event virtualRowSelected is deprecated, to register for individual row ' + 'selection events, add a listener directly to the row node.');
                }
                this.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
            };
            GridApi.prototype.setQuickFilter = function (newFilter) {
                this.filterManager.setQuickFilter(newFilter);
            };
            GridApi.prototype.selectIndex = function (index, tryMulti, suppressEvents) {
                console.log('ag-Grid: do not use api for selection, call node.setSelected(value) instead');
                if (suppressEvents) {
                    console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
                }
                this.selectionController.selectIndex(index, tryMulti);
            };
            GridApi.prototype.deselectIndex = function (index, suppressEvents) {
                if (suppressEvents === void 0) {
                    suppressEvents = false;
                }
                console.log('ag-Grid: do not use api for selection, call node.setSelected(value) instead');
                if (suppressEvents) {
                    console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
                }
                this.selectionController.deselectIndex(index);
            };
            GridApi.prototype.selectNode = function (node, tryMulti, suppressEvents) {
                if (tryMulti === void 0) {
                    tryMulti = false;
                }
                if (suppressEvents === void 0) {
                    suppressEvents = false;
                }
                console.log('ag-Grid: API for selection is deprecated, call node.setSelected(value) instead');
                if (suppressEvents) {
                    console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
                }
                node.setSelectedParams({ newValue: true, clearSelection: !tryMulti });
            };
            GridApi.prototype.deselectNode = function (node, suppressEvents) {
                if (suppressEvents === void 0) {
                    suppressEvents = false;
                }
                console.log('ag-Grid: API for selection is deprecated, call node.setSelected(value) instead');
                if (suppressEvents) {
                    console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
                }
                node.setSelectedParams({ newValue: false });
            };
            GridApi.prototype.selectAll = function () {
                this.selectionController.selectAllRowNodes();
            };
            GridApi.prototype.deselectAll = function () {
                this.selectionController.deselectAllRowNodes();
            };
            GridApi.prototype.recomputeAggregates = function () {
                if (utils_1.Utils.missing(this.inMemoryRowModel)) {
                    console.log('cannot call recomputeAggregates unless using normal row model');
                }
                this.inMemoryRowModel.refreshModel(constants_1.Constants.STEP_AGGREGATE);
            };
            GridApi.prototype.sizeColumnsToFit = function () {
                if (this.gridOptionsWrapper.isForPrint()) {
                    console.warn('ag-grid: sizeColumnsToFit does not work when forPrint=true');
                    return;
                }
                this.gridPanel.sizeColumnsToFit();
            };
            GridApi.prototype.showLoadingOverlay = function () {
                this.gridPanel.showLoadingOverlay();
            };
            GridApi.prototype.showNoRowsOverlay = function () {
                this.gridPanel.showNoRowsOverlay();
            };
            GridApi.prototype.hideOverlay = function () {
                this.gridPanel.hideOverlay();
            };
            GridApi.prototype.isNodeSelected = function (node) {
                console.log('ag-Grid: no need to call api.isNodeSelected(), just call node.isSelected() instead');
                return node.isSelected();
            };
            GridApi.prototype.getSelectedNodesById = function () {
                console.error('ag-Grid: since version 3.4, getSelectedNodesById no longer exists, use getSelectedNodes() instead');
                return null;
            };
            GridApi.prototype.getSelectedNodes = function () {
                return this.selectionController.getSelectedNodes();
            };
            GridApi.prototype.getSelectedRows = function () {
                return this.selectionController.getSelectedRows();
            };
            GridApi.prototype.getBestCostNodeSelection = function () {
                return this.selectionController.getBestCostNodeSelection();
            };
            GridApi.prototype.getRenderedNodes = function () {
                return this.rowRenderer.getRenderedNodes();
            };
            GridApi.prototype.ensureColIndexVisible = function (index) {
                console.warn('ag-Grid: ensureColIndexVisible(index) no longer supported, use ensureColumnVisible(colKey) instead.');
            };
            GridApi.prototype.ensureColumnVisible = function (key) {
                this.gridPanel.ensureColumnVisible(key);
            };
            GridApi.prototype.ensureIndexVisible = function (index) {
                this.gridPanel.ensureIndexVisible(index);
            };
            GridApi.prototype.ensureNodeVisible = function (comparator) {
                this.gridCore.ensureNodeVisible(comparator);
            };
            GridApi.prototype.forEachLeafNode = function (callback) {
                if (utils_1.Utils.missing(this.inMemoryRowModel)) {
                    console.log('cannot call forEachNodeAfterFilter unless using normal row model');
                }
                this.inMemoryRowModel.forEachLeafNode(callback);
            };
            GridApi.prototype.forEachNode = function (callback) {
                this.rowModel.forEachNode(callback);
            };
            GridApi.prototype.forEachNodeAfterFilter = function (callback) {
                if (utils_1.Utils.missing(this.inMemoryRowModel)) {
                    console.log('cannot call forEachNodeAfterFilter unless using normal row model');
                }
                this.inMemoryRowModel.forEachNodeAfterFilter(callback);
            };
            GridApi.prototype.forEachNodeAfterFilterAndSort = function (callback) {
                if (utils_1.Utils.missing(this.inMemoryRowModel)) {
                    console.log('cannot call forEachNodeAfterFilterAndSort unless using normal row model');
                }
                this.inMemoryRowModel.forEachNodeAfterFilterAndSort(callback);
            };
            GridApi.prototype.getFilterApiForColDef = function (colDef) {
                console.warn('ag-grid API method getFilterApiForColDef deprecated, use getFilterApi instead');
                return this.getFilterComponent(colDef);
            };
            GridApi.prototype.getFilterComponent = function (key) {
                var column = this.columnController.getPrimaryColumn(key);
                if (column) {
                    return this.filterManager.getFilterComponent(column);
                }
            };
            GridApi.prototype.getFilterApi = function (key) {
                console.warn('ag-Grid: getFilterApi is deprecated, use getFilterComponent instead');
                return this.getFilterComponent(key);
            };
            GridApi.prototype.destroyFilter = function (key) {
                var column = this.columnController.getPrimaryColumn(key);
                if (column) {
                    return this.filterManager.destroyFilter(column);
                }
            };
            GridApi.prototype.getColumnDef = function (key) {
                var column = this.columnController.getPrimaryColumn(key);
                if (column) {
                    return column.getColDef();
                } else {
                    return null;
                }
            };
            GridApi.prototype.onFilterChanged = function () {
                this.filterManager.onFilterChanged();
            };
            GridApi.prototype.setSortModel = function (sortModel) {
                this.sortController.setSortModel(sortModel);
            };
            GridApi.prototype.getSortModel = function () {
                return this.sortController.getSortModel();
            };
            GridApi.prototype.setFilterModel = function (model) {
                this.filterManager.setFilterModel(model);
            };
            GridApi.prototype.getFilterModel = function () {
                return this.filterManager.getFilterModel();
            };
            GridApi.prototype.getFocusedCell = function () {
                return this.focusedCellController.getFocusedCell();
            };
            GridApi.prototype.setFocusedCell = function (rowIndex, colKey, floating) {
                this.focusedCellController.setFocusedCell(rowIndex, colKey, floating, true);
            };
            GridApi.prototype.setHeaderHeight = function (headerHeight) {
                this.gridOptionsWrapper.setProperty(gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, headerHeight);
            };
            GridApi.prototype.showToolPanel = function (show) {
                this.gridCore.showToolPanel(show);
            };
            GridApi.prototype.isToolPanelShowing = function () {
                return this.gridCore.isToolPanelShowing();
            };
            GridApi.prototype.doLayout = function () {
                this.gridCore.doLayout();
            };
            GridApi.prototype.getValue = function (colKey, rowNode) {
                var column = this.columnController.getPrimaryColumn(colKey);
                return this.valueService.getValue(column, rowNode);
            };
            GridApi.prototype.addEventListener = function (eventType, listener) {
                this.eventService.addEventListener(eventType, listener);
            };
            GridApi.prototype.addGlobalListener = function (listener) {
                this.eventService.addGlobalListener(listener);
            };
            GridApi.prototype.removeEventListener = function (eventType, listener) {
                this.eventService.removeEventListener(eventType, listener);
            };
            GridApi.prototype.removeGlobalListener = function (listener) {
                this.eventService.removeGlobalListener(listener);
            };
            GridApi.prototype.dispatchEvent = function (eventType, event) {
                this.eventService.dispatchEvent(eventType, event);
            };
            GridApi.prototype.destroy = function () {
                this.context.destroy();
            };
            GridApi.prototype.resetQuickFilter = function () {
                this.rowModel.forEachNode(function (node) {
                    return node.quickFilterAggregateText = null;
                });
            };
            GridApi.prototype.getRangeSelections = function () {
                if (this.rangeController) {
                    return this.rangeController.getCellRanges();
                } else {
                    console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
                    return null;
                }
            };
            GridApi.prototype.addRangeSelection = function (rangeSelection) {
                if (!this.rangeController) {
                    console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
                }
                this.rangeController.addRange(rangeSelection);
            };
            GridApi.prototype.clearRangeSelection = function () {
                if (!this.rangeController) {
                    console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
                }
                this.rangeController.clearSelection();
            };
            GridApi.prototype.copySelectedRowsToClipboard = function (includeHeader, columnKeys) {
                if (!this.clipboardService) {
                    console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
                }
                var column = null;
                this.clipboardService.copySelectedRowsToClipboard(includeHeader, columnKeys);
            };
            GridApi.prototype.copySelectedRangeToClipboard = function (includeHeader) {
                if (!this.clipboardService) {
                    console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
                }
                this.clipboardService.copySelectedRangeToClipboard(includeHeader);
            };
            GridApi.prototype.copySelectedRangeDown = function () {
                if (!this.clipboardService) {
                    console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
                }
                this.clipboardService.copyRangeDown();
            };
            GridApi.prototype.showColumnMenuAfterButtonClick = function (colKey, buttonElement) {
                var column = this.columnController.getPrimaryColumn(colKey);
                this.menuFactory.showMenuAfterButtonClick(column, buttonElement);
            };
            GridApi.prototype.showColumnMenuAfterMouseClick = function (colKey, mouseEvent) {
                var column = this.columnController.getPrimaryColumn(colKey);
                this.menuFactory.showMenuAfterMouseEvent(column, mouseEvent);
            };
            GridApi.prototype.stopEditing = function (cancel) {
                if (cancel === void 0) {
                    cancel = false;
                }
                this.rowRenderer.stopEditing(cancel);
            };
            GridApi.prototype.startEditingCell = function (params) {
                var column = this.columnController.getGridColumn(params.colKey);
                var gridCell = new gridCell_1.GridCell(params.rowIndex, null, column);
                this.rowRenderer.startEditingCell(gridCell, params.keyPress, params.charPress);
            };
            GridApi.prototype.addAggFunc = function (key, aggFunc) {
                if (this.aggFuncService) {
                    this.aggFuncService.addAggFunc(key, aggFunc);
                }
            };
            GridApi.prototype.addAggFuncs = function (aggFuncs) {
                if (this.aggFuncService) {
                    this.aggFuncService.addAggFuncs(aggFuncs);
                }
            };
            GridApi.prototype.clearAggFuncs = function () {
                if (this.aggFuncService) {
                    this.aggFuncService.clear();
                }
            };
            GridApi.prototype.insertItemsAtIndex = function (index, items) {
                this.rowModel.insertItemsAtIndex(index, items);
            };
            GridApi.prototype.removeItems = function (rowNodes) {
                this.rowModel.removeItems(rowNodes);
            };
            GridApi.prototype.addItems = function (items) {
                this.rowModel.addItems(items);
            };
            GridApi.prototype.refreshVirtualPageCache = function () {
                if (this.virtualPageRowModel) {
                    this.virtualPageRowModel.refreshVirtualPageCache();
                } else {
                    console.warn("ag-Grid: api.refreshVirtualPageCache is only available when rowModelType='virtual'.");
                }
            };
            GridApi.prototype.purgeVirtualPageCache = function () {
                if (this.virtualPageRowModel) {
                    this.virtualPageRowModel.purgeVirtualPageCache();
                } else {
                    console.warn("ag-Grid: api.refreshVirtualPageCache is only available when rowModelType='virtual'.");
                }
            };
            GridApi.prototype.getVirtualRowCount = function () {
                if (this.virtualPageRowModel) {
                    return this.virtualPageRowModel.getVirtualRowCount();
                } else {
                    console.warn("ag-Grid: api.getVirtualRowCount is only available when rowModelType='virtual'.");
                }
            };
            GridApi.prototype.isMaxRowFound = function () {
                if (this.virtualPageRowModel) {
                    return this.virtualPageRowModel.isMaxRowFound();
                } else {
                    console.warn("ag-Grid: api.isMaxRowFound is only available when rowModelType='virtual'.");
                }
            };
            GridApi.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {
                if (this.virtualPageRowModel) {
                    this.virtualPageRowModel.setVirtualRowCount(rowCount, maxRowFound);
                } else {
                    console.warn("ag-Grid: api.setVirtualRowCount is only available when rowModelType='virtual'.");
                }
            };
            GridApi.prototype.getVirtualPageState = function () {
                if (this.virtualPageRowModel) {
                    return this.virtualPageRowModel.getVirtualPageState();
                } else {
                    console.warn("ag-Grid: api.getVirtualPageState is only available when rowModelType='virtual'.");
                }
            };
            __decorate([context_1.Autowired('csvCreator'), __metadata('design:type', csvCreator_1.CsvCreator)], GridApi.prototype, "csvCreator", void 0);
            __decorate([context_1.Autowired('gridCore'), __metadata('design:type', gridCore_1.GridCore)], GridApi.prototype, "gridCore", void 0);
            __decorate([context_1.Autowired('rowRenderer'), __metadata('design:type', rowRenderer_1.RowRenderer)], GridApi.prototype, "rowRenderer", void 0);
            __decorate([context_1.Autowired('headerRenderer'), __metadata('design:type', headerRenderer_1.HeaderRenderer)], GridApi.prototype, "headerRenderer", void 0);
            __decorate([context_1.Autowired('filterManager'), __metadata('design:type', filterManager_1.FilterManager)], GridApi.prototype, "filterManager", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], GridApi.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('selectionController'), __metadata('design:type', selectionController_1.SelectionController)], GridApi.prototype, "selectionController", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], GridApi.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], GridApi.prototype, "gridPanel", void 0);
            __decorate([context_1.Autowired('valueService'), __metadata('design:type', valueService_1.ValueService)], GridApi.prototype, "valueService", void 0);
            __decorate([context_1.Autowired('masterSlaveService'), __metadata('design:type', masterSlaveService_1.MasterSlaveService)], GridApi.prototype, "masterSlaveService", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], GridApi.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('floatingRowModel'), __metadata('design:type', floatingRowModel_1.FloatingRowModel)], GridApi.prototype, "floatingRowModel", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], GridApi.prototype, "context", void 0);
            __decorate([context_1.Autowired('rowModel'), __metadata('design:type', Object)], GridApi.prototype, "rowModel", void 0);
            __decorate([context_1.Autowired('sortController'), __metadata('design:type', sortController_1.SortController)], GridApi.prototype, "sortController", void 0);
            __decorate([context_1.Autowired('paginationController'), __metadata('design:type', paginationController_1.PaginationController)], GridApi.prototype, "paginationController", void 0);
            __decorate([context_1.Autowired('focusedCellController'), __metadata('design:type', focusedCellController_1.FocusedCellController)], GridApi.prototype, "focusedCellController", void 0);
            __decorate([context_1.Optional('rangeController'), __metadata('design:type', Object)], GridApi.prototype, "rangeController", void 0);
            __decorate([context_1.Optional('clipboardService'), __metadata('design:type', Object)], GridApi.prototype, "clipboardService", void 0);
            __decorate([context_1.Optional('aggFuncService'), __metadata('design:type', Object)], GridApi.prototype, "aggFuncService", void 0);
            __decorate([context_1.Autowired('menuFactory'), __metadata('design:type', Object)], GridApi.prototype, "menuFactory", void 0);
            __decorate([context_1.Autowired('cellRendererFactory'), __metadata('design:type', cellRendererFactory_1.CellRendererFactory)], GridApi.prototype, "cellRendererFactory", void 0);
            __decorate([context_1.Autowired('cellEditorFactory'), __metadata('design:type', cellEditorFactory_1.CellEditorFactory)], GridApi.prototype, "cellEditorFactory", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], GridApi.prototype, "init", null);
            GridApi = __decorate([context_1.Bean('gridApi'), __metadata('design:paramtypes', [])], GridApi);
            return GridApi;
        }();
        exports.GridApi = GridApi;

        /***/ },
    /* 250 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var columnController_1 = __webpack_require__(251);
        var valueService_1 = __webpack_require__(267);
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var constants_1 = __webpack_require__(246);
        var floatingRowModel_1 = __webpack_require__(264);
        var utils_1 = __webpack_require__(245);
        var LINE_SEPARATOR = '\r\n';
        var CsvCreator = function () {
            function CsvCreator() {}
            CsvCreator.prototype.exportDataAsCsv = function (params) {
                var csvString = this.getDataAsCsv(params);
                var fileNamePresent = params && params.fileName && params.fileName.length !== 0;
                var fileName = fileNamePresent ? params.fileName : 'export.csv';
                // for Excel, we need \ufeff at the start
                // http://stackoverflow.com/questions/17879198/adding-utf-8-bom-to-string-blob
                var blobObject = new Blob(["", csvString], {
                    type: "text/csv;charset=utf-8;"
                });
                // Internet Explorer
                if (window.navigator.msSaveOrOpenBlob) {
                    window.navigator.msSaveOrOpenBlob(blobObject, fileName);
                } else {
                    // Chrome
                    var downloadLink = document.createElement("a");
                    downloadLink.href = window.URL.createObjectURL(blobObject);
                    downloadLink.download = fileName;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                }
            };
            CsvCreator.prototype.getDataAsCsv = function (params) {
                if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
                    console.log('ag-Grid: getDataAsCsv is only available for standard row model');
                    return '';
                }
                var inMemoryRowModel = this.rowModel;
                var that = this;
                var result = '';
                var skipGroups = params && params.skipGroups;
                var skipHeader = params && params.skipHeader;
                var skipFooters = params && params.skipFooters;
                var skipFloatingTop = params && params.skipFloatingTop;
                var skipFloatingBottom = params && params.skipFloatingBottom;
                var includeCustomHeader = params && params.customHeader;
                var includeCustomFooter = params && params.customFooter;
                var allColumns = params && params.allColumns;
                var onlySelected = params && params.onlySelected;
                var columnSeparator = params && params.columnSeparator || ',';
                var suppressQuotes = params && params.suppressQuotes;
                var columnKeys = params && params.columnKeys;
                var processCellCallback = params && params.processCellCallback;
                var processHeaderCallback = params && params.processHeaderCallback;
                // when in pivot mode, we always render cols on screen, never 'all columns'
                var isPivotMode = this.columnController.isPivotMode();
                var isRowGrouping = this.columnController.getRowGroupColumns().length > 0;
                var columnsToExport;
                if (utils_1.Utils.existsAndNotEmpty(columnKeys)) {
                    columnsToExport = this.columnController.getGridColumns(columnKeys);
                } else if (allColumns && !isPivotMode) {
                    columnsToExport = this.columnController.getAllPrimaryColumns();
                } else {
                    columnsToExport = this.columnController.getAllDisplayedColumns();
                }
                if (!columnsToExport || columnsToExport.length === 0) {
                    return '';
                }
                if (includeCustomHeader) {
                    result += params.customHeader;
                }
                // first pass, put in the header names of the cols
                if (!skipHeader) {
                    columnsToExport.forEach(processHeaderColumn);
                    result += LINE_SEPARATOR;
                }
                this.floatingRowModel.forEachFloatingTopRow(processRow);
                if (isPivotMode) {
                    inMemoryRowModel.forEachPivotNode(processRow);
                } else {
                    inMemoryRowModel.forEachNodeAfterFilterAndSort(processRow);
                }
                this.floatingRowModel.forEachFloatingBottomRow(processRow);
                if (includeCustomFooter) {
                    result += params.customFooter;
                }
                function processRow(node) {
                    if (skipGroups && node.group) {
                        return;
                    }
                    if (skipFooters && node.footer) {
                        return;
                    }
                    if (onlySelected && !node.isSelected()) {
                        return;
                    }
                    if (skipFloatingTop && node.floating === 'top') {
                        return;
                    }
                    if (skipFloatingBottom && node.floating === 'bottom') {
                        return;
                    }
                    // if we are in pivotMode, then the grid will show the root node only
                    // if it's not a leaf group
                    var nodeIsRootNode = node.level === -1;
                    if (nodeIsRootNode && !node.leafGroup) {
                        return;
                    }
                    columnsToExport.forEach(function (column, index) {
                        var valueForCell;
                        if (node.group && isRowGrouping && index === 0) {
                            valueForCell = that.createValueForGroupNode(node);
                        } else {
                            valueForCell = that.valueService.getValue(column, node);
                        }
                        valueForCell = that.processCell(node, column, valueForCell, processCellCallback);
                        if (valueForCell === null || valueForCell === undefined) {
                            valueForCell = '';
                        }
                        if (index != 0) {
                            result += columnSeparator;
                        }
                        result += that.putInQuotes(valueForCell, suppressQuotes);
                    });
                    result += LINE_SEPARATOR;
                }
                function processHeaderColumn(column, index) {
                    var nameForCol = that.getHeaderName(processHeaderCallback, column);
                    if (nameForCol === null || nameForCol === undefined) {
                        nameForCol = '';
                    }
                    if (index != 0) {
                        result += columnSeparator;
                    }
                    result += that.putInQuotes(nameForCol, suppressQuotes);
                }
                return result;
            };
            CsvCreator.prototype.getHeaderName = function (callback, column) {
                if (callback) {
                    return callback({
                        column: column,
                        api: this.gridOptionsWrapper.getApi(),
                        columnApi: this.gridOptionsWrapper.getColumnApi(),
                        context: this.gridOptionsWrapper.getContext()
                    });
                } else {
                    return this.columnController.getDisplayNameForCol(column, true);
                }
            };
            CsvCreator.prototype.processCell = function (rowNode, column, value, processCellCallback) {
                if (processCellCallback) {
                    return processCellCallback({
                        column: column,
                        node: rowNode,
                        value: value,
                        api: this.gridOptionsWrapper.getApi(),
                        columnApi: this.gridOptionsWrapper.getColumnApi(),
                        context: this.gridOptionsWrapper.getContext()
                    });
                } else {
                    return value;
                }
            };
            CsvCreator.prototype.createValueForGroupNode = function (node) {
                var keys = [node.key];
                while (node.parent) {
                    node = node.parent;
                    keys.push(node.key);
                }
                return keys.reverse().join(' -> ');
            };
            CsvCreator.prototype.putInQuotes = function (value, suppressQuotes) {
                if (suppressQuotes) {
                    return value;
                }
                if (value === null || value === undefined) {
                    return '""';
                }
                var stringValue;
                if (typeof value === 'string') {
                    stringValue = value;
                } else if (typeof value.toString === 'function') {
                    stringValue = value.toString();
                } else {
                    console.warn('unknown value type during csv conversion');
                    stringValue = '';
                }
                // replace each " with "" (ie two sets of double quotes is how to do double quotes in csv)
                var valueEscaped = stringValue.replace(/"/g, "\"\"");
                return '"' + valueEscaped + '"';
            };
            __decorate([context_1.Autowired('rowModel'), __metadata('design:type', Object)], CsvCreator.prototype, "rowModel", void 0);
            __decorate([context_1.Autowired('floatingRowModel'), __metadata('design:type', floatingRowModel_1.FloatingRowModel)], CsvCreator.prototype, "floatingRowModel", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], CsvCreator.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('valueService'), __metadata('design:type', valueService_1.ValueService)], CsvCreator.prototype, "valueService", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], CsvCreator.prototype, "gridOptionsWrapper", void 0);
            CsvCreator = __decorate([context_1.Bean('csvCreator'), __metadata('design:paramtypes', [])], CsvCreator);
            return CsvCreator;
        }();
        exports.CsvCreator = CsvCreator;

        /***/ },
    /* 251 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var utils_1 = __webpack_require__(245);
        var columnGroup_1 = __webpack_require__(252);
        var column_1 = __webpack_require__(253);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var expressionService_1 = __webpack_require__(256);
        var balancedColumnTreeBuilder_1 = __webpack_require__(257);
        var displayedGroupCreator_1 = __webpack_require__(259);
        var autoWidthCalculator_1 = __webpack_require__(260);
        var eventService_1 = __webpack_require__(242);
        var columnUtils_1 = __webpack_require__(254);
        var logger_1 = __webpack_require__(243);
        var events_1 = __webpack_require__(248);
        var columnChangeEvent_1 = __webpack_require__(316);
        var originalColumnGroup_1 = __webpack_require__(255);
        var groupInstanceIdCreator_1 = __webpack_require__(317);
        var functions_1 = __webpack_require__(318);
        var context_1 = __webpack_require__(244);
        var gridPanel_1 = __webpack_require__(262);
        var ColumnApi = function () {
            function ColumnApi() {}
            ColumnApi.prototype.sizeColumnsToFit = function (gridWidth) {
                this._columnController.sizeColumnsToFit(gridWidth);
            };
            ColumnApi.prototype.setColumnGroupOpened = function (group, newValue, instanceId) {
                this._columnController.setColumnGroupOpened(group, newValue, instanceId);
            };
            ColumnApi.prototype.getColumnGroup = function (name, instanceId) {
                return this._columnController.getColumnGroup(name, instanceId);
            };
            ColumnApi.prototype.getDisplayNameForCol = function (column) {
                return this._columnController.getDisplayNameForCol(column);
            };
            ColumnApi.prototype.getColumn = function (key) {
                return this._columnController.getPrimaryColumn(key);
            };
            ColumnApi.prototype.setColumnState = function (columnState) {
                return this._columnController.setColumnState(columnState);
            };
            ColumnApi.prototype.getColumnState = function () {
                return this._columnController.getColumnState();
            };
            ColumnApi.prototype.resetColumnState = function () {
                this._columnController.resetColumnState();
            };
            ColumnApi.prototype.isPinning = function () {
                return this._columnController.isPinningLeft() || this._columnController.isPinningRight();
            };
            ColumnApi.prototype.isPinningLeft = function () {
                return this._columnController.isPinningLeft();
            };
            ColumnApi.prototype.isPinningRight = function () {
                return this._columnController.isPinningRight();
            };
            ColumnApi.prototype.getDisplayedColAfter = function (col) {
                return this._columnController.getDisplayedColAfter(col);
            };
            ColumnApi.prototype.getDisplayedColBefore = function (col) {
                return this._columnController.getDisplayedColBefore(col);
            };
            ColumnApi.prototype.setColumnVisible = function (key, visible) {
                this._columnController.setColumnVisible(key, visible);
            };
            ColumnApi.prototype.setColumnsVisible = function (keys, visible) {
                this._columnController.setColumnsVisible(keys, visible);
            };
            ColumnApi.prototype.setColumnPinned = function (key, pinned) {
                this._columnController.setColumnPinned(key, pinned);
            };
            ColumnApi.prototype.setColumnsPinned = function (keys, pinned) {
                this._columnController.setColumnsPinned(keys, pinned);
            };
            ColumnApi.prototype.getAllColumns = function () {
                return this._columnController.getAllPrimaryColumns();
            };
            ColumnApi.prototype.getAllGridColumns = function () {
                return this._columnController.getAllGridColumns();
            };
            ColumnApi.prototype.getDisplayedLeftColumns = function () {
                return this._columnController.getDisplayedLeftColumns();
            };
            ColumnApi.prototype.getDisplayedCenterColumns = function () {
                return this._columnController.getDisplayedCenterColumns();
            };
            ColumnApi.prototype.getDisplayedRightColumns = function () {
                return this._columnController.getDisplayedRightColumns();
            };
            ColumnApi.prototype.getAllDisplayedColumns = function () {
                return this._columnController.getAllDisplayedColumns();
            };
            ColumnApi.prototype.getAllDisplayedVirtualColumns = function () {
                return this._columnController.getAllDisplayedVirtualColumns();
            };
            ColumnApi.prototype.moveColumn = function (fromIndex, toIndex) {
                this._columnController.moveColumnByIndex(fromIndex, toIndex);
            };
            ColumnApi.prototype.moveRowGroupColumn = function (fromIndex, toIndex) {
                this._columnController.moveRowGroupColumn(fromIndex, toIndex);
            };
            ColumnApi.prototype.setColumnAggFunct = function (column, aggFunc) {
                this._columnController.setColumnAggFunc(column, aggFunc);
            };
            ColumnApi.prototype.setColumnWidth = function (key, newWidth, finished) {
                if (finished === void 0) {
                    finished = true;
                }
                this._columnController.setColumnWidth(key, newWidth, finished);
            };
            ColumnApi.prototype.setPivotMode = function (pivotMode) {
                this._columnController.setPivotMode(pivotMode);
            };
            ColumnApi.prototype.isPivotMode = function () {
                return this._columnController.isPivotMode();
            };
            ColumnApi.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {
                return this._columnController.getSecondaryPivotColumn(pivotKeys, valueColKey);
            };
            ColumnApi.prototype.getValueColumns = function () {
                return this._columnController.getValueColumns();
            };
            ColumnApi.prototype.removeValueColumn = function (colKey) {
                this._columnController.removeValueColumn(colKey);
            };
            ColumnApi.prototype.removeValueColumns = function (colKeys) {
                this._columnController.removeValueColumns(colKeys);
            };
            ColumnApi.prototype.addValueColumn = function (colKey) {
                this._columnController.addValueColumn(colKey);
            };
            ColumnApi.prototype.addValueColumns = function (colKeys) {
                this._columnController.addValueColumns(colKeys);
            };
            ColumnApi.prototype.setRowGroupColumns = function (colKeys) {
                this._columnController.setRowGroupColumns(colKeys);
            };
            ColumnApi.prototype.removeRowGroupColumn = function (colKey) {
                this._columnController.removeRowGroupColumn(colKey);
            };
            ColumnApi.prototype.removeRowGroupColumns = function (colKeys) {
                this._columnController.removeRowGroupColumns(colKeys);
            };
            ColumnApi.prototype.addRowGroupColumn = function (colKey) {
                this._columnController.addRowGroupColumn(colKey);
            };
            ColumnApi.prototype.addRowGroupColumns = function (colKeys) {
                this._columnController.addRowGroupColumns(colKeys);
            };
            ColumnApi.prototype.getRowGroupColumns = function () {
                return this._columnController.getRowGroupColumns();
            };
            ColumnApi.prototype.setPivotColumns = function (colKeys) {
                this._columnController.setPivotColumns(colKeys);
            };
            ColumnApi.prototype.removePivotColumn = function (colKey) {
                this._columnController.removePivotColumn(colKey);
            };
            ColumnApi.prototype.removePivotColumns = function (colKeys) {
                this._columnController.removePivotColumns(colKeys);
            };
            ColumnApi.prototype.addPivotColumn = function (colKey) {
                this._columnController.addPivotColumn(colKey);
            };
            ColumnApi.prototype.addPivotColumns = function (colKeys) {
                this._columnController.addPivotColumns(colKeys);
            };
            ColumnApi.prototype.getPivotColumns = function () {
                return this._columnController.getPivotColumns();
            };
            ColumnApi.prototype.getLeftDisplayedColumnGroups = function () {
                return this._columnController.getLeftDisplayedColumnGroups();
            };
            ColumnApi.prototype.getCenterDisplayedColumnGroups = function () {
                return this._columnController.getCenterDisplayedColumnGroups();
            };
            ColumnApi.prototype.getRightDisplayedColumnGroups = function () {
                return this._columnController.getRightDisplayedColumnGroups();
            };
            ColumnApi.prototype.getAllDisplayedColumnGroups = function () {
                return this._columnController.getAllDisplayedColumnGroups();
            };
            ColumnApi.prototype.autoSizeColumn = function (key) {
                return this._columnController.autoSizeColumn(key);
            };
            ColumnApi.prototype.autoSizeColumns = function (keys) {
                return this._columnController.autoSizeColumns(keys);
            };
            ColumnApi.prototype.autoSizeAllColumns = function () {
                this._columnController.autoSizeAllColumns();
            };
            ColumnApi.prototype.setSecondaryColumns = function (colDefs) {
                this._columnController.setSecondaryColumns(colDefs);
            };
            // below goes through deprecated items, prints message to user, then calls the new version of the same method
            ColumnApi.prototype.columnGroupOpened = function (group, newValue) {
                console.error('ag-Grid: columnGroupOpened no longer exists, use setColumnGroupOpened');
                this.setColumnGroupOpened(group, newValue);
            };
            ColumnApi.prototype.hideColumns = function (colIds, hide) {
                console.error('ag-Grid: hideColumns is deprecated, use setColumnsVisible');
                this._columnController.setColumnsVisible(colIds, !hide);
            };
            ColumnApi.prototype.hideColumn = function (colId, hide) {
                console.error('ag-Grid: hideColumn is deprecated, use setColumnVisible');
                this._columnController.setColumnVisible(colId, !hide);
            };
            ColumnApi.prototype.setState = function (columnState) {
                console.error('ag-Grid: setState is deprecated, use setColumnState');
                return this.setColumnState(columnState);
            };
            ColumnApi.prototype.getState = function () {
                console.error('ag-Grid: getState is deprecated, use getColumnState');
                return this.getColumnState();
            };
            ColumnApi.prototype.resetState = function () {
                console.error('ag-Grid: resetState is deprecated, use resetColumnState');
                this.resetColumnState();
            };
            ColumnApi.prototype.getAggregationColumns = function () {
                console.error('ag-Grid: getAggregationColumns is deprecated, use getValueColumns');
                return this._columnController.getValueColumns();
            };
            ColumnApi.prototype.removeAggregationColumn = function (colKey) {
                console.error('ag-Grid: removeAggregationColumn is deprecated, use removeValueColumn');
                this._columnController.removeValueColumn(colKey);
            };
            ColumnApi.prototype.removeAggregationColumns = function (colKeys) {
                console.error('ag-Grid: removeAggregationColumns is deprecated, use removeValueColumns');
                this._columnController.removeValueColumns(colKeys);
            };
            ColumnApi.prototype.addAggregationColumn = function (colKey) {
                console.error('ag-Grid: addAggregationColumn is deprecated, use addValueColumn');
                this._columnController.addValueColumn(colKey);
            };
            ColumnApi.prototype.addAggregationColumns = function (colKeys) {
                console.error('ag-Grid: addAggregationColumns is deprecated, use addValueColumns');
                this._columnController.addValueColumns(colKeys);
            };
            ColumnApi.prototype.setColumnAggFunction = function (column, aggFunc) {
                console.error('ag-Grid: setColumnAggFunction is deprecated, use setColumnAggFunc');
                this._columnController.setColumnAggFunc(column, aggFunc);
            };
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', ColumnController)], ColumnApi.prototype, "_columnController", void 0);
            ColumnApi = __decorate([context_1.Bean('columnApi'), __metadata('design:paramtypes', [])], ColumnApi);
            return ColumnApi;
        }();
        exports.ColumnApi = ColumnApi;
        var ColumnController = function () {
            function ColumnController() {
                // header row count, based on user provided columns
                this.primaryHeaderRowCount = 0;
                this.secondaryHeaderRowCount = 0;
                this.secondaryColumnsPresent = false;
                // header row count, either above, or based on pivoting if we are pivoting
                this.gridHeaderRowCount = 0;
                // these are the lists used by the rowRenderer to render nodes. almost the leaf nodes of the above
                // displayed trees, however it also takes into account if the groups are open or not.
                this.displayedLeftColumns = [];
                this.displayedRightColumns = [];
                this.displayedCenterColumns = [];
                // all three lists above combined
                this.allDisplayedColumns = [];
                // same as above, except trimmed down to only columns within the viewport
                this.allDisplayedVirtualColumns = [];
                this.rowGroupColumns = [];
                this.valueColumns = [];
                this.pivotColumns = [];
                this.ready = false;
                this.pivotMode = false;
            }
            ColumnController.prototype.init = function () {
                this.pivotMode = this.gridOptionsWrapper.isPivotMode();
                if (this.gridOptionsWrapper.getColumnDefs()) {
                    this.setColumnDefs(this.gridOptionsWrapper.getColumnDefs());
                }
            };
            ColumnController.prototype.setViewportLeftAndRight = function () {
                this.viewportLeft = this.scrollPosition;
                this.viewportRight = this.totalWidth + this.scrollPosition;
            };
            ColumnController.prototype.checkDisplayedCenterColumns = function () {
                // check displayCenterColumnTree exists first, as it won't exist when grid is initialising
                if (utils_1.Utils.exists(this.displayedCenterColumns)) {
                    var hashBefore = this.allDisplayedVirtualColumns.map(function (column) {
                        return column.getId();
                    }).join('#');
                    this.updateVirtualSets();
                    var hashAfter = this.allDisplayedVirtualColumns.map(function (column) {
                        return column.getId();
                    }).join('#');
                    if (hashBefore !== hashAfter) {
                        this.eventService.dispatchEvent(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED);
                    }
                }
            };
            ColumnController.prototype.setWidthAndScrollPosition = function (totalWidth, scrollPosition) {
                if (totalWidth !== this.totalWidth || scrollPosition !== this.scrollPosition) {
                    this.totalWidth = totalWidth;
                    this.scrollPosition = scrollPosition;
                    this.setViewportLeftAndRight();
                    if (this.ready) {
                        this.checkDisplayedCenterColumns();
                    }
                }
            };
            ColumnController.prototype.isPivotMode = function () {
                return this.pivotMode;
            };
            ColumnController.prototype.setPivotMode = function (pivotMode) {
                if (pivotMode === this.pivotMode) {
                    return;
                }
                this.pivotMode = pivotMode;
                this.updateDisplayedColumns();
                var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED);
                this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, event);
            };
            ColumnController.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {
                if (!this.secondaryColumnsPresent) {
                    return null;
                }
                var valueColumnToFind = this.getPrimaryColumn(valueColKey);
                var foundColumn = null;
                this.secondaryColumns.forEach(function (column) {
                    var thisPivotKeys = column.getColDef().pivotKeys;
                    var pivotValueColumn = column.getColDef().pivotValueColumn;
                    var pivotKeyMatches = utils_1.Utils.compareArrays(thisPivotKeys, pivotKeys);
                    var pivotValueMatches = pivotValueColumn === valueColumnToFind;
                    if (pivotKeyMatches && pivotValueMatches) {
                        foundColumn = column;
                    }
                });
                return foundColumn;
            };
            ColumnController.prototype.setBeans = function (loggerFactory) {
                this.logger = loggerFactory.create('ColumnController');
            };
            ColumnController.prototype.setFirstRightAndLastLeftPinned = function () {
                var lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[this.displayedLeftColumns.length - 1] : null;
                var firstRight = this.displayedRightColumns ? this.displayedRightColumns[0] : null;
                this.gridColumns.forEach(function (column) {
                    column.setLastLeftPinned(column === lastLeft);
                    column.setFirstRightPinned(column === firstRight);
                });
            };
            ColumnController.prototype.autoSizeColumns = function (keys) {
                // because of column virtualisation, we can only do this function on columns that are
                // actually rendered, as non-rendered columns (outside the viewport and not rendered
                // due to column virtualisation) are not present. this can result in all rendered columns
                // getting narrowed, which in turn introduces more rendered columns on the RHS which
                // did not get autosized in the original run, leaving the visible grid with columns on
                // the LHS sized, but RHS no. so we keep looping through teh visible columns until
                // no more cols are available (rendered) to be resized
                var _this = this;
                // keep track of which cols we have resized in here
                var columnsAutosized = [];
                // initialise with anything except 0 so that while loop executs at least once
                var changesThisTimeAround = -1;
                while (changesThisTimeAround !== 0) {
                    changesThisTimeAround = 0;
                    this.actionOnGridColumns(keys, function (column) {
                        // if already autosized, skip it
                        if (columnsAutosized.indexOf(column) >= 0) {
                            return;
                        }
                        // get how wide this col should be
                        var preferredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column);
                        // preferredWidth = -1 if this col is not on the screen
                        if (preferredWidth > 0) {
                            var newWidth = _this.normaliseColumnWidth(column, preferredWidth);
                            column.setActualWidth(newWidth);
                            columnsAutosized.push(column);
                            changesThisTimeAround++;
                        }
                        return true;
                    }, function () {
                        return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_RESIZED).withFinished(true);
                    });
                }
            };
            ColumnController.prototype.autoSizeColumn = function (key) {
                this.autoSizeColumns([key]);
            };
            ColumnController.prototype.autoSizeAllColumns = function () {
                var allDisplayedColumns = this.getAllDisplayedColumns();
                this.autoSizeColumns(allDisplayedColumns);
            };
            ColumnController.prototype.getColumnsFromTree = function (rootColumns) {
                var result = [];
                recursiveFindColumns(rootColumns);
                return result;
                function recursiveFindColumns(childColumns) {
                    for (var i = 0; i < childColumns.length; i++) {
                        var child = childColumns[i];
                        if (child instanceof column_1.Column) {
                            result.push(child);
                        } else if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                            recursiveFindColumns(child.getChildren());
                        }
                    }
                }
            };
            ColumnController.prototype.getAllDisplayedColumnGroups = function () {
                if (this.displayedLeftColumnTree && this.displayedRightColumnTree && this.displayedCentreColumnTree) {
                    return this.displayedLeftColumnTree.concat(this.displayedCentreColumnTree).concat(this.displayedRightColumnTree);
                } else {
                    return null;
                }
            };
            ColumnController.prototype.getPrimaryColumnTree = function () {
                return this.primaryBalancedTree;
            };
            // + gridPanel -> for resizing the body and setting top margin
            ColumnController.prototype.getHeaderRowCount = function () {
                return this.gridHeaderRowCount;
            };
            // + headerRenderer -> setting pinned body width
            ColumnController.prototype.getLeftDisplayedColumnGroups = function () {
                return this.displayedLeftColumnTree;
            };
            // + headerRenderer -> setting pinned body width
            ColumnController.prototype.getRightDisplayedColumnGroups = function () {
                return this.displayedRightColumnTree;
            };
            // + headerRenderer -> setting pinned body width
            ColumnController.prototype.getCenterDisplayedColumnGroups = function () {
                return this.displayedCentreColumnTree;
            };
            ColumnController.prototype.getDisplayedColumnGroups = function (type) {
                switch (type) {
                    case column_1.Column.PINNED_LEFT:
                        return this.getLeftDisplayedColumnGroups();
                    case column_1.Column.PINNED_RIGHT:
                        return this.getRightDisplayedColumnGroups();
                    default:
                        return this.getCenterDisplayedColumnGroups();
                }
            };
            // gridPanel -> ensureColumnVisible
            ColumnController.prototype.isColumnDisplayed = function (column) {
                return this.getAllDisplayedColumns().indexOf(column) >= 0;
            };
            // + csvCreator
            ColumnController.prototype.getAllDisplayedColumns = function () {
                return this.allDisplayedColumns;
            };
            // + rowRenderer
            ColumnController.prototype.getAllDisplayedVirtualColumns = function () {
                return this.allDisplayedVirtualColumns;
            };
            // used by:
            // + angularGrid -> setting pinned body width
            // todo: this needs to be cached
            ColumnController.prototype.getPinnedLeftContainerWidth = function () {
                return this.getWidthOfColsInList(this.displayedLeftColumns);
            };
            // todo: this needs to be cached
            ColumnController.prototype.getPinnedRightContainerWidth = function () {
                return this.getWidthOfColsInList(this.displayedRightColumns);
            };
            ColumnController.prototype.addRowGroupColumns = function (keys, columnsToIncludeInEvent) {
                var _this = this;
                this.actionOnPrimaryColumns(keys, function (column) {
                    if (!column.isRowGroupActive()) {
                        _this.rowGroupColumns.push(column);
                        column.setRowGroupActive(true);
                        return true;
                    } else {
                        return false;
                    }
                }, function () {
                    return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
                }, columnsToIncludeInEvent);
            };
            ColumnController.prototype.setRowGroupColumns = function (keys) {
                var updatedColumns = [];
                this.rowGroupColumns.forEach(function (column) {
                    column.setRowGroupActive(false);
                    updatedColumns.push(column);
                });
                this.rowGroupColumns.length = 0;
                this.addRowGroupColumns(keys, updatedColumns);
            };
            ColumnController.prototype.addRowGroupColumn = function (key) {
                this.addRowGroupColumns([key]);
            };
            ColumnController.prototype.removeRowGroupColumns = function (keys) {
                var _this = this;
                this.actionOnPrimaryColumns(keys, function (column) {
                    if (column.isRowGroupActive()) {
                        utils_1.Utils.removeFromArray(_this.rowGroupColumns, column);
                        column.setRowGroupActive(false);
                        return true;
                    } else {
                        return false;
                    }
                }, function () {
                    return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
                });
            };
            ColumnController.prototype.removeRowGroupColumn = function (key) {
                this.removeRowGroupColumns([key]);
            };
            ColumnController.prototype.addPivotColumns = function (keys, columnsToIncludeInEvent) {
                var _this = this;
                this.actionOnPrimaryColumns(keys, function (column) {
                    if (!column.isPivotActive()) {
                        _this.pivotColumns.push(column);
                        column.setPivotActive(true);
                        return true;
                    } else {
                        return false;
                    }
                }, function () {
                    return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED);
                }, columnsToIncludeInEvent);
            };
            ColumnController.prototype.setPivotColumns = function (keys) {
                var updatedColumns = [];
                this.pivotColumns.forEach(function (column) {
                    column.setPivotActive(false);
                    updatedColumns.push(column);
                });
                this.pivotColumns.length = 0;
                this.addPivotColumns(keys, updatedColumns);
            };
            ColumnController.prototype.addPivotColumn = function (key) {
                this.addPivotColumns([key]);
            };
            ColumnController.prototype.removePivotColumns = function (keys) {
                var _this = this;
                this.actionOnPrimaryColumns(keys, function (column) {
                    if (column.isPivotActive()) {
                        utils_1.Utils.removeFromArray(_this.pivotColumns, column);
                        column.setPivotActive(false);
                        return true;
                    } else {
                        return false;
                    }
                }, function () {
                    return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED);
                });
            };
            ColumnController.prototype.removePivotColumn = function (key) {
                this.removePivotColumns([key]);
            };
            ColumnController.prototype.addValueColumns = function (keys) {
                var _this = this;
                this.actionOnPrimaryColumns(keys, function (column) {
                    if (!column.isValueActive()) {
                        if (!column.getAggFunc()) {
                            var defaultAggFunc = _this.aggFuncService.getDefaultAggFunc();
                            column.setAggFunc(defaultAggFunc);
                        }
                        _this.valueColumns.push(column);
                        column.setValueActive(true);
                        return true;
                    } else {
                        return false;
                    }
                }, function () {
                    return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED);
                });
            };
            ColumnController.prototype.addValueColumn = function (colKey) {
                this.addValueColumns([colKey]);
            };
            ColumnController.prototype.removeValueColumn = function (colKey) {
                this.removeValueColumns([colKey]);
            };
            ColumnController.prototype.removeValueColumns = function (keys) {
                var _this = this;
                this.actionOnPrimaryColumns(keys, function (column) {
                    if (column.isValueActive()) {
                        utils_1.Utils.removeFromArray(_this.valueColumns, column);
                        column.setValueActive(false);
                        return true;
                    } else {
                        return false;
                    }
                }, function () {
                    return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED);
                });
            };
            // returns the width we can set to this col, taking into consideration min and max widths
            ColumnController.prototype.normaliseColumnWidth = function (column, newWidth) {
                if (newWidth < column.getMinWidth()) {
                    newWidth = column.getMinWidth();
                }
                if (column.isGreaterThanMax(newWidth)) {
                    newWidth = column.getMaxWidth();
                }
                return newWidth;
            };
            ColumnController.prototype.getPrimaryOrGridColumn = function (key) {
                var column = this.getPrimaryColumn(key);
                if (column) {
                    return column;
                } else {
                    return this.getGridColumn(key);
                }
            };
            ColumnController.prototype.setColumnWidth = function (key, newWidth, finished) {
                var column = this.getPrimaryOrGridColumn(key);
                if (!column) {
                    return;
                }
                newWidth = this.normaliseColumnWidth(column, newWidth);
                var widthChanged = column.getActualWidth() !== newWidth;
                if (widthChanged) {
                    column.setActualWidth(newWidth);
                    this.setLeftValues();
                }
                // check for change first, to avoid unnecessary firing of events
                // however we always fire 'finished' events. this is important
                // when groups are resized, as if the group is changing slowly,
                // eg 1 pixel at a time, then each change will fire change events
                // in all the columns in the group, but only one with get the pixel.
                if (finished || widthChanged) {
                    var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_RESIZED).withColumn(column).withFinished(finished);
                    this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_RESIZED, event);
                }
                this.checkDisplayedCenterColumns();
            };
            ColumnController.prototype.setColumnAggFunc = function (column, aggFunc) {
                column.setAggFunc(aggFunc);
                var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED).withColumn(column);
                this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, event);
            };
            ColumnController.prototype.moveRowGroupColumn = function (fromIndex, toIndex) {
                var column = this.rowGroupColumns[fromIndex];
                this.rowGroupColumns.splice(fromIndex, 1);
                this.rowGroupColumns.splice(toIndex, 0, column);
                var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
                this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, event);
            };
            ColumnController.prototype.moveColumns = function (columnsToMoveKeys, toIndex) {
                if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {
                    console.warn('ag-Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);
                    console.warn('ag-Grid: remember that you should not count the moving columns when calculating the new index');
                    return;
                }
                // we want to pull all the columns out first and put them into an ordered list
                var columnsToMove = this.getGridColumns(columnsToMoveKeys);
                var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);
                if (failedRules) {
                    return;
                }
                this.gridPanel.turnOnAnimationForABit();
                utils_1.Utils.moveInArray(this.gridColumns, columnsToMove, toIndex);
                this.updateDisplayedColumns();
                var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_MOVED).withToIndex(toIndex).withColumns(columnsToMove);
                if (columnsToMove.length === 1) {
                    event.withColumn(columnsToMove[0]);
                }
                this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_MOVED, event);
            };
            ColumnController.prototype.doesMovePassRules = function (columnsToMove, toIndex) {
                var allColumnsCopy = this.gridColumns.slice();
                utils_1.Utils.moveInArray(allColumnsCopy, columnsToMove, toIndex);
                // look for broken groups, ie stray columns from groups that should be married
                for (var index = 0; index < allColumnsCopy.length - 1; index++) {
                    var thisColumn = allColumnsCopy[index];
                    var nextColumn = allColumnsCopy[index + 1];
                    // skip hidden columns
                    if (!nextColumn.isVisible()) {
                        continue;
                    }
                    var thisPath = this.columnUtils.getOriginalPathForColumn(thisColumn, this.gridBalancedTree);
                    var nextPath = this.columnUtils.getOriginalPathForColumn(nextColumn, this.gridBalancedTree);
                    if (!nextPath || !thisPath) {
                        console.log('next path is missing');
                    }
                    // start at the top of the path and work down
                    for (var dept = 0; dept < thisPath.length; dept++) {
                        var thisOriginalGroup = thisPath[dept];
                        var nextOriginalGroup = nextPath[dept];
                        var lastColInGroup = thisOriginalGroup !== nextOriginalGroup;
                        // a runaway is a column from this group that left the group, and the group has it's children marked as married
                        var colGroupDef = thisOriginalGroup.getColGroupDef();
                        var marryChildren = colGroupDef && colGroupDef.marryChildren;
                        var needToCheckForRunaways = lastColInGroup && marryChildren;
                        if (needToCheckForRunaways) {
                            for (var tailIndex = index + 1; tailIndex < allColumnsCopy.length; tailIndex++) {
                                var tailColumn = allColumnsCopy[tailIndex];
                                var tailPath = this.columnUtils.getOriginalPathForColumn(tailColumn, this.gridBalancedTree);
                                var tailOriginalGroup = tailPath[dept];
                                if (tailOriginalGroup === thisOriginalGroup) {
                                    return false;
                                }
                            }
                        }
                    }
                }
                return true;
            };
            ColumnController.prototype.moveColumn = function (key, toIndex) {
                this.moveColumns([key], toIndex);
            };
            ColumnController.prototype.moveColumnByIndex = function (fromIndex, toIndex) {
                var column = this.gridColumns[fromIndex];
                this.moveColumn(column, toIndex);
            };
            // used by:
            // + angularGrid -> for setting body width
            // + rowController -> setting main row widths (when inserting and resizing)
            // need to cache this
            ColumnController.prototype.getBodyContainerWidth = function () {
                var result = this.getWidthOfColsInList(this.displayedCenterColumns);
                return result;
            };
            // + rowController
            ColumnController.prototype.getValueColumns = function () {
                return this.valueColumns ? this.valueColumns : [];
            };
            // + rowController
            ColumnController.prototype.getPivotColumns = function () {
                return this.pivotColumns ? this.pivotColumns : [];
            };
            // + inMemoryRowModel
            ColumnController.prototype.isPivotActive = function () {
                return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;
            };
            // + toolPanel
            ColumnController.prototype.getRowGroupColumns = function () {
                return this.rowGroupColumns ? this.rowGroupColumns : [];
            };
            // + rowController -> while inserting rows
            ColumnController.prototype.getDisplayedCenterColumns = function () {
                return this.displayedCenterColumns.slice(0);
            };
            // + rowController -> while inserting rows
            ColumnController.prototype.getDisplayedLeftColumns = function () {
                return this.displayedLeftColumns.slice(0);
            };
            ColumnController.prototype.getDisplayedRightColumns = function () {
                return this.displayedRightColumns.slice(0);
            };
            ColumnController.prototype.getDisplayedColumns = function (type) {
                switch (type) {
                    case column_1.Column.PINNED_LEFT:
                        return this.getDisplayedLeftColumns();
                    case column_1.Column.PINNED_RIGHT:
                        return this.getDisplayedRightColumns();
                    default:
                        return this.getDisplayedCenterColumns();
                }
            };
            // used by:
            // + inMemoryRowController -> sorting, building quick filter text
            // + headerRenderer -> sorting (clearing icon)
            ColumnController.prototype.getAllPrimaryColumns = function () {
                return this.primaryColumns;
            };
            // + moveColumnController
            ColumnController.prototype.getAllGridColumns = function () {
                return this.gridColumns;
            };
            ColumnController.prototype.isEmpty = function () {
                return utils_1.Utils.missingOrEmpty(this.gridColumns);
            };
            ColumnController.prototype.isRowGroupEmpty = function () {
                return utils_1.Utils.missingOrEmpty(this.rowGroupColumns);
            };
            ColumnController.prototype.setColumnVisible = function (key, visible) {
                this.setColumnsVisible([key], visible);
            };
            ColumnController.prototype.setColumnsVisible = function (keys, visible) {
                this.gridPanel.turnOnAnimationForABit();
                this.actionOnGridColumns(keys, function (column) {
                    column.setVisible(visible);
                    return true;
                }, function () {
                    return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VISIBLE).withVisible(visible);
                });
            };
            ColumnController.prototype.setColumnPinned = function (key, pinned) {
                this.setColumnsPinned([key], pinned);
            };
            ColumnController.prototype.setColumnsPinned = function (keys, pinned) {
                this.gridPanel.turnOnAnimationForABit();
                var actualPinned;
                if (pinned === true || pinned === column_1.Column.PINNED_LEFT) {
                    actualPinned = column_1.Column.PINNED_LEFT;
                } else if (pinned === column_1.Column.PINNED_RIGHT) {
                    actualPinned = column_1.Column.PINNED_RIGHT;
                } else {
                    actualPinned = null;
                }
                this.actionOnGridColumns(keys, function (column) {
                    column.setPinned(actualPinned);
                    return true;
                }, function () {
                    return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_PINNED).withPinned(actualPinned);
                });
            };
            ColumnController.prototype.actionOnGridColumns = function (keys, action, createEvent, columnsToIncludeInEvent) {
                this.actionOnColumns(keys, this.getGridColumn.bind(this), action, createEvent, columnsToIncludeInEvent);
            };
            ColumnController.prototype.actionOnPrimaryColumns = function (keys, action, createEvent, columnsToIncludeInEvent) {
                this.actionOnColumns(keys, this.getPrimaryColumn.bind(this), action, createEvent, columnsToIncludeInEvent);
            };
            // does an action on a set of columns. provides common functionality for looking up the
            // columns based on key, getting a list of effected columns, and then updated the event
            // with either one column (if it was just one col) or a list of columns
            // used by: autoResize, setVisible, setPinned
            ColumnController.prototype.actionOnColumns = function ( // the column keys this action will be on
                keys, columnLookup,
                // the action to do - if this returns false, the column was skipped
                action,
                // should return back a column event of the right type
                createEvent, columnsToIncludeInEvent) {
                if (utils_1.Utils.missingOrEmpty(keys) && utils_1.Utils.missingOrEmpty(columnsToIncludeInEvent)) {
                    return;
                }
                var updatedColumns = [];
                keys.forEach(function (key) {
                    var column = columnLookup(key);
                    if (!column) {
                        return;
                    }
                    // need to check for false with type (ie !== instead of !=)
                    // as not returning anything (undefined) would also be false
                    var resultOfAction = action(column);
                    if (resultOfAction !== false) {
                        updatedColumns.push(column);
                    }
                });
                if (updatedColumns.length === 0 && utils_1.Utils.missingOrEmpty(columnsToIncludeInEvent)) {
                    return;
                }
                if (utils_1.Utils.existsAndNotEmpty(columnsToIncludeInEvent)) {
                    columnsToIncludeInEvent.forEach(function (column) {
                        if (updatedColumns.indexOf(column) < 0) {
                            updatedColumns.push(column);
                        }
                    });
                }
                this.updateDisplayedColumns();
                var event = createEvent();
                event.withColumns(updatedColumns);
                if (updatedColumns.length === 1) {
                    event.withColumn(updatedColumns[0]);
                }
                this.eventService.dispatchEvent(event.getType(), event);
            };
            ColumnController.prototype.getDisplayedColBefore = function (col) {
                var allDisplayedColumns = this.getAllDisplayedColumns();
                var oldIndex = allDisplayedColumns.indexOf(col);
                if (oldIndex > 0) {
                    return allDisplayedColumns[oldIndex - 1];
                } else {
                    return null;
                }
            };
            // used by:
            // + rowRenderer -> for navigation
            ColumnController.prototype.getDisplayedColAfter = function (col) {
                var allDisplayedColumns = this.getAllDisplayedColumns();
                var oldIndex = allDisplayedColumns.indexOf(col);
                if (oldIndex < allDisplayedColumns.length - 1) {
                    return allDisplayedColumns[oldIndex + 1];
                } else {
                    return null;
                }
            };
            ColumnController.prototype.isPinningLeft = function () {
                return this.displayedLeftColumns.length > 0;
            };
            ColumnController.prototype.isPinningRight = function () {
                return this.displayedRightColumns.length > 0;
            };
            ColumnController.prototype.getPrimaryAndSecondaryAndAutoColumns = function () {
                var result = this.primaryColumns ? this.primaryColumns.slice(0) : [];
                if (this.groupAutoColumnActive) {
                    result.push(this.groupAutoColumn);
                }
                if (this.secondaryColumnsPresent) {
                    this.secondaryColumns.forEach(function (column) {
                        return result.push(column);
                    });
                }
                return result;
            };
            ColumnController.prototype.createStateItemFromColumn = function (column) {
                var rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;
                var pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;
                var aggFunc = column.isValueActive() ? column.getAggFunc() : null;
                var resultItem = {
                    colId: column.getColId(),
                    hide: !column.isVisible(),
                    aggFunc: aggFunc,
                    width: column.getActualWidth(),
                    pivotIndex: pivotIndex,
                    pinned: column.getPinned(),
                    rowGroupIndex: rowGroupIndex
                };
                return resultItem;
            };
            ColumnController.prototype.getColumnState = function () {
                if (utils_1.Utils.missing(this.primaryColumns)) {
                    return [];
                }
                var columnStateList = this.primaryColumns.map(this.createStateItemFromColumn.bind(this));
                if (!this.pivotMode) {
                    this.orderColumnStateList(columnStateList);
                }
                return columnStateList;
            };
            ColumnController.prototype.orderColumnStateList = function (columnStateList) {
                var gridColumnIds = this.gridColumns.map(function (column) {
                    return column.getColId();
                });
                columnStateList.sort(function (itemA, itemB) {
                    var posA = gridColumnIds.indexOf(itemA.colId);
                    var posB = gridColumnIds.indexOf(itemB.colId);
                    return posA - posB;
                });
            };
            ColumnController.prototype.resetColumnState = function () {
                // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list
                var primaryColumns = this.getColumnsFromTree(this.primaryBalancedTree);
                var state = [];
                if (primaryColumns) {
                    primaryColumns.forEach(function (column) {
                        state.push({
                            colId: column.getColId(),
                            aggFunc: column.getColDef().aggFunc,
                            hide: column.getColDef().hide,
                            pinned: column.getColDef().pinned,
                            rowGroupIndex: column.getColDef().rowGroupIndex,
                            pivotIndex: column.getColDef().pivotIndex,
                            width: column.getColDef().width
                        });
                    });
                }
                this.setColumnState(state);
            };
            ColumnController.prototype.setColumnState = function (columnState) {
                var _this = this;
                if (utils_1.Utils.missingOrEmpty(this.primaryColumns)) {
                    return false;
                }
                // at the end below, this list will have all columns we got no state for
                var columnsWithNoState = this.primaryColumns.slice();
                this.rowGroupColumns = [];
                this.valueColumns = [];
                this.pivotColumns = [];
                var success = true;
                var rowGroupIndexes = {};
                var pivotIndexes = {};
                if (columnState) {
                    columnState.forEach(function (stateItem) {
                        var column = _this.getPrimaryColumn(stateItem.colId);
                        if (!column) {
                            console.warn('ag-grid: column ' + stateItem.colId + ' not found');
                            success = false;
                        } else {
                            _this.syncColumnWithStateItem(column, stateItem, rowGroupIndexes, pivotIndexes);
                            utils_1.Utils.removeFromArray(columnsWithNoState, column);
                        }
                    });
                }
                // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden
                columnsWithNoState.forEach(this.syncColumnWithNoState.bind(this));
                // sort the lists according to the indexes that were provided
                this.rowGroupColumns.sort(this.sortColumnListUsingIndexes.bind(this, rowGroupIndexes));
                this.pivotColumns.sort(this.sortColumnListUsingIndexes.bind(this, pivotIndexes));
                this.copyDownGridColumns();
                var orderOfColIds = columnState.map(function (stateItem) {
                    return stateItem.colId;
                });
                this.gridColumns.sort(function (colA, colB) {
                    var indexA = orderOfColIds.indexOf(colA.getId());
                    var indexB = orderOfColIds.indexOf(colB.getId());
                    return indexA - indexB;
                });
                this.updateDisplayedColumns();
                var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED);
                this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, event);
                return success;
            };
            ColumnController.prototype.sortColumnListUsingIndexes = function (indexes, colA, colB) {
                var indexA = indexes[colA.getId()];
                var indexB = indexes[colB.getId()];
                return indexA - indexB;
            };
            ColumnController.prototype.syncColumnWithNoState = function (column) {
                column.setVisible(false);
                column.setAggFunc(null);
                column.setPinned(null);
                column.setRowGroupActive(false);
                column.setPivotActive(false);
                column.setValueActive(false);
            };
            ColumnController.prototype.syncColumnWithStateItem = function (column, stateItem, rowGroupIndexes, pivotIndexes) {
                // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true
                column.setVisible(!stateItem.hide);
                // sets pinned to 'left' or 'right'
                column.setPinned(stateItem.pinned);
                // if width provided and valid, use it, otherwise stick with the old width
                if (stateItem.width >= this.gridOptionsWrapper.getMinColWidth()) {
                    column.setActualWidth(stateItem.width);
                }
                if (typeof stateItem.aggFunc === 'string') {
                    column.setAggFunc(stateItem.aggFunc);
                    column.setValueActive(true);
                    this.valueColumns.push(column);
                } else {
                    column.setAggFunc(null);
                    column.setValueActive(false);
                }
                if (typeof stateItem.rowGroupIndex === 'number') {
                    this.rowGroupColumns.push(column);
                    column.setRowGroupActive(true);
                    rowGroupIndexes[column.getId()] = stateItem.rowGroupIndex;
                } else {
                    column.setRowGroupActive(false);
                }
                if (typeof stateItem.pivotIndex === 'number') {
                    this.pivotColumns.push(column);
                    column.setPivotActive(true);
                    pivotIndexes[column.getId()] = stateItem.pivotIndex;
                } else {
                    column.setPivotActive(false);
                }
            };
            ColumnController.prototype.getGridColumns = function (keys) {
                return this.getColumns(keys, this.getGridColumn.bind(this));
            };
            ColumnController.prototype.getColumns = function (keys, columnLookupCallback) {
                var foundColumns = [];
                if (keys) {
                    keys.forEach(function (key) {
                        var column = columnLookupCallback(key);
                        if (column) {
                            foundColumns.push(column);
                        }
                    });
                }
                return foundColumns;
            };
            // used by growGroupPanel
            ColumnController.prototype.getColumnWithValidation = function (key) {
                var column = this.getPrimaryColumn(key);
                if (!column) {
                    console.warn('ag-Grid: could not find column ' + column);
                }
                return column;
            };
            ColumnController.prototype.getPrimaryColumn = function (key) {
                return this.getColumn(key, this.primaryColumns);
            };
            ColumnController.prototype.getGridColumn = function (key) {
                return this.getColumn(key, this.gridColumns);
            };
            ColumnController.prototype.getColumn = function (key, columnList) {
                if (!key) {
                    return null;
                }
                for (var i = 0; i < columnList.length; i++) {
                    if (colMatches(columnList[i])) {
                        return columnList[i];
                    }
                }
                if (this.groupAutoColumnActive && colMatches(this.groupAutoColumn)) {
                    return this.groupAutoColumn;
                }
                function colMatches(column) {
                    var columnMatches = column === key;
                    var colDefMatches = column.getColDef() === key;
                    var idMatches = column.getColId() == key;
                    return columnMatches || colDefMatches || idMatches;
                }
                return null;
            };
            ColumnController.prototype.getDisplayNameForCol = function (column, includeAggFunc) {
                if (includeAggFunc === void 0) {
                    includeAggFunc = false;
                }
                var headerName = this.getHeaderName(column);
                if (includeAggFunc) {
                    return this.wrapHeaderNameWithAggFunc(column, headerName);
                } else {
                    return headerName;
                }
            };
            ColumnController.prototype.getHeaderName = function (column) {
                var colDef = column.getColDef();
                var headerValueGetter = colDef.headerValueGetter;
                if (headerValueGetter) {
                    var params = {
                        colDef: colDef,
                        api: this.gridOptionsWrapper.getApi(),
                        context: this.gridOptionsWrapper.getContext()
                    };
                    if (typeof headerValueGetter === 'function') {
                        // valueGetter is a function, so just call it
                        return headerValueGetter(params);
                    } else if (typeof headerValueGetter === 'string') {
                        // valueGetter is an expression, so execute the expression
                        return this.expressionService.evaluate(headerValueGetter, params);
                    } else {
                        console.warn('ag-grid: headerValueGetter must be a function or a string');
                        return '';
                    }
                } else {
                    return colDef.headerName;
                }
            };
            ColumnController.prototype.wrapHeaderNameWithAggFunc = function (column, headerName) {
                if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) {
                    return headerName;
                }
                // only columns with aggregation active can have aggregations
                var pivotValueColumn = column.getColDef().pivotValueColumn;
                var pivotActiveOnThisColumn = utils_1.Utils.exists(pivotValueColumn);
                var aggFunc = null;
                var aggFuncFound;
                // otherwise we have a measure that is active, and we are doing aggregation on it
                if (pivotActiveOnThisColumn) {
                    aggFunc = pivotValueColumn.getAggFunc();
                    aggFuncFound = true;
                } else {
                    var measureActive = column.isValueActive();
                    var aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();
                    if (measureActive && aggregationPresent) {
                        aggFunc = column.getAggFunc();
                        aggFuncFound = true;
                    } else {
                        aggFuncFound = false;
                    }
                }
                if (aggFuncFound) {
                    var aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'func';
                    return aggFuncString + "(" + headerName + ")";
                } else {
                    return headerName;
                }
            };
            // returns the group with matching colId and instanceId. If instanceId is missing,
            // matches only on the colId.
            ColumnController.prototype.getColumnGroup = function (colId, instanceId) {
                if (!colId) {
                    return null;
                }
                if (colId instanceof columnGroup_1.ColumnGroup) {
                    return colId;
                }
                var allColumnGroups = this.getAllDisplayedColumnGroups();
                var checkInstanceId = typeof instanceId === 'number';
                var result = null;
                this.columnUtils.deptFirstAllColumnTreeSearch(allColumnGroups, function (child) {
                    if (child instanceof columnGroup_1.ColumnGroup) {
                        var columnGroup = child;
                        var matched;
                        if (checkInstanceId) {
                            matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();
                        } else {
                            matched = colId === columnGroup.getGroupId();
                        }
                        if (matched) {
                            result = columnGroup;
                        }
                    }
                });
                return result;
            };
            ColumnController.prototype.setColumnDefs = function (columnDefs) {
                var balancedTreeResult = this.balancedColumnTreeBuilder.createBalancedColumnGroups(columnDefs, true);
                this.primaryBalancedTree = balancedTreeResult.balancedTree;
                this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;
                this.primaryColumns = this.getColumnsFromTree(this.primaryBalancedTree);
                this.extractRowGroupColumns();
                this.extractPivotColumns();
                this.createValueColumns();
                this.copyDownGridColumns();
                this.updateDisplayedColumns();
                this.ready = true;
                var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED);
                this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, event);
                this.eventService.dispatchEvent(events_1.Events.EVENT_NEW_COLUMNS_LOADED);
            };
            ColumnController.prototype.isReady = function () {
                return this.ready;
            };
            ColumnController.prototype.extractRowGroupColumns = function () {
                var _this = this;
                this.rowGroupColumns.forEach(function (column) {
                    return column.setRowGroupActive(false);
                });
                this.rowGroupColumns = [];
                // pull out the columns
                this.primaryColumns.forEach(function (column) {
                    if (typeof column.getColDef().rowGroupIndex === 'number') {
                        _this.rowGroupColumns.push(column);
                        column.setRowGroupActive(true);
                    }
                });
                // then sort them
                this.rowGroupColumns.sort(function (colA, colB) {
                    return colA.getColDef().rowGroupIndex - colB.getColDef().rowGroupIndex;
                });
            };
            ColumnController.prototype.extractPivotColumns = function () {
                var _this = this;
                this.pivotColumns.forEach(function (column) {
                    return column.setPivotActive(false);
                });
                this.pivotColumns = [];
                // pull out the columns
                this.primaryColumns.forEach(function (column) {
                    if (typeof column.getColDef().pivotIndex === 'number') {
                        _this.pivotColumns.push(column);
                        column.setPivotActive(true);
                    }
                });
                // then sort them
                this.pivotColumns.sort(function (colA, colB) {
                    return colA.getColDef().pivotIndex - colB.getColDef().pivotIndex;
                });
            };
            // called by headerRenderer - when a header is opened or closed
            ColumnController.prototype.setColumnGroupOpened = function (passedGroup, newValue, instanceId) {
                var groupToUse = this.getColumnGroup(passedGroup, instanceId);
                if (!groupToUse) {
                    return;
                }
                this.logger.log('columnGroupOpened(' + groupToUse.getGroupId() + ',' + newValue + ')');
                groupToUse.setExpanded(newValue);
                this.gridPanel.turnOnAnimationForABit();
                this.updateGroupsAndDisplayedColumns();
                var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_GROUP_OPENED).withColumnGroup(groupToUse);
                this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_GROUP_OPENED, event);
            };
            // used by updateModel
            ColumnController.prototype.getColumnGroupState = function () {
                var groupState = {};
                this.columnUtils.deptFirstDisplayedColumnTreeSearch(this.getAllDisplayedColumnGroups(), function (child) {
                    if (child instanceof columnGroup_1.ColumnGroup) {
                        var columnGroup = child;
                        var key = columnGroup.getGroupId();
                        // if more than one instance of the group, we only record the state of the first item
                        if (!groupState.hasOwnProperty(key)) {
                            groupState[key] = columnGroup.isExpanded();
                        }
                    }
                });
                return groupState;
            };
            // used by updateModel
            ColumnController.prototype.setColumnGroupState = function (groupState) {
                this.columnUtils.deptFirstDisplayedColumnTreeSearch(this.getAllDisplayedColumnGroups(), function (child) {
                    if (child instanceof columnGroup_1.ColumnGroup) {
                        var columnGroup = child;
                        var key = columnGroup.getGroupId();
                        var shouldExpandGroup = groupState[key] === true && columnGroup.isExpandable();
                        if (shouldExpandGroup) {
                            columnGroup.setExpanded(true);
                        }
                    }
                });
            };
            ColumnController.prototype.calculateColumnsForDisplay = function () {
                var columnsForDisplay;
                if (this.pivotMode && !this.secondaryColumnsPresent) {
                    // pivot mode is on, but we are not pivoting, so we only
                    // show columns we are aggregating on
                    columnsForDisplay = this.createColumnsToDisplayFromValueColumns();
                } else {
                    // otherwise continue as normal. this can be working on the primary
                    // or secondary columns, whatever the gridColumns are set to
                    columnsForDisplay = utils_1.Utils.filter(this.gridColumns, function (column) {
                        return column.isVisible();
                    });
                }
                this.createGroupAutoColumn();
                if (this.groupAutoColumnActive) {
                    columnsForDisplay.unshift(this.groupAutoColumn);
                }
                return columnsForDisplay;
            };
            ColumnController.prototype.createColumnsToDisplayFromValueColumns = function () {
                var _this = this;
                // make a copy of the value columns, so we have to side effects
                var result = this.valueColumns.slice();
                // order the columns as per the grid columns. having the order is
                // important as without it, reordering of columns would have no impact
                result.sort(function (colA, colB) {
                    return _this.gridColumns.indexOf(colA) - _this.gridColumns.indexOf(colB);
                });
                return result;
            };
            ColumnController.prototype.updateDisplayedColumns = function () {
                // save opened / closed state
                var oldGroupState = this.getColumnGroupState();
                var columnsForDisplay = this.calculateColumnsForDisplay();
                this.buildDisplayedTrees(columnsForDisplay);
                // restore opened / closed state
                this.setColumnGroupState(oldGroupState);
                // this is also called when a group is opened or closed
                this.updateGroupsAndDisplayedColumns();
                this.setFirstRightAndLastLeftPinned();
            };
            ColumnController.prototype.isSecondaryColumnsPresent = function () {
                return this.secondaryColumnsPresent;
            };
            ColumnController.prototype.setSecondaryColumns = function (colDefs) {
                var newColsPresent = colDefs && colDefs.length > 0;
                // if not cols passed, and we had to cols anyway, then do nothing
                if (!newColsPresent && !this.secondaryColumnsPresent) {
                    return;
                }
                if (newColsPresent) {
                    var balancedTreeResult = this.balancedColumnTreeBuilder.createBalancedColumnGroups(colDefs, false);
                    this.secondaryBalancedTree = balancedTreeResult.balancedTree;
                    this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;
                    this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);
                    this.secondaryColumnsPresent = true;
                } else {
                    this.secondaryBalancedTree = null;
                    this.secondaryHeaderRowCount = -1;
                    this.secondaryColumns = null;
                    this.secondaryColumnsPresent = false;
                }
                this.copyDownGridColumns();
                this.updateDisplayedColumns();
            };
            // called from: setColumnState, setColumnDefs, setAlternativeColumnDefs
            ColumnController.prototype.copyDownGridColumns = function () {
                if (this.secondaryColumns) {
                    this.gridBalancedTree = this.secondaryBalancedTree.slice();
                    this.gridHeaderRowCount = this.secondaryHeaderRowCount;
                    this.gridColumns = this.secondaryColumns.slice();
                } else {
                    this.gridBalancedTree = this.primaryBalancedTree.slice();
                    this.gridHeaderRowCount = this.primaryHeaderRowCount;
                    this.gridColumns = this.primaryColumns.slice();
                }
                this.clearDisplayedColumns();
                var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_GRID_COLUMNS_CHANGED);
                this.eventService.dispatchEvent(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, event);
            };
            // gets called after we copy down grid columns, to make sure any part of the gui
            // that tries to draw, eg the header, it will get empty lists of columns rather
            // than stale columns. for example, the header will received gridColumnsChanged
            // event, so will try and draw, but it will draw successfully when it acts on the
            // virtualColumnsChanged event
            ColumnController.prototype.clearDisplayedColumns = function () {
                this.displayedLeftColumnTree = [];
                this.displayedRightColumnTree = [];
                this.displayedCentreColumnTree = [];
                this.displayedLeftHeaderRows = {};
                this.displayedRightHeaderRows = {};
                this.displayedCentreHeaderRows = {};
                this.displayedLeftColumns = [];
                this.displayedRightColumns = [];
                this.displayedCenterColumns = [];
                this.allDisplayedColumns = [];
                this.allDisplayedVirtualColumns = [];
            };
            ColumnController.prototype.updateGroupsAndDisplayedColumns = function () {
                this.updateGroups();
                this.updateDisplayedColumnsFromTrees();
                this.updateVirtualSets();
                // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display
                var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED);
                this.eventService.dispatchEvent(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, event);
            };
            ColumnController.prototype.updateDisplayedColumnsFromTrees = function () {
                this.addToDisplayedColumns(this.displayedLeftColumnTree, this.displayedLeftColumns);
                this.addToDisplayedColumns(this.displayedCentreColumnTree, this.displayedCenterColumns);
                this.addToDisplayedColumns(this.displayedRightColumnTree, this.displayedRightColumns);
                // order we add the arrays together is important, so the result
                // has the columns left to right, as they appear on the screen.
                this.allDisplayedColumns = this.displayedLeftColumns.concat(this.displayedCenterColumns).concat(this.displayedRightColumns);
                this.setLeftValues();
            };
            // sets the left pixel position of each column
            ColumnController.prototype.setLeftValues = function () {
                this.setLeftValuesOfColumns();
                this.setLeftValuesOfGroups();
            };
            ColumnController.prototype.setLeftValuesOfColumns = function () {
                // go through each list of displayed columns
                var allColumns = this.primaryColumns.slice(0);
                [this.displayedLeftColumns, this.displayedRightColumns, this.displayedCenterColumns].forEach(function (columns) {
                    var left = 0;
                    columns.forEach(function (column) {
                        column.setLeft(left);
                        left += column.getActualWidth();
                        utils_1.Utils.removeFromArray(allColumns, column);
                    });
                });
                // items left in allColumns are columns not displayed, so remove the left position. this is
                // important for the rows, as if a col is made visible, then taken out, then made visible again,
                // we don't want the animation of the cell floating in from the old position, whatever that was.
                allColumns.forEach(function (column) {
                    column.setLeft(null);
                });
            };
            ColumnController.prototype.setLeftValuesOfGroups = function () {
                // a groups left value is the lest left value of it's children
                [this.displayedLeftColumnTree, this.displayedRightColumnTree, this.displayedCentreColumnTree].forEach(function (columns) {
                    columns.forEach(function (column) {
                        if (column instanceof columnGroup_1.ColumnGroup) {
                            var columnGroup = column;
                            columnGroup.checkLeft();
                        }
                    });
                });
            };
            ColumnController.prototype.addToDisplayedColumns = function (displayedColumnTree, displayedColumns) {
                displayedColumns.length = 0;
                this.columnUtils.deptFirstDisplayedColumnTreeSearch(displayedColumnTree, function (child) {
                    if (child instanceof column_1.Column) {
                        displayedColumns.push(child);
                    }
                });
            };
            ColumnController.prototype.updateDisplayedCenterVirtualColumns = function () {
                var filteredCenterColumns;
                var skipVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation() || this.gridOptionsWrapper.isForPrint();
                if (skipVirtualisation) {
                    // no virtualisation, so don't filter
                    filteredCenterColumns = this.displayedCenterColumns;
                } else {
                    // filter out what should be visible
                    filteredCenterColumns = this.filterOutColumnsWithinViewport(this.displayedCenterColumns);
                }
                this.allDisplayedVirtualColumns = filteredCenterColumns.concat(this.displayedLeftColumns).concat(this.displayedRightColumns);
                // return map of virtual col id's, for easy lookup when building the groups.
                // the map will be colId=>true, ie col id's mapping to 'true'.
                var result = {};
                this.allDisplayedVirtualColumns.forEach(function (col) {
                    result[col.getId()] = true;
                });
                return result;
            };
            ColumnController.prototype.getVirtualHeaderGroupRow = function (type, dept) {
                var result;
                switch (type) {
                    case column_1.Column.PINNED_LEFT:
                        result = this.displayedLeftHeaderRows[dept];
                        break;
                    case column_1.Column.PINNED_RIGHT:
                        result = this.displayedRightHeaderRows[dept];
                        break;
                    default:
                        result = this.displayedCentreHeaderRows[dept];
                        break;
                }
                if (utils_1.Utils.missing(result)) {
                    result = [];
                }
                return result;
            };
            ColumnController.prototype.updateDisplayedVirtualGroups = function (virtualColIds) {
                // go through each group, see if any of it's cols are displayed, and if yes,
                // then this group is included
                this.displayedLeftHeaderRows = {};
                this.displayedRightHeaderRows = {};
                this.displayedCentreHeaderRows = {};
                testGroup(this.displayedLeftColumnTree, this.displayedLeftHeaderRows, 0);
                testGroup(this.displayedRightColumnTree, this.displayedRightHeaderRows, 0);
                testGroup(this.displayedCentreColumnTree, this.displayedCentreHeaderRows, 0);
                function testGroup(children, result, dept) {
                    var returnValue = false;
                    for (var i = 0; i < children.length; i++) {
                        // see if this item is within viewport
                        var child = children[i];
                        var addThisItem;
                        if (child instanceof column_1.Column) {
                            // for column, test if column is included
                            addThisItem = virtualColIds[child.getId()] === true;
                        } else {
                            // if group, base decision on children
                            var columnGroup = child;
                            addThisItem = testGroup(columnGroup.getDisplayedChildren(), result, dept + 1);
                        }
                        if (addThisItem) {
                            returnValue = true;
                            if (!result[dept]) {
                                result[dept] = [];
                            }
                            result[dept].push(child);
                        }
                    }
                    return returnValue;
                }
            };
            ColumnController.prototype.updateVirtualSets = function () {
                var virtualColIds = this.updateDisplayedCenterVirtualColumns();
                this.updateDisplayedVirtualGroups(virtualColIds);
            };
            ColumnController.prototype.filterOutColumnsWithinViewport = function (columns) {
                var _this = this;
                var result = utils_1.Utils.filter(columns, function (column) {
                    // only out if both sides of columns are to the left or to the right of the boundary
                    var columnLeft = column.getLeft();
                    var columnRight = column.getLeft() + column.getActualWidth();
                    var columnToMuchLeft = columnLeft < _this.viewportLeft && columnRight < _this.viewportLeft;
                    var columnToMuchRight = columnLeft > _this.viewportRight && columnRight > _this.viewportRight;
                    var includeThisCol = !columnToMuchLeft && !columnToMuchRight;
                    return includeThisCol;
                });
                return result;
            };
            // called from api
            ColumnController.prototype.sizeColumnsToFit = function (gridWidth) {
                var _this = this;
                // avoid divide by zero
                var allDisplayedColumns = this.getAllDisplayedColumns();
                if (gridWidth <= 0 || allDisplayedColumns.length === 0) {
                    return;
                }
                var colsToNotSpread = utils_1.Utils.filter(allDisplayedColumns, function (column) {
                    return column.getColDef().suppressSizeToFit === true;
                });
                var colsToSpread = utils_1.Utils.filter(allDisplayedColumns, function (column) {
                    return column.getColDef().suppressSizeToFit !== true;
                });
                // make a copy of the cols that are going to be resized
                var colsToFireEventFor = colsToSpread.slice(0);
                var finishedResizing = false;
                while (!finishedResizing) {
                    finishedResizing = true;
                    var availablePixels = gridWidth - getTotalWidth(colsToNotSpread);
                    if (availablePixels <= 0) {
                        // no width, set everything to minimum
                        colsToSpread.forEach(function (column) {
                            column.setMinimum();
                        });
                    } else {
                        var scale = availablePixels / getTotalWidth(colsToSpread);
                        // we set the pixels for the last col based on what's left, as otherwise
                        // we could be a pixel or two short or extra because of rounding errors.
                        var pixelsForLastCol = availablePixels;
                        // backwards through loop, as we are removing items as we go
                        for (var i = colsToSpread.length - 1; i >= 0; i--) {
                            var column = colsToSpread[i];
                            var newWidth = Math.round(column.getActualWidth() * scale);
                            if (newWidth < column.getMinWidth()) {
                                column.setMinimum();
                                moveToNotSpread(column);
                                finishedResizing = false;
                            } else if (column.isGreaterThanMax(newWidth)) {
                                column.setActualWidth(column.getMaxWidth());
                                moveToNotSpread(column);
                                finishedResizing = false;
                            } else {
                                var onLastCol = i === 0;
                                if (onLastCol) {
                                    column.setActualWidth(pixelsForLastCol);
                                } else {
                                    column.setActualWidth(newWidth);
                                }
                            }
                            pixelsForLastCol -= newWidth;
                        }
                    }
                }
                this.setLeftValues();
                // widths set, refresh the gui
                colsToFireEventFor.forEach(function (column) {
                    var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_RESIZED).withColumn(column);
                    _this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_RESIZED, event);
                });
                this.checkDisplayedCenterColumns();
                function moveToNotSpread(column) {
                    utils_1.Utils.removeFromArray(colsToSpread, column);
                    colsToNotSpread.push(column);
                }
                function getTotalWidth(columns) {
                    var result = 0;
                    for (var i = 0; i < columns.length; i++) {
                        result += columns[i].getActualWidth();
                    }
                    return result;
                }
            };
            ColumnController.prototype.buildDisplayedTrees = function (visibleColumns) {
                var leftVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
                    return column.getPinned() === 'left';
                });
                var rightVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
                    return column.getPinned() === 'right';
                });
                var centerVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
                    return column.getPinned() !== 'left' && column.getPinned() !== 'right';
                });
                var groupInstanceIdCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();
                this.displayedLeftColumnTree = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator);
                this.displayedRightColumnTree = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator);
                this.displayedCentreColumnTree = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator);
            };
            ColumnController.prototype.updateGroups = function () {
                var allGroups = this.getAllDisplayedColumnGroups();
                this.columnUtils.deptFirstAllColumnTreeSearch(allGroups, function (child) {
                    if (child instanceof columnGroup_1.ColumnGroup) {
                        var group = child;
                        group.calculateDisplayedColumns();
                    }
                });
            };
            ColumnController.prototype.createGroupAutoColumn = function () {
                // see if we need to insert the default grouping column
                var needAGroupColumn = this.rowGroupColumns.length > 0 && !this.gridOptionsWrapper.isGroupSuppressAutoColumn() && !this.gridOptionsWrapper.isGroupUseEntireRow() && !this.gridOptionsWrapper.isGroupSuppressRow();
                this.groupAutoColumnActive = needAGroupColumn;
                // lazy create group auto-column
                if (needAGroupColumn && !this.groupAutoColumn) {
                    // if one provided by user, use it, otherwise create one
                    var autoColDef = this.gridOptionsWrapper.getGroupColumnDef();
                    if (!autoColDef) {
                        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                        autoColDef = {
                            headerName: localeTextFunc('group', 'Group'),
                            comparator: functions_1.defaultGroupComparator,
                            valueGetter: function valueGetter(params) {
                                if (params.node.group) {
                                    return params.node.key;
                                } else if (params.data && params.colDef.field) {
                                    return params.data[params.colDef.field];
                                } else {
                                    return null;
                                }
                            },
                            cellRenderer: 'group'
                        };
                    }
                    // we never allow moving the group column
                    autoColDef.suppressMovable = true;
                    var colId = ColumnController.GROUP_AUTO_COLUMN_ID;
                    this.groupAutoColumn = new column_1.Column(autoColDef, colId, true);
                    this.context.wireBean(this.groupAutoColumn);
                }
            };
            ColumnController.prototype.createValueColumns = function () {
                this.valueColumns.forEach(function (column) {
                    return column.setValueActive(false);
                });
                this.valueColumns = [];
                // override with columns that have the aggFunc specified explicitly
                for (var i = 0; i < this.primaryColumns.length; i++) {
                    var column = this.primaryColumns[i];
                    if (column.getColDef().aggFunc) {
                        column.setAggFunc(column.getColDef().aggFunc);
                        this.valueColumns.push(column);
                        column.setValueActive(true);
                    }
                }
            };
            ColumnController.prototype.getWidthOfColsInList = function (columnList) {
                var result = 0;
                for (var i = 0; i < columnList.length; i++) {
                    result += columnList[i].getActualWidth();
                }
                return result;
            };
            ColumnController.GROUP_AUTO_COLUMN_ID = 'ag-Grid-AutoColumn';
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], ColumnController.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('expressionService'), __metadata('design:type', expressionService_1.ExpressionService)], ColumnController.prototype, "expressionService", void 0);
            __decorate([context_1.Autowired('balancedColumnTreeBuilder'), __metadata('design:type', balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder)], ColumnController.prototype, "balancedColumnTreeBuilder", void 0);
            __decorate([context_1.Autowired('displayedGroupCreator'), __metadata('design:type', displayedGroupCreator_1.DisplayedGroupCreator)], ColumnController.prototype, "displayedGroupCreator", void 0);
            __decorate([context_1.Autowired('autoWidthCalculator'), __metadata('design:type', autoWidthCalculator_1.AutoWidthCalculator)], ColumnController.prototype, "autoWidthCalculator", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], ColumnController.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('columnUtils'), __metadata('design:type', columnUtils_1.ColumnUtils)], ColumnController.prototype, "columnUtils", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], ColumnController.prototype, "gridPanel", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], ColumnController.prototype, "context", void 0);
            __decorate([context_1.Optional('aggFuncService'), __metadata('design:type', Object)], ColumnController.prototype, "aggFuncService", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ColumnController.prototype, "init", null);
            __decorate([__param(0, context_1.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], ColumnController.prototype, "setBeans", null);
            ColumnController = __decorate([context_1.Bean('columnController'), __metadata('design:paramtypes', [])], ColumnController);
            return ColumnController;
        }();
        exports.ColumnController = ColumnController;

        /***/ },
    /* 252 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var column_1 = __webpack_require__(253);
        var eventService_1 = __webpack_require__(242);
        var ColumnGroup = function () {
            function ColumnGroup(originalColumnGroup, groupId, instanceId) {
                // depends on the open/closed state of the group, only displaying columns are stored here
                this.displayedChildren = [];
                this.moving = false;
                this.eventService = new eventService_1.EventService();
                this.groupId = groupId;
                this.instanceId = instanceId;
                this.originalColumnGroup = originalColumnGroup;
            }
            ColumnGroup.prototype.getUniqueId = function () {
                return this.groupId + '_' + this.instanceId;
            };
            // returns header name if it exists, otherwise null. if will not exist if
            // this group is a padding group, as they don't have colGroupDef's
            ColumnGroup.prototype.getHeaderName = function () {
                if (this.originalColumnGroup.getColGroupDef()) {
                    return this.originalColumnGroup.getColGroupDef().headerName;
                } else {
                    return null;
                }
            };
            ColumnGroup.prototype.checkLeft = function () {
                // first get all children to setLeft, as it impacts our decision below
                this.displayedChildren.forEach(function (child) {
                    if (child instanceof ColumnGroup) {
                        child.checkLeft();
                    }
                });
                // set our left based on first displayed column
                if (this.displayedChildren.length > 0) {
                    var firstChildLeft = this.displayedChildren[0].getLeft();
                    this.setLeft(firstChildLeft);
                } else {
                    // this should never happen, as if we have no displayed columns, then
                    // this groups should not even exist.
                    this.setLeft(null);
                }
            };
            ColumnGroup.prototype.getLeft = function () {
                return this.left;
            };
            ColumnGroup.prototype.setLeft = function (left) {
                if (this.left !== left) {
                    this.left = left;
                    this.eventService.dispatchEvent(ColumnGroup.EVENT_LEFT_CHANGED);
                }
            };
            ColumnGroup.prototype.addEventListener = function (eventType, listener) {
                this.eventService.addEventListener(eventType, listener);
            };
            ColumnGroup.prototype.removeEventListener = function (eventType, listener) {
                this.eventService.removeEventListener(eventType, listener);
            };
            ColumnGroup.prototype.setMoving = function (moving) {
                this.getDisplayedLeafColumns().forEach(function (column) {
                    return column.setMoving(moving);
                });
            };
            ColumnGroup.prototype.isMoving = function () {
                return this.moving;
            };
            ColumnGroup.prototype.getGroupId = function () {
                return this.groupId;
            };
            ColumnGroup.prototype.getInstanceId = function () {
                return this.instanceId;
            };
            ColumnGroup.prototype.isChildInThisGroupDeepSearch = function (wantedChild) {
                var result = false;
                this.children.forEach(function (foundChild) {
                    if (wantedChild === foundChild) {
                        result = true;
                    }
                    if (foundChild instanceof ColumnGroup) {
                        if (foundChild.isChildInThisGroupDeepSearch(wantedChild)) {
                            result = true;
                        }
                    }
                });
                return result;
            };
            ColumnGroup.prototype.getActualWidth = function () {
                var groupActualWidth = 0;
                if (this.displayedChildren) {
                    this.displayedChildren.forEach(function (child) {
                        groupActualWidth += child.getActualWidth();
                    });
                }
                return groupActualWidth;
            };
            ColumnGroup.prototype.getMinWidth = function () {
                var result = 0;
                this.displayedChildren.forEach(function (groupChild) {
                    result += groupChild.getMinWidth();
                });
                return result;
            };
            ColumnGroup.prototype.addChild = function (child) {
                if (!this.children) {
                    this.children = [];
                }
                this.children.push(child);
            };
            ColumnGroup.prototype.getDisplayedChildren = function () {
                return this.displayedChildren;
            };
            ColumnGroup.prototype.getLeafColumns = function () {
                var result = [];
                this.addLeafColumns(result);
                return result;
            };
            ColumnGroup.prototype.getDisplayedLeafColumns = function () {
                var result = [];
                this.addDisplayedLeafColumns(result);
                return result;
            };
            // why two methods here doing the same thing?
            ColumnGroup.prototype.getDefinition = function () {
                return this.originalColumnGroup.getColGroupDef();
            };
            ColumnGroup.prototype.getColGroupDef = function () {
                return this.originalColumnGroup.getColGroupDef();
            };
            ColumnGroup.prototype.isExpandable = function () {
                return this.originalColumnGroup.isExpandable();
            };
            ColumnGroup.prototype.isExpanded = function () {
                return this.originalColumnGroup.isExpanded();
            };
            ColumnGroup.prototype.setExpanded = function (expanded) {
                this.originalColumnGroup.setExpanded(expanded);
            };
            ColumnGroup.prototype.addDisplayedLeafColumns = function (leafColumns) {
                this.displayedChildren.forEach(function (child) {
                    if (child instanceof column_1.Column) {
                        leafColumns.push(child);
                    } else if (child instanceof ColumnGroup) {
                        child.addDisplayedLeafColumns(leafColumns);
                    }
                });
            };
            ColumnGroup.prototype.addLeafColumns = function (leafColumns) {
                this.children.forEach(function (child) {
                    if (child instanceof column_1.Column) {
                        leafColumns.push(child);
                    } else if (child instanceof ColumnGroup) {
                        child.addLeafColumns(leafColumns);
                    }
                });
            };
            ColumnGroup.prototype.getChildren = function () {
                return this.children;
            };
            ColumnGroup.prototype.getColumnGroupShow = function () {
                return this.originalColumnGroup.getColumnGroupShow();
            };
            ColumnGroup.prototype.getOriginalColumnGroup = function () {
                return this.originalColumnGroup;
            };
            ColumnGroup.prototype.calculateDisplayedColumns = function () {
                // clear out last time we calculated
                this.displayedChildren = [];
                // it not expandable, everything is visible
                if (!this.originalColumnGroup.isExpandable()) {
                    this.displayedChildren = this.children;
                    return;
                }
                // and calculate again
                for (var i = 0, j = this.children.length; i < j; i++) {
                    var abstractColumn = this.children[i];
                    var headerGroupShow = abstractColumn.getColumnGroupShow();
                    switch (headerGroupShow) {
                        case ColumnGroup.HEADER_GROUP_SHOW_OPEN:
                            // when set to open, only show col if group is open
                            if (this.originalColumnGroup.isExpanded()) {
                                this.displayedChildren.push(abstractColumn);
                            }
                            break;
                        case ColumnGroup.HEADER_GROUP_SHOW_CLOSED:
                            // when set to open, only show col if group is open
                            if (!this.originalColumnGroup.isExpanded()) {
                                this.displayedChildren.push(abstractColumn);
                            }
                            break;
                        default:
                            // default is always show the column
                            this.displayedChildren.push(abstractColumn);
                            break;
                    }
                }
            };
            ColumnGroup.HEADER_GROUP_SHOW_OPEN = 'open';
            ColumnGroup.HEADER_GROUP_SHOW_CLOSED = 'closed';
            ColumnGroup.EVENT_LEFT_CHANGED = 'leftChanged';
            return ColumnGroup;
        }();
        exports.ColumnGroup = ColumnGroup;

        /***/ },
    /* 253 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var eventService_1 = __webpack_require__(242);
        var utils_1 = __webpack_require__(245);
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnUtils_1 = __webpack_require__(254);
        // Wrapper around a user provide column definition. The grid treats the column definition as ready only.
        // This class contains all the runtime information about a column, plus some logic (the definition has no logic).
        // This class implements both interfaces ColumnGroupChild and OriginalColumnGroupChild as the class can
        // appear as a child of either the original tree or the displayed tree. However the relevant group classes
        // for each type only implements one, as each group can only appear in it's associated tree (eg OriginalColumnGroup
        // can only appear in OriginalColumn tree).
        var Column = function () {
            function Column(colDef, colId, primary) {
                this.moving = false;
                this.filterActive = false;
                this.eventService = new eventService_1.EventService();
                this.rowGroupActive = false;
                this.pivotActive = false;
                this.aggregationActive = false;
                this.colDef = colDef;
                this.visible = !colDef.hide;
                this.sort = colDef.sort;
                this.sortedAt = colDef.sortedAt;
                this.colId = colId;
                this.primary = primary;
            }
            // this is done after constructor as it uses gridOptionsWrapper
            Column.prototype.initialise = function () {
                this.floatingCellRenderer = this.frameworkFactory.colDefFloatingCellRenderer(this.colDef);
                this.cellRenderer = this.frameworkFactory.colDefCellRenderer(this.colDef);
                this.cellEditor = this.frameworkFactory.colDefCellEditor(this.colDef);
                this.filter = this.frameworkFactory.colDefFilter(this.colDef);
                this.setPinned(this.colDef.pinned);
                var minColWidth = this.gridOptionsWrapper.getMinColWidth();
                var maxColWidth = this.gridOptionsWrapper.getMaxColWidth();
                if (this.colDef.minWidth) {
                    this.minWidth = this.colDef.minWidth;
                } else {
                    this.minWidth = minColWidth;
                }
                if (this.colDef.maxWidth) {
                    this.maxWidth = this.colDef.maxWidth;
                } else {
                    this.maxWidth = maxColWidth;
                }
                this.actualWidth = this.columnUtils.calculateColInitialWidth(this.colDef);
                var suppressDotNotation = this.gridOptionsWrapper.isSuppressFieldDotNotation();
                this.fieldContainsDots = utils_1.Utils.exists(this.colDef.field) && this.colDef.field.indexOf('.') >= 0 && !suppressDotNotation;
                this.tooltipFieldContainsDots = utils_1.Utils.exists(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf('.') >= 0 && !suppressDotNotation;
                this.validate();
            };
            Column.prototype.getCellRenderer = function () {
                return this.cellRenderer;
            };
            Column.prototype.getCellEditor = function () {
                return this.cellEditor;
            };
            Column.prototype.getFloatingCellRenderer = function () {
                return this.floatingCellRenderer;
            };
            Column.prototype.getFilter = function () {
                return this.filter;
            };
            Column.prototype.getUniqueId = function () {
                return this.getId();
            };
            Column.prototype.isPrimary = function () {
                return this.primary;
            };
            Column.prototype.isFilterAllowed = function () {
                return this.primary && !this.colDef.suppressFilter;
            };
            Column.prototype.isFieldContainsDots = function () {
                return this.fieldContainsDots;
            };
            Column.prototype.isTooltipFieldContainsDots = function () {
                return this.tooltipFieldContainsDots;
            };
            Column.prototype.validate = function () {
                if (!this.gridOptionsWrapper.isEnterprise()) {
                    if (utils_1.Utils.exists(this.colDef.aggFunc)) {
                        console.warn('ag-Grid: aggFunc is only valid in ag-Grid-Enterprise');
                    }
                    if (utils_1.Utils.exists(this.colDef.rowGroupIndex)) {
                        console.warn('ag-Grid: rowGroupIndex is only valid in ag-Grid-Enterprise');
                    }
                }
                if (utils_1.Utils.exists(this.colDef.width) && typeof this.colDef.width !== 'number') {
                    console.warn('ag-Grid: colDef.width should be a number, not ' + _typeof(this.colDef.width));
                }
            };
            Column.prototype.addEventListener = function (eventType, listener) {
                this.eventService.addEventListener(eventType, listener);
            };
            Column.prototype.removeEventListener = function (eventType, listener) {
                this.eventService.removeEventListener(eventType, listener);
            };
            Column.prototype.isCellEditable = function (rowNode) {
                // if boolean set, then just use it
                if (typeof this.colDef.editable === 'boolean') {
                    return this.colDef.editable;
                }
                // if function, then call the function to find out
                if (typeof this.colDef.editable === 'function') {
                    var params = {
                        node: rowNode,
                        column: this,
                        colDef: this.colDef,
                        context: this.gridOptionsWrapper.getContext(),
                        api: this.gridOptionsWrapper.getApi(),
                        columnApi: this.gridOptionsWrapper.getColumnApi()
                    };
                    var editableFunc = this.colDef.editable;
                    return editableFunc(params);
                }
                return false;
            };
            Column.prototype.setMoving = function (moving) {
                this.moving = moving;
                this.eventService.dispatchEvent(Column.EVENT_MOVING_CHANGED);
            };
            Column.prototype.isMoving = function () {
                return this.moving;
            };
            Column.prototype.getSort = function () {
                return this.sort;
            };
            Column.prototype.setSort = function (sort) {
                if (this.sort !== sort) {
                    this.sort = sort;
                    this.eventService.dispatchEvent(Column.EVENT_SORT_CHANGED);
                }
            };
            Column.prototype.isSortAscending = function () {
                return this.sort === Column.SORT_ASC;
            };
            Column.prototype.isSortDescending = function () {
                return this.sort === Column.SORT_DESC;
            };
            Column.prototype.isSortNone = function () {
                return utils_1.Utils.missing(this.sort);
            };
            Column.prototype.getSortedAt = function () {
                return this.sortedAt;
            };
            Column.prototype.setSortedAt = function (sortedAt) {
                this.sortedAt = sortedAt;
            };
            Column.prototype.setAggFunc = function (aggFunc) {
                this.aggFunc = aggFunc;
            };
            Column.prototype.getAggFunc = function () {
                return this.aggFunc;
            };
            Column.prototype.getLeft = function () {
                return this.left;
            };
            Column.prototype.getRight = function () {
                return this.left + this.actualWidth;
            };
            Column.prototype.setLeft = function (left) {
                if (this.left !== left) {
                    this.left = left;
                    this.eventService.dispatchEvent(Column.EVENT_LEFT_CHANGED);
                }
            };
            Column.prototype.isFilterActive = function () {
                return this.filterActive;
            };
            Column.prototype.setFilterActive = function (active) {
                if (this.filterActive !== active) {
                    this.filterActive = active;
                    this.eventService.dispatchEvent(Column.EVENT_FILTER_CHANGED);
                }
            };
            Column.prototype.setPinned = function (pinned) {
                // pinning is not allowed when doing 'forPrint'
                if (this.gridOptionsWrapper.isForPrint()) {
                    return;
                }
                if (pinned === true || pinned === Column.PINNED_LEFT) {
                    this.pinned = Column.PINNED_LEFT;
                } else if (pinned === Column.PINNED_RIGHT) {
                    this.pinned = Column.PINNED_RIGHT;
                } else {
                    this.pinned = null;
                }
                // console.log(`setColumnsPinned ${this.getColId()} ${this.pinned}`);
            };
            Column.prototype.setFirstRightPinned = function (firstRightPinned) {
                if (this.firstRightPinned !== firstRightPinned) {
                    this.firstRightPinned = firstRightPinned;
                    this.eventService.dispatchEvent(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED);
                }
            };
            Column.prototype.setLastLeftPinned = function (lastLeftPinned) {
                if (this.lastLeftPinned !== lastLeftPinned) {
                    this.lastLeftPinned = lastLeftPinned;
                    this.eventService.dispatchEvent(Column.EVENT_LAST_LEFT_PINNED_CHANGED);
                }
            };
            Column.prototype.isFirstRightPinned = function () {
                return this.firstRightPinned;
            };
            Column.prototype.isLastLeftPinned = function () {
                return this.lastLeftPinned;
            };
            Column.prototype.isPinned = function () {
                return this.pinned === Column.PINNED_LEFT || this.pinned === Column.PINNED_RIGHT;
            };
            Column.prototype.isPinnedLeft = function () {
                return this.pinned === Column.PINNED_LEFT;
            };
            Column.prototype.isPinnedRight = function () {
                return this.pinned === Column.PINNED_RIGHT;
            };
            Column.prototype.getPinned = function () {
                return this.pinned;
            };
            Column.prototype.setVisible = function (visible) {
                var newValue = visible === true;
                if (this.visible !== newValue) {
                    this.visible = newValue;
                    this.eventService.dispatchEvent(Column.EVENT_VISIBLE_CHANGED);
                }
            };
            Column.prototype.isVisible = function () {
                return this.visible;
            };
            Column.prototype.getColDef = function () {
                return this.colDef;
            };
            Column.prototype.getColumnGroupShow = function () {
                return this.colDef.columnGroupShow;
            };
            Column.prototype.getColId = function () {
                return this.colId;
            };
            Column.prototype.getId = function () {
                return this.getColId();
            };
            Column.prototype.getDefinition = function () {
                return this.colDef;
            };
            Column.prototype.getActualWidth = function () {
                return this.actualWidth;
            };
            Column.prototype.setActualWidth = function (actualWidth) {
                if (this.actualWidth !== actualWidth) {
                    this.actualWidth = actualWidth;
                    this.eventService.dispatchEvent(Column.EVENT_WIDTH_CHANGED);
                }
            };
            Column.prototype.isGreaterThanMax = function (width) {
                if (this.maxWidth) {
                    return width > this.maxWidth;
                } else {
                    return false;
                }
            };
            Column.prototype.getMinWidth = function () {
                return this.minWidth;
            };
            Column.prototype.getMaxWidth = function () {
                return this.maxWidth;
            };
            Column.prototype.setMinimum = function () {
                this.setActualWidth(this.minWidth);
            };
            Column.prototype.setRowGroupActive = function (rowGroup) {
                if (this.rowGroupActive !== rowGroup) {
                    this.rowGroupActive = rowGroup;
                    this.eventService.dispatchEvent(Column.EVENT_ROW_GROUP_CHANGED, this);
                }
            };
            Column.prototype.isRowGroupActive = function () {
                return this.rowGroupActive;
            };
            Column.prototype.setPivotActive = function (pivot) {
                if (this.pivotActive !== pivot) {
                    this.pivotActive = pivot;
                    this.eventService.dispatchEvent(Column.EVENT_PIVOT_CHANGED, this);
                }
            };
            Column.prototype.isPivotActive = function () {
                return this.pivotActive;
            };
            Column.prototype.isAnyFunctionActive = function () {
                return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
            };
            Column.prototype.isAnyFunctionAllowed = function () {
                return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
            };
            Column.prototype.setValueActive = function (value) {
                if (this.aggregationActive !== value) {
                    this.aggregationActive = value;
                    this.eventService.dispatchEvent(Column.EVENT_VALUE_CHANGED, this);
                }
            };
            Column.prototype.isValueActive = function () {
                return this.aggregationActive;
            };
            Column.prototype.isAllowPivot = function () {
                return this.colDef.enablePivot === true;
            };
            Column.prototype.isAllowValue = function () {
                return this.colDef.enableValue === true;
            };
            Column.prototype.isAllowRowGroup = function () {
                return this.colDef.enableRowGroup === true;
            };
            // + renderedHeaderCell - for making header cell transparent when moving
            Column.EVENT_MOVING_CHANGED = 'movingChanged';
            // + renderedCell - changing left position
            Column.EVENT_LEFT_CHANGED = 'leftChanged';
            // + renderedCell - changing width
            Column.EVENT_WIDTH_CHANGED = 'widthChanged';
            // + renderedCell - for changing pinned classes
            Column.EVENT_LAST_LEFT_PINNED_CHANGED = 'lastLeftPinnedChanged';
            Column.EVENT_FIRST_RIGHT_PINNED_CHANGED = 'firstRightPinnedChanged';
            // + renderedColumn - for changing visibility icon
            Column.EVENT_VISIBLE_CHANGED = 'visibleChanged';
            // + renderedHeaderCell - marks the header with filter icon
            Column.EVENT_FILTER_CHANGED = 'filterChanged';
            // + renderedHeaderCell - marks the header with sort icon
            Column.EVENT_SORT_CHANGED = 'sortChanged';
            // + toolpanel, for gui updates
            Column.EVENT_ROW_GROUP_CHANGED = 'columnRowGroupChanged';
            // + toolpanel, for gui updates
            Column.EVENT_PIVOT_CHANGED = 'columnPivotChanged';
            // + toolpanel, for gui updates
            Column.EVENT_VALUE_CHANGED = 'columnValueChanged';
            Column.PINNED_RIGHT = 'right';
            Column.PINNED_LEFT = 'left';
            Column.SORT_ASC = 'asc';
            Column.SORT_DESC = 'desc';
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], Column.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('columnUtils'), __metadata('design:type', columnUtils_1.ColumnUtils)], Column.prototype, "columnUtils", void 0);
            __decorate([context_1.Autowired('frameworkFactory'), __metadata('design:type', Object)], Column.prototype, "frameworkFactory", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], Column.prototype, "initialise", null);
            return Column;
        }();
        exports.Column = Column;

        /***/ },
    /* 254 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnGroup_1 = __webpack_require__(252);
        var originalColumnGroup_1 = __webpack_require__(255);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        // takes in a list of columns, as specified by the column definitions, and returns column groups
        var ColumnUtils = function () {
            function ColumnUtils() {}
            ColumnUtils.prototype.calculateColInitialWidth = function (colDef) {
                if (!colDef.width) {
                    // if no width defined in colDef, use default
                    return this.gridOptionsWrapper.getColWidth();
                } else if (colDef.width < this.gridOptionsWrapper.getMinColWidth()) {
                    // if width in col def to small, set to min width
                    return this.gridOptionsWrapper.getMinColWidth();
                } else {
                    // otherwise use the provided width
                    return colDef.width;
                }
            };
            ColumnUtils.prototype.getOriginalPathForColumn = function (column, originalBalancedTree) {
                var result = [];
                var found = false;
                recursePath(originalBalancedTree, 0);
                // we should always find the path, but in case there is a bug somewhere, returning null
                // will make it fail rather than provide a 'hard to track down' bug
                if (found) {
                    return result;
                } else {
                    return null;
                }
                function recursePath(balancedColumnTree, dept) {
                    for (var i = 0; i < balancedColumnTree.length; i++) {
                        if (found) {
                            // quit the search, so 'result' is kept with the found result
                            return;
                        }
                        var node = balancedColumnTree[i];
                        if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
                            var nextNode = node;
                            recursePath(nextNode.getChildren(), dept + 1);
                            result[dept] = node;
                        } else {
                            if (node === column) {
                                found = true;
                            }
                        }
                    }
                }
            };
            /*    public getPathForColumn(column: Column, allDisplayedColumnGroups: ColumnGroupChild[]): ColumnGroup[] {
             var result: ColumnGroup[] = [];
             var found = false;

             recursePath(allDisplayedColumnGroups, 0);

             // we should always find the path, but in case there is a bug somewhere, returning null
             // will make it fail rather than provide a 'hard to track down' bug
             if (found) {
             return result;
             } else {
             return null;
             }

             function recursePath(balancedColumnTree: ColumnGroupChild[], dept: number): void {

             for (var i = 0; i<balancedColumnTree.length; i++) {
             if (found) {
             // quit the search, so 'result' is kept with the found result
             return;
             }
             var node = balancedColumnTree[i];
             if (node instanceof ColumnGroup) {
             var nextNode = <ColumnGroup> node;
             recursePath(nextNode.getChildren(), dept+1);
             result[dept] = node;
             } else {
             if (node === column) {
             found = true;
             }
             }
             }
             }
             }*/
            ColumnUtils.prototype.deptFirstOriginalTreeSearch = function (tree, callback) {
                var _this = this;
                if (!tree) {
                    return;
                }
                tree.forEach(function (child) {
                    if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                        _this.deptFirstOriginalTreeSearch(child.getChildren(), callback);
                    }
                    callback(child);
                });
            };
            ColumnUtils.prototype.deptFirstAllColumnTreeSearch = function (tree, callback) {
                var _this = this;
                if (!tree) {
                    return;
                }
                tree.forEach(function (child) {
                    if (child instanceof columnGroup_1.ColumnGroup) {
                        _this.deptFirstAllColumnTreeSearch(child.getChildren(), callback);
                    }
                    callback(child);
                });
            };
            ColumnUtils.prototype.deptFirstDisplayedColumnTreeSearch = function (tree, callback) {
                var _this = this;
                if (!tree) {
                    return;
                }
                tree.forEach(function (child) {
                    if (child instanceof columnGroup_1.ColumnGroup) {
                        _this.deptFirstDisplayedColumnTreeSearch(child.getDisplayedChildren(), callback);
                    }
                    callback(child);
                });
            };
            __decorate([context_2.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], ColumnUtils.prototype, "gridOptionsWrapper", void 0);
            ColumnUtils = __decorate([context_1.Bean('columnUtils'), __metadata('design:paramtypes', [])], ColumnUtils);
            return ColumnUtils;
        }();
        exports.ColumnUtils = ColumnUtils;

        /***/ },
    /* 255 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var columnGroup_1 = __webpack_require__(252);
        var column_1 = __webpack_require__(253);
        var OriginalColumnGroup = function () {
            function OriginalColumnGroup(colGroupDef, groupId) {
                this.expandable = false;
                this.colGroupDef = colGroupDef;
                this.groupId = groupId;
                this.expanded = colGroupDef && !!colGroupDef.openByDefault;
            }
            OriginalColumnGroup.prototype.setExpanded = function (expanded) {
                this.expanded = expanded;
            };
            OriginalColumnGroup.prototype.isExpandable = function () {
                return this.expandable;
            };
            OriginalColumnGroup.prototype.isExpanded = function () {
                return this.expanded;
            };
            OriginalColumnGroup.prototype.getGroupId = function () {
                return this.groupId;
            };
            OriginalColumnGroup.prototype.getId = function () {
                return this.getGroupId();
            };
            OriginalColumnGroup.prototype.setChildren = function (children) {
                this.children = children;
            };
            OriginalColumnGroup.prototype.getChildren = function () {
                return this.children;
            };
            OriginalColumnGroup.prototype.getColGroupDef = function () {
                return this.colGroupDef;
            };
            OriginalColumnGroup.prototype.getLeafColumns = function () {
                var result = [];
                this.addLeafColumns(result);
                return result;
            };
            OriginalColumnGroup.prototype.addLeafColumns = function (leafColumns) {
                this.children.forEach(function (child) {
                    if (child instanceof column_1.Column) {
                        leafColumns.push(child);
                    } else if (child instanceof OriginalColumnGroup) {
                        child.addLeafColumns(leafColumns);
                    }
                });
            };
            OriginalColumnGroup.prototype.getColumnGroupShow = function () {
                if (this.colGroupDef) {
                    return this.colGroupDef.columnGroupShow;
                } else {
                    // if there is no col def, then this must be a padding
                    // group, which means we have exactly only child. we then
                    // take the value from the child and push it up, making
                    // this group 'invisible'.
                    return this.children[0].getColumnGroupShow();
                }
            };
            // need to check that this group has at least one col showing when both expanded and contracted.
            // if not, then we don't allow expanding and contracting on this group
            OriginalColumnGroup.prototype.calculateExpandable = function () {
                // want to make sure the group doesn't disappear when it's open
                var atLeastOneShowingWhenOpen = false;
                // want to make sure the group doesn't disappear when it's closed
                var atLeastOneShowingWhenClosed = false;
                // want to make sure the group has something to show / hide
                var atLeastOneChangeable = false;
                for (var i = 0, j = this.children.length; i < j; i++) {
                    var abstractColumn = this.children[i];
                    // if the abstractColumn is a grid generated group, there will be no colDef
                    var headerGroupShow = abstractColumn.getColumnGroupShow();
                    if (headerGroupShow === columnGroup_1.ColumnGroup.HEADER_GROUP_SHOW_OPEN) {
                        atLeastOneShowingWhenOpen = true;
                        atLeastOneChangeable = true;
                    } else if (headerGroupShow === columnGroup_1.ColumnGroup.HEADER_GROUP_SHOW_CLOSED) {
                        atLeastOneShowingWhenClosed = true;
                        atLeastOneChangeable = true;
                    } else {
                        atLeastOneShowingWhenOpen = true;
                        atLeastOneShowingWhenClosed = true;
                    }
                }
                this.expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
            };
            return OriginalColumnGroup;
        }();
        exports.OriginalColumnGroup = OriginalColumnGroup;

        /***/ },
    /* 256 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var logger_1 = __webpack_require__(243);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var ExpressionService = function () {
            function ExpressionService() {
                this.expressionToFunctionCache = {};
            }
            ExpressionService.prototype.setBeans = function (loggerFactory) {
                this.logger = loggerFactory.create('ExpressionService');
            };
            ExpressionService.prototype.evaluate = function (expression, params) {
                try {
                    var javaScriptFunction = this.createExpressionFunction(expression);
                    var result = javaScriptFunction(params.value, params.context, params.node, params.data, params.colDef, params.rowIndex, params.api, params.getValue);
                    return result;
                } catch (e) {
                    // the expression failed, which can happen, as it's the client that
                    // provides the expression. so print a nice message
                    this.logger.log('Processing of the expression failed');
                    this.logger.log('Expression = ' + expression);
                    this.logger.log('Exception = ' + e);
                    return null;
                }
            };
            ExpressionService.prototype.createExpressionFunction = function (expression) {
                // check cache first
                if (this.expressionToFunctionCache[expression]) {
                    return this.expressionToFunctionCache[expression];
                }
                // if not found in cache, return the function
                var functionBody = this.createFunctionBody(expression);
                var theFunction = new Function('x, ctx, node, data, colDef, rowIndex, api, getValue', functionBody);
                // store in cache
                this.expressionToFunctionCache[expression] = theFunction;
                return theFunction;
            };
            ExpressionService.prototype.createFunctionBody = function (expression) {
                // if the expression has the 'return' word in it, then use as is,
                // if not, then wrap it with return and ';' to make a function
                if (expression.indexOf('return') >= 0) {
                    return expression;
                } else {
                    return 'return ' + expression + ';';
                }
            };
            __decorate([__param(0, context_2.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], ExpressionService.prototype, "setBeans", null);
            ExpressionService = __decorate([context_1.Bean('expressionService'), __metadata('design:paramtypes', [])], ExpressionService);
            return ExpressionService;
        }();
        exports.ExpressionService = ExpressionService;

        /***/ },
    /* 257 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var logger_1 = __webpack_require__(243);
        var columnUtils_1 = __webpack_require__(254);
        var columnKeyCreator_1 = __webpack_require__(258);
        var originalColumnGroup_1 = __webpack_require__(255);
        var column_1 = __webpack_require__(253);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var context_3 = __webpack_require__(244);
        var context_4 = __webpack_require__(244);
        // takes in a list of columns, as specified by the column definitions, and returns column groups
        var BalancedColumnTreeBuilder = function () {
            function BalancedColumnTreeBuilder() {}
            BalancedColumnTreeBuilder.prototype.setBeans = function (loggerFactory) {
                this.logger = loggerFactory.create('BalancedColumnTreeBuilder');
            };
            BalancedColumnTreeBuilder.prototype.createBalancedColumnGroups = function (abstractColDefs, primaryColumns) {
                // column key creator dishes out unique column id's in a deterministic way,
                // so if we have two grids (that cold be master/slave) with same column definitions,
                // then this ensures the two grids use identical id's.
                var columnKeyCreator = new columnKeyCreator_1.ColumnKeyCreator();
                // create am unbalanced tree that maps the provided definitions
                var unbalancedTree = this.recursivelyCreateColumns(abstractColDefs, 0, columnKeyCreator, primaryColumns);
                var treeDept = this.findMaxDept(unbalancedTree, 0);
                this.logger.log('Number of levels for grouped columns is ' + treeDept);
                var balancedTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);
                this.columnUtils.deptFirstOriginalTreeSearch(balancedTree, function (child) {
                    if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                        child.calculateExpandable();
                    }
                });
                return {
                    balancedTree: balancedTree,
                    treeDept: treeDept
                };
            };
            BalancedColumnTreeBuilder.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {
                var _this = this;
                var result = [];
                // go through each child, for groups, recurse a level deeper,
                // for columns we need to pad
                unbalancedTree.forEach(function (child) {
                    if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
                        var originalGroup = child;
                        var newChildren = _this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);
                        originalGroup.setChildren(newChildren);
                        result.push(originalGroup);
                    } else {
                        var newChild = child;
                        for (var i = columnDept - 1; i >= currentDept; i--) {
                            var newColId = columnKeyCreator.getUniqueKey(null, null);
                            var paddedGroup = new originalColumnGroup_1.OriginalColumnGroup(null, newColId);
                            paddedGroup.setChildren([newChild]);
                            newChild = paddedGroup;
                        }
                        result.push(newChild);
                    }
                });
                return result;
            };
            BalancedColumnTreeBuilder.prototype.findMaxDept = function (treeChildren, dept) {
                var maxDeptThisLevel = dept;
                for (var i = 0; i < treeChildren.length; i++) {
                    var abstractColumn = treeChildren[i];
                    if (abstractColumn instanceof originalColumnGroup_1.OriginalColumnGroup) {
                        var originalGroup = abstractColumn;
                        var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);
                        if (maxDeptThisLevel < newDept) {
                            maxDeptThisLevel = newDept;
                        }
                    }
                }
                return maxDeptThisLevel;
            };
            BalancedColumnTreeBuilder.prototype.recursivelyCreateColumns = function (abstractColDefs, level, columnKeyCreator, primaryColumns) {
                var _this = this;
                var result = [];
                if (!abstractColDefs) {
                    return result;
                }
                abstractColDefs.forEach(function (abstractColDef) {
                    _this.checkForDeprecatedItems(abstractColDef);
                    if (_this.isColumnGroup(abstractColDef)) {
                        var groupColDef = abstractColDef;
                        var groupId = columnKeyCreator.getUniqueKey(groupColDef.groupId, null);
                        var originalGroup = new originalColumnGroup_1.OriginalColumnGroup(groupColDef, groupId);
                        var children = _this.recursivelyCreateColumns(groupColDef.children, level + 1, columnKeyCreator, primaryColumns);
                        originalGroup.setChildren(children);
                        result.push(originalGroup);
                    } else {
                        var colDef = abstractColDef;
                        var colId = columnKeyCreator.getUniqueKey(colDef.colId, colDef.field);
                        var column = new column_1.Column(colDef, colId, primaryColumns);
                        _this.context.wireBean(column);
                        result.push(column);
                    }
                });
                return result;
            };
            BalancedColumnTreeBuilder.prototype.checkForDeprecatedItems = function (colDef) {
                if (colDef) {
                    var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type
                    if (colDefNoType.group !== undefined) {
                        console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');
                    }
                    if (colDefNoType.headerGroup !== undefined) {
                        console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');
                    }
                    if (colDefNoType.headerGroupShow !== undefined) {
                        console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');
                    }
                    if (colDefNoType.suppressRowGroup !== undefined) {
                        console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');
                    }
                    if (colDefNoType.suppressAggregation !== undefined) {
                        console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');
                    }
                    if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {
                        console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');
                    }
                    if (colDefNoType.displayName) {
                        console.warn("ag-grid: Found displayName " + colDefNoType.displayName + ", please use headerName instead, displayName is deprecated.");
                        colDefNoType.headerName = colDefNoType.displayName;
                    }
                }
            };
            // if object has children, we assume it's a group
            BalancedColumnTreeBuilder.prototype.isColumnGroup = function (abstractColDef) {
                return abstractColDef.children !== undefined;
            };
            __decorate([context_3.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], BalancedColumnTreeBuilder.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_3.Autowired('columnUtils'), __metadata('design:type', columnUtils_1.ColumnUtils)], BalancedColumnTreeBuilder.prototype, "columnUtils", void 0);
            __decorate([context_3.Autowired('context'), __metadata('design:type', context_4.Context)], BalancedColumnTreeBuilder.prototype, "context", void 0);
            __decorate([__param(0, context_2.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], BalancedColumnTreeBuilder.prototype, "setBeans", null);
            BalancedColumnTreeBuilder = __decorate([context_1.Bean('balancedColumnTreeBuilder'), __metadata('design:paramtypes', [])], BalancedColumnTreeBuilder);
            return BalancedColumnTreeBuilder;
        }();
        exports.BalancedColumnTreeBuilder = BalancedColumnTreeBuilder;

        /***/ },
    /* 258 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
            // class returns a unique id to use for the column. it checks the existing columns, and if the requested
            // id is already taken, it will start appending numbers until it gets a unique id.
            // eg, if the col field is 'name', it will try ids: {name, name_1, name_2...}
            // if no field or id provided in the col, it will try the ids of natural numbers
        var utils_1 = __webpack_require__(245);
        var ColumnKeyCreator = function () {
            function ColumnKeyCreator() {
                this.existingKeys = [];
            }
            ColumnKeyCreator.prototype.getUniqueKey = function (colId, colField) {
                // in case user passed in number for colId, convert to string
                colId = utils_1.Utils.toStringOrNull(colId);
                var count = 0;
                while (true) {
                    var idToTry;
                    if (colId) {
                        idToTry = colId;
                        if (count !== 0) {
                            idToTry += '_' + count;
                        }
                    } else if (colField) {
                        idToTry = colField;
                        if (count !== 0) {
                            idToTry += '_' + count;
                        }
                    } else {
                        idToTry = '' + count;
                    }
                    if (this.existingKeys.indexOf(idToTry) < 0) {
                        this.existingKeys.push(idToTry);
                        return idToTry;
                    }
                    count++;
                }
            };
            return ColumnKeyCreator;
        }();
        exports.ColumnKeyCreator = ColumnKeyCreator;

        /***/ },
    /* 259 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var columnUtils_1 = __webpack_require__(254);
        var columnGroup_1 = __webpack_require__(252);
        var originalColumnGroup_1 = __webpack_require__(255);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        // takes in a list of columns, as specified by the column definitions, and returns column groups
        var DisplayedGroupCreator = function () {
            function DisplayedGroupCreator() {}
            DisplayedGroupCreator.prototype.createDisplayedGroups = function (sortedVisibleColumns, balancedColumnTree, groupInstanceIdCreator) {
                var _this = this;
                var result = [];
                var previousRealPath;
                var previousOriginalPath;
                // go through each column, then do a bottom up comparison to the previous column, and start
                // to share groups if they converge at any point.
                sortedVisibleColumns.forEach(function (currentColumn) {
                    var currentOriginalPath = _this.getOriginalPathForColumn(balancedColumnTree, currentColumn);
                    var currentRealPath = [];
                    var firstColumn = !previousOriginalPath;
                    for (var i = 0; i < currentOriginalPath.length; i++) {
                        if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {
                            // new group needed
                            var originalGroup = currentOriginalPath[i];
                            var groupId = originalGroup.getGroupId();
                            var instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
                            var newGroup = new columnGroup_1.ColumnGroup(originalGroup, groupId, instanceId);
                            currentRealPath[i] = newGroup;
                            // if top level, add to result, otherwise add to parent
                            if (i == 0) {
                                result.push(newGroup);
                            } else {
                                currentRealPath[i - 1].addChild(newGroup);
                            }
                        } else {
                            // reuse old group
                            currentRealPath[i] = previousRealPath[i];
                        }
                    }
                    var noColumnGroups = currentRealPath.length === 0;
                    if (noColumnGroups) {
                        // if we are not grouping, then the result of the above is an empty
                        // path (no groups), and we just add the column to the root list.
                        result.push(currentColumn);
                    } else {
                        var leafGroup = currentRealPath[currentRealPath.length - 1];
                        leafGroup.addChild(currentColumn);
                    }
                    previousRealPath = currentRealPath;
                    previousOriginalPath = currentOriginalPath;
                });
                return result;
            };
            DisplayedGroupCreator.prototype.createFakePath = function (balancedColumnTree) {
                var result = [];
                var currentChildren = balancedColumnTree;
                // this while look does search on the balanced tree, so our result is the right length
                var index = 0;
                while (currentChildren && currentChildren[0] && currentChildren[0] instanceof originalColumnGroup_1.OriginalColumnGroup) {
                    // putting in a deterministic fake id, in case the API in the future needs to reference the col
                    result.push(new originalColumnGroup_1.OriginalColumnGroup(null, 'FAKE_PATH_' + index));
                    currentChildren = currentChildren[0].getChildren();
                    index++;
                }
                return result;
            };
            DisplayedGroupCreator.prototype.getOriginalPathForColumn = function (balancedColumnTree, column) {
                var result = [];
                var found = false;
                recursePath(balancedColumnTree, 0);
                // it's possible we didn't find a path. this happens if the column is generated
                // by the grid, in that the definition didn't come from the client. in this case,
                // we create a fake original path.
                if (found) {
                    return result;
                } else {
                    return this.createFakePath(balancedColumnTree);
                }
                function recursePath(balancedColumnTree, dept) {
                    for (var i = 0; i < balancedColumnTree.length; i++) {
                        if (found) {
                            // quit the search, so 'result' is kept with the found result
                            return;
                        }
                        var node = balancedColumnTree[i];
                        if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
                            var nextNode = node;
                            recursePath(nextNode.getChildren(), dept + 1);
                            result[dept] = node;
                        } else {
                            if (node === column) {
                                found = true;
                            }
                        }
                    }
                }
            };
            __decorate([context_2.Autowired('columnUtils'), __metadata('design:type', columnUtils_1.ColumnUtils)], DisplayedGroupCreator.prototype, "columnUtils", void 0);
            DisplayedGroupCreator = __decorate([context_1.Bean('displayedGroupCreator'), __metadata('design:paramtypes', [])], DisplayedGroupCreator);
            return DisplayedGroupCreator;
        }();
        exports.DisplayedGroupCreator = DisplayedGroupCreator;

        /***/ },
    /* 260 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var rowRenderer_1 = __webpack_require__(261);
        var gridPanel_1 = __webpack_require__(262);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var headerRenderer_1 = __webpack_require__(304);
        var renderedHeaderCell_1 = __webpack_require__(311);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var AutoWidthCalculator = function () {
            function AutoWidthCalculator() {}
            // this is the trick: we create a dummy container and clone all the cells
            // into the dummy, then check the dummy's width. then destroy the dummy
            // as we don't need it any more.
            // drawback: only the cells visible on the screen are considered
            AutoWidthCalculator.prototype.getPreferredWidthForColumn = function (column) {
                var renderedHeaderCell = this.getHeaderCellForColumn(column);
                // cell isn't visible
                if (!renderedHeaderCell) {
                    return -1;
                }
                var eDummyContainer = document.createElement('span');
                // position fixed, so it isn't restricted to the boundaries of the parent
                eDummyContainer.style.position = 'fixed';
                // we put the dummy into the body container, so it will inherit all the
                // css styles that the real cells are inheriting
                var eBodyContainer = this.gridPanel.getBodyContainer();
                eBodyContainer.appendChild(eDummyContainer);
                // get all the cells that are currently displayed (this only brings back
                // rendered cells, rows not rendered due to row visualisation will not be here)
                this.putRowCellsIntoDummyContainer(column, eDummyContainer);
                // also put header cell in
                // we only consider the lowest level cell, not the group cell. in 99% of the time, this
                // will be enough. if we consider groups, then it gets to complicated for what it's worth,
                // as the groups can span columns and this class only considers one column at a time.
                this.cloneItemIntoDummy(renderedHeaderCell.getGui(), eDummyContainer);
                // at this point, all the clones are lined up vertically with natural widths. the dummy
                // container will have a width wide enough just to fit the largest.
                var dummyContainerWidth = eDummyContainer.offsetWidth;
                // we are finished with the dummy container, so get rid of it
                eBodyContainer.removeChild(eDummyContainer);
                // we add padding as I found without it, the gui still put '...' after some of the texts
                var autoSizePadding = this.gridOptionsWrapper.getAutoSizePadding();
                if (typeof autoSizePadding !== 'number' || autoSizePadding < 0) {
                    autoSizePadding = 4;
                }
                return dummyContainerWidth + autoSizePadding;
            };
            AutoWidthCalculator.prototype.getHeaderCellForColumn = function (column) {
                var renderedHeaderCell = null;
                // find the rendered header cell
                this.headerRenderer.forEachHeaderElement(function (headerElement) {
                    if (headerElement instanceof renderedHeaderCell_1.RenderedHeaderCell) {
                        var currentCell = headerElement;
                        if (currentCell.getColumn() === column) {
                            renderedHeaderCell = currentCell;
                        }
                    }
                });
                return renderedHeaderCell;
            };
            AutoWidthCalculator.prototype.putRowCellsIntoDummyContainer = function (column, eDummyContainer) {
                var _this = this;
                var eOriginalCells = this.rowRenderer.getAllCellsForColumn(column);
                eOriginalCells.forEach(function (eCell, index) {
                    _this.cloneItemIntoDummy(eCell, eDummyContainer);
                });
            };
            AutoWidthCalculator.prototype.cloneItemIntoDummy = function (eCell, eDummyContainer) {
                // make a deep clone of the cell
                var eCellClone = eCell.cloneNode(true);
                // the original has a fixed width, we remove this to allow the natural width based on content
                eCellClone.style.width = '';
                // the original has position = absolute, we need to remove this so it's positioned normally
                eCellClone.style.position = 'static';
                eCellClone.style.left = '';
                // we put the cell into a containing div, as otherwise the cells would just line up
                // on the same line, standard flow layout, by putting them into divs, they are laid
                // out one per line
                var eCloneParent = document.createElement('div');
                // table-row, so that each cell is on a row. i also tried display='block', but this
                // didn't work in IE
                eCloneParent.style.display = 'table-row';
                // the twig on the branch, the branch on the tree, the tree in the hole,
                // the hole in the bog, the bog in the clone, the clone in the parent,
                // the parent in the dummy, and the dummy down in the vall-e-ooo, OOOOOOOOO! Oh row the rattling bog....
                eCloneParent.appendChild(eCellClone);
                eDummyContainer.appendChild(eCloneParent);
            };
            __decorate([context_2.Autowired('rowRenderer'), __metadata('design:type', rowRenderer_1.RowRenderer)], AutoWidthCalculator.prototype, "rowRenderer", void 0);
            __decorate([context_2.Autowired('headerRenderer'), __metadata('design:type', headerRenderer_1.HeaderRenderer)], AutoWidthCalculator.prototype, "headerRenderer", void 0);
            __decorate([context_2.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], AutoWidthCalculator.prototype, "gridPanel", void 0);
            __decorate([context_2.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], AutoWidthCalculator.prototype, "gridOptionsWrapper", void 0);
            AutoWidthCalculator = __decorate([context_1.Bean('autoWidthCalculator'), __metadata('design:paramtypes', [])], AutoWidthCalculator);
            return AutoWidthCalculator;
        }();
        exports.AutoWidthCalculator = AutoWidthCalculator;

        /***/ },
    /* 261 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var utils_1 = __webpack_require__(245);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var gridPanel_1 = __webpack_require__(262);
        var expressionService_1 = __webpack_require__(256);
        var templateService_1 = __webpack_require__(274);
        var valueService_1 = __webpack_require__(267);
        var eventService_1 = __webpack_require__(242);
        var floatingRowModel_1 = __webpack_require__(264);
        var renderedRow_1 = __webpack_require__(275);
        var events_1 = __webpack_require__(248);
        var constants_1 = __webpack_require__(246);
        var context_1 = __webpack_require__(244);
        var gridCore_1 = __webpack_require__(278);
        var columnController_1 = __webpack_require__(251);
        var logger_1 = __webpack_require__(243);
        var focusedCellController_1 = __webpack_require__(273);
        var cellNavigationService_1 = __webpack_require__(303);
        var gridCell_1 = __webpack_require__(271);
        var RowRenderer = function () {
            function RowRenderer() {
                // map of row ids to row objects. keeps track of which elements
                // are rendered for which rows in the dom.
                this.renderedRows = {};
                this.renderedTopFloatingRows = [];
                this.renderedBottomFloatingRows = [];
                this.destroyFunctions = [];
            }
            RowRenderer.prototype.agWire = function (loggerFactory) {
                this.logger = this.loggerFactory.create('RowRenderer');
                this.logger = loggerFactory.create('BalancedColumnTreeBuilder');
            };
            RowRenderer.prototype.init = function () {
                var _this = this;
                this.getContainersFromGridPanel();
                var columnListener = this.onColumnEvent.bind(this);
                var refreshViewListener = this.refreshView.bind(this);
                this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, columnListener);
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnListener);
                this.eventService.addEventListener(events_1.Events.EVENT_MODEL_UPDATED, refreshViewListener);
                this.eventService.addEventListener(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED, refreshViewListener);
                this.destroyFunctions.push(function () {
                    _this.eventService.removeEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, columnListener);
                    _this.eventService.removeEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnListener);
                    _this.eventService.removeEventListener(events_1.Events.EVENT_MODEL_UPDATED, refreshViewListener);
                    _this.eventService.removeEventListener(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED, refreshViewListener);
                });
                this.refreshView();
            };
            RowRenderer.prototype.onColumnEvent = function (event) {
                this.setMainRowWidths();
            };
            RowRenderer.prototype.getContainersFromGridPanel = function () {
                this.eFullWidthContainer = this.gridPanel.getFullWidthCellContainer();
                this.eBodyContainer = this.gridPanel.getBodyContainer();
                this.ePinnedLeftColsContainer = this.gridPanel.getPinnedLeftColsContainer();
                this.ePinnedRightColsContainer = this.gridPanel.getPinnedRightColsContainer();
                this.eFloatingTopContainer = this.gridPanel.getFloatingTopContainer();
                this.eFloatingTopPinnedLeftContainer = this.gridPanel.getPinnedLeftFloatingTop();
                this.eFloatingTopPinnedRightContainer = this.gridPanel.getPinnedRightFloatingTop();
                this.eFloatingTopFullWidthContainer = this.gridPanel.getFloatingTopFullWidthCellContainer();
                this.eFloatingBottomContainer = this.gridPanel.getFloatingBottomContainer();
                this.eFloatingBottomPinnedLeftContainer = this.gridPanel.getPinnedLeftFloatingBottom();
                this.eFloatingBottomPinnedRightContainer = this.gridPanel.getPinnedRightFloatingBottom();
                this.eFloatingBottomFullWithContainer = this.gridPanel.getFloatingBottomFullWidthCellContainer();
                this.eBodyViewport = this.gridPanel.getBodyViewport();
                this.eAllBodyContainers = [this.eBodyContainer, this.eFloatingBottomContainer, this.eFloatingTopContainer];
                this.eAllPinnedLeftContainers = [this.ePinnedLeftColsContainer, this.eFloatingBottomPinnedLeftContainer, this.eFloatingTopPinnedLeftContainer];
                this.eAllPinnedRightContainers = [this.ePinnedRightColsContainer, this.eFloatingBottomPinnedRightContainer, this.eFloatingTopPinnedRightContainer];
            };
            RowRenderer.prototype.setRowModel = function (rowModel) {
                this.rowModel = rowModel;
            };
            RowRenderer.prototype.getAllCellsForColumn = function (column) {
                var eCells = [];
                utils_1.Utils.iterateObject(this.renderedRows, callback);
                utils_1.Utils.iterateObject(this.renderedBottomFloatingRows, callback);
                utils_1.Utils.iterateObject(this.renderedBottomFloatingRows, callback);
                function callback(key, renderedRow) {
                    var eCell = renderedRow.getCellForCol(column);
                    if (eCell) {
                        eCells.push(eCell);
                    }
                }
                return eCells;
            };
            RowRenderer.prototype.setMainRowWidths = function () {
                var mainRowWidth = this.columnController.getBodyContainerWidth() + "px";
                this.eAllBodyContainers.forEach(function (container) {
                    var unpinnedRows = container.querySelectorAll(".ag-row");
                    for (var i = 0; i < unpinnedRows.length; i++) {
                        unpinnedRows[i].style.width = mainRowWidth;
                    }
                });
            };
            RowRenderer.prototype.refreshAllFloatingRows = function () {
                this.refreshFloatingRows(this.renderedTopFloatingRows, this.floatingRowModel.getFloatingTopRowData(), this.eFloatingTopPinnedLeftContainer, this.eFloatingTopPinnedRightContainer, this.eFloatingTopContainer, this.eFloatingTopFullWidthContainer);
                this.refreshFloatingRows(this.renderedBottomFloatingRows, this.floatingRowModel.getFloatingBottomRowData(), this.eFloatingBottomPinnedLeftContainer, this.eFloatingBottomPinnedRightContainer, this.eFloatingBottomContainer, this.eFloatingBottomFullWithContainer);
            };
            RowRenderer.prototype.refreshFloatingRows = function (renderedRows, rowNodes, ePinnedLeftContainer, ePinnedRightContainer, eBodyContainer, eFullWidthContainer) {
                var _this = this;
                renderedRows.forEach(function (row) {
                    row.destroy();
                });
                renderedRows.length = 0;
                // if no cols, don't draw row - can we get rid of this???
                var columns = this.columnController.getAllDisplayedColumns();
                if (utils_1.Utils.missingOrEmpty(columns)) {
                    return;
                }
                if (rowNodes) {
                    rowNodes.forEach(function (node, rowIndex) {
                        var renderedRow = new renderedRow_1.RenderedRow(_this.$scope, _this, eBodyContainer, eFullWidthContainer, ePinnedLeftContainer, ePinnedRightContainer, node, rowIndex);
                        _this.context.wireBean(renderedRow);
                        renderedRows.push(renderedRow);
                    });
                }
            };
            RowRenderer.prototype.refreshView = function (refreshEvent) {
                this.logger.log('refreshView');
                var focusedCell = this.focusedCellController.getFocusCellToUseAfterRefresh();
                var refreshFromIndex = refreshEvent ? refreshEvent.fromIndex : null;
                if (!this.gridOptionsWrapper.isForPrint()) {
                    var containerHeight = this.rowModel.getRowCombinedHeight();
                    this.eBodyContainer.style.height = containerHeight + "px";
                    this.eFullWidthContainer.style.height = containerHeight + "px";
                    this.ePinnedLeftColsContainer.style.height = containerHeight + "px";
                    this.ePinnedRightColsContainer.style.height = containerHeight + "px";
                }
                this.refreshAllVirtualRows(refreshFromIndex);
                this.refreshAllFloatingRows();
                this.restoreFocusedCell(focusedCell);
            };
            // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
            // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
            // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
            // edited cell).
            RowRenderer.prototype.restoreFocusedCell = function (gridCell) {
                if (gridCell) {
                    this.focusedCellController.setFocusedCell(gridCell.rowIndex, gridCell.column, gridCell.floating, true);
                }
            };
            RowRenderer.prototype.softRefreshView = function () {
                var focusedCell = this.focusedCellController.getFocusCellToUseAfterRefresh();
                this.forEachRenderedCell(function (renderedCell) {
                    if (renderedCell.isVolatile()) {
                        renderedCell.refreshCell();
                    }
                });
                this.restoreFocusedCell(focusedCell);
            };
            RowRenderer.prototype.stopEditing = function (cancel) {
                if (cancel === void 0) {
                    cancel = false;
                }
                this.forEachRenderedCell(function (renderedCell) {
                    renderedCell.stopEditing(cancel);
                });
            };
            RowRenderer.prototype.forEachRenderedCell = function (callback) {
                utils_1.Utils.iterateObject(this.renderedRows, function (key, renderedRow) {
                    renderedRow.forEachRenderedCell(callback);
                });
            };
            RowRenderer.prototype.forEachRenderedRow = function (callback) {
                utils_1.Utils.iterateObject(this.renderedRows, callback);
                utils_1.Utils.iterateObject(this.renderedTopFloatingRows, callback);
                utils_1.Utils.iterateObject(this.renderedBottomFloatingRows, callback);
            };
            RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {
                var renderedRow = this.renderedRows[rowIndex];
                renderedRow.addEventListener(eventName, callback);
            };
            RowRenderer.prototype.refreshRows = function (rowNodes) {
                if (!rowNodes || rowNodes.length == 0) {
                    return;
                }
                var focusedCell = this.focusedCellController.getFocusCellToUseAfterRefresh();
                // we only need to be worried about rendered rows, as this method is
                // called to whats rendered. if the row isn't rendered, we don't care
                var indexesToRemove = [];
                utils_1.Utils.iterateObject(this.renderedRows, function (key, renderedRow) {
                    var rowNode = renderedRow.getRowNode();
                    if (rowNodes.indexOf(rowNode) >= 0) {
                        indexesToRemove.push(key);
                    }
                });
                // remove the rows
                this.removeVirtualRow(indexesToRemove);
                // add draw them again
                this.drawVirtualRows();
                this.restoreFocusedCell(focusedCell);
            };
            RowRenderer.prototype.refreshCells = function (rowNodes, colIds, animate) {
                if (animate === void 0) {
                    animate = false;
                }
                if (!rowNodes || rowNodes.length == 0) {
                    return;
                }
                // we only need to be worried about rendered rows, as this method is
                // called to whats rendered. if the row isn't rendered, we don't care
                utils_1.Utils.iterateObject(this.renderedRows, function (key, renderedRow) {
                    var rowNode = renderedRow.getRowNode();
                    if (rowNodes.indexOf(rowNode) >= 0) {
                        renderedRow.refreshCells(colIds, animate);
                    }
                });
            };
            RowRenderer.prototype.rowDataChanged = function (rows) {
                // we only need to be worried about rendered rows, as this method is
                // called to whats rendered. if the row isn't rendered, we don't care
                var indexesToRemove = [];
                var renderedRows = this.renderedRows;
                Object.keys(renderedRows).forEach(function (index) {
                    var renderedRow = renderedRows[index];
                    // see if the rendered row is in the list of rows we have to update
                    if (renderedRow.isDataInList(rows)) {
                        indexesToRemove.push(index);
                    }
                });
                // remove the rows
                this.removeVirtualRow(indexesToRemove);
                // add draw them again
                this.drawVirtualRows();
            };
            RowRenderer.prototype.destroy = function () {
                this.destroyFunctions.forEach(function (func) {
                    return func();
                });
                var rowsToRemove = Object.keys(this.renderedRows);
                this.removeVirtualRow(rowsToRemove);
            };
            RowRenderer.prototype.refreshAllVirtualRows = function (fromIndex) {
                // remove all current virtual rows, as they have old data
                var rowsToRemove = Object.keys(this.renderedRows);
                this.removeVirtualRow(rowsToRemove, fromIndex);
                // add in new rows
                this.drawVirtualRows();
            };
            // public - removes the group rows and then redraws them again
            RowRenderer.prototype.refreshGroupRows = function () {
                var _this = this;
                // find all the group rows
                var rowsToRemove = [];
                Object.keys(this.renderedRows).forEach(function (index) {
                    var renderedRow = _this.renderedRows[index];
                    if (renderedRow.isGroup()) {
                        rowsToRemove.push(index);
                    }
                });
                // remove the rows
                this.removeVirtualRow(rowsToRemove);
                // and draw them back again
                this.ensureRowsRendered();
            };
            // takes array of row indexes
            RowRenderer.prototype.removeVirtualRow = function (rowsToRemove, fromIndex) {
                var that = this;
                // if no fromIndex then set to -1, which will refresh everything
                var realFromIndex = typeof fromIndex === 'number' ? fromIndex : -1;
                rowsToRemove.forEach(function (indexToRemove) {
                    if (indexToRemove >= realFromIndex) {
                        that.unbindVirtualRow(indexToRemove);
                    }
                });
            };
            RowRenderer.prototype.unbindVirtualRow = function (indexToRemove) {
                var renderedRow = this.renderedRows[indexToRemove];
                renderedRow.destroy();
                var event = { node: renderedRow.getRowNode(), rowIndex: indexToRemove };
                this.eventService.dispatchEvent(events_1.Events.EVENT_VIRTUAL_ROW_REMOVED, event);
                delete this.renderedRows[indexToRemove];
            };
            RowRenderer.prototype.drawVirtualRows = function () {
                this.workOutFirstAndLastRowsToRender();
                this.ensureRowsRendered();
            };
            RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {
                var newFirst;
                var newLast;
                if (!this.rowModel.isRowsToRender()) {
                    newFirst = 0;
                    newLast = -1; // setting to -1 means nothing in range
                } else {
                    var rowCount = this.rowModel.getRowCount();
                    if (this.gridOptionsWrapper.isForPrint()) {
                        newFirst = 0;
                        newLast = rowCount;
                    } else {
                        var topPixel = this.eBodyViewport.scrollTop;
                        var bottomPixel = topPixel + this.eBodyViewport.offsetHeight;
                        var first = this.rowModel.getRowIndexAtPixel(topPixel);
                        var last = this.rowModel.getRowIndexAtPixel(bottomPixel);
                        //add in buffer
                        var buffer = this.gridOptionsWrapper.getRowBuffer();
                        first = first - buffer;
                        last = last + buffer;
                        // adjust, in case buffer extended actual size
                        if (first < 0) {
                            first = 0;
                        }
                        if (last > rowCount - 1) {
                            last = rowCount - 1;
                        }
                        newFirst = first;
                        newLast = last;
                    }
                }
                var firstDiffers = newFirst !== this.firstRenderedRow;
                var lastDiffers = newLast !== this.lastRenderedRow;
                if (firstDiffers || lastDiffers) {
                    this.firstRenderedRow = newFirst;
                    this.lastRenderedRow = newLast;
                    var event = { firstRow: newFirst, lastRow: newLast };
                    this.eventService.dispatchEvent(events_1.Events.EVENT_VIEWPORT_CHANGED, event);
                }
            };
            RowRenderer.prototype.getFirstVirtualRenderedRow = function () {
                return this.firstRenderedRow;
            };
            RowRenderer.prototype.getLastVirtualRenderedRow = function () {
                return this.lastRenderedRow;
            };
            RowRenderer.prototype.ensureRowsRendered = function () {
                //var start = new Date().getTime();
                var _this = this;
                // at the end, this array will contain the items we need to remove
                var rowsToRemove = Object.keys(this.renderedRows);
                // add in new rows
                for (var rowIndex = this.firstRenderedRow; rowIndex <= this.lastRenderedRow; rowIndex++) {
                    // see if item already there, and if yes, take it out of the 'to remove' array
                    if (rowsToRemove.indexOf(rowIndex.toString()) >= 0) {
                        rowsToRemove.splice(rowsToRemove.indexOf(rowIndex.toString()), 1);
                        continue;
                    }
                    // check this row actually exists (in case overflow buffer window exceeds real data)
                    var node = this.rowModel.getRow(rowIndex);
                    if (node) {
                        this.insertRow(node, rowIndex);
                    }
                }
                // at this point, everything in our 'rowsToRemove' . . .
                this.removeVirtualRow(rowsToRemove);
                // if we are doing angular compiling, then do digest the scope here
                if (this.gridOptionsWrapper.isAngularCompileRows()) {
                    // we do it in a timeout, in case we are already in an apply
                    setTimeout(function () {
                        _this.$scope.$apply();
                    }, 0);
                }
                //var end = new Date().getTime();
                //console.log(end-start);
            };
            RowRenderer.prototype.onMouseEvent = function (eventName, mouseEvent, cell) {
                var renderedRow;
                switch (cell.floating) {
                    case constants_1.Constants.FLOATING_TOP:
                        renderedRow = this.renderedTopFloatingRows[cell.rowIndex];
                        break;
                    case constants_1.Constants.FLOATING_BOTTOM:
                        renderedRow = this.renderedBottomFloatingRows[cell.rowIndex];
                        break;
                    default:
                        renderedRow = this.renderedRows[cell.rowIndex];
                        break;
                }
                if (renderedRow) {
                    renderedRow.onMouseEvent(eventName, mouseEvent, cell);
                }
            };
            RowRenderer.prototype.insertRow = function (node, rowIndex) {
                var columns = this.columnController.getAllDisplayedColumns();
                // if no cols, don't draw row
                if (utils_1.Utils.missingOrEmpty(columns)) {
                    return;
                }
                var renderedRow = new renderedRow_1.RenderedRow(this.$scope, this, this.eBodyContainer, this.eFullWidthContainer, this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, node, rowIndex);
                this.context.wireBean(renderedRow);
                this.renderedRows[rowIndex] = renderedRow;
            };
            RowRenderer.prototype.getRenderedNodes = function () {
                var renderedRows = this.renderedRows;
                return Object.keys(renderedRows).map(function (key) {
                    return renderedRows[key].getRowNode();
                });
            };
            // we use index for rows, but column object for columns, as the next column (by index) might not
            // be visible (header grouping) so it's not reliable, so using the column object instead.
            RowRenderer.prototype.navigateToNextCell = function (key, rowIndex, column, floating) {
                var nextCell = new gridCell_1.GridCell(rowIndex, floating, column);
                // we keep searching for a next cell until we find one. this is how the group rows get skipped
                while (true) {
                    nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);
                    if (utils_1.Utils.missing(nextCell)) {
                        break;
                    }
                    var skipGroupRows = this.gridOptionsWrapper.isGroupUseEntireRow();
                    if (skipGroupRows) {
                        var rowNode = this.rowModel.getRow(nextCell.rowIndex);
                        if (!rowNode.group) {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid
                if (!nextCell) {
                    return;
                }
                // this scrolls the row into view
                if (utils_1.Utils.missing(nextCell.floating)) {
                    this.gridPanel.ensureIndexVisible(nextCell.rowIndex);
                }
                if (!nextCell.column.isPinned()) {
                    this.gridPanel.ensureColumnVisible(nextCell.column);
                }
                // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible
                // floating cell, the scrolls get out of sync
                this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();
                this.focusedCellController.setFocusedCell(nextCell.rowIndex, nextCell.column, nextCell.floating, true);
                if (this.rangeController) {
                    this.rangeController.setRangeToCell(new gridCell_1.GridCell(nextCell.rowIndex, nextCell.floating, nextCell.column));
                }
            };
            RowRenderer.prototype.startEditingCell = function (gridCell, keyPress, charPress) {
                var cell = this.getComponentForCell(gridCell);
                cell.startEditingIfEnabled(keyPress, charPress);
            };
            RowRenderer.prototype.getComponentForCell = function (gridCell) {
                var rowComponent;
                switch (gridCell.floating) {
                    case constants_1.Constants.FLOATING_TOP:
                        rowComponent = this.renderedTopFloatingRows[gridCell.rowIndex];
                        break;
                    case constants_1.Constants.FLOATING_BOTTOM:
                        rowComponent = this.renderedBottomFloatingRows[gridCell.rowIndex];
                        break;
                    default:
                        rowComponent = this.renderedRows[gridCell.rowIndex];
                        break;
                }
                if (!rowComponent) {
                    return null;
                }
                var cellComponent = rowComponent.getRenderedCellForColumn(gridCell.column);
                return cellComponent;
            };
            // called by the cell, when tab is pressed while editing.
            // @return: true when navigation successful, otherwise false
            RowRenderer.prototype.moveFocusToNextCell = function (rowIndex, column, floating, shiftKey, startEditing) {
                var nextCell = new gridCell_1.GridCell(rowIndex, floating, column);
                while (true) {
                    nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, shiftKey);
                    // if no 'next cell', means we have got to last cell of grid, so nothing to move to,
                    // so bottom right cell going forwards, or top left going backwards
                    if (!nextCell) {
                        return false;
                    }
                    // this scrolls the row into view
                    var cellIsNotFloating = utils_1.Utils.missing(nextCell.floating);
                    if (cellIsNotFloating) {
                        this.gridPanel.ensureIndexVisible(nextCell.rowIndex);
                    }
                    this.gridPanel.ensureColumnVisible(nextCell.column);
                    // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible
                    // floating cell, the scrolls get out of sync
                    this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();
                    // we have to call this after ensureColumnVisible - otherwise it could be a virtual column
                    // or row that is not currently in view, hence the renderedCell would not exist
                    var nextRenderedCell = this.getComponentForCell(nextCell);
                    // if editing, but cell not editable, skip cell
                    if (startEditing && !nextRenderedCell.isCellEditable()) {
                        continue;
                    }
                    if (startEditing) {
                        nextRenderedCell.startEditingIfEnabled();
                        nextRenderedCell.focusCell(false);
                    } else {
                        nextRenderedCell.focusCell(true);
                    }
                    // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation
                    // consistent, we set into range here also.
                    if (this.rangeController) {
                        this.rangeController.setRangeToCell(new gridCell_1.GridCell(nextCell.rowIndex, nextCell.floating, nextCell.column));
                    }
                    // we successfully tabbed onto a grid cell, so return true
                    return true;
                }
            };
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], RowRenderer.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], RowRenderer.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('gridCore'), __metadata('design:type', gridCore_1.GridCore)], RowRenderer.prototype, "gridCore", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], RowRenderer.prototype, "gridPanel", void 0);
            __decorate([context_1.Autowired('$compile'), __metadata('design:type', Object)], RowRenderer.prototype, "$compile", void 0);
            __decorate([context_1.Autowired('$scope'), __metadata('design:type', Object)], RowRenderer.prototype, "$scope", void 0);
            __decorate([context_1.Autowired('expressionService'), __metadata('design:type', expressionService_1.ExpressionService)], RowRenderer.prototype, "expressionService", void 0);
            __decorate([context_1.Autowired('templateService'), __metadata('design:type', templateService_1.TemplateService)], RowRenderer.prototype, "templateService", void 0);
            __decorate([context_1.Autowired('valueService'), __metadata('design:type', valueService_1.ValueService)], RowRenderer.prototype, "valueService", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], RowRenderer.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('floatingRowModel'), __metadata('design:type', floatingRowModel_1.FloatingRowModel)], RowRenderer.prototype, "floatingRowModel", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], RowRenderer.prototype, "context", void 0);
            __decorate([context_1.Autowired('loggerFactory'), __metadata('design:type', logger_1.LoggerFactory)], RowRenderer.prototype, "loggerFactory", void 0);
            __decorate([context_1.Autowired('rowModel'), __metadata('design:type', Object)], RowRenderer.prototype, "rowModel", void 0);
            __decorate([context_1.Autowired('focusedCellController'), __metadata('design:type', focusedCellController_1.FocusedCellController)], RowRenderer.prototype, "focusedCellController", void 0);
            __decorate([context_1.Optional('rangeController'), __metadata('design:type', Object)], RowRenderer.prototype, "rangeController", void 0);
            __decorate([context_1.Autowired('cellNavigationService'), __metadata('design:type', cellNavigationService_1.CellNavigationService)], RowRenderer.prototype, "cellNavigationService", void 0);
            __decorate([__param(0, context_1.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], RowRenderer.prototype, "agWire", null);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RowRenderer.prototype, "init", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RowRenderer.prototype, "destroy", null);
            RowRenderer = __decorate([context_1.Bean('rowRenderer'), __metadata('design:paramtypes', [])], RowRenderer);
            return RowRenderer;
        }();
        exports.RowRenderer = RowRenderer;

        /***/ },
    /* 262 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var utils_1 = __webpack_require__(245);
        var masterSlaveService_1 = __webpack_require__(263);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnController_1 = __webpack_require__(251);
        var rowRenderer_1 = __webpack_require__(261);
        var floatingRowModel_1 = __webpack_require__(264);
        var borderLayout_1 = __webpack_require__(268);
        var logger_1 = __webpack_require__(243);
        var context_1 = __webpack_require__(244);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var dragService_1 = __webpack_require__(269);
        var constants_1 = __webpack_require__(246);
        var selectionController_1 = __webpack_require__(266);
        var csvCreator_1 = __webpack_require__(250);
        var mouseEventService_1 = __webpack_require__(270);
        var focusedCellController_1 = __webpack_require__(273);
        // in the html below, it is important that there are no white space between some of the divs, as if there is white space,
        // it won't render correctly in safari, as safari renders white space as a gap
        var gridHtml = '<div>' +
            // header
            '<div class="ag-header">' + '<div class="ag-pinned-left-header"></div>' + '<div class="ag-pinned-right-header"></div>' + '<div class="ag-header-viewport">' + '<div class="ag-header-container"></div>' + '</div>' + '<div class="ag-header-overlay"></div>' + '</div>' +
            // floating top
            '<div class="ag-floating-top">' + '<div class="ag-pinned-left-floating-top"></div>' + '<div class="ag-pinned-right-floating-top"></div>' + '<div class="ag-floating-top-viewport">' + '<div class="ag-floating-top-container"></div>' + '</div>' + '<div class="ag-floating-top-full-width-container"></div>' + '</div>' +
            // floating bottom
            '<div class="ag-floating-bottom">' + '<div class="ag-pinned-left-floating-bottom"></div>' + '<div class="ag-pinned-right-floating-bottom"></div>' + '<div class="ag-floating-bottom-viewport">' + '<div class="ag-floating-bottom-container"></div>' + '</div>' + '<div class="ag-floating-bottom-full-width-container"></div>' + '</div>' +
            // body
            '<div class="ag-body">' + '<div class="ag-pinned-left-cols-viewport">' + '<div class="ag-pinned-left-cols-container"></div>' + '</div>' + '<div class="ag-pinned-right-cols-viewport">' + '<div class="ag-pinned-right-cols-container"></div>' + '</div>' + '<div class="ag-body-viewport-wrapper">' + '<div class="ag-body-viewport">' + '<div class="ag-body-container"></div>' + '</div>' + '</div>' + '<div class="ag-full-width-viewport">' + '<div class="ag-full-width-container"></div>' + '</div>' + '</div>' + '</div>';
        var gridForPrintHtml = '<div>' +
            // header
            '<div class="ag-header-container"></div>' +
            // floating
            '<div class="ag-floating-top-container"></div>' +
            // body
            '<div class="ag-body-container"></div>' +
            // floating bottom
            '<div class="ag-floating-bottom-container"></div>' + '</div>';
        // wrapping in outer div, and wrapper, is needed to center the loading icon
        // The idea for centering came from here: http://www.vanseodesign.com/css/vertical-centering/
        var mainOverlayTemplate = '<div class="ag-overlay-panel">' + '<div class="ag-overlay-wrapper ag-overlay-[OVERLAY_NAME]-wrapper">[OVERLAY_TEMPLATE]</div>' + '</div>';
        var defaultLoadingOverlayTemplate = '<span class="ag-overlay-loading-center">[LOADING...]</span>';
        var defaultNoRowsOverlayTemplate = '<span class="ag-overlay-no-rows-center">[NO_ROWS_TO_SHOW]</span>';
        var GridPanel = function () {
            function GridPanel() {
                this.requestAnimationFrameExists = typeof requestAnimationFrame === 'function';
                this.scrollLagCounter = 0;
                this.scrollLagTicking = false;
                this.lastLeftPosition = -1;
                this.lastTopPosition = -1;
                this.animationThreadCount = 0;
                this.destroyFunctions = [];
            }
            GridPanel.prototype.agWire = function (loggerFactory) {
                // makes code below more readable if we pull 'forPrint' out
                this.forPrint = this.gridOptionsWrapper.isForPrint();
                this.scrollWidth = utils_1.Utils.getScrollbarWidth();
                this.logger = loggerFactory.create('GridPanel');
                this.findElements();
            };
            GridPanel.prototype.destroy = function () {
                this.destroyFunctions.forEach(function (func) {
                    return func();
                });
            };
            GridPanel.prototype.onRowDataChanged = function () {
                if (this.rowModel.isEmpty() && !this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
                    this.showNoRowsOverlay();
                } else {
                    this.hideOverlay();
                }
            };
            GridPanel.prototype.getLayout = function () {
                return this.layout;
            };
            GridPanel.prototype.init = function () {
                this.addEventListeners();
                this.addDragListeners();
                this.useScrollLag = this.isUseScrollLag();
                this.layout = new borderLayout_1.BorderLayout({
                    overlays: {
                        loading: utils_1.Utils.loadTemplate(this.createLoadingOverlayTemplate()),
                        noRows: utils_1.Utils.loadTemplate(this.createNoRowsOverlayTemplate())
                    },
                    center: this.eRoot,
                    dontFill: this.forPrint,
                    name: 'eGridPanel'
                });
                this.layout.addSizeChangeListener(this.sizeHeaderAndBody.bind(this));
                this.addScrollListener();
                this.setLeftAndRightBounds();
                if (this.gridOptionsWrapper.isSuppressHorizontalScroll()) {
                    this.eBodyViewport.style.overflowX = 'hidden';
                }
                if (this.gridOptionsWrapper.isRowModelDefault() && !this.gridOptionsWrapper.getRowData()) {
                    this.showLoadingOverlay();
                }
                this.setWidthsOfContainers();
                this.showPinnedColContainersIfNeeded();
                this.sizeHeaderAndBody();
                this.disableBrowserDragging();
                this.addShortcutKeyListeners();
                this.addCellListeners();
                this.addBodyViewportListener();
                if (this.$scope) {
                    this.addAngularApplyCheck();
                }
            };
            GridPanel.prototype.addAngularApplyCheck = function () {
                var _this = this;
                // this makes sure if we queue up requests, we only execute oe
                var applyTriggered = false;
                var listener = function listener() {
                    // only need to do one apply at a time
                    if (applyTriggered) {
                        return;
                    }
                    applyTriggered = true; // mark 'need apply' to true
                    setTimeout(function () {
                        applyTriggered = false;
                        _this.$scope.$apply();
                    }, 0);
                };
                // these are the events we need to do an apply after - these are the ones that can end up
                // with columns added or removed
                this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
                this.eventService.addEventListener(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, listener);
                this.destroyFunctions.push(function () {
                    _this.eventService.removeEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
                    _this.eventService.removeEventListener(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, listener);
                });
            };
            // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
            // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
            GridPanel.prototype.disableBrowserDragging = function () {
                this.eRoot.addEventListener('dragstart', function (event) {
                    if (event.target instanceof HTMLImageElement) {
                        event.preventDefault();
                        return false;
                    }
                });
            };
            GridPanel.prototype.addEventListeners = function () {
                this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED, this.sizeHeaderAndBody.bind(this));
                this.gridOptionsWrapper.addEventListener(gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, this.sizeHeaderAndBody.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.onRowDataChanged.bind(this));
            };
            GridPanel.prototype.addDragListeners = function () {
                var _this = this;
                if (this.forPrint // no range select when doing 'for print'
                    || !this.gridOptionsWrapper.isEnableRangeSelection() // no range selection if no property
                    || utils_1.Utils.missing(this.rangeController)) {
                    return;
                }
                var containers = [this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, this.eBodyContainer, this.eFloatingTop, this.eFloatingBottom];
                containers.forEach(function (container) {
                    _this.dragService.addDragSource({
                        dragStartPixels: 0,
                        eElement: container,
                        onDragStart: _this.rangeController.onDragStart.bind(_this.rangeController),
                        onDragStop: _this.rangeController.onDragStop.bind(_this.rangeController),
                        onDragging: _this.rangeController.onDragging.bind(_this.rangeController)
                    });
                });
            };
            GridPanel.prototype.addCellListeners = function () {
                var _this = this;
                var eventNames = ['click', 'mousedown', 'dblclick', 'contextmenu'];
                eventNames.forEach(function (eventName) {
                    var listener = _this.processMouseEvent.bind(_this, eventName);
                    _this.eAllCellContainers.forEach(function (container) {
                        container.addEventListener(eventName, listener);
                        _this.destroyFunctions.push(function () {
                            return container.removeEventListener(eventName, listener);
                        });
                    });
                });
            };
            GridPanel.prototype.addBodyViewportListener = function () {
                var _this = this;
                // we never add this when doing 'forPrint'
                if (this.gridOptionsWrapper.isForPrint()) {
                    return;
                }
                // we want to listen for clicks directly on the eBodyViewport, so the user has a way of showing
                // the context menu if no rows are displayed, or user simply clicks outside of a cell
                var listener = function listener(mouseEvent) {
                    var target = utils_1.Utils.getTarget(mouseEvent);
                    if (target === _this.eBodyViewport) {
                        // show it
                        _this.onContextMenu(mouseEvent);
                        _this.preventDefaultOnContextMenu(mouseEvent);
                    }
                };
                this.eBodyViewport.addEventListener('contextmenu', listener);
                this.destroyFunctions.push(function () {
                    return _this.eBodyViewport.removeEventListener('contextmenu', listener);
                });
            };
            GridPanel.prototype.processMouseEvent = function (eventName, mouseEvent) {
                var cell = this.mouseEventService.getCellForMouseEvent(mouseEvent);
                if (utils_1.Utils.exists(cell)) {
                    //console.log(`row = ${cell.rowIndex}, floating = ${floating}`);
                    this.rowRenderer.onMouseEvent(eventName, mouseEvent, cell);
                }
                this.preventDefaultOnContextMenu(mouseEvent);
            };
            GridPanel.prototype.onContextMenu = function (mouseEvent) {
                // to allow us to debug in chrome, we ignore the event if ctrl is pressed,
                // thus the normal menu is displayed
                if (mouseEvent.ctrlKey || mouseEvent.metaKey) {
                    return;
                }
                if (this.contextMenuFactory && !this.gridOptionsWrapper.isSuppressContextMenu()) {
                    this.contextMenuFactory.showMenu(null, null, null, mouseEvent);
                    mouseEvent.preventDefault();
                }
            };
            GridPanel.prototype.preventDefaultOnContextMenu = function (mouseEvent) {
                // if we don't do this, then middle click will never result in a 'click' event, as 'mousedown'
                // will be consumed by the browser to mean 'scroll' (as you can scroll with the middle mouse
                // button in the browser). so this property allows the user to receive middle button clicks if
                // they want.
                if (this.gridOptionsWrapper.isSuppressMiddleClickScrolls() && mouseEvent.which === 2) {
                    mouseEvent.preventDefault();
                }
            };
            GridPanel.prototype.addShortcutKeyListeners = function () {
                var _this = this;
                this.eAllCellContainers.forEach(function (container) {
                    container.addEventListener('keydown', function (event) {
                        if (event.ctrlKey || event.metaKey) {
                            switch (event.which) {
                                case constants_1.Constants.KEY_A:
                                    return _this.onCtrlAndA(event);
                                case constants_1.Constants.KEY_C:
                                    return _this.onCtrlAndC(event);
                                case constants_1.Constants.KEY_V:
                                    return _this.onCtrlAndV(event);
                                case constants_1.Constants.KEY_D:
                                    return _this.onCtrlAndD(event);
                            }
                        }
                    });
                });
            };
            GridPanel.prototype.onCtrlAndA = function (event) {
                if (this.rangeController && this.rowModel.isRowsToRender()) {
                    var rowEnd;
                    var floatingStart;
                    var floatingEnd;
                    if (this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_TOP)) {
                        floatingStart = null;
                    } else {
                        floatingStart = constants_1.Constants.FLOATING_TOP;
                    }
                    if (this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_BOTTOM)) {
                        floatingEnd = null;
                        rowEnd = this.rowModel.getRowCount() - 1;
                    } else {
                        floatingEnd = constants_1.Constants.FLOATING_BOTTOM;
                        rowEnd = this.floatingRowModel.getFloatingBottomRowData().length = 1;
                    }
                    var allDisplayedColumns = this.columnController.getAllDisplayedColumns();
                    if (utils_1.Utils.missingOrEmpty(allDisplayedColumns)) {
                        return;
                    }
                    this.rangeController.setRange({
                        rowStart: 0,
                        floatingStart: floatingStart,
                        rowEnd: rowEnd,
                        floatingEnd: floatingEnd,
                        columnStart: allDisplayedColumns[0],
                        columnEnd: allDisplayedColumns[allDisplayedColumns.length - 1]
                    });
                }
                event.preventDefault();
                return false;
            };
            GridPanel.prototype.onCtrlAndC = function (event) {
                if (!this.clipboardService) {
                    return;
                }
                var focusedCell = this.focusedCellController.getFocusedCell();
                this.clipboardService.copyToClipboard();
                event.preventDefault();
                // the copy operation results in loosing focus on the cell,
                // because of the trickery the copy logic uses with a temporary
                // widget. so we set it back again.
                if (focusedCell) {
                    this.focusedCellController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.floating, true);
                }
                return false;
            };
            GridPanel.prototype.onCtrlAndV = function (event) {
                if (!this.rangeController) {
                    return;
                }
                this.clipboardService.pasteFromClipboard();
                return false;
            };
            GridPanel.prototype.onCtrlAndD = function (event) {
                if (!this.clipboardService) {
                    return;
                }
                this.clipboardService.copyRangeDown();
                event.preventDefault();
                return false;
            };
            GridPanel.prototype.getPinnedLeftFloatingTop = function () {
                return this.ePinnedLeftFloatingTop;
            };
            GridPanel.prototype.getPinnedRightFloatingTop = function () {
                return this.ePinnedRightFloatingTop;
            };
            GridPanel.prototype.getFloatingTopContainer = function () {
                return this.eFloatingTopContainer;
            };
            GridPanel.prototype.getPinnedLeftFloatingBottom = function () {
                return this.ePinnedLeftFloatingBottom;
            };
            GridPanel.prototype.getPinnedRightFloatingBottom = function () {
                return this.ePinnedRightFloatingBottom;
            };
            GridPanel.prototype.getFloatingBottomContainer = function () {
                return this.eFloatingBottomContainer;
            };
            GridPanel.prototype.createOverlayTemplate = function (name, defaultTemplate, userProvidedTemplate) {
                var template = mainOverlayTemplate.replace('[OVERLAY_NAME]', name);
                if (userProvidedTemplate) {
                    template = template.replace('[OVERLAY_TEMPLATE]', userProvidedTemplate);
                } else {
                    template = template.replace('[OVERLAY_TEMPLATE]', defaultTemplate);
                }
                return template;
            };
            GridPanel.prototype.createLoadingOverlayTemplate = function () {
                var userProvidedTemplate = this.gridOptionsWrapper.getOverlayLoadingTemplate();
                var templateNotLocalised = this.createOverlayTemplate('loading', defaultLoadingOverlayTemplate, userProvidedTemplate);
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                var templateLocalised = templateNotLocalised.replace('[LOADING...]', localeTextFunc('loadingOoo', 'Loading...'));
                return templateLocalised;
            };
            GridPanel.prototype.createNoRowsOverlayTemplate = function () {
                var userProvidedTemplate = this.gridOptionsWrapper.getOverlayNoRowsTemplate();
                var templateNotLocalised = this.createOverlayTemplate('no-rows', defaultNoRowsOverlayTemplate, userProvidedTemplate);
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                var templateLocalised = templateNotLocalised.replace('[NO_ROWS_TO_SHOW]', localeTextFunc('noRowsToShow', 'No Rows To Show'));
                return templateLocalised;
            };
            GridPanel.prototype.ensureIndexVisible = function (index) {
                this.logger.log('ensureIndexVisible: ' + index);
                var lastRow = this.rowModel.getRowCount();
                if (typeof index !== 'number' || index < 0 || index >= lastRow) {
                    console.warn('invalid row index for ensureIndexVisible: ' + index);
                    return;
                }
                var nodeAtIndex = this.rowModel.getRow(index);
                var rowTopPixel = nodeAtIndex.rowTop;
                var rowBottomPixel = rowTopPixel + nodeAtIndex.rowHeight;
                var viewportTopPixel = this.eBodyViewport.scrollTop;
                var viewportHeight = this.eBodyViewport.offsetHeight;
                var scrollShowing = this.isHorizontalScrollShowing();
                if (scrollShowing) {
                    viewportHeight -= this.scrollWidth;
                }
                var viewportBottomPixel = viewportTopPixel + viewportHeight;
                var viewportScrolledPastRow = viewportTopPixel > rowTopPixel;
                var viewportScrolledBeforeRow = viewportBottomPixel < rowBottomPixel;
                var eViewportToScroll = this.columnController.isPinningRight() ? this.ePinnedRightColsViewport : this.eBodyViewport;
                if (viewportScrolledPastRow) {
                    // if row is before, scroll up with row at top
                    eViewportToScroll.scrollTop = rowTopPixel;
                } else if (viewportScrolledBeforeRow) {
                    // if row is below, scroll down with row at bottom
                    var newScrollPosition = rowBottomPixel - viewportHeight;
                    eViewportToScroll.scrollTop = newScrollPosition;
                }
                // otherwise, row is already in view, so do nothing
            };
            // + moveColumnController
            GridPanel.prototype.getCenterWidth = function () {
                return this.eBodyViewport.clientWidth;
            };
            GridPanel.prototype.isHorizontalScrollShowing = function () {
                var result = this.eBodyViewport.clientWidth < this.eBodyViewport.scrollWidth;
                return result;
            };
            GridPanel.prototype.isVerticalScrollShowing = function () {
                if (this.columnController.isPinningRight()) {
                    return utils_1.Utils.isScrollShowing(this.ePinnedRightColsViewport);
                } else {
                    return utils_1.Utils.isScrollShowing(this.eBodyViewport);
                }
            };
            GridPanel.prototype.isBodyVerticalScrollShowing = function () {
                if (this.columnController.isPinningRight()) {
                    return false;
                } else {
                    return utils_1.Utils.isScrollShowing(this.eBodyViewport);
                }
            };
            // gets called every 500 ms. we use this to set padding on right pinned column
            GridPanel.prototype.periodicallyCheck = function () {
                if (this.forPrint) {
                    return;
                }
                this.setBottomPaddingOnPinnedRight();
                this.setMarginOnFullWidthCellContainer();
            };
            // the pinned container needs extra space at the bottom, some blank space, otherwise when
            // vertically scrolled all the way down, the last row will be hidden behind the scrolls.
            // this extra padding allows the last row to be lifted above the bottom scrollbar.
            GridPanel.prototype.setBottomPaddingOnPinnedRight = function () {
                if (this.forPrint) {
                    return;
                }
                if (this.columnController.isPinningRight()) {
                    var bodyHorizontalScrollShowing = this.eBodyViewport.clientWidth < this.eBodyViewport.scrollWidth;
                    if (bodyHorizontalScrollShowing) {
                        this.ePinnedRightColsContainer.style.marginBottom = this.scrollWidth + 'px';
                    } else {
                        this.ePinnedRightColsContainer.style.marginBottom = '';
                    }
                }
            };
            GridPanel.prototype.setMarginOnFullWidthCellContainer = function () {
                if (this.forPrint) {
                    return;
                }
                // if either right or bottom scrollbars are showing, we need to make sure the
                // fullWidthCell panel isn't covering the scrollbars. originally i tried to do this using
                // margin, but the overflow was not getting clipped and going into the margin,
                // so used border instead. dunno why it works, trial and error found the solution.
                if (this.isVerticalScrollShowing()) {
                    this.eFullWidthCellViewport.style.borderRight = this.scrollWidth + 'px solid transparent';
                } else {
                    this.eFullWidthCellViewport.style.borderRight = '';
                }
                if (this.isHorizontalScrollShowing()) {
                    this.eFullWidthCellViewport.style.borderBottom = this.scrollWidth + 'px solid transparent';
                } else {
                    this.eFullWidthCellViewport.style.borderBottom = '';
                }
            };
            GridPanel.prototype.ensureColumnVisible = function (key) {
                var column = this.columnController.getGridColumn(key);
                if (!column) {
                    return;
                }
                if (column.isPinned()) {
                    console.warn('calling ensureIndexVisible on a ' + column.getPinned() + ' pinned column doesn\'t make sense for column ' + column.getColId());
                    return;
                }
                if (!this.columnController.isColumnDisplayed(column)) {
                    console.warn('column is not currently visible');
                    return;
                }
                var colLeftPixel = column.getLeft();
                var colRightPixel = colLeftPixel + column.getActualWidth();
                var viewportLeftPixel = this.eBodyViewport.scrollLeft;
                var viewportWidth = this.eBodyViewport.offsetWidth;
                var scrollShowing = this.eBodyViewport.clientHeight < this.eBodyViewport.scrollHeight;
                if (scrollShowing) {
                    viewportWidth -= this.scrollWidth;
                }
                var viewportRightPixel = viewportLeftPixel + viewportWidth;
                var viewportScrolledPastCol = viewportLeftPixel > colLeftPixel;
                var viewportScrolledBeforeCol = viewportRightPixel < colRightPixel;
                if (viewportScrolledPastCol) {
                    // if viewport's left side is after col's left side, scroll right to pull col into viewport at left
                    this.eBodyViewport.scrollLeft = colLeftPixel;
                } else if (viewportScrolledBeforeCol) {
                    // if viewport's right side is before col's right side, scroll left to pull col into viewport at right
                    var newScrollPosition = colRightPixel - viewportWidth;
                    this.eBodyViewport.scrollLeft = newScrollPosition;
                } else {}
                // this will happen anyway, as the move will cause a 'scroll' event on the body, however
                // it is possible that the ensureColumnVisible method is called from within ag-Grid and
                // the caller will need to have the columns rendered to continue, which will be before
                // the event has been worked on (which is the case for cell navigation).
                this.setLeftAndRightBounds();
            };
            GridPanel.prototype.showLoadingOverlay = function () {
                if (!this.gridOptionsWrapper.isSuppressLoadingOverlay()) {
                    this.layout.showOverlay('loading');
                }
            };
            GridPanel.prototype.showNoRowsOverlay = function () {
                if (!this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
                    this.layout.showOverlay('noRows');
                }
            };
            GridPanel.prototype.hideOverlay = function () {
                this.layout.hideOverlay();
            };
            GridPanel.prototype.getWidthForSizeColsToFit = function () {
                var availableWidth = this.eBody.clientWidth;
                // if pinning right, then the scroll bar can show, however for some reason
                // it overlays the grid and doesn't take space. so we are only interested
                // in the body scroll showing.
                var removeScrollWidth = this.isBodyVerticalScrollShowing();
                if (removeScrollWidth) {
                    availableWidth -= this.scrollWidth;
                }
                return availableWidth;
            };
            // method will call itself if no available width. this covers if the grid
            // isn't visible, but is just about to be visible.
            GridPanel.prototype.sizeColumnsToFit = function (nextTimeout) {
                var _this = this;
                var availableWidth = this.getWidthForSizeColsToFit();
                if (availableWidth > 0) {
                    this.columnController.sizeColumnsToFit(availableWidth);
                } else {
                    if (nextTimeout === undefined) {
                        setTimeout(function () {
                            _this.sizeColumnsToFit(100);
                        }, 0);
                    } else if (nextTimeout === 100) {
                        setTimeout(function () {
                            _this.sizeColumnsToFit(-1);
                        }, 100);
                    } else {
                        console.log('ag-Grid: tried to call sizeColumnsToFit() but the grid is coming back with ' + 'zero width, maybe the grid is not visible yet on the screen?');
                    }
                }
            };
            GridPanel.prototype.getBodyContainer = function () {
                return this.eBodyContainer;
            };
            GridPanel.prototype.getFullWidthCellContainer = function () {
                return this.eFullWidthCellContainer;
            };
            GridPanel.prototype.getFloatingTopFullWidthCellContainer = function () {
                return this.eFloatingTopFullWidthCellContainer;
            };
            GridPanel.prototype.getFloatingBottomFullWidthCellContainer = function () {
                return this.eFloatingBottomFullWidthCellContainer;
            };
            GridPanel.prototype.getDropTargetBodyContainers = function () {
                if (this.forPrint) {
                    return [this.eBodyContainer, this.eFloatingTopContainer, this.eFloatingBottomContainer];
                } else {
                    return [this.eBodyViewport, this.eFloatingTopViewport, this.eFloatingBottomViewport];
                }
            };
            GridPanel.prototype.getBodyViewport = function () {
                return this.eBodyViewport;
            };
            GridPanel.prototype.getPinnedLeftColsContainer = function () {
                return this.ePinnedLeftColsContainer;
            };
            GridPanel.prototype.getDropTargetLeftContainers = function () {
                if (this.forPrint) {
                    return [];
                } else {
                    return [this.ePinnedLeftColsViewport, this.ePinnedLeftFloatingBottom, this.ePinnedLeftFloatingTop];
                }
            };
            GridPanel.prototype.getPinnedRightColsContainer = function () {
                return this.ePinnedRightColsContainer;
            };
            GridPanel.prototype.getDropTargetPinnedRightContainers = function () {
                if (this.forPrint) {
                    return [];
                } else {
                    return [this.ePinnedRightColsViewport, this.ePinnedRightFloatingBottom, this.ePinnedRightFloatingTop];
                }
            };
            GridPanel.prototype.getHeaderContainer = function () {
                return this.eHeaderContainer;
            };
            GridPanel.prototype.getHeaderOverlay = function () {
                return this.eHeaderOverlay;
            };
            GridPanel.prototype.getRoot = function () {
                return this.eRoot;
            };
            GridPanel.prototype.getPinnedLeftHeader = function () {
                return this.ePinnedLeftHeader;
            };
            GridPanel.prototype.getPinnedRightHeader = function () {
                return this.ePinnedRightHeader;
            };
            GridPanel.prototype.queryHtmlElement = function (selector) {
                return this.eRoot.querySelector(selector);
            };
            GridPanel.prototype.findElements = function () {
                if (this.forPrint) {
                    this.eRoot = utils_1.Utils.loadTemplate(gridForPrintHtml);
                    utils_1.Utils.addCssClass(this.eRoot, 'ag-root');
                    utils_1.Utils.addCssClass(this.eRoot, 'ag-font-style');
                    utils_1.Utils.addCssClass(this.eRoot, 'ag-no-scrolls');
                } else {
                    this.eRoot = utils_1.Utils.loadTemplate(gridHtml);
                    utils_1.Utils.addCssClass(this.eRoot, 'ag-root');
                    utils_1.Utils.addCssClass(this.eRoot, 'ag-font-style');
                    utils_1.Utils.addCssClass(this.eRoot, 'ag-scrolls');
                }
                if (this.forPrint) {
                    this.eHeaderContainer = this.queryHtmlElement('.ag-header-container');
                    this.eBodyContainer = this.queryHtmlElement('.ag-body-container');
                    this.eFloatingTopContainer = this.queryHtmlElement('.ag-floating-top-container');
                    this.eFloatingBottomContainer = this.queryHtmlElement('.ag-floating-bottom-container');
                    this.eAllCellContainers = [this.eBodyContainer, this.eFloatingTopContainer, this.eFloatingBottomContainer];
                    // when doing forPrint, we don't have any fullWidth containers, instead we add directly to the main
                    // containers. this works in forPrint only as there are no pinned columns (no need for fullWidth to
                    // span pinned columns) and the rows are already the full width of the grid (the reason for fullWidth)
                    this.eFullWidthCellContainer = this.eBodyContainer;
                    this.eFloatingBottomFullWidthCellContainer = this.eFloatingBottomContainer;
                    this.eFloatingTopFullWidthCellContainer = this.eFloatingTopContainer;
                } else {
                    this.eBody = this.queryHtmlElement('.ag-body');
                    this.eBodyContainer = this.queryHtmlElement('.ag-body-container');
                    this.eBodyViewport = this.queryHtmlElement('.ag-body-viewport');
                    this.eBodyViewportWrapper = this.queryHtmlElement('.ag-body-viewport-wrapper');
                    this.eFullWidthCellContainer = this.queryHtmlElement('.ag-full-width-container');
                    this.eFullWidthCellViewport = this.queryHtmlElement('.ag-full-width-viewport');
                    this.ePinnedLeftColsContainer = this.queryHtmlElement('.ag-pinned-left-cols-container');
                    this.ePinnedRightColsContainer = this.queryHtmlElement('.ag-pinned-right-cols-container');
                    this.ePinnedLeftColsViewport = this.queryHtmlElement('.ag-pinned-left-cols-viewport');
                    this.ePinnedRightColsViewport = this.queryHtmlElement('.ag-pinned-right-cols-viewport');
                    this.ePinnedLeftHeader = this.queryHtmlElement('.ag-pinned-left-header');
                    this.ePinnedRightHeader = this.queryHtmlElement('.ag-pinned-right-header');
                    this.eHeader = this.queryHtmlElement('.ag-header');
                    this.eHeaderContainer = this.queryHtmlElement('.ag-header-container');
                    this.eHeaderOverlay = this.queryHtmlElement('.ag-header-overlay');
                    this.eHeaderViewport = this.queryHtmlElement('.ag-header-viewport');
                    this.eFloatingTop = this.queryHtmlElement('.ag-floating-top');
                    this.ePinnedLeftFloatingTop = this.queryHtmlElement('.ag-pinned-left-floating-top');
                    this.ePinnedRightFloatingTop = this.queryHtmlElement('.ag-pinned-right-floating-top');
                    this.eFloatingTopContainer = this.queryHtmlElement('.ag-floating-top-container');
                    this.eFloatingTopViewport = this.queryHtmlElement('.ag-floating-top-viewport');
                    this.eFloatingTopFullWidthCellContainer = this.queryHtmlElement('.ag-floating-top-full-width-container');
                    this.eFloatingBottom = this.queryHtmlElement('.ag-floating-bottom');
                    this.ePinnedLeftFloatingBottom = this.queryHtmlElement('.ag-pinned-left-floating-bottom');
                    this.ePinnedRightFloatingBottom = this.queryHtmlElement('.ag-pinned-right-floating-bottom');
                    this.eFloatingBottomContainer = this.queryHtmlElement('.ag-floating-bottom-container');
                    this.eFloatingBottomViewport = this.queryHtmlElement('.ag-floating-bottom-viewport');
                    this.eFloatingBottomFullWidthCellContainer = this.queryHtmlElement('.ag-floating-bottom-full-width-container');
                    this.eAllCellContainers = [this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, this.eBodyContainer, this.eFloatingTop, this.eFloatingBottom];
                    this.addMouseWheelEventListeners();
                }
            };
            GridPanel.prototype.addMouseWheelEventListeners = function () {
                var _this = this;
                var genericListener = this.genericMouseWheelListener.bind(this);
                var centerListener = this.centerMouseWheelListener.bind(this);
                // IE9, Chrome, Safari, Opera
                this.ePinnedLeftColsViewport.addEventListener('mousewheel', genericListener);
                this.eBodyViewport.addEventListener('mousewheel', centerListener);
                // Firefox
                this.ePinnedLeftColsViewport.addEventListener('DOMMouseScroll', genericListener);
                this.eBodyViewport.addEventListener('DOMMouseScroll', centerListener);
                this.destroyFunctions.push(function () {
                    _this.ePinnedLeftColsViewport.removeEventListener('mousewheel', genericListener);
                    _this.eBodyViewport.removeEventListener('mousewheel', centerListener);
                    _this.ePinnedLeftColsViewport.removeEventListener('DOMMouseScroll', genericListener);
                    _this.eBodyViewport.removeEventListener('DOMMouseScroll', centerListener);
                });
            };
            GridPanel.prototype.getHeaderViewport = function () {
                return this.eHeaderViewport;
            };
            GridPanel.prototype.centerMouseWheelListener = function (event) {
                // we are only interested in mimicking the mouse wheel if we are pinning on the right,
                // as if we are not pinning on the right, then we have scrollbars in the center body, and
                // as such we just use the default browser wheel behaviour.
                if (this.columnController.isPinningRight()) {
                    return this.generalMouseWheelListener(event, this.ePinnedRightColsViewport);
                }
            };
            // used for listening to mouse wheel events on 1) left pinned and also the 2) fullWidthCell components.
            // the fullWidthCell listener is added in renderedRow, hence public.
            GridPanel.prototype.genericMouseWheelListener = function (event) {
                var targetPanel;
                if (this.columnController.isPinningRight()) {
                    targetPanel = this.ePinnedRightColsViewport;
                } else {
                    targetPanel = this.eBodyViewport;
                }
                return this.generalMouseWheelListener(event, targetPanel);
            };
            GridPanel.prototype.generalMouseWheelListener = function (event, targetPanel) {
                var wheelEvent = utils_1.Utils.normalizeWheel(event);
                // we need to detect in which direction scroll is happening to allow trackpads scroll horizontally
                // horizontal scroll
                if (Math.abs(wheelEvent.pixelX) > Math.abs(wheelEvent.pixelY)) {
                    var newLeftPosition = this.eBodyViewport.scrollLeft + wheelEvent.pixelX;
                    this.eBodyViewport.scrollLeft = newLeftPosition;
                } else {
                    var newTopPosition = this.eBodyViewport.scrollTop + wheelEvent.pixelY;
                    targetPanel.scrollTop = newTopPosition;
                }
                // allow the option to pass mouse wheel events to the browser
                // https://github.com/ceolter/ag-grid/issues/800
                // in the future, this should be tied in with 'forPrint' option, or have an option 'no vertical scrolls'
                if (!this.gridOptionsWrapper.isSuppressPreventDefaultOnMouseWheel()) {
                    // if we don't prevent default, then the whole browser will scroll also as well as the grid
                    event.preventDefault();
                }
                return false;
            };
            GridPanel.prototype.onColumnResized = function () {
                this.setWidthsOfContainers();
            };
            GridPanel.prototype.onDisplayedColumnsChanged = function () {
                this.setWidthsOfContainers();
                this.showPinnedColContainersIfNeeded();
                this.sizeHeaderAndBody();
            };
            GridPanel.prototype.setWidthsOfContainers = function () {
                this.logger.log('setWidthsOfContainers()');
                this.showPinnedColContainersIfNeeded();
                var mainRowWidth = this.columnController.getBodyContainerWidth() + 'px';
                this.eBodyContainer.style.width = mainRowWidth;
                if (this.forPrint) {
                    // pinned col doesn't exist when doing forPrint
                    return;
                }
                this.eFloatingBottomContainer.style.width = mainRowWidth;
                this.eFloatingTopContainer.style.width = mainRowWidth;
                var pinnedLeftWidth = this.columnController.getPinnedLeftContainerWidth() + 'px';
                this.ePinnedLeftColsContainer.style.width = pinnedLeftWidth;
                this.ePinnedLeftFloatingBottom.style.width = pinnedLeftWidth;
                this.ePinnedLeftFloatingTop.style.width = pinnedLeftWidth;
                this.eBodyViewportWrapper.style.marginLeft = pinnedLeftWidth;
                var pinnedRightWidth = this.columnController.getPinnedRightContainerWidth() + 'px';
                this.ePinnedRightColsContainer.style.width = pinnedRightWidth;
                this.ePinnedRightFloatingBottom.style.width = pinnedRightWidth;
                this.ePinnedRightFloatingTop.style.width = pinnedRightWidth;
                this.eBodyViewportWrapper.style.marginRight = pinnedRightWidth;
            };
            GridPanel.prototype.showPinnedColContainersIfNeeded = function () {
                // no need to do this if not using scrolls
                if (this.forPrint) {
                    return;
                }
                //some browsers had layout issues with the blank divs, so if blank,
                //we don't display them
                if (this.columnController.isPinningLeft()) {
                    this.ePinnedLeftHeader.style.display = 'inline-block';
                    this.ePinnedLeftColsViewport.style.display = 'inline';
                } else {
                    this.ePinnedLeftHeader.style.display = 'none';
                    this.ePinnedLeftColsViewport.style.display = 'none';
                }
                if (this.columnController.isPinningRight()) {
                    this.ePinnedRightHeader.style.display = 'inline-block';
                    this.ePinnedRightColsViewport.style.display = 'inline';
                    this.eBodyViewport.style.overflowY = 'hidden';
                } else {
                    this.ePinnedRightHeader.style.display = 'none';
                    this.ePinnedRightColsViewport.style.display = 'none';
                    this.eBodyViewport.style.overflowY = 'auto';
                }
            };
            GridPanel.prototype.sizeHeaderAndBody = function () {
                if (this.forPrint) {
                    // if doing 'for print', then the header and footers are laid
                    // out naturally by the browser. it whatever size that's needed to fit.
                    return;
                }
                this.setLeftAndRightBounds();
                var heightOfContainer = this.layout.getCentreHeight();
                if (!heightOfContainer) {
                    return;
                }
                var headerHeight = this.gridOptionsWrapper.getHeaderHeight();
                var numberOfRowsInHeader = this.columnController.getHeaderRowCount();
                var totalHeaderHeight = headerHeight * numberOfRowsInHeader;
                this.eHeader.style['height'] = totalHeaderHeight + 'px';
                // padding top covers the header and the floating rows on top
                var floatingTopHeight = this.floatingRowModel.getFloatingTopTotalHeight();
                var paddingTop = totalHeaderHeight + floatingTopHeight;
                // bottom is just the bottom floating rows
                var floatingBottomHeight = this.floatingRowModel.getFloatingBottomTotalHeight();
                var floatingBottomTop = heightOfContainer - floatingBottomHeight;
                var heightOfCentreRows = heightOfContainer - totalHeaderHeight - floatingBottomHeight - floatingTopHeight;
                // this.eBody.style.paddingTop = paddingTop + 'px';
                // this.eBody.style.paddingBottom = floatingBottomHeight + 'px';
                this.eBody.style.top = paddingTop + 'px';
                this.eBody.style.height = heightOfCentreRows + 'px';
                this.eFloatingTop.style.top = totalHeaderHeight + 'px';
                this.eFloatingTop.style.height = floatingTopHeight + 'px';
                this.eFloatingBottom.style.height = floatingBottomHeight + 'px';
                this.eFloatingBottom.style.top = floatingBottomTop + 'px';
                this.ePinnedLeftColsViewport.style.height = heightOfCentreRows + 'px';
                this.ePinnedRightColsViewport.style.height = heightOfCentreRows + 'px';
            };
            GridPanel.prototype.setHorizontalScrollPosition = function (hScrollPosition) {
                this.eBodyViewport.scrollLeft = hScrollPosition;
            };
            // tries to scroll by pixels, but returns what the result actually was
            GridPanel.prototype.scrollHorizontally = function (pixels) {
                var oldScrollPosition = this.eBodyViewport.scrollLeft;
                this.setHorizontalScrollPosition(oldScrollPosition + pixels);
                var newScrollPosition = this.eBodyViewport.scrollLeft;
                return newScrollPosition - oldScrollPosition;
            };
            GridPanel.prototype.getHorizontalScrollPosition = function () {
                if (this.forPrint) {
                    return 0;
                } else {
                    return this.eBodyViewport.scrollLeft;
                }
            };
            GridPanel.prototype.turnOnAnimationForABit = function () {
                var _this = this;
                if (this.gridOptionsWrapper.isSuppressColumnMoveAnimation()) {
                    return;
                }
                this.animationThreadCount++;
                var animationThreadCountCopy = this.animationThreadCount;
                utils_1.Utils.addCssClass(this.eRoot, 'ag-column-moving');
                setTimeout(function () {
                    if (_this.animationThreadCount === animationThreadCountCopy) {
                        utils_1.Utils.removeCssClass(_this.eRoot, 'ag-column-moving');
                    }
                }, 300);
            };
            GridPanel.prototype.addScrollListener = function () {
                var _this = this;
                // if printing, then no scrolling, so no point in listening for scroll events
                if (this.forPrint) {
                    return;
                }
                var that = this;
                function onBodyViewportScroll() {
                    // we are always interested in horizontal scrolls of the body
                    var newLeftPosition = that.eBodyViewport.scrollLeft;
                    if (newLeftPosition !== that.lastLeftPosition) {
                        that.lastLeftPosition = newLeftPosition;
                        that.horizontallyScrollHeaderCenterAndFloatingCenter();
                        that.masterSlaveService.fireHorizontalScrollEvent(newLeftPosition);
                        that.setLeftAndRightBounds();
                    }
                    // if we are pinning to the right, then it's the right pinned container
                    // that has the scroll.
                    if (!that.columnController.isPinningRight()) {
                        var newTopPosition = that.eBodyViewport.scrollTop;
                        if (newTopPosition !== that.lastTopPosition) {
                            that.lastTopPosition = newTopPosition;
                            that.verticallyScrollLeftPinned(newTopPosition);
                            that.verticallyScrollFullWidthCellContainer(newTopPosition);
                            that.rowRenderer.drawVirtualRows();
                        }
                    }
                }
                function onPinnedRightScroll() {
                    var newTopPosition = that.ePinnedRightColsViewport.scrollTop;
                    if (newTopPosition !== that.lastTopPosition) {
                        that.lastTopPosition = newTopPosition;
                        that.verticallyScrollLeftPinned(newTopPosition);
                        that.verticallyScrollFullWidthCellContainer(newTopPosition);
                        that.verticallyScrollBody(newTopPosition);
                        that.rowRenderer.drawVirtualRows();
                    }
                }
                if (this.useScrollLag) {
                    this.eBodyViewport.addEventListener('scroll', this.debounce.bind(this, onBodyViewportScroll));
                    this.ePinnedRightColsViewport.addEventListener('scroll', this.debounce.bind(this, onPinnedRightScroll));
                } else {
                    this.eBodyViewport.addEventListener('scroll', onBodyViewportScroll);
                    this.ePinnedRightColsViewport.addEventListener('scroll', onPinnedRightScroll);
                }
                // this means the pinned panel was moved, which can only
                // happen when the user is navigating in the pinned container
                // as the pinned col should never scroll. so we rollback
                // the scroll on the pinned.
                this.ePinnedLeftColsViewport.addEventListener('scroll', function () {
                    _this.ePinnedLeftColsViewport.scrollTop = 0;
                });
            };
            GridPanel.prototype.setLeftAndRightBounds = function () {
                if (this.gridOptionsWrapper.isForPrint()) {
                    return;
                }
                var scrollPosition = this.eBodyViewport.scrollLeft;
                var totalWidth = this.eBody.offsetWidth;
                this.columnController.setWidthAndScrollPosition(totalWidth, scrollPosition);
            };
            GridPanel.prototype.isUseScrollLag = function () {
                // if we are in IE or Safari, then we only redraw if there was no scroll event
                // in the 50ms following this scroll event. without this, these browsers have
                // a bad scrolling feel, where the redraws clog the scroll experience
                // (makes the scroll clunky and sticky). this method is like throttling
                // the scroll events.
                // let the user override scroll lag option
                if (this.gridOptionsWrapper.isSuppressScrollLag()) {
                    return false;
                } else if (this.gridOptionsWrapper.getIsScrollLag()) {
                    return this.gridOptionsWrapper.getIsScrollLag()();
                } else {
                    return utils_1.Utils.isBrowserIE() || utils_1.Utils.isBrowserSafari();
                }
            };
            GridPanel.prototype.debounce = function (callback) {
                var _this = this;
                if (this.requestAnimationFrameExists && utils_1.Utils.isBrowserSafari()) {
                    if (!this.scrollLagTicking) {
                        this.scrollLagTicking = true;
                        requestAnimationFrame(function () {
                            callback();
                            _this.scrollLagTicking = false;
                        });
                    }
                } else {
                    this.scrollLagCounter++;
                    var scrollLagCounterCopy = this.scrollLagCounter;
                    setTimeout(function () {
                        if (_this.scrollLagCounter === scrollLagCounterCopy) {
                            callback();
                        }
                    }, 50);
                }
            };
            GridPanel.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function () {
                var bodyLeftPosition = this.eBodyViewport.scrollLeft;
                this.eHeaderContainer.style.left = -bodyLeftPosition + 'px';
                this.eFloatingBottomContainer.style.left = -bodyLeftPosition + 'px';
                this.eFloatingTopContainer.style.left = -bodyLeftPosition + 'px';
            };
            GridPanel.prototype.verticallyScrollLeftPinned = function (bodyTopPosition) {
                this.ePinnedLeftColsContainer.style.top = -bodyTopPosition + 'px';
            };
            GridPanel.prototype.verticallyScrollFullWidthCellContainer = function (bodyTopPosition) {
                this.eFullWidthCellContainer.style.top = -bodyTopPosition + 'px';
            };
            GridPanel.prototype.verticallyScrollBody = function (position) {
                this.eBodyViewport.scrollTop = position;
            };
            GridPanel.prototype.getVerticalScrollPosition = function () {
                if (this.forPrint) {
                    return 0;
                } else {
                    return this.eBodyViewport.scrollTop;
                }
            };
            GridPanel.prototype.getBodyViewportClientRect = function () {
                if (this.forPrint) {
                    return this.eBodyContainer.getBoundingClientRect();
                } else {
                    return this.eBodyViewport.getBoundingClientRect();
                }
            };
            GridPanel.prototype.getFloatingTopClientRect = function () {
                if (this.forPrint) {
                    return this.eFloatingTopContainer.getBoundingClientRect();
                } else {
                    return this.eFloatingTop.getBoundingClientRect();
                }
            };
            GridPanel.prototype.getFloatingBottomClientRect = function () {
                if (this.forPrint) {
                    return this.eFloatingBottomContainer.getBoundingClientRect();
                } else {
                    return this.eFloatingBottom.getBoundingClientRect();
                }
            };
            GridPanel.prototype.getPinnedLeftColsViewportClientRect = function () {
                return this.ePinnedLeftColsViewport.getBoundingClientRect();
            };
            GridPanel.prototype.getPinnedRightColsViewportClientRect = function () {
                return this.ePinnedRightColsViewport.getBoundingClientRect();
            };
            GridPanel.prototype.addScrollEventListener = function (listener) {
                this.eBodyViewport.addEventListener('scroll', listener);
            };
            GridPanel.prototype.removeScrollEventListener = function (listener) {
                this.eBodyViewport.removeEventListener('scroll', listener);
            };
            __decorate([context_1.Autowired('masterSlaveService'), __metadata('design:type', masterSlaveService_1.MasterSlaveService)], GridPanel.prototype, "masterSlaveService", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], GridPanel.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], GridPanel.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('rowRenderer'), __metadata('design:type', rowRenderer_1.RowRenderer)], GridPanel.prototype, "rowRenderer", void 0);
            __decorate([context_1.Autowired('floatingRowModel'), __metadata('design:type', floatingRowModel_1.FloatingRowModel)], GridPanel.prototype, "floatingRowModel", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], GridPanel.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('rowModel'), __metadata('design:type', Object)], GridPanel.prototype, "rowModel", void 0);
            __decorate([context_1.Optional('rangeController'), __metadata('design:type', Object)], GridPanel.prototype, "rangeController", void 0);
            __decorate([context_1.Autowired('dragService'), __metadata('design:type', dragService_1.DragService)], GridPanel.prototype, "dragService", void 0);
            __decorate([context_1.Autowired('selectionController'), __metadata('design:type', selectionController_1.SelectionController)], GridPanel.prototype, "selectionController", void 0);
            __decorate([context_1.Optional('clipboardService'), __metadata('design:type', Object)], GridPanel.prototype, "clipboardService", void 0);
            __decorate([context_1.Autowired('csvCreator'), __metadata('design:type', csvCreator_1.CsvCreator)], GridPanel.prototype, "csvCreator", void 0);
            __decorate([context_1.Autowired('mouseEventService'), __metadata('design:type', mouseEventService_1.MouseEventService)], GridPanel.prototype, "mouseEventService", void 0);
            __decorate([context_1.Autowired('focusedCellController'), __metadata('design:type', focusedCellController_1.FocusedCellController)], GridPanel.prototype, "focusedCellController", void 0);
            __decorate([context_1.Autowired('$scope'), __metadata('design:type', Object)], GridPanel.prototype, "$scope", void 0);
            __decorate([context_1.Optional('contextMenuFactory'), __metadata('design:type', Object)], GridPanel.prototype, "contextMenuFactory", void 0);
            __decorate([__param(0, context_1.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], GridPanel.prototype, "agWire", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], GridPanel.prototype, "destroy", null);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], GridPanel.prototype, "init", null);
            GridPanel = __decorate([context_1.Bean('gridPanel'), __metadata('design:paramtypes', [])], GridPanel);
            return GridPanel;
        }();
        exports.GridPanel = GridPanel;

        /***/ },
    /* 263 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnController_1 = __webpack_require__(251);
        var gridPanel_1 = __webpack_require__(262);
        var eventService_1 = __webpack_require__(242);
        var logger_1 = __webpack_require__(243);
        var events_1 = __webpack_require__(248);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var context_3 = __webpack_require__(244);
        var context_4 = __webpack_require__(244);
        var MasterSlaveService = function () {
            function MasterSlaveService() {
                // flag to mark if we are consuming. to avoid cyclic events (ie slave firing back to master
                // while processing a master event) we mark this if consuming an event, and if we are, then
                // we don't fire back any events.
                this.consuming = false;
            }
            MasterSlaveService.prototype.setBeans = function (loggerFactory) {
                this.logger = loggerFactory.create('MasterSlaveService');
            };
            MasterSlaveService.prototype.init = function () {
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this));
            };
            // common logic across all the fire methods
            MasterSlaveService.prototype.fireEvent = function (callback) {
                // if we are already consuming, then we are acting on an event from a master,
                // so we don't cause a cyclic firing of events
                if (this.consuming) {
                    return;
                }
                // iterate through the slave grids, and pass each slave service to the callback
                var slaveGrids = this.gridOptionsWrapper.getSlaveGrids();
                if (slaveGrids) {
                    slaveGrids.forEach(function (slaveGridOptions) {
                        if (slaveGridOptions.api) {
                            var slaveService = slaveGridOptions.api.__getMasterSlaveService();
                            callback(slaveService);
                        }
                    });
                }
            };
            // common logic across all consume methods. very little common logic, however extracting
            // guarantees consistency across the methods.
            MasterSlaveService.prototype.onEvent = function (callback) {
                this.consuming = true;
                callback();
                this.consuming = false;
            };
            MasterSlaveService.prototype.fireColumnEvent = function (event) {
                this.fireEvent(function (slaveService) {
                    slaveService.onColumnEvent(event);
                });
            };
            MasterSlaveService.prototype.fireHorizontalScrollEvent = function (horizontalScroll) {
                this.fireEvent(function (slaveService) {
                    slaveService.onScrollEvent(horizontalScroll);
                });
            };
            MasterSlaveService.prototype.onScrollEvent = function (horizontalScroll) {
                var _this = this;
                this.onEvent(function () {
                    _this.gridPanel.setHorizontalScrollPosition(horizontalScroll);
                });
            };
            MasterSlaveService.prototype.getMasterColumns = function (event) {
                var result = [];
                if (event.getColumn()) {
                    result.push(event.getColumn());
                }
                if (event.getColumns()) {
                    event.getColumns().forEach(function (column) {
                        result.push(column);
                    });
                }
                return result;
            };
            MasterSlaveService.prototype.getColumnIds = function (event) {
                var result = [];
                if (event.getColumn()) {
                    result.push(event.getColumn().getColId());
                } else if (event.getColumns()) {
                    event.getColumns().forEach(function (column) {
                        result.push(column.getColId());
                    });
                }
                return result;
            };
            MasterSlaveService.prototype.onColumnEvent = function (event) {
                var _this = this;
                this.onEvent(function () {
                    // the column in the event is from the master grid. need to
                    // look up the equivalent from this (slave) grid
                    var masterColumn = event.getColumn();
                    var slaveColumn;
                    if (masterColumn) {
                        slaveColumn = _this.columnController.getPrimaryColumn(masterColumn.getColId());
                    }
                    // if event was with respect to a master column, that is not present in this
                    // grid, then we ignore the event
                    if (masterColumn && !slaveColumn) {
                        return;
                    }
                    // likewise for column group
                    var masterColumnGroup = event.getColumnGroup();
                    var slaveColumnGroup;
                    if (masterColumnGroup) {
                        var colId = masterColumnGroup.getGroupId();
                        var instanceId = masterColumnGroup.getInstanceId();
                        slaveColumnGroup = _this.columnController.getColumnGroup(colId, instanceId);
                    }
                    if (masterColumnGroup && !slaveColumnGroup) {
                        return;
                    }
                    // in time, all the methods below should use the column ids, it's a more generic way
                    // of handling columns, and also allows for single or multi column events
                    var columnIds = _this.getColumnIds(event);
                    var masterColumns = _this.getMasterColumns(event);
                    switch (event.getType()) {
                        case events_1.Events.EVENT_COLUMN_PIVOT_CHANGED:
                            // we cannot support pivoting with master / slave as the columns will be out of sync as the
                            // grids will have columns created based on the row data of the grid.
                            console.warn('ag-Grid: pivoting is not supported with Master / Slave grids. ' + 'You can only use one of these features at a time in a grid.');
                            break;
                        case events_1.Events.EVENT_COLUMN_MOVED:
                            _this.logger.log('onColumnEvent-> processing ' + event + ' toIndex = ' + event.getToIndex());
                            _this.columnController.moveColumns(columnIds, event.getToIndex());
                            break;
                        case events_1.Events.EVENT_COLUMN_VISIBLE:
                            _this.logger.log('onColumnEvent-> processing ' + event + ' visible = ' + event.isVisible());
                            _this.columnController.setColumnsVisible(columnIds, event.isVisible());
                            break;
                        case events_1.Events.EVENT_COLUMN_PINNED:
                            _this.logger.log('onColumnEvent-> processing ' + event + ' pinned = ' + event.getPinned());
                            _this.columnController.setColumnsPinned(columnIds, event.getPinned());
                            break;
                        case events_1.Events.EVENT_COLUMN_GROUP_OPENED:
                            _this.logger.log('onColumnEvent-> processing ' + event + ' expanded = ' + masterColumnGroup.isExpanded());
                            _this.columnController.setColumnGroupOpened(slaveColumnGroup, masterColumnGroup.isExpanded());
                            break;
                        case events_1.Events.EVENT_COLUMN_RESIZED:
                            masterColumns.forEach(function (masterColumn) {
                                _this.logger.log('onColumnEvent-> processing ' + event + ' actualWidth = ' + masterColumn.getActualWidth());
                                _this.columnController.setColumnWidth(masterColumn.getColId(), masterColumn.getActualWidth(), event.isFinished());
                            });
                            break;
                    }
                });
            };
            __decorate([context_3.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], MasterSlaveService.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_3.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], MasterSlaveService.prototype, "columnController", void 0);
            __decorate([context_3.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], MasterSlaveService.prototype, "gridPanel", void 0);
            __decorate([context_3.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], MasterSlaveService.prototype, "eventService", void 0);
            __decorate([__param(0, context_2.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], MasterSlaveService.prototype, "setBeans", null);
            __decorate([context_4.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], MasterSlaveService.prototype, "init", null);
            MasterSlaveService = __decorate([context_1.Bean('masterSlaveService'), __metadata('design:paramtypes', [])], MasterSlaveService);
            return MasterSlaveService;
        }();
        exports.MasterSlaveService = MasterSlaveService;

        /***/ },
    /* 264 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var rowNode_1 = __webpack_require__(265);
        var context_1 = __webpack_require__(244);
        var eventService_1 = __webpack_require__(242);
        var context_2 = __webpack_require__(244);
        var events_1 = __webpack_require__(248);
        var context_3 = __webpack_require__(244);
        var constants_1 = __webpack_require__(246);
        var utils_1 = __webpack_require__(245);
        var FloatingRowModel = function () {
            function FloatingRowModel() {}
            FloatingRowModel.prototype.init = function () {
                this.setFloatingTopRowData(this.gridOptionsWrapper.getFloatingTopRowData());
                this.setFloatingBottomRowData(this.gridOptionsWrapper.getFloatingBottomRowData());
            };
            FloatingRowModel.prototype.isEmpty = function (floating) {
                var rows = floating === constants_1.Constants.FLOATING_TOP ? this.floatingTopRows : this.floatingBottomRows;
                return utils_1.Utils.missingOrEmpty(rows);
            };
            FloatingRowModel.prototype.isRowsToRender = function (floating) {
                return !this.isEmpty(floating);
            };
            FloatingRowModel.prototype.getRowAtPixel = function (pixel, floating) {
                var rows = floating === constants_1.Constants.FLOATING_TOP ? this.floatingTopRows : this.floatingBottomRows;
                if (utils_1.Utils.missingOrEmpty(rows)) {
                    return 0; // this should never happen, just in case, 0 is graceful failure
                }
                for (var i = 0; i < rows.length; i++) {
                    var rowNode = rows[i];
                    var rowTopPixel = rowNode.rowTop + rowNode.rowHeight - 1;
                    // only need to range check against the top pixel, as we are going through the list
                    // in order, first row to hit the pixel wins
                    if (rowTopPixel >= pixel) {
                        return i;
                    }
                }
                return rows.length - 1;
            };
            FloatingRowModel.prototype.setFloatingTopRowData = function (rowData) {
                this.floatingTopRows = this.createNodesFromData(rowData, true);
                this.eventService.dispatchEvent(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED);
            };
            FloatingRowModel.prototype.setFloatingBottomRowData = function (rowData) {
                this.floatingBottomRows = this.createNodesFromData(rowData, false);
                this.eventService.dispatchEvent(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED);
            };
            FloatingRowModel.prototype.createNodesFromData = function (allData, isTop) {
                var _this = this;
                var rowNodes = [];
                if (allData) {
                    var nextRowTop = 0;
                    allData.forEach(function (dataItem) {
                        var rowNode = new rowNode_1.RowNode();
                        _this.context.wireBean(rowNode);
                        rowNode.data = dataItem;
                        rowNode.floating = isTop ? constants_1.Constants.FLOATING_TOP : constants_1.Constants.FLOATING_BOTTOM;
                        rowNode.rowTop = nextRowTop;
                        rowNode.rowHeight = _this.gridOptionsWrapper.getRowHeightForNode(rowNode);
                        nextRowTop += rowNode.rowHeight;
                        rowNodes.push(rowNode);
                    });
                }
                return rowNodes;
            };
            FloatingRowModel.prototype.getFloatingTopRowData = function () {
                return this.floatingTopRows;
            };
            FloatingRowModel.prototype.getFloatingBottomRowData = function () {
                return this.floatingBottomRows;
            };
            FloatingRowModel.prototype.getFloatingTopTotalHeight = function () {
                return this.getTotalHeight(this.floatingTopRows);
            };
            FloatingRowModel.prototype.forEachFloatingTopRow = function (callback) {
                if (utils_1.Utils.missingOrEmpty(this.floatingTopRows)) {
                    return;
                }
                this.floatingTopRows.forEach(callback);
            };
            FloatingRowModel.prototype.forEachFloatingBottomRow = function (callback) {
                if (utils_1.Utils.missingOrEmpty(this.floatingBottomRows)) {
                    return;
                }
                this.floatingBottomRows.forEach(callback);
            };
            FloatingRowModel.prototype.getFloatingBottomTotalHeight = function () {
                return this.getTotalHeight(this.floatingBottomRows);
            };
            FloatingRowModel.prototype.getTotalHeight = function (rowNodes) {
                if (!rowNodes || rowNodes.length === 0) {
                    return 0;
                } else {
                    var lastNode = rowNodes[rowNodes.length - 1];
                    return lastNode.rowTop + lastNode.rowHeight;
                }
            };
            __decorate([context_2.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], FloatingRowModel.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_2.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], FloatingRowModel.prototype, "eventService", void 0);
            __decorate([context_2.Autowired('context'), __metadata('design:type', context_1.Context)], FloatingRowModel.prototype, "context", void 0);
            __decorate([context_3.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], FloatingRowModel.prototype, "init", null);
            FloatingRowModel = __decorate([context_1.Bean('floatingRowModel'), __metadata('design:paramtypes', [])], FloatingRowModel);
            return FloatingRowModel;
        }();
        exports.FloatingRowModel = FloatingRowModel;

        /***/ },
    /* 265 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var selectionController_1 = __webpack_require__(266);
        var valueService_1 = __webpack_require__(267);
        var columnController_1 = __webpack_require__(251);
        var context_1 = __webpack_require__(244);
        var constants_1 = __webpack_require__(246);
        var RowNode = function () {
            function RowNode() {
                /** Children mapped by the pivot columns */
                this.childrenMapped = {};
                this.selected = false;
            }
            RowNode.prototype.setData = function (data) {
                var oldData = this.data;
                this.data = data;
                var event = { oldData: oldData, newData: data };
                this.dispatchLocalEvent(RowNode.EVENT_DATA_CHANGED, event);
            };
            RowNode.prototype.setDataAndId = function (data, id) {
                var oldData = this.data;
                this.data = data;
                this.setId(id);
                this.selectionController.syncInRowNode(this);
                var event = { oldData: oldData, newData: data };
                this.dispatchLocalEvent(RowNode.EVENT_DATA_CHANGED, event);
            };
            RowNode.prototype.setId = function (id) {
                // see if user is providing the id's
                var getRowNodeId = this.gridOptionsWrapper.getRowNodeIdFunc();
                if (getRowNodeId) {
                    // if user is providing the id's, then we set the id only after the data has been set.
                    // this is important for virtual pagination and viewport, where empty rows exist.
                    if (this.data) {
                        this.id = getRowNodeId(this.data);
                    } else {
                        // this can happen if user has set blank into the rowNode after the row previously
                        // having data. this happens in virtual page row model, when data is delete and
                        // the page is refreshed.
                        this.id = undefined;
                    }
                } else {
                    this.id = id;
                }
            };
            RowNode.prototype.dispatchLocalEvent = function (eventName, event) {
                if (this.eventService) {
                    this.eventService.dispatchEvent(eventName, event);
                }
            };
            // we also allow editing the value via the editors. when it is done via
            // the editors, no 'cell changed' event gets fired, as it's assumed that
            // the cell knows about the change given it's in charge of the editing.
            // this method is for the client to call, so the cell listens for the change
            // event, and also flashes the cell when the change occurs.
            RowNode.prototype.setDataValue = function (colKey, newValue) {
                var column = this.columnController.getGridColumn(colKey);
                this.valueService.setValue(this, column, newValue);
                var event = { column: column, newValue: newValue };
                this.dispatchLocalEvent(RowNode.EVENT_CELL_CHANGED, event);
            };
            RowNode.prototype.resetQuickFilterAggregateText = function () {
                this.quickFilterAggregateText = null;
            };
            RowNode.prototype.isExpandable = function () {
                return this.group || this.canFlower;
            };
            RowNode.prototype.isSelected = function () {
                // for footers, we just return what our sibling selected state is, as cannot select a footer
                if (this.footer) {
                    return this.sibling.isSelected();
                }
                return this.selected;
            };
            RowNode.prototype.deptFirstSearch = function (callback) {
                if (this.childrenAfterGroup) {
                    this.childrenAfterGroup.forEach(function (child) {
                        return child.deptFirstSearch(callback);
                    });
                }
                callback(this);
            };
            // + rowController.updateGroupsInSelection()
            RowNode.prototype.calculateSelectedFromChildren = function () {
                var atLeastOneSelected = false;
                var atLeastOneDeSelected = false;
                var atLeastOneMixed = false;
                var newSelectedValue;
                if (this.childrenAfterGroup) {
                    for (var i = 0; i < this.childrenAfterGroup.length; i++) {
                        var childState = this.childrenAfterGroup[i].isSelected();
                        switch (childState) {
                            case true:
                                atLeastOneSelected = true;
                                break;
                            case false:
                                atLeastOneDeSelected = true;
                                break;
                            default:
                                atLeastOneMixed = true;
                                break;
                        }
                    }
                }
                if (atLeastOneMixed) {
                    newSelectedValue = undefined;
                } else if (atLeastOneSelected && !atLeastOneDeSelected) {
                    newSelectedValue = true;
                } else if (!atLeastOneSelected && atLeastOneDeSelected) {
                    newSelectedValue = false;
                } else {
                    newSelectedValue = undefined;
                }
                this.selectThisNode(newSelectedValue);
            };
            RowNode.prototype.calculateSelectedFromChildrenBubbleUp = function () {
                this.calculateSelectedFromChildren();
                if (this.parent) {
                    this.parent.calculateSelectedFromChildrenBubbleUp();
                }
            };
            RowNode.prototype.setSelectedInitialValue = function (selected) {
                this.selected = selected;
            };
            RowNode.prototype.setSelected = function (newValue, clearSelection, tailingNodeInSequence) {
                if (clearSelection === void 0) {
                    clearSelection = false;
                }
                if (tailingNodeInSequence === void 0) {
                    tailingNodeInSequence = false;
                }
                this.setSelectedParams({
                    newValue: newValue,
                    clearSelection: clearSelection,
                    tailingNodeInSequence: tailingNodeInSequence,
                    rangeSelect: false
                });
            };
            // to make calling code more readable, this is the same method as setSelected except it takes names parameters
            RowNode.prototype.setSelectedParams = function (params) {
                var newValue = params.newValue === true;
                var clearSelection = params.clearSelection === true;
                var tailingNodeInSequence = params.tailingNodeInSequence === true;
                var rangeSelect = params.rangeSelect === true;
                if (this.id === undefined) {
                    console.warn('ag-Grid: cannot select node until id for node is known');
                    return;
                }
                if (this.floating) {
                    console.log('ag-Grid: cannot select floating rows');
                    return;
                }
                // if we are a footer, we don't do selection, just pass the info
                // to the sibling (the parent of the group)
                if (this.footer) {
                    this.sibling.setSelectedParams(params);
                    return;
                }
                if (rangeSelect) {
                    var rowModelNormal = this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL;
                    var newRowClicked = this.selectionController.getLastSelectedNode() !== this;
                    var allowMultiSelect = this.gridOptionsWrapper.isRowSelectionMulti();
                    if (rowModelNormal && newRowClicked && allowMultiSelect) {
                        this.doRowRangeSelection();
                        return;
                    }
                }
                this.selectThisNode(newValue);
                var groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
                if (groupSelectsChildren && this.group) {
                    this.selectChildNodes(newValue);
                }
                // clear other nodes if not doing multi select
                var actionWasOnThisNode = !tailingNodeInSequence;
                if (actionWasOnThisNode) {
                    if (newValue && (clearSelection || !this.gridOptionsWrapper.isRowSelectionMulti())) {
                        this.selectionController.clearOtherNodes(this);
                    }
                    if (groupSelectsChildren && this.parent) {
                        this.parent.calculateSelectedFromChildrenBubbleUp();
                    }
                    // this is the very end of the 'action node', so we are finished all the updates,
                    // include any parent / child changes that this method caused
                    this.mainEventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
                    // so if user next does shift-select, we know where to start the selection from
                    if (newValue) {
                        this.selectionController.setLastSelectedNode(this);
                    }
                }
            };
            // selects all rows between this node and the last selected node (or the top if this is the first selection).
            // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
            // holding down 'shift'.
            RowNode.prototype.doRowRangeSelection = function () {
                var _this = this;
                var lastSelectedNode = this.selectionController.getLastSelectedNode();
                // if lastSelectedNode is missing, we start at the first row
                var firstRowHit = !lastSelectedNode;
                var lastRowHit = false;
                var lastRow;
                var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
                var inMemoryRowModel = this.rowModel;
                inMemoryRowModel.forEachNodeAfterFilterAndSort(function (rowNode) {
                    var lookingForLastRow = firstRowHit && !lastRowHit;
                    // check if we need to flip the select switch
                    if (!firstRowHit) {
                        if (rowNode === lastSelectedNode || rowNode === _this) {
                            firstRowHit = true;
                        }
                    }
                    var skipThisGroupNode = rowNode.group && groupsSelectChildren;
                    if (!skipThisGroupNode) {
                        var inRange = firstRowHit && !lastRowHit;
                        var childOfLastRow = rowNode.isParentOfNode(lastRow);
                        rowNode.selectThisNode(inRange || childOfLastRow);
                    }
                    if (lookingForLastRow) {
                        if (rowNode === lastSelectedNode || rowNode === _this) {
                            lastRowHit = true;
                            if (rowNode === lastSelectedNode) {
                                lastRow = lastSelectedNode;
                            } else {
                                lastRow = _this;
                            }
                        }
                    }
                });
                if (groupsSelectChildren) {
                    this.calculatedSelectedForAllGroupNodes();
                }
                this.mainEventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
            };
            RowNode.prototype.isParentOfNode = function (potentialParent) {
                var parentNode = this.parent;
                while (parentNode) {
                    if (parentNode === potentialParent) {
                        return true;
                    }
                    parentNode = parentNode.parent;
                }
                return false;
            };
            RowNode.prototype.calculatedSelectedForAllGroupNodes = function () {
                // we have to make sure we do this dept first, as parent nodes
                // will have dependencies on the children having correct values
                var inMemoryRowModel = this.rowModel;
                inMemoryRowModel.getTopLevelNodes().forEach(function (topLevelNode) {
                    if (topLevelNode.group) {
                        topLevelNode.deptFirstSearch(function (childNode) {
                            if (childNode.group) {
                                childNode.calculateSelectedFromChildren();
                            }
                        });
                        topLevelNode.calculateSelectedFromChildren();
                    }
                });
            };
            RowNode.prototype.selectThisNode = function (newValue) {
                if (this.selected !== newValue) {
                    this.selected = newValue;
                    if (this.eventService) {
                        this.dispatchLocalEvent(RowNode.EVENT_ROW_SELECTED);
                    }
                    var event = { node: this };
                    this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_SELECTED, event);
                }
            };
            RowNode.prototype.selectChildNodes = function (newValue) {
                for (var i = 0; i < this.childrenAfterGroup.length; i++) {
                    this.childrenAfterGroup[i].setSelectedParams({
                        newValue: newValue,
                        clearSelection: false,
                        tailingNodeInSequence: true
                    });
                }
            };
            RowNode.prototype.addEventListener = function (eventType, listener) {
                if (!this.eventService) {
                    this.eventService = new eventService_1.EventService();
                }
                this.eventService.addEventListener(eventType, listener);
            };
            RowNode.prototype.removeEventListener = function (eventType, listener) {
                this.eventService.removeEventListener(eventType, listener);
            };
            RowNode.prototype.onMouseEnter = function () {
                this.dispatchLocalEvent(RowNode.EVENT_MOUSE_ENTER);
            };
            RowNode.prototype.onMouseLeave = function () {
                this.dispatchLocalEvent(RowNode.EVENT_MOUSE_LEAVE);
            };
            RowNode.EVENT_ROW_SELECTED = 'rowSelected';
            RowNode.EVENT_DATA_CHANGED = 'dataChanged';
            RowNode.EVENT_CELL_CHANGED = 'cellChanged';
            RowNode.EVENT_MOUSE_ENTER = 'mouseEnter';
            RowNode.EVENT_MOUSE_LEAVE = 'mouseLeave';
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], RowNode.prototype, "mainEventService", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], RowNode.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('selectionController'), __metadata('design:type', selectionController_1.SelectionController)], RowNode.prototype, "selectionController", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], RowNode.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('valueService'), __metadata('design:type', valueService_1.ValueService)], RowNode.prototype, "valueService", void 0);
            __decorate([context_1.Autowired('rowModel'), __metadata('design:type', Object)], RowNode.prototype, "rowModel", void 0);
            return RowNode;
        }();
        exports.RowNode = RowNode;

        /***/ },
    /* 266 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var utils_1 = __webpack_require__(245);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var logger_1 = __webpack_require__(243);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var context_3 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var context_4 = __webpack_require__(244);
        var constants_1 = __webpack_require__(246);
        var SelectionController = function () {
            function SelectionController() {}
            SelectionController.prototype.setBeans = function (loggerFactory) {
                this.logger = loggerFactory.create('SelectionController');
                this.reset();
                if (this.gridOptionsWrapper.isRowModelDefault()) {
                    this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.reset.bind(this));
                } else {
                    this.logger.log('dont know what to do here');
                }
            };
            SelectionController.prototype.init = function () {
                this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
                this.eventService.addEventListener(events_1.Events.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
            };
            SelectionController.prototype.setLastSelectedNode = function (rowNode) {
                this.lastSelectedNode = rowNode;
            };
            SelectionController.prototype.getLastSelectedNode = function () {
                return this.lastSelectedNode;
            };
            SelectionController.prototype.getSelectedNodes = function () {
                var selectedNodes = [];
                utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
                    if (rowNode) {
                        selectedNodes.push(rowNode);
                    }
                });
                return selectedNodes;
            };
            SelectionController.prototype.getSelectedRows = function () {
                var selectedRows = [];
                utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
                    if (rowNode) {
                        selectedRows.push(rowNode.data);
                    }
                });
                return selectedRows;
            };
            SelectionController.prototype.removeGroupsFromSelection = function () {
                var _this = this;
                utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
                    if (rowNode && rowNode.group) {
                        _this.selectedNodes[rowNode.id] = undefined;
                    }
                });
            };
            // should only be called if groupSelectsChildren=true
            SelectionController.prototype.updateGroupsFromChildrenSelections = function () {
                if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
                    console.warn('updateGroupsFromChildrenSelections not available when rowModel is not normal');
                }
                var inMemoryRowModel = this.rowModel;
                inMemoryRowModel.getTopLevelNodes().forEach(function (rowNode) {
                    rowNode.deptFirstSearch(function (rowNode) {
                        if (rowNode.group) {
                            rowNode.calculateSelectedFromChildren();
                        }
                    });
                });
            };
            SelectionController.prototype.getNodeForIdIfSelected = function (id) {
                return this.selectedNodes[id];
            };
            SelectionController.prototype.clearOtherNodes = function (rowNodeToKeepSelected) {
                var _this = this;
                var groupsToRefresh = {};
                utils_1.Utils.iterateObject(this.selectedNodes, function (key, otherRowNode) {
                    if (otherRowNode && otherRowNode.id !== rowNodeToKeepSelected.id) {
                        _this.selectedNodes[otherRowNode.id].setSelectedParams({ newValue: false, clearSelection: false, tailingNodeInSequence: true });
                        if (_this.groupSelectsChildren && otherRowNode.parent) {
                            groupsToRefresh[otherRowNode.parent.id] = otherRowNode.parent;
                        }
                    }
                });
                utils_1.Utils.iterateObject(groupsToRefresh, function (key, group) {
                    group.calculateSelectedFromChildren();
                });
            };
            SelectionController.prototype.onRowSelected = function (event) {
                var rowNode = event.node;
                // we do not store the group rows when the groups select children
                if (this.groupSelectsChildren && rowNode.group) {
                    return;
                }
                if (rowNode.isSelected()) {
                    this.selectedNodes[rowNode.id] = rowNode;
                } else {
                    this.selectedNodes[rowNode.id] = undefined;
                }
            };
            SelectionController.prototype.syncInRowNode = function (rowNode) {
                if (this.selectedNodes[rowNode.id] !== undefined) {
                    rowNode.setSelectedInitialValue(true);
                    this.selectedNodes[rowNode.id] = rowNode;
                }
            };
            SelectionController.prototype.reset = function () {
                this.logger.log('reset');
                this.selectedNodes = {};
                this.lastSelectedNode = null;
            };
            // returns a list of all nodes at 'best cost' - a feature to be used
            // with groups / trees. if a group has all it's children selected,
            // then the group appears in the result, but not the children.
            // Designed for use with 'children' as the group selection type,
            // where groups don't actually appear in the selection normally.
            SelectionController.prototype.getBestCostNodeSelection = function () {
                if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
                    console.warn('getBestCostNodeSelection is only avilable when using normal row model');
                }
                var inMemoryRowModel = this.rowModel;
                var topLevelNodes = inMemoryRowModel.getTopLevelNodes();
                if (topLevelNodes === null) {
                    console.warn('selectAll not available doing rowModel=virtual');
                    return;
                }
                var result = [];
                // recursive function, to find the selected nodes
                function traverse(nodes) {
                    for (var i = 0, l = nodes.length; i < l; i++) {
                        var node = nodes[i];
                        if (node.isSelected()) {
                            result.push(node);
                        } else {
                            // if not selected, then if it's a group, and the group
                            // has children, continue to search for selections
                            if (node.group && node.children) {
                                traverse(node.children);
                            }
                        }
                    }
                }
                traverse(topLevelNodes);
                return result;
            };
            SelectionController.prototype.setRowModel = function (rowModel) {
                this.rowModel = rowModel;
            };
            SelectionController.prototype.isEmpty = function () {
                var count = 0;
                utils_1.Utils.iterateObject(this.selectedNodes, function (nodeId, rowNode) {
                    if (rowNode) {
                        count++;
                    }
                });
                return count === 0;
            };
            SelectionController.prototype.deselectAllRowNodes = function () {
                utils_1.Utils.iterateObject(this.selectedNodes, function (nodeId, rowNode) {
                    if (rowNode) {
                        rowNode.selectThisNode(false);
                    }
                });
                // the above does not clean up the parent rows if they are selected
                if (this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL && this.groupSelectsChildren) {
                    this.updateGroupsFromChildrenSelections();
                }
                // we should not have to do this, as deselecting the nodes fires events
                // that we pick up, however it's good to clean it down, as we are still
                // left with entries pointing to 'undefined'
                this.selectedNodes = {};
                this.eventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
            };
            SelectionController.prototype.selectAllRowNodes = function () {
                if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
                    throw 'selectAll only available with normal row model, ie not virtual pagination';
                }
                this.rowModel.forEachNode(function (rowNode) {
                    rowNode.selectThisNode(true);
                });
                this.eventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
            };
            // Deprecated method
            SelectionController.prototype.selectNode = function (rowNode, tryMulti) {
                rowNode.setSelectedParams({ newValue: true, clearSelection: !tryMulti });
            };
            // Deprecated method
            SelectionController.prototype.deselectIndex = function (rowIndex) {
                var node = this.rowModel.getRow(rowIndex);
                this.deselectNode(node);
            };
            // Deprecated method
            SelectionController.prototype.deselectNode = function (rowNode) {
                rowNode.setSelectedParams({ newValue: false, clearSelection: false });
            };
            // Deprecated method
            SelectionController.prototype.selectIndex = function (index, tryMulti) {
                var node = this.rowModel.getRow(index);
                this.selectNode(node, tryMulti);
            };
            __decorate([context_3.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], SelectionController.prototype, "eventService", void 0);
            __decorate([context_3.Autowired('rowModel'), __metadata('design:type', Object)], SelectionController.prototype, "rowModel", void 0);
            __decorate([context_3.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], SelectionController.prototype, "gridOptionsWrapper", void 0);
            __decorate([__param(0, context_2.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], SelectionController.prototype, "setBeans", null);
            __decorate([context_4.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], SelectionController.prototype, "init", null);
            SelectionController = __decorate([context_1.Bean('selectionController'), __metadata('design:paramtypes', [])], SelectionController);
            return SelectionController;
        }();
        exports.SelectionController = SelectionController;

        /***/ },
    /* 267 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var expressionService_1 = __webpack_require__(256);
        var columnController_1 = __webpack_require__(251);
        var context_1 = __webpack_require__(244);
        var utils_1 = __webpack_require__(245);
        var events_1 = __webpack_require__(248);
        var eventService_1 = __webpack_require__(242);
        var ValueService = function () {
            function ValueService() {
                this.initialised = false;
            }
            ValueService.prototype.init = function () {
                this.cellExpressions = this.gridOptionsWrapper.isEnableCellExpressions();
                this.userProvidedTheGroups = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
                this.suppressUseColIdForGroups = this.gridOptionsWrapper.isSuppressUseColIdForGroups();
                this.initialised = true;
            };
            ValueService.prototype.getValue = function (column, node) {
                return this.getValueUsingSpecificData(column, node.data, node);
            };
            ValueService.prototype.getValueUsingSpecificData = function (column, data, node) {
                // hack - the grid is getting refreshed before this bean gets initialised, race condition.
                // really should have a way so they get initialised in the right order???
                if (!this.initialised) {
                    this.init();
                }
                var colDef = column.getColDef();
                var field = colDef.field;
                var result;
                // if there is a value getter, this gets precedence over a field
                // - need to revisit this, we check 'data' as this is the way for the grid to
                //   not render when on the footer row
                if (data && node.group && !this.userProvidedTheGroups && !this.suppressUseColIdForGroups) {
                    result = node.data ? node.data[column.getId()] : undefined;
                } else if (colDef.valueGetter) {
                    result = this.executeValueGetter(colDef.valueGetter, data, column, node);
                } else if (field && data) {
                    result = utils_1.Utils.getValueUsingField(data, field, column.isFieldContainsDots());
                } else {
                    result = undefined;
                }
                // the result could be an expression itself, if we are allowing cell values to be expressions
                if (this.cellExpressions && typeof result === 'string' && result.indexOf('=') === 0) {
                    var cellValueGetter = result.substring(1);
                    result = this.executeValueGetter(cellValueGetter, data, column, node);
                }
                return result;
            };
            ValueService.prototype.setValue = function (rowNode, colKey, newValue) {
                var column = this.columnController.getPrimaryColumn(colKey);
                if (!rowNode || !column) {
                    return;
                }
                // this will only happen if user is trying to paste into a group row, which doesn't make sense
                // the user should not be trying to paste into group rows
                var data = rowNode.data;
                if (utils_1.Utils.missing(data)) {
                    return;
                }
                var field = column.getColDef().field;
                var newValueHandler = column.getColDef().newValueHandler;
                // need either a field or a newValueHandler for this to work
                if (utils_1.Utils.missing(field) && utils_1.Utils.missing(newValueHandler)) {
                    console.warn("ag-Grid: you need either field or newValueHandler set on colDef for editing to work");
                    return;
                }
                var paramsForCallbacks = {
                    node: rowNode,
                    data: rowNode.data,
                    oldValue: this.getValue(column, rowNode),
                    newValue: newValue,
                    colDef: column.getColDef(),
                    api: this.gridOptionsWrapper.getApi(),
                    context: this.gridOptionsWrapper.getContext()
                };
                if (newValueHandler) {
                    newValueHandler(paramsForCallbacks);
                } else {
                    this.setValueUsingField(data, field, newValue, column.isFieldContainsDots());
                }
                // reset quick filter on this row
                rowNode.resetQuickFilterAggregateText();
                paramsForCallbacks.newValue = this.getValue(column, rowNode);
                if (typeof column.getColDef().onCellValueChanged === 'function') {
                    column.getColDef().onCellValueChanged(paramsForCallbacks);
                }
                this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_VALUE_CHANGED, paramsForCallbacks);
            };
            ValueService.prototype.setValueUsingField = function (data, field, newValue, isFieldContainsDots) {
                // if no '.', then it's not a deep value
                if (!isFieldContainsDots) {
                    data[field] = newValue;
                } else {
                    // otherwise it is a deep value, so need to dig for it
                    var fieldPieces = field.split('.');
                    var currentObject = data;
                    while (fieldPieces.length > 0 && currentObject) {
                        var fieldPiece = fieldPieces.shift();
                        if (fieldPieces.length === 0) {
                            currentObject[fieldPiece] = newValue;
                        } else {
                            currentObject = currentObject[fieldPiece];
                        }
                    }
                }
            };
            ValueService.prototype.executeValueGetter = function (valueGetter, data, column, node) {
                var context = this.gridOptionsWrapper.getContext();
                var api = this.gridOptionsWrapper.getApi();
                var params = {
                    data: data,
                    node: node,
                    colDef: column.getColDef(),
                    api: api,
                    context: context,
                    getValue: this.getValueCallback.bind(this, data, node)
                };
                if (typeof valueGetter === 'function') {
                    // valueGetter is a function, so just call it
                    return valueGetter(params);
                } else if (typeof valueGetter === 'string') {
                    // valueGetter is an expression, so execute the expression
                    return this.expressionService.evaluate(valueGetter, params);
                }
            };
            ValueService.prototype.getValueCallback = function (data, node, field) {
                var otherColumn = this.columnController.getPrimaryColumn(field);
                if (otherColumn) {
                    return this.getValueUsingSpecificData(otherColumn, data, node);
                } else {
                    return null;
                }
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], ValueService.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('expressionService'), __metadata('design:type', expressionService_1.ExpressionService)], ValueService.prototype, "expressionService", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], ValueService.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], ValueService.prototype, "eventService", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ValueService.prototype, "init", null);
            ValueService = __decorate([context_1.Bean('valueService'), __metadata('design:paramtypes', [])], ValueService);
            return ValueService;
        }();
        exports.ValueService = ValueService;

        /***/ },
    /* 268 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var utils_1 = __webpack_require__(245);
        var BorderLayout = function () {
            function BorderLayout(params) {
                this.centerHeightLastTime = -1;
                this.centerWidthLastTime = -1;
                this.centerLeftMarginLastTime = -1;
                this.visibleLastTime = false;
                this.sizeChangeListeners = [];
                this.isLayoutPanel = true;
                this.fullHeight = !params.north && !params.south;
                var template;
                if (!params.dontFill) {
                    if (this.fullHeight) {
                        template = BorderLayout.TEMPLATE_FULL_HEIGHT;
                    } else {
                        template = BorderLayout.TEMPLATE_NORMAL;
                    }
                    this.layoutActive = true;
                } else {
                    template = BorderLayout.TEMPLATE_DONT_FILL;
                    this.layoutActive = false;
                }
                this.eGui = utils_1.Utils.loadTemplate(template);
                this.id = 'borderLayout';
                if (params.name) {
                    this.id += '_' + params.name;
                }
                this.eGui.setAttribute('id', this.id);
                this.childPanels = [];
                if (params) {
                    this.setupPanels(params);
                }
                this.overlays = params.overlays;
                this.setupOverlays();
            }
            BorderLayout.prototype.addSizeChangeListener = function (listener) {
                this.sizeChangeListeners.push(listener);
            };
            BorderLayout.prototype.fireSizeChanged = function () {
                this.sizeChangeListeners.forEach(function (listener) {
                    listener();
                });
            };
            BorderLayout.prototype.setupPanels = function (params) {
                this.eNorthWrapper = this.eGui.querySelector('#north');
                this.eSouthWrapper = this.eGui.querySelector('#south');
                this.eEastWrapper = this.eGui.querySelector('#east');
                this.eWestWrapper = this.eGui.querySelector('#west');
                this.eCenterWrapper = this.eGui.querySelector('#center');
                this.eOverlayWrapper = this.eGui.querySelector('#overlay');
                this.eCenterRow = this.eGui.querySelector('#centerRow');
                this.eNorthChildLayout = this.setupPanel(params.north, this.eNorthWrapper);
                this.eSouthChildLayout = this.setupPanel(params.south, this.eSouthWrapper);
                this.eEastChildLayout = this.setupPanel(params.east, this.eEastWrapper);
                this.eWestChildLayout = this.setupPanel(params.west, this.eWestWrapper);
                this.eCenterChildLayout = this.setupPanel(params.center, this.eCenterWrapper);
            };
            BorderLayout.prototype.setupPanel = function (content, ePanel) {
                if (!ePanel) {
                    return;
                }
                if (content) {
                    if (content.isLayoutPanel) {
                        this.childPanels.push(content);
                        ePanel.appendChild(content.getGui());
                        return content;
                    } else {
                        ePanel.appendChild(content);
                        return null;
                    }
                } else {
                    ePanel.parentNode.removeChild(ePanel);
                    return null;
                }
            };
            BorderLayout.prototype.getGui = function () {
                return this.eGui;
            };
            // returns true if any item changed size, otherwise returns false
            BorderLayout.prototype.doLayout = function () {
                var _this = this;
                var isVisible = utils_1.Utils.isVisible(this.eGui);
                if (!isVisible) {
                    this.visibleLastTime = false;
                    return false;
                }
                var atLeastOneChanged = false;
                if (this.visibleLastTime !== isVisible) {
                    atLeastOneChanged = true;
                }
                this.visibleLastTime = true;
                var childLayouts = [this.eNorthChildLayout, this.eSouthChildLayout, this.eEastChildLayout, this.eWestChildLayout];
                childLayouts.forEach(function (childLayout) {
                    var childChangedSize = _this.layoutChild(childLayout);
                    if (childChangedSize) {
                        atLeastOneChanged = true;
                    }
                });
                if (this.layoutActive) {
                    var ourHeightChanged = this.layoutHeight();
                    var ourWidthChanged = this.layoutWidth();
                    if (ourHeightChanged || ourWidthChanged) {
                        atLeastOneChanged = true;
                    }
                }
                var centerChanged = this.layoutChild(this.eCenterChildLayout);
                if (centerChanged) {
                    atLeastOneChanged = true;
                }
                if (atLeastOneChanged) {
                    this.fireSizeChanged();
                }
                return atLeastOneChanged;
            };
            BorderLayout.prototype.layoutChild = function (childPanel) {
                if (childPanel) {
                    return childPanel.doLayout();
                } else {
                    return false;
                }
            };
            BorderLayout.prototype.layoutHeight = function () {
                if (this.fullHeight) {
                    return this.layoutHeightFullHeight();
                } else {
                    return this.layoutHeightNormal();
                }
            };
            // full height never changes the height, because the center is always 100%,
            // however we do check for change, to inform the listeners
            BorderLayout.prototype.layoutHeightFullHeight = function () {
                var centerHeight = utils_1.Utils.offsetHeight(this.eGui);
                if (centerHeight < 0) {
                    centerHeight = 0;
                }
                if (this.centerHeightLastTime !== centerHeight) {
                    this.centerHeightLastTime = centerHeight;
                    return true;
                } else {
                    return false;
                }
            };
            BorderLayout.prototype.layoutHeightNormal = function () {
                var totalHeight = utils_1.Utils.offsetHeight(this.eGui);
                var northHeight = utils_1.Utils.offsetHeight(this.eNorthWrapper);
                var southHeight = utils_1.Utils.offsetHeight(this.eSouthWrapper);
                var centerHeight = totalHeight - northHeight - southHeight;
                if (centerHeight < 0) {
                    centerHeight = 0;
                }
                if (this.centerHeightLastTime !== centerHeight) {
                    this.eCenterRow.style.height = centerHeight + 'px';
                    this.centerHeightLastTime = centerHeight;
                    return true; // return true because there was a change
                } else {
                    return false;
                }
            };
            BorderLayout.prototype.getCentreHeight = function () {
                return this.centerHeightLastTime;
            };
            BorderLayout.prototype.layoutWidth = function () {
                var totalWidth = utils_1.Utils.offsetWidth(this.eGui);
                var eastWidth = utils_1.Utils.offsetWidth(this.eEastWrapper);
                var westWidth = utils_1.Utils.offsetWidth(this.eWestWrapper);
                var centerWidth = totalWidth - eastWidth - westWidth;
                if (centerWidth < 0) {
                    centerWidth = 0;
                }
                var atLeastOneChanged = false;
                if (this.centerLeftMarginLastTime !== westWidth) {
                    this.centerLeftMarginLastTime = westWidth;
                    this.eCenterWrapper.style.marginLeft = westWidth + 'px';
                    atLeastOneChanged = true;
                }
                if (this.centerWidthLastTime !== centerWidth) {
                    this.centerWidthLastTime = centerWidth;
                    this.eCenterWrapper.style.width = centerWidth + 'px';
                    atLeastOneChanged = true;
                }
                return atLeastOneChanged;
            };
            BorderLayout.prototype.setEastVisible = function (visible) {
                if (this.eEastWrapper) {
                    this.eEastWrapper.style.display = visible ? '' : 'none';
                }
                this.doLayout();
            };
            BorderLayout.prototype.setupOverlays = function () {
                // if no overlays, just remove the panel
                if (!this.overlays) {
                    this.eOverlayWrapper.parentNode.removeChild(this.eOverlayWrapper);
                    return;
                }
                this.hideOverlay();
            };
            BorderLayout.prototype.hideOverlay = function () {
                utils_1.Utils.removeAllChildren(this.eOverlayWrapper);
                this.eOverlayWrapper.style.display = 'none';
            };
            BorderLayout.prototype.showOverlay = function (key) {
                var overlay = this.overlays ? this.overlays[key] : null;
                if (overlay) {
                    utils_1.Utils.removeAllChildren(this.eOverlayWrapper);
                    this.eOverlayWrapper.style.display = '';
                    this.eOverlayWrapper.appendChild(overlay);
                } else {
                    console.log('ag-Grid: unknown overlay');
                    this.hideOverlay();
                }
            };
            BorderLayout.TEMPLATE_FULL_HEIGHT = '<div class="ag-bl ag-bl-full-height">' + '  <div class="ag-bl-west ag-bl-full-height-west" id="west"></div>' + '  <div class="ag-bl-east ag-bl-full-height-east" id="east"></div>' + '  <div class="ag-bl-center ag-bl-full-height-center" id="center"></div>' + '  <div class="ag-bl-overlay" id="overlay"></div>' + '</div>';
            BorderLayout.TEMPLATE_NORMAL = '<div class="ag-bl ag-bl-normal">' + '  <div id="north"></div>' + '  <div class="ag-bl-center-row ag-bl-normal-center-row" id="centerRow">' + '    <div class="ag-bl-west ag-bl-normal-west" id="west"></div>' + '    <div class="ag-bl-east ag-bl-normal-east" id="east"></div>' + '    <div class="ag-bl-center ag-bl-normal-center" id="center"></div>' + '  </div>' + '  <div id="south"></div>' + '  <div class="ag-bl-overlay" id="overlay"></div>' + '</div>';
            BorderLayout.TEMPLATE_DONT_FILL = '<div class="ag-bl ag-bl-dont-fill">' + '  <div id="north"></div>' + '  <div id="centerRow">' + '    <div id="west"></div>' + '    <div id="east"></div>' + '    <div id="center"></div>' + '  </div>' + '  <div id="south"></div>' + '  <div class="ag-bl-overlay" id="overlay"></div>' + '</div>';
            return BorderLayout;
        }();
        exports.BorderLayout = BorderLayout;

        /***/ },
    /* 269 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var logger_1 = __webpack_require__(243);
        var utils_1 = __webpack_require__(245);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        /** Adds drag listening onto an element. In ag-Grid this is used twice, first is resizing columns,
         * second is moving the columns and column groups around (ie the 'drag' part of Drag and Drop. */
        var DragService = function () {
            function DragService() {
                this.onMouseUpListener = this.onMouseUp.bind(this);
                this.onMouseMoveListener = this.onMouseMove.bind(this);
                this.destroyFunctions = [];
            }
            DragService.prototype.init = function () {
                this.logger = this.loggerFactory.create('DragService');
                this.eBody = document.querySelector('body');
            };
            DragService.prototype.destroy = function () {
                this.destroyFunctions.forEach(function (func) {
                    return func();
                });
            };
            DragService.prototype.setNoSelectToBody = function (noSelect) {
                if (utils_1.Utils.exists(this.eBody)) {
                    utils_1.Utils.addOrRemoveCssClass(this.eBody, 'ag-body-no-select', noSelect);
                }
            };
            DragService.prototype.addDragSource = function (params) {
                var listener = this.onMouseDown.bind(this, params);
                params.eElement.addEventListener('mousedown', listener);
                this.destroyFunctions.push(function () {
                    return params.eElement.removeEventListener('mousedown', listener);
                });
            };
            // gets called whenever mouse down on any drag source
            DragService.prototype.onMouseDown = function (params, mouseEvent) {
                // only interested in left button clicks
                if (mouseEvent.button !== 0) {
                    return;
                }
                this.currentDragParams = params;
                this.dragging = false;
                this.eventLastTime = mouseEvent;
                this.dragStartEvent = mouseEvent;
                // we temporally add these listeners, for the duration of the drag, they
                // are removed in mouseup handling.
                document.addEventListener('mousemove', this.onMouseMoveListener);
                document.addEventListener('mouseup', this.onMouseUpListener);
                // see if we want to start dragging straight away
                if (params.dragStartPixels === 0) {
                    this.onMouseMove(mouseEvent);
                }
            };
            // returns true if the event is close to the original event by X pixels either vertically or horizontally.
            // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
            DragService.prototype.isEventNearStartEvent = function (event) {
                // by default, we wait 4 pixels before starting the drag
                var requiredPixelDiff = utils_1.Utils.exists(this.currentDragParams.dragStartPixels) ? this.currentDragParams.dragStartPixels : 4;
                if (requiredPixelDiff === 0) {
                    return false;
                }
                var diffX = Math.abs(event.clientX - this.dragStartEvent.clientX);
                var diffY = Math.abs(event.clientY - this.dragStartEvent.clientY);
                return Math.max(diffX, diffY) <= requiredPixelDiff;
            };
            // only gets called after a mouse down - as this is only added after mouseDown
            // and is removed when mouseUp happens
            DragService.prototype.onMouseMove = function (mouseEvent) {
                if (!this.dragging) {
                    // if mouse hasn't travelled from the start position enough, do nothing
                    var toEarlyToDrag = !this.dragging && this.isEventNearStartEvent(mouseEvent);
                    if (toEarlyToDrag) {
                        return;
                    } else {
                        this.dragging = true;
                        this.eventService.dispatchEvent(events_1.Events.EVENT_DRAG_STARTED);
                        this.currentDragParams.onDragStart(this.dragStartEvent);
                        this.setNoSelectToBody(true);
                    }
                }
                this.currentDragParams.onDragging(mouseEvent);
            };
            DragService.prototype.onMouseUp = function (mouseEvent) {
                document.removeEventListener('mouseup', this.onMouseUpListener);
                document.removeEventListener('mousemove', this.onMouseMoveListener);
                this.setNoSelectToBody(false);
                this.dragStartEvent = null;
                this.eventLastTime = null;
                if (this.dragging) {
                    this.dragging = false;
                    this.currentDragParams.onDragStop(mouseEvent);
                    this.eventService.dispatchEvent(events_1.Events.EVENT_DRAG_STOPPED);
                }
            };
            __decorate([context_1.Autowired('loggerFactory'), __metadata('design:type', logger_1.LoggerFactory)], DragService.prototype, "loggerFactory", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], DragService.prototype, "eventService", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], DragService.prototype, "init", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], DragService.prototype, "destroy", null);
            DragService = __decorate([context_1.Bean('dragService'), __metadata('design:paramtypes', [])], DragService);
            return DragService;
        }();
        exports.DragService = DragService;

        /***/ },
    /* 270 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var gridPanel_1 = __webpack_require__(262);
        var columnController_1 = __webpack_require__(251);
        var column_1 = __webpack_require__(253);
        var constants_1 = __webpack_require__(246);
        var floatingRowModel_1 = __webpack_require__(264);
        var utils_1 = __webpack_require__(245);
        var gridCell_1 = __webpack_require__(271);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var MouseEventService = function () {
            function MouseEventService() {}
            MouseEventService.prototype.getCellForMouseEvent = function (mouseEvent) {
                var floating = this.getFloating(mouseEvent);
                var rowIndex = this.getRowIndex(mouseEvent, floating);
                var column = this.getColumn(mouseEvent);
                if (rowIndex >= 0 && utils_1.Utils.exists(column)) {
                    return new gridCell_1.GridCell(rowIndex, floating, column);
                } else {
                    return null;
                }
            };
            MouseEventService.prototype.getFloating = function (mouseEvent) {
                var floatingTopRect = this.gridPanel.getFloatingTopClientRect();
                var floatingBottomRect = this.gridPanel.getFloatingBottomClientRect();
                var floatingTopRowsExist = !this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_TOP);
                var floatingBottomRowsExist = !this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_BOTTOM);
                if (floatingTopRowsExist && floatingTopRect.bottom >= mouseEvent.clientY) {
                    return constants_1.Constants.FLOATING_TOP;
                } else if (floatingBottomRowsExist && floatingBottomRect.top <= mouseEvent.clientY) {
                    return constants_1.Constants.FLOATING_BOTTOM;
                } else {
                    return null;
                }
            };
            MouseEventService.prototype.getFloatingRowIndex = function (mouseEvent, floating) {
                var clientRect;
                switch (floating) {
                    case constants_1.Constants.FLOATING_TOP:
                        clientRect = this.gridPanel.getFloatingTopClientRect();
                        break;
                    case constants_1.Constants.FLOATING_BOTTOM:
                        clientRect = this.gridPanel.getFloatingBottomClientRect();
                        break;
                }
                var bodyY = mouseEvent.clientY - clientRect.top;
                var rowIndex = this.floatingRowModel.getRowAtPixel(bodyY, floating);
                return rowIndex;
            };
            MouseEventService.prototype.getRowIndex = function (mouseEvent, floating) {
                switch (floating) {
                    case constants_1.Constants.FLOATING_TOP:
                    case constants_1.Constants.FLOATING_BOTTOM:
                        return this.getFloatingRowIndex(mouseEvent, floating);
                    default:
                        return this.getBodyRowIndex(mouseEvent);
                }
            };
            MouseEventService.prototype.getBodyRowIndex = function (mouseEvent) {
                var clientRect = this.gridPanel.getBodyViewportClientRect();
                var scrollY = this.gridPanel.getVerticalScrollPosition();
                var bodyY = mouseEvent.clientY - clientRect.top + scrollY;
                var rowIndex = this.rowModel.getRowIndexAtPixel(bodyY);
                return rowIndex;
            };
            MouseEventService.prototype.getContainer = function (mouseEvent) {
                var centerRect = this.gridPanel.getBodyViewportClientRect();
                var mouseX = mouseEvent.clientX;
                if (mouseX < centerRect.left && this.columnController.isPinningLeft()) {
                    return column_1.Column.PINNED_LEFT;
                } else if (mouseX > centerRect.right && this.columnController.isPinningRight()) {
                    return column_1.Column.PINNED_RIGHT;
                } else {
                    return null;
                }
            };
            MouseEventService.prototype.getColumn = function (mouseEvent) {
                if (this.columnController.isEmpty()) {
                    return null;
                }
                var container = this.getContainer(mouseEvent);
                var columns = this.getColumnsForContainer(container);
                var containerX = this.getXForContainer(container, mouseEvent);
                var hoveringColumn;
                if (containerX < 0) {
                    hoveringColumn = columns[0];
                }
                columns.forEach(function (column) {
                    var afterLeft = containerX >= column.getLeft();
                    var beforeRight = containerX <= column.getRight();
                    if (afterLeft && beforeRight) {
                        hoveringColumn = column;
                    }
                });
                if (!hoveringColumn) {
                    hoveringColumn = columns[columns.length - 1];
                }
                return hoveringColumn;
            };
            MouseEventService.prototype.getColumnsForContainer = function (container) {
                switch (container) {
                    case column_1.Column.PINNED_LEFT:
                        return this.columnController.getDisplayedLeftColumns();
                    case column_1.Column.PINNED_RIGHT:
                        return this.columnController.getDisplayedRightColumns();
                    default:
                        return this.columnController.getDisplayedCenterColumns();
                }
            };
            MouseEventService.prototype.getXForContainer = function (container, mouseEvent) {
                var containerX;
                switch (container) {
                    case column_1.Column.PINNED_LEFT:
                        containerX = this.gridPanel.getPinnedLeftColsViewportClientRect().left;
                        break;
                    case column_1.Column.PINNED_RIGHT:
                        containerX = this.gridPanel.getPinnedRightColsViewportClientRect().left;
                        break;
                    default:
                        var centerRect = this.gridPanel.getBodyViewportClientRect();
                        var centerScroll = this.gridPanel.getHorizontalScrollPosition();
                        containerX = centerRect.left - centerScroll;
                }
                var result = mouseEvent.clientX - containerX;
                return result;
            };
            __decorate([context_2.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], MouseEventService.prototype, "gridPanel", void 0);
            __decorate([context_2.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], MouseEventService.prototype, "columnController", void 0);
            __decorate([context_2.Autowired('rowModel'), __metadata('design:type', Object)], MouseEventService.prototype, "rowModel", void 0);
            __decorate([context_2.Autowired('floatingRowModel'), __metadata('design:type', floatingRowModel_1.FloatingRowModel)], MouseEventService.prototype, "floatingRowModel", void 0);
            __decorate([context_2.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], MouseEventService.prototype, "gridOptionsWrapper", void 0);
            MouseEventService = __decorate([context_1.Bean('mouseEventService'), __metadata('design:paramtypes', [])], MouseEventService);
            return MouseEventService;
        }();
        exports.MouseEventService = MouseEventService;

        /***/ },
    /* 271 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var utils_1 = __webpack_require__(245);
        var gridRow_1 = __webpack_require__(272);
        var GridCell = function () {
            function GridCell(rowIndex, floating, column) {
                this.rowIndex = rowIndex;
                this.column = column;
                this.floating = utils_1.Utils.makeNull(floating);
            }
            GridCell.prototype.getGridRow = function () {
                return new gridRow_1.GridRow(this.rowIndex, this.floating);
            };
            GridCell.prototype.toString = function () {
                return "rowIndex = " + this.rowIndex + ", floating = " + this.floating + ", column = " + (this.column ? this.column.getId() : null);
            };
            GridCell.prototype.createId = function () {
                return this.rowIndex + "." + this.floating + "." + this.column.getId();
            };
            return GridCell;
        }();
        exports.GridCell = GridCell;

        /***/ },
    /* 272 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var constants_1 = __webpack_require__(246);
        var utils_1 = __webpack_require__(245);
        var gridCell_1 = __webpack_require__(271);
        var GridRow = function () {
            function GridRow(rowIndex, floating) {
                this.rowIndex = rowIndex;
                this.floating = utils_1.Utils.makeNull(floating);
            }
            GridRow.prototype.isFloatingTop = function () {
                return this.floating === constants_1.Constants.FLOATING_TOP;
            };
            GridRow.prototype.isFloatingBottom = function () {
                return this.floating === constants_1.Constants.FLOATING_BOTTOM;
            };
            GridRow.prototype.isNotFloating = function () {
                return !this.isFloatingBottom() && !this.isFloatingTop();
            };
            GridRow.prototype.equals = function (otherSelection) {
                return this.rowIndex === otherSelection.rowIndex && this.floating === otherSelection.floating;
            };
            GridRow.prototype.toString = function () {
                return "rowIndex = " + this.rowIndex + ", floating = " + this.floating;
            };
            GridRow.prototype.getGridCell = function (column) {
                return new gridCell_1.GridCell(this.rowIndex, this.floating, column);
            };
            // tests if this row selection is before the other row selection
            GridRow.prototype.before = function (otherSelection) {
                var otherFloating = otherSelection.floating;
                switch (this.floating) {
                    case constants_1.Constants.FLOATING_TOP:
                        // we we are floating top, and other isn't, then we are always before
                        if (otherFloating !== constants_1.Constants.FLOATING_TOP) {
                            return true;
                        }
                        break;
                    case constants_1.Constants.FLOATING_BOTTOM:
                        // if we are floating bottom, and the other isn't, then we are never before
                        if (otherFloating !== constants_1.Constants.FLOATING_BOTTOM) {
                            return false;
                        }
                        break;
                    default:
                        // if we are not floating, but the other one is floating...
                        if (utils_1.Utils.exists(otherFloating)) {
                            if (otherFloating === constants_1.Constants.FLOATING_TOP) {
                                // we are not floating, other is floating top, we are first
                                return false;
                            } else {
                                // we are not floating, other is floating bottom, we are always first
                                return true;
                            }
                        }
                        break;
                }
                return this.rowIndex <= otherSelection.rowIndex;
            };
            return GridRow;
        }();
        exports.GridRow = GridRow;

        /***/ },
    /* 273 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnController_1 = __webpack_require__(251);
        var utils_1 = __webpack_require__(245);
        var gridCell_1 = __webpack_require__(271);
        var constants_1 = __webpack_require__(246);
        var FocusedCellController = function () {
            function FocusedCellController() {}
            FocusedCellController.prototype.init = function () {
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearFocusedCell.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.clearFocusedCell.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.clearFocusedCell.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.clearFocusedCell.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.clearFocusedCell.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearFocusedCell.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.clearFocusedCell.bind(this));
            };
            FocusedCellController.prototype.clearFocusedCell = function () {
                this.focusedCell = null;
                this.onCellFocused(false);
            };
            FocusedCellController.prototype.getFocusedCell = function () {
                return this.focusedCell;
            };
            // we check if the browser is focusing something, and if it is, and
            // it's the cell we think is focused, then return the cell. so this
            // methods returns the cell if a) we think it has focus and b) the
            // browser thinks it has focus. this then returns nothign if we
            // first focus a cell, then second click outside the grid, as then the
            // grid cell will still be focused as far as the grid is conerned,
            // however the browser focus will have moved somewhere else.
            FocusedCellController.prototype.getFocusCellToUseAfterRefresh = function () {
                if (this.gridOptionsWrapper.isSuppressFocusAfterRefresh()) {
                    return null;
                }
                if (!this.focusedCell) {
                    return null;
                }
                var browserFocusedCell = this.getGridCellForDomElement(document.activeElement);
                if (!browserFocusedCell) {
                    return null;
                }
                var gridFocusId = this.focusedCell.createId();
                var browserFocusId = browserFocusedCell.createId();
                if (gridFocusId === browserFocusId) {
                    return this.focusedCell;
                } else {
                    return null;
                }
            };
            FocusedCellController.prototype.getGridCellForDomElement = function (eBrowserCell) {
                if (!eBrowserCell) {
                    return null;
                }
                var column = null;
                var row = null;
                var floating = null;
                var that = this;
                while (eBrowserCell) {
                    checkRow(eBrowserCell);
                    checkColumn(eBrowserCell);
                    eBrowserCell = eBrowserCell.parentNode;
                }
                if (utils_1.Utils.exists(column) && utils_1.Utils.exists(row)) {
                    var gridCell = new gridCell_1.GridCell(row, floating, column);
                    return gridCell;
                } else {
                    return null;
                }
                function checkRow(eTarget) {
                    // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
                    var rowId = utils_1.Utils.getElementAttribute(eTarget, 'row');
                    if (utils_1.Utils.exists(rowId) && utils_1.Utils.containsClass(eTarget, 'ag-row')) {
                        if (rowId.indexOf('ft') === 0) {
                            floating = constants_1.Constants.FLOATING_TOP;
                            rowId = rowId.substr(3);
                        } else if (rowId.indexOf('fb') === 0) {
                            floating = constants_1.Constants.FLOATING_BOTTOM;
                            rowId = rowId.substr(3);
                        } else {
                            floating = null;
                        }
                        row = parseInt(rowId);
                    }
                }
                function checkColumn(eTarget) {
                    // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
                    var colId = utils_1.Utils.getElementAttribute(eTarget, 'colid');
                    if (utils_1.Utils.exists(colId) && utils_1.Utils.containsClass(eTarget, 'ag-cell')) {
                        var foundColumn = that.columnController.getGridColumn(colId);
                        if (foundColumn) {
                            column = foundColumn;
                        }
                    }
                }
            };
            FocusedCellController.prototype.setFocusedCell = function (rowIndex, colKey, floating, forceBrowserFocus) {
                if (forceBrowserFocus === void 0) {
                    forceBrowserFocus = false;
                }
                if (this.gridOptionsWrapper.isSuppressCellSelection()) {
                    return;
                }
                var column = utils_1.Utils.makeNull(this.columnController.getGridColumn(colKey));
                this.focusedCell = new gridCell_1.GridCell(rowIndex, utils_1.Utils.makeNull(floating), column);
                this.onCellFocused(forceBrowserFocus);
            };
            FocusedCellController.prototype.isCellFocused = function (gridCell) {
                if (utils_1.Utils.missing(this.focusedCell)) {
                    return false;
                }
                return this.focusedCell.column === gridCell.column && this.isRowFocused(gridCell.rowIndex, gridCell.floating);
            };
            FocusedCellController.prototype.isRowFocused = function (rowIndex, floating) {
                if (utils_1.Utils.missing(this.focusedCell)) {
                    return false;
                }
                var floatingOrNull = utils_1.Utils.makeNull(floating);
                return this.focusedCell.rowIndex === rowIndex && this.focusedCell.floating === floatingOrNull;
            };
            FocusedCellController.prototype.onCellFocused = function (forceBrowserFocus) {
                var event = {
                    rowIndex: null,
                    column: null,
                    floating: null,
                    forceBrowserFocus: forceBrowserFocus
                };
                if (this.focusedCell) {
                    event.rowIndex = this.focusedCell.rowIndex;
                    event.column = this.focusedCell.column;
                    event.floating = this.focusedCell.floating;
                }
                this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_FOCUSED, event);
            };
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], FocusedCellController.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], FocusedCellController.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], FocusedCellController.prototype, "columnController", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], FocusedCellController.prototype, "init", null);
            FocusedCellController = __decorate([context_1.Bean('focusedCellController'), __metadata('design:paramtypes', [])], FocusedCellController);
            return FocusedCellController;
        }();
        exports.FocusedCellController = FocusedCellController;

        /***/ },
    /* 274 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var TemplateService = function () {
            function TemplateService() {
                this.templateCache = {};
                this.waitingCallbacks = {};
            }
            // returns the template if it is loaded, or null if it is not loaded
            // but will call the callback when it is loaded
            TemplateService.prototype.getTemplate = function (url, callback) {
                var templateFromCache = this.templateCache[url];
                if (templateFromCache) {
                    return templateFromCache;
                }
                var callbackList = this.waitingCallbacks[url];
                var that = this;
                if (!callbackList) {
                    // first time this was called, so need a new list for callbacks
                    callbackList = [];
                    this.waitingCallbacks[url] = callbackList;
                    // and also need to do the http request
                    var client = new XMLHttpRequest();
                    client.onload = function () {
                        that.handleHttpResult(this, url);
                    };
                    client.open("GET", url);
                    client.send();
                }
                // add this callback
                if (callback) {
                    callbackList.push(callback);
                }
                // caller needs to wait for template to load, so return null
                return null;
            };
            TemplateService.prototype.handleHttpResult = function (httpResult, url) {
                if (httpResult.status !== 200 || httpResult.response === null) {
                    console.warn('Unable to get template error ' + httpResult.status + ' - ' + url);
                    return;
                }
                // response success, so process it
                // in IE9 the response is in - responseText
                this.templateCache[url] = httpResult.response || httpResult.responseText;
                // inform all listeners that this is now in the cache
                var callbacks = this.waitingCallbacks[url];
                for (var i = 0; i < callbacks.length; i++) {
                    var callback = callbacks[i];
                    // we could pass the callback the response, however we know the client of this code
                    // is the cell renderer, and it passes the 'cellRefresh' method in as the callback
                    // which doesn't take any parameters.
                    callback();
                }
                if (this.$scope) {
                    var that = this;
                    setTimeout(function () {
                        that.$scope.$apply();
                    }, 0);
                }
            };
            __decorate([context_2.Autowired('$scope'), __metadata('design:type', Object)], TemplateService.prototype, "$scope", void 0);
            TemplateService = __decorate([context_1.Bean('templateService'), __metadata('design:paramtypes', [])], TemplateService);
            return TemplateService;
        }();
        exports.TemplateService = TemplateService;

        /***/ },
    /* 275 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var renderedCell_1 = __webpack_require__(276);
        var rowNode_1 = __webpack_require__(265);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnController_1 = __webpack_require__(251);
        var column_1 = __webpack_require__(253);
        var events_1 = __webpack_require__(248);
        var eventService_1 = __webpack_require__(242);
        var context_1 = __webpack_require__(244);
        var focusedCellController_1 = __webpack_require__(273);
        var constants_1 = __webpack_require__(246);
        var cellRendererService_1 = __webpack_require__(298);
        var cellRendererFactory_1 = __webpack_require__(293);
        var gridPanel_1 = __webpack_require__(262);
        var RenderedRow = function () {
            function RenderedRow(parentScope, rowRenderer, eBodyContainer, eFullWidthContainer, ePinnedLeftContainer, ePinnedRightContainer, node, rowIndex) {
                this.eAllRowContainers = [];
                this.renderedCells = {};
                this.destroyFunctions = [];
                this.initialised = false;
                this.parentScope = parentScope;
                this.rowRenderer = rowRenderer;
                this.eBodyContainer = eBodyContainer;
                this.eFullWidthContainer = eFullWidthContainer;
                this.ePinnedLeftContainer = ePinnedLeftContainer;
                this.ePinnedRightContainer = ePinnedRightContainer;
                this.rowIndex = rowIndex;
                this.rowNode = node;
            }
            RenderedRow.prototype.setupRowContainers = function () {
                var isFullWidthCellFunc = this.gridOptionsWrapper.getIsFullWidthCellFunc();
                var isFullWidthCell = isFullWidthCellFunc ? isFullWidthCellFunc(this.rowNode) : false;
                var isGroupSpanningRow = this.rowNode.group && this.gridOptionsWrapper.isGroupUseEntireRow();
                if (isFullWidthCell) {
                    this.setupFullWidthContainers();
                } else if (isGroupSpanningRow) {
                    this.setupFullWidthGroupContainers();
                } else {
                    this.setupNormalContainers();
                }
            };
            RenderedRow.prototype.setupFullWidthContainers = function () {
                this.fullWidthRow = true;
                this.fullWidthCellRenderer = this.gridOptionsWrapper.getFullWidthCellRenderer();
                this.fullWidthCellRendererParams = this.gridOptionsWrapper.getFullWidthCellRendererParams();
                if (utils_1.Utils.missing(this.fullWidthCellRenderer)) {
                    console.warn("ag-Grid: you need to provide a fullWidthCellRenderer if using isFullWidthCell()");
                }
                this.eFullWidthRow = this.createRowContainer(this.eFullWidthContainer);
                if (!this.gridOptionsWrapper.isForPrint()) {
                    this.addMouseWheelListenerToFullWidthRow();
                }
            };
            RenderedRow.prototype.addMouseWheelListenerToFullWidthRow = function () {
                var _this = this;
                var mouseWheelListener = this.gridPanel.genericMouseWheelListener.bind(this.gridPanel);
                // IE9, Chrome, Safari, Opera
                this.eFullWidthRow.addEventListener('mousewheel', mouseWheelListener);
                // Firefox
                this.eFullWidthRow.addEventListener('DOMMouseScroll', mouseWheelListener);
                this.destroyFunctions.push(function () {
                    _this.eFullWidthRow.removeEventListener('mousewheel', mouseWheelListener);
                    _this.eFullWidthRow.removeEventListener('DOMMouseScroll', mouseWheelListener);
                });
            };
            RenderedRow.prototype.setupFullWidthGroupContainers = function () {
                this.fullWidthRow = true;
                this.fullWidthCellRenderer = this.gridOptionsWrapper.getGroupRowRenderer();
                this.fullWidthCellRendererParams = this.gridOptionsWrapper.getGroupRowRendererParams();
                if (!this.fullWidthCellRenderer) {
                    this.fullWidthCellRenderer = cellRendererFactory_1.CellRendererFactory.GROUP;
                    this.fullWidthCellRendererParams = {
                        innerRenderer: this.gridOptionsWrapper.getGroupRowInnerRenderer()
                    };
                }
                this.eFullWidthRow = this.createRowContainer(this.eFullWidthContainer);
            };
            RenderedRow.prototype.setupNormalContainers = function () {
                this.fullWidthRow = false;
                this.eBodyRow = this.createRowContainer(this.eBodyContainer);
                if (!this.gridOptionsWrapper.isForPrint()) {
                    this.ePinnedLeftRow = this.createRowContainer(this.ePinnedLeftContainer);
                    this.ePinnedRightRow = this.createRowContainer(this.ePinnedRightContainer);
                }
            };
            RenderedRow.prototype.init = function () {
                this.setupRowContainers();
                this.scope = this.createChildScopeOrNull(this.rowNode.data);
                if (this.fullWidthRow) {
                    this.refreshFullWidthComponent();
                } else {
                    this.refreshCellsIntoRow();
                }
                this.addGridClasses();
                this.addStyleFromRowStyle();
                this.addStyleFromRowStyleFunc();
                this.addClassesFromRowClass();
                this.addClassesFromRowClassFunc();
                this.addRowIds();
                this.setTopAndHeightCss();
                this.addRowSelectedListener();
                this.addCellFocusedListener();
                this.addNodeDataChangedListener();
                this.addColumnListener();
                this.addHoverFunctionality();
                this.gridOptionsWrapper.executeProcessRowPostCreateFunc({
                    eRow: this.eBodyRow,
                    ePinnedLeftRow: this.ePinnedLeftRow,
                    ePinnedRightRow: this.ePinnedRightRow,
                    node: this.rowNode,
                    api: this.gridOptionsWrapper.getApi(),
                    rowIndex: this.rowIndex,
                    addRenderedRowListener: this.addEventListener.bind(this),
                    columnApi: this.gridOptionsWrapper.getColumnApi(),
                    context: this.gridOptionsWrapper.getContext()
                });
                this.addDataChangedListener();
                this.initialised = true;
            };
            // because data can change, especially in virtual pagination and viewport row models, need to allow setting
            // styles and classes after the data has changed
            RenderedRow.prototype.addDataChangedListener = function () {
                var _this = this;
                var dataChangedListener = function dataChangedListener() {
                    _this.addStyleFromRowStyleFunc();
                    _this.addClassesFromRowClass();
                };
                this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, dataChangedListener);
                this.destroyFunctions.push(function () {
                    return _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, dataChangedListener);
                });
            };
            RenderedRow.prototype.angular1Compile = function (element) {
                if (this.scope) {
                    this.$compile(element)(this.scope);
                }
            };
            RenderedRow.prototype.addColumnListener = function () {
                var _this = this;
                var columnListener = this.onDisplayedColumnsChanged.bind(this);
                var virtualListener = this.onVirtualColumnsChanged.bind(this);
                var gridColumnsChangedListener = this.onGridColumnsChanged.bind(this);
                this.mainEventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, columnListener);
                this.mainEventService.addEventListener(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, virtualListener);
                this.mainEventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnListener);
                this.mainEventService.addEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, gridColumnsChangedListener);
                this.destroyFunctions.push(function () {
                    _this.mainEventService.removeEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, columnListener);
                    _this.mainEventService.removeEventListener(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, virtualListener);
                    _this.mainEventService.removeEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnListener);
                    _this.mainEventService.removeEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, gridColumnsChangedListener);
                });
            };
            RenderedRow.prototype.onDisplayedColumnsChanged = function (event) {
                // if row is a group row that spans, then it's not impacted by column changes, with exception of pinning
                if (this.fullWidthRow) {
                    var columnPinned = event.getType() === events_1.Events.EVENT_COLUMN_PINNED;
                    if (columnPinned) {
                        this.refreshFullWidthComponent();
                    }
                } else {
                    this.refreshCellsIntoRow();
                }
            };
            RenderedRow.prototype.onVirtualColumnsChanged = function (event) {
                // if row is a group row that spans, then it's not impacted by column changes, with exception of pinning
                if (!this.fullWidthRow) {
                    this.refreshCellsIntoRow();
                }
            };
            // when grid columns change, then all cells should be cleaned out,
            // as the new columns could have same id as the previous columns and may conflict
            RenderedRow.prototype.onGridColumnsChanged = function () {
                var allRenderedCellIds = Object.keys(this.renderedCells);
                this.removeRenderedCells(allRenderedCellIds);
            };
            // method makes sure the right cells are present, and are in the right container. so when this gets called for
            // the first time, it sets up all the cells. but then over time the cells might appear / dissappear or move
            // container (ie into pinned)
            RenderedRow.prototype.refreshCellsIntoRow = function () {
                var _this = this;
                var columns = this.columnController.getAllDisplayedVirtualColumns();
                var renderedCellKeys = Object.keys(this.renderedCells);
                columns.forEach(function (column) {
                    var renderedCell = _this.getOrCreateCell(column);
                    _this.ensureCellInCorrectRow(renderedCell);
                    utils_1.Utils.removeFromArray(renderedCellKeys, column.getColId());
                });
                // remove old cells from gui, but we don't destroy them, we might use them again
                this.removeRenderedCells(renderedCellKeys);
            };
            RenderedRow.prototype.removeRenderedCells = function (colIds) {
                var _this = this;
                colIds.forEach(function (key) {
                    var renderedCell = _this.renderedCells[key];
                    // could be old reference, ie removed cell
                    if (utils_1.Utils.missing(renderedCell)) {
                        return;
                    }
                    if (renderedCell.getParentRow()) {
                        renderedCell.getParentRow().removeChild(renderedCell.getGui());
                        renderedCell.setParentRow(null);
                    }
                    renderedCell.destroy();
                    _this.renderedCells[key] = null;
                });
            };
            RenderedRow.prototype.ensureCellInCorrectRow = function (renderedCell) {
                var eRowGui = renderedCell.getGui();
                var column = renderedCell.getColumn();
                var rowWeWant;
                switch (column.getPinned()) {
                    case column_1.Column.PINNED_LEFT:
                        rowWeWant = this.ePinnedLeftRow;
                        break;
                    case column_1.Column.PINNED_RIGHT:
                        rowWeWant = this.ePinnedRightRow;
                        break;
                    default:
                        rowWeWant = this.eBodyRow;
                        break;
                }
                // if in wrong container, remove it
                var oldRow = renderedCell.getParentRow();
                var inWrongRow = oldRow !== rowWeWant;
                if (inWrongRow) {
                    // take out from old row
                    if (oldRow) {
                        oldRow.removeChild(eRowGui);
                    }
                    rowWeWant.appendChild(eRowGui);
                    renderedCell.setParentRow(rowWeWant);
                }
            };
            RenderedRow.prototype.getOrCreateCell = function (column) {
                var colId = column.getColId();
                if (this.renderedCells[colId]) {
                    return this.renderedCells[colId];
                } else {
                    var renderedCell = new renderedCell_1.RenderedCell(column, this.rowNode, this.rowIndex, this.scope, this);
                    this.context.wireBean(renderedCell);
                    this.renderedCells[colId] = renderedCell;
                    this.angular1Compile(renderedCell.getGui());
                    return renderedCell;
                }
            };
            RenderedRow.prototype.onRowSelected = function () {
                var selected = this.rowNode.isSelected();
                this.eAllRowContainers.forEach(function (row) {
                    return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-selected', selected);
                });
            };
            RenderedRow.prototype.addRowSelectedListener = function () {
                var _this = this;
                var rowSelectedListener = this.onRowSelected.bind(this);
                this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_ROW_SELECTED, rowSelectedListener);
                this.destroyFunctions.push(function () {
                    _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_ROW_SELECTED, rowSelectedListener);
                });
            };
            RenderedRow.prototype.addHoverFunctionality = function () {
                var _this = this;
                var onGuiMouseEnter = this.rowNode.onMouseEnter.bind(this.rowNode);
                var onGuiMouseLeave = this.rowNode.onMouseLeave.bind(this.rowNode);
                this.eAllRowContainers.forEach(function (eRow) {
                    eRow.addEventListener('mouseenter', onGuiMouseEnter);
                    eRow.addEventListener('mouseleave', onGuiMouseLeave);
                });
                var onNodeMouseEnter = this.addHoverClass.bind(this, true);
                var onNodeMouseLeave = this.addHoverClass.bind(this, false);
                this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_MOUSE_ENTER, onNodeMouseEnter);
                this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_MOUSE_LEAVE, onNodeMouseLeave);
                this.destroyFunctions.push(function () {
                    _this.eAllRowContainers.forEach(function (eRow) {
                        eRow.removeEventListener('mouseenter', onGuiMouseEnter);
                        eRow.removeEventListener('mouseleave', onGuiMouseLeave);
                    });
                    _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_MOUSE_ENTER, onNodeMouseEnter);
                    _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_MOUSE_LEAVE, onNodeMouseLeave);
                });
            };
            RenderedRow.prototype.addHoverClass = function (hover) {
                this.eAllRowContainers.forEach(function (eRow) {
                    return utils_1.Utils.addOrRemoveCssClass(eRow, 'ag-row-hover', hover);
                });
            };
            RenderedRow.prototype.addCellFocusedListener = function () {
                var _this = this;
                var rowFocusedLastTime = null;
                var rowFocusedListener = function rowFocusedListener() {
                    var rowFocused = _this.focusedCellController.isRowFocused(_this.rowIndex, _this.rowNode.floating);
                    if (rowFocused !== rowFocusedLastTime) {
                        _this.eAllRowContainers.forEach(function (row) {
                            return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-focus', rowFocused);
                        });
                        _this.eAllRowContainers.forEach(function (row) {
                            return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-no-focus', !rowFocused);
                        });
                        rowFocusedLastTime = rowFocused;
                    }
                };
                this.mainEventService.addEventListener(events_1.Events.EVENT_CELL_FOCUSED, rowFocusedListener);
                this.destroyFunctions.push(function () {
                    _this.mainEventService.removeEventListener(events_1.Events.EVENT_CELL_FOCUSED, rowFocusedListener);
                });
                rowFocusedListener();
            };
            RenderedRow.prototype.forEachRenderedCell = function (callback) {
                utils_1.Utils.iterateObject(this.renderedCells, function (key, renderedCell) {
                    if (renderedCell) {
                        callback(renderedCell);
                    }
                });
            };
            RenderedRow.prototype.addNodeDataChangedListener = function () {
                var _this = this;
                var nodeDataChangedListener = function nodeDataChangedListener() {
                    var animate = false;
                    var newData = true;
                    _this.forEachRenderedCell(function (renderedCell) {
                        return renderedCell.refreshCell(animate, newData);
                    });
                    // check for selected also, as this could be after lazy loading of the row data, in which csae
                    // the id might of just gotten set inside the row and the row selected state may of changed
                    // as a result. this is what happens when selected rows are loaded in virtual pagination.
                    _this.onRowSelected();
                };
                this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, nodeDataChangedListener);
                this.destroyFunctions.push(function () {
                    _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, nodeDataChangedListener);
                });
            };
            RenderedRow.prototype.onMouseEvent = function (eventName, mouseEvent, cell) {
                var renderedCell = this.renderedCells[cell.column.getId()];
                if (renderedCell) {
                    renderedCell.onMouseEvent(eventName, mouseEvent);
                }
            };
            RenderedRow.prototype.setTopAndHeightCss = function () {
                // if showing scrolls, position on the container
                if (!this.gridOptionsWrapper.isForPrint()) {
                    var topPx = this.rowNode.rowTop + "px";
                    this.eAllRowContainers.forEach(function (row) {
                        return row.style.top = topPx;
                    });
                }
                var heightPx = this.rowNode.rowHeight + 'px';
                this.eAllRowContainers.forEach(function (row) {
                    return row.style.height = heightPx;
                });
            };
            // adds in row and row-id attributes to the row
            RenderedRow.prototype.addRowIds = function () {
                var rowStr = this.rowIndex.toString();
                if (this.rowNode.floating === constants_1.Constants.FLOATING_BOTTOM) {
                    rowStr = 'fb-' + rowStr;
                } else if (this.rowNode.floating === constants_1.Constants.FLOATING_TOP) {
                    rowStr = 'ft-' + rowStr;
                }
                this.eAllRowContainers.forEach(function (row) {
                    return row.setAttribute('row', rowStr);
                });
                if (typeof this.gridOptionsWrapper.getBusinessKeyForNodeFunc() === 'function') {
                    var businessKey = this.gridOptionsWrapper.getBusinessKeyForNodeFunc()(this.rowNode);
                    if (typeof businessKey === 'string' || typeof businessKey === 'number') {
                        this.eAllRowContainers.forEach(function (row) {
                            return row.setAttribute('row-id', businessKey);
                        });
                    }
                }
            };
            RenderedRow.prototype.addEventListener = function (eventType, listener) {
                if (!this.renderedRowEventService) {
                    this.renderedRowEventService = new eventService_1.EventService();
                }
                this.renderedRowEventService.addEventListener(eventType, listener);
            };
            RenderedRow.prototype.removeEventListener = function (eventType, listener) {
                this.renderedRowEventService.removeEventListener(eventType, listener);
            };
            RenderedRow.prototype.getRenderedCellForColumn = function (column) {
                return this.renderedCells[column.getColId()];
            };
            RenderedRow.prototype.getCellForCol = function (column) {
                var renderedCell = this.renderedCells[column.getColId()];
                if (renderedCell) {
                    return renderedCell.getGui();
                } else {
                    return null;
                }
            };
            RenderedRow.prototype.destroy = function () {
                this.destroyScope();
                this.destroyFullWidthComponent();
                this.forEachRenderedCell(function (renderedCell) {
                    return renderedCell.destroy();
                });
                this.destroyFunctions.forEach(function (func) {
                    return func();
                });
                if (this.renderedRowEventService) {
                    this.renderedRowEventService.dispatchEvent(RenderedRow.EVENT_RENDERED_ROW_REMOVED, { node: this.rowNode });
                }
            };
            RenderedRow.prototype.destroyScope = function () {
                if (this.scope) {
                    this.scope.$destroy();
                    this.scope = null;
                }
            };
            RenderedRow.prototype.isDataInList = function (rows) {
                return rows.indexOf(this.rowNode.data) >= 0;
            };
            RenderedRow.prototype.isGroup = function () {
                return this.rowNode.group === true;
            };
            RenderedRow.prototype.refreshFullWidthComponent = function () {
                this.destroyFullWidthComponent();
                this.createFullWidthComponent();
            };
            RenderedRow.prototype.createFullWidthComponent = function () {
                var params = this.createFullWidthParams(this.eFullWidthRow);
                this.fullWidthRowComponent = this.cellRendererService.useCellRenderer(this.fullWidthCellRenderer, this.eFullWidthRow, params);
                this.angular1Compile(this.eFullWidthRow);
            };
            RenderedRow.prototype.destroyFullWidthComponent = function () {
                if (this.fullWidthRowComponent && this.fullWidthRowComponent.destroy) {
                    this.fullWidthRowComponent.destroy();
                    this.fullWidthRowComponent = null;
                }
                utils_1.Utils.removeAllChildren(this.eFullWidthRow);
            };
            RenderedRow.prototype.createFullWidthParams = function (eRow) {
                var params = {
                    data: this.rowNode.data,
                    node: this.rowNode,
                    $scope: this.scope,
                    rowIndex: this.rowIndex,
                    api: this.gridOptionsWrapper.getApi(),
                    columnApi: this.gridOptionsWrapper.getColumnApi(),
                    context: this.gridOptionsWrapper.getContext(),
                    eGridCell: eRow,
                    eParentOfValue: eRow,
                    addRenderedRowListener: this.addEventListener.bind(this),
                    colDef: {
                        cellRenderer: this.fullWidthCellRenderer,
                        cellRendererParams: this.fullWidthCellRendererParams
                    }
                };
                if (this.fullWidthCellRendererParams) {
                    utils_1.Utils.assign(params, this.fullWidthCellRendererParams);
                }
                return params;
            };
            RenderedRow.prototype.createGroupSpanningEntireRowCell = function (padding) {
                var eRow = document.createElement('span');
                // padding means we are on the right hand side of a pinned table, ie
                // in the main body.
                if (!padding) {
                    var params = this.createFullWidthParams(eRow);
                    var cellComponent = this.cellRendererService.useCellRenderer(this.fullWidthCellRenderer, eRow, params);
                    if (cellComponent && cellComponent.destroy) {
                        this.destroyFunctions.push(function () {
                            return cellComponent.destroy();
                        });
                    }
                }
                if (this.rowNode.footer) {
                    utils_1.Utils.addCssClass(eRow, 'ag-footer-cell-entire-row');
                } else {
                    utils_1.Utils.addCssClass(eRow, 'ag-group-cell-entire-row');
                }
                return eRow;
            };
            RenderedRow.prototype.createChildScopeOrNull = function (data) {
                if (this.gridOptionsWrapper.isAngularCompileRows()) {
                    var newChildScope = this.parentScope.$new();
                    newChildScope.data = data;
                    newChildScope.rowNode = this.rowNode;
                    newChildScope.context = this.gridOptionsWrapper.getContext();
                    return newChildScope;
                } else {
                    return null;
                }
            };
            RenderedRow.prototype.addStyleFromRowStyle = function () {
                var rowStyle = this.gridOptionsWrapper.getRowStyle();
                if (rowStyle) {
                    if (typeof rowStyle === 'function') {
                        console.log('ag-Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead');
                    } else {
                        this.eAllRowContainers.forEach(function (row) {
                            return utils_1.Utils.addStylesToElement(row, rowStyle);
                        });
                    }
                }
            };
            RenderedRow.prototype.addStyleFromRowStyleFunc = function () {
                var rowStyleFunc = this.gridOptionsWrapper.getRowStyleFunc();
                if (rowStyleFunc) {
                    var params = {
                        data: this.rowNode.data,
                        node: this.rowNode,
                        api: this.gridOptionsWrapper.getApi(),
                        context: this.gridOptionsWrapper.getContext(),
                        $scope: this.scope
                    };
                    var cssToUseFromFunc = rowStyleFunc(params);
                    this.eAllRowContainers.forEach(function (row) {
                        return utils_1.Utils.addStylesToElement(row, cssToUseFromFunc);
                    });
                }
            };
            RenderedRow.prototype.createParams = function () {
                var params = {
                    node: this.rowNode,
                    data: this.rowNode.data,
                    rowIndex: this.rowIndex,
                    $scope: this.scope,
                    context: this.gridOptionsWrapper.getContext(),
                    api: this.gridOptionsWrapper.getApi()
                };
                return params;
            };
            RenderedRow.prototype.createEvent = function (event, eventSource) {
                var agEvent = this.createParams();
                agEvent.event = event;
                agEvent.eventSource = eventSource;
                return agEvent;
            };
            RenderedRow.prototype.createRowContainer = function (eParent) {
                var eRow = document.createElement('div');
                var rowClickListener = this.onRowClick.bind(this);
                var rowDblClickListener = this.onRowDblClick.bind(this);
                eRow.addEventListener("click", rowClickListener);
                eRow.addEventListener("dblclick", rowDblClickListener);
                eParent.appendChild(eRow);
                this.eAllRowContainers.push(eRow);
                this.destroyFunctions.push(function () {
                    eRow.removeEventListener("click", rowClickListener);
                    eRow.removeEventListener("dblclick", rowDblClickListener);
                    eParent.removeChild(eRow);
                });
                return eRow;
            };
            RenderedRow.prototype.onRowDblClick = function (event) {
                var agEvent = this.createEvent(event, this);
                this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_DOUBLE_CLICKED, agEvent);
            };
            RenderedRow.prototype.onRowClick = function (event) {
                var agEvent = this.createEvent(event, this);
                this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_CLICKED, agEvent);
                // ctrlKey for windows, metaKey for Apple
                var multiSelectKeyPressed = event.ctrlKey || event.metaKey;
                var shiftKeyPressed = event.shiftKey;
                // we do not allow selecting groups by clicking (as the click here expands the group)
                // so return if it's a group row
                if (this.rowNode.group) {
                    return;
                }
                // we also don't allow selection of floating rows
                if (this.rowNode.floating) {
                    return;
                }
                // making local variables to make the below more readable
                var gridOptionsWrapper = this.gridOptionsWrapper;
                // if no selection method enabled, do nothing
                if (!gridOptionsWrapper.isRowSelection()) {
                    return;
                }
                // if click selection suppressed, do nothing
                if (gridOptionsWrapper.isSuppressRowClickSelection()) {
                    return;
                }
                if (this.rowNode.isSelected()) {
                    if (multiSelectKeyPressed) {
                        if (gridOptionsWrapper.isRowDeselection()) {
                            this.rowNode.setSelectedParams({ newValue: false });
                        }
                    } else {
                        // selected with no multi key, must make sure anything else is unselected
                        this.rowNode.setSelectedParams({ newValue: true, clearSelection: true });
                    }
                } else {
                    this.rowNode.setSelectedParams({ newValue: true, clearSelection: !multiSelectKeyPressed, rangeSelect: shiftKeyPressed });
                }
            };
            RenderedRow.prototype.getRowNode = function () {
                return this.rowNode;
            };
            RenderedRow.prototype.refreshCells = function (colIds, animate) {
                if (!colIds) {
                    return;
                }
                var columnsToRefresh = this.columnController.getGridColumns(colIds);
                this.forEachRenderedCell(function (renderedCell) {
                    var colForCel = renderedCell.getColumn();
                    if (columnsToRefresh.indexOf(colForCel) >= 0) {
                        renderedCell.refreshCell(animate);
                    }
                });
            };
            RenderedRow.prototype.addClassesFromRowClassFunc = function () {
                var _this = this;
                var classes = [];
                var gridOptionsRowClassFunc = this.gridOptionsWrapper.getRowClassFunc();
                if (gridOptionsRowClassFunc) {
                    var params = {
                        node: this.rowNode,
                        data: this.rowNode.data,
                        rowIndex: this.rowIndex,
                        context: this.gridOptionsWrapper.getContext(),
                        api: this.gridOptionsWrapper.getApi()
                    };
                    var classToUseFromFunc = gridOptionsRowClassFunc(params);
                    if (classToUseFromFunc) {
                        if (typeof classToUseFromFunc === 'string') {
                            classes.push(classToUseFromFunc);
                        } else if (Array.isArray(classToUseFromFunc)) {
                            classToUseFromFunc.forEach(function (classItem) {
                                classes.push(classItem);
                            });
                        }
                    }
                }
                classes.forEach(function (classStr) {
                    _this.eAllRowContainers.forEach(function (row) {
                        return utils_1.Utils.addCssClass(row, classStr);
                    });
                });
            };
            RenderedRow.prototype.addGridClasses = function () {
                var _this = this;
                var classes = [];
                classes.push('ag-row');
                classes.push('ag-row-no-focus');
                classes.push(this.rowIndex % 2 == 0 ? 'ag-row-even' : 'ag-row-odd');
                if (this.rowNode.isSelected()) {
                    classes.push('ag-row-selected');
                }
                if (this.rowNode.group) {
                    classes.push('ag-row-group');
                    // if a group, put the level of the group in
                    classes.push('ag-row-level-' + this.rowNode.level);
                    if (!this.rowNode.footer && this.rowNode.expanded) {
                        classes.push('ag-row-group-expanded');
                    }
                    if (!this.rowNode.footer && !this.rowNode.expanded) {
                        // opposite of expanded is contracted according to the internet.
                        classes.push('ag-row-group-contracted');
                    }
                    if (this.rowNode.footer) {
                        classes.push('ag-row-footer');
                    }
                } else {
                    // if a leaf, and a parent exists, put a level of the parent, else put level of 0 for top level item
                    if (this.rowNode.parent) {
                        classes.push('ag-row-level-' + (this.rowNode.parent.level + 1));
                    } else {
                        classes.push('ag-row-level-0');
                    }
                }
                if (this.fullWidthRow) {
                    classes.push('ag-full-width-row');
                }
                classes.forEach(function (classStr) {
                    _this.eAllRowContainers.forEach(function (row) {
                        return utils_1.Utils.addCssClass(row, classStr);
                    });
                });
            };
            RenderedRow.prototype.addClassesFromRowClass = function () {
                var _this = this;
                var classes = [];
                // add in extra classes provided by the config
                var gridOptionsRowClass = this.gridOptionsWrapper.getRowClass();
                if (gridOptionsRowClass) {
                    if (typeof gridOptionsRowClass === 'function') {
                        console.warn('ag-Grid: rowClass should not be a function, please use getRowClass instead');
                    } else {
                        if (typeof gridOptionsRowClass === 'string') {
                            classes.push(gridOptionsRowClass);
                        } else if (Array.isArray(gridOptionsRowClass)) {
                            gridOptionsRowClass.forEach(function (classItem) {
                                classes.push(classItem);
                            });
                        }
                    }
                }
                classes.forEach(function (classStr) {
                    _this.eAllRowContainers.forEach(function (row) {
                        return utils_1.Utils.addCssClass(row, classStr);
                    });
                });
            };
            RenderedRow.EVENT_RENDERED_ROW_REMOVED = 'renderedRowRemoved';
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], RenderedRow.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], RenderedRow.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('$compile'), __metadata('design:type', Object)], RenderedRow.prototype, "$compile", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], RenderedRow.prototype, "mainEventService", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], RenderedRow.prototype, "context", void 0);
            __decorate([context_1.Autowired('focusedCellController'), __metadata('design:type', focusedCellController_1.FocusedCellController)], RenderedRow.prototype, "focusedCellController", void 0);
            __decorate([context_1.Autowired('cellRendererService'), __metadata('design:type', cellRendererService_1.CellRendererService)], RenderedRow.prototype, "cellRendererService", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], RenderedRow.prototype, "gridPanel", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RenderedRow.prototype, "init", null);
            return RenderedRow;
        }();
        exports.RenderedRow = RenderedRow;

        /***/ },
    /* 276 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var column_1 = __webpack_require__(253);
        var rowNode_1 = __webpack_require__(265);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var expressionService_1 = __webpack_require__(256);
        var rowRenderer_1 = __webpack_require__(261);
        var templateService_1 = __webpack_require__(274);
        var columnController_1 = __webpack_require__(251);
        var valueService_1 = __webpack_require__(267);
        var eventService_1 = __webpack_require__(242);
        var constants_1 = __webpack_require__(246);
        var events_1 = __webpack_require__(248);
        var context_1 = __webpack_require__(244);
        var gridApi_1 = __webpack_require__(249);
        var focusedCellController_1 = __webpack_require__(273);
        var gridCell_1 = __webpack_require__(271);
        var focusService_1 = __webpack_require__(277);
        var cellEditorFactory_1 = __webpack_require__(286);
        var component_1 = __webpack_require__(285);
        var popupService_1 = __webpack_require__(282);
        var cellRendererFactory_1 = __webpack_require__(293);
        var cellRendererService_1 = __webpack_require__(298);
        var valueFormatterService_1 = __webpack_require__(299);
        var checkboxSelectionComponent_1 = __webpack_require__(300);
        var setLeftFeature_1 = __webpack_require__(301);
        var methodNotImplementedException_1 = __webpack_require__(302);
        var RenderedCell = function (_super) {
            __extends(RenderedCell, _super);
            function RenderedCell(column, node, rowIndex, scope, renderedRow) {
                _super.call(this, '<div/>');
                this.firstRightPinned = false;
                this.lastLeftPinned = false;
                // because we reference eGridCell everywhere in this class,
                // we keep a local reference
                this.eGridCell = this.getGui();
                this.column = column;
                this.node = node;
                this.rowIndex = rowIndex;
                this.scope = scope;
                this.renderedRow = renderedRow;
                this.gridCell = new gridCell_1.GridCell(rowIndex, node.floating, column);
            }
            RenderedCell.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                if (this.cellEditor && this.cellEditor.destroy) {
                    this.cellEditor.destroy();
                }
                if (this.cellRenderer && this.cellRenderer.destroy) {
                    this.cellRenderer.destroy();
                }
            };
            RenderedCell.prototype.setPinnedClasses = function () {
                var _this = this;
                var firstPinnedChangedListener = function firstPinnedChangedListener() {
                    if (_this.firstRightPinned !== _this.column.isFirstRightPinned()) {
                        _this.firstRightPinned = _this.column.isFirstRightPinned();
                        utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-first-right-pinned', _this.firstRightPinned);
                    }
                    if (_this.lastLeftPinned !== _this.column.isLastLeftPinned()) {
                        _this.lastLeftPinned = _this.column.isLastLeftPinned();
                        utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-last-left-pinned', _this.lastLeftPinned);
                    }
                };
                this.column.addEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstPinnedChangedListener);
                this.column.addEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, firstPinnedChangedListener);
                this.addDestroyFunc(function () {
                    _this.column.removeEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstPinnedChangedListener);
                    _this.column.removeEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, firstPinnedChangedListener);
                });
                firstPinnedChangedListener();
            };
            RenderedCell.prototype.getParentRow = function () {
                return this.eParentRow;
            };
            RenderedCell.prototype.setParentRow = function (eParentRow) {
                this.eParentRow = eParentRow;
            };
            RenderedCell.prototype.calculateCheckboxSelection = function () {
                // never allow selection on floating rows
                if (this.node.floating) {
                    return false;
                }
                // if boolean set, then just use it
                var colDef = this.column.getColDef();
                if (typeof colDef.checkboxSelection === 'boolean') {
                    return colDef.checkboxSelection;
                }
                // if function, then call the function to find out. we first check colDef for
                // a function, and if missing then check gridOptions, so colDef has precedence
                var selectionFunc;
                if (typeof colDef.checkboxSelection === 'function') {
                    selectionFunc = colDef.checkboxSelection;
                }
                if (!selectionFunc && this.gridOptionsWrapper.getCheckboxSelection()) {
                    selectionFunc = this.gridOptionsWrapper.getCheckboxSelection();
                }
                if (selectionFunc) {
                    var params = this.createParams();
                    return selectionFunc(params);
                }
                return false;
            };
            RenderedCell.prototype.getColumn = function () {
                return this.column;
            };
            RenderedCell.prototype.getValue = function () {
                var data = this.getDataForRow();
                return this.valueService.getValueUsingSpecificData(this.column, data, this.node);
            };
            RenderedCell.prototype.getDataForRow = function () {
                if (this.node.footer) {
                    // if footer, we always show the data
                    return this.node.data;
                } else if (this.node.group) {
                    // if header and header is expanded, we show data in footer only
                    var footersEnabled = this.gridOptionsWrapper.isGroupIncludeFooter();
                    var suppressHideHeader = this.gridOptionsWrapper.isGroupSuppressBlankHeader();
                    if (this.node.expanded && footersEnabled && !suppressHideHeader) {
                        return undefined;
                    } else {
                        return this.node.data;
                    }
                } else {
                    // otherwise it's a normal node, just return data as normal
                    return this.node.data;
                }
            };
            RenderedCell.prototype.addRangeSelectedListener = function () {
                var _this = this;
                if (!this.rangeController) {
                    return;
                }
                var rangeCountLastTime = 0;
                var rangeSelectedListener = function rangeSelectedListener() {
                    var rangeCount = _this.rangeController.getCellRangeCount(_this.gridCell);
                    if (rangeCountLastTime !== rangeCount) {
                        utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected', rangeCount !== 0);
                        utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-1', rangeCount === 1);
                        utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-2', rangeCount === 2);
                        utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-3', rangeCount === 3);
                        utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-4', rangeCount >= 4);
                        rangeCountLastTime = rangeCount;
                    }
                };
                this.eventService.addEventListener(events_1.Events.EVENT_RANGE_SELECTION_CHANGED, rangeSelectedListener);
                this.addDestroyFunc(function () {
                    _this.eventService.removeEventListener(events_1.Events.EVENT_RANGE_SELECTION_CHANGED, rangeSelectedListener);
                });
                rangeSelectedListener();
            };
            RenderedCell.prototype.addHighlightListener = function () {
                var _this = this;
                if (!this.rangeController) {
                    return;
                }
                var clipboardListener = function clipboardListener(event) {
                    var cellId = _this.gridCell.createId();
                    var shouldFlash = event.cells[cellId];
                    if (shouldFlash) {
                        _this.animateCellWithHighlight();
                    }
                };
                this.eventService.addEventListener(events_1.Events.EVENT_FLASH_CELLS, clipboardListener);
                this.addDestroyFunc(function () {
                    _this.eventService.removeEventListener(events_1.Events.EVENT_FLASH_CELLS, clipboardListener);
                });
            };
            RenderedCell.prototype.addChangeListener = function () {
                var _this = this;
                var cellChangeListener = function cellChangeListener(event) {
                    if (event.column === _this.column) {
                        _this.refreshCell();
                        _this.animateCellWithDataChanged();
                    }
                };
                this.addDestroyableEventListener(this.node, rowNode_1.RowNode.EVENT_CELL_CHANGED, cellChangeListener);
            };
            RenderedCell.prototype.animateCellWithDataChanged = function () {
                if (this.gridOptionsWrapper.isEnableCellChangeFlash() || this.column.getColDef().enableCellChangeFlash) {
                    this.animateCell('data-changed');
                }
            };
            RenderedCell.prototype.animateCellWithHighlight = function () {
                this.animateCell('highlight');
            };
            RenderedCell.prototype.animateCell = function (cssName) {
                var _this = this;
                var fullName = 'ag-cell-' + cssName;
                var animationFullName = 'ag-cell-' + cssName + '-animation';
                // we want to highlight the cells, without any animation
                utils_1.Utils.addCssClass(this.eGridCell, fullName);
                utils_1.Utils.removeCssClass(this.eGridCell, animationFullName);
                // then once that is applied, we remove the highlight with animation
                setTimeout(function () {
                    utils_1.Utils.removeCssClass(_this.eGridCell, fullName);
                    utils_1.Utils.addCssClass(_this.eGridCell, animationFullName);
                    setTimeout(function () {
                        // and then to leave things as we got them, we remove the animation
                        utils_1.Utils.removeCssClass(_this.eGridCell, animationFullName);
                    }, 1000);
                }, 500);
            };
            RenderedCell.prototype.addCellFocusedListener = function () {
                var _this = this;
                // set to null, not false, as we need to set 'ag-cell-no-focus' first time around
                var cellFocusedLastTime = null;
                var cellFocusedListener = function cellFocusedListener(event) {
                    var cellFocused = _this.focusedCellController.isCellFocused(_this.gridCell);
                    // see if we need to change the classes on this cell
                    if (cellFocused !== cellFocusedLastTime) {
                        utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-focus', cellFocused);
                        utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-no-focus', !cellFocused);
                        cellFocusedLastTime = cellFocused;
                    }
                    // if this cell was just focused, see if we need to force browser focus, his can
                    // happen if focus is programmatically set.
                    if (cellFocused && event && event.forceBrowserFocus) {
                        _this.eGridCell.focus();
                    }
                    // if another cell was focused, and we are editing, then stop editing
                    if (_this.editingCell && !cellFocused) {
                        _this.stopEditing();
                    }
                };
                this.eventService.addEventListener(events_1.Events.EVENT_CELL_FOCUSED, cellFocusedListener);
                this.addDestroyFunc(function () {
                    _this.eventService.removeEventListener(events_1.Events.EVENT_CELL_FOCUSED, cellFocusedListener);
                });
                cellFocusedListener();
            };
            RenderedCell.prototype.setWidthOnCell = function () {
                var _this = this;
                var widthChangedListener = function widthChangedListener() {
                    _this.eGridCell.style.width = _this.column.getActualWidth() + "px";
                };
                this.column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
                this.addDestroyFunc(function () {
                    _this.column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
                });
                widthChangedListener();
            };
            RenderedCell.prototype.init = function () {
                this.value = this.getValue();
                this.checkboxSelection = this.calculateCheckboxSelection();
                this.setWidthOnCell();
                this.setPinnedClasses();
                this.addRangeSelectedListener();
                this.addHighlightListener();
                this.addChangeListener();
                this.addCellFocusedListener();
                this.addKeyDownListener();
                this.addKeyPressListener();
                // this.addFocusListener();
                var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.column, this.eGridCell);
                this.addDestroyFunc(setLeftFeature.destroy.bind(setLeftFeature));
                // only set tab index if cell selection is enabled
                if (!this.gridOptionsWrapper.isSuppressCellSelection()) {
                    this.eGridCell.setAttribute("tabindex", "-1");
                }
                // these are the grid styles, don't change between soft refreshes
                this.addClasses();
                this.setInlineEditingClass();
                this.createParentOfValue();
                this.populateCell();
            };
            RenderedCell.prototype.onEnterKeyDown = function () {
                if (this.editingCell) {
                    this.stopEditing();
                    this.focusCell(true);
                } else {
                    this.startEditingIfEnabled(constants_1.Constants.KEY_ENTER);
                }
            };
            RenderedCell.prototype.onF2KeyDown = function () {
                if (!this.editingCell) {
                    this.startEditingIfEnabled(constants_1.Constants.KEY_F2);
                }
            };
            RenderedCell.prototype.onEscapeKeyDown = function () {
                if (this.editingCell) {
                    this.stopEditing(true);
                    this.focusCell(true);
                }
            };
            RenderedCell.prototype.onPopupEditorClosed = function () {
                if (this.editingCell) {
                    this.stopEditing(true);
                    // we only focus cell again if this cell is still focused. it is possible
                    // it is not focused if the user cancelled the edit by clicking on another
                    // cell outside of this one
                    if (this.focusedCellController.isCellFocused(this.gridCell)) {
                        this.focusCell(true);
                    }
                }
            };
            RenderedCell.prototype.onTabKeyDown = function (event) {
                var editNextCell;
                if (this.editingCell) {
                    // if editing, we stop editing, then start editing next cell
                    this.stopEditing();
                    editNextCell = true;
                } else {
                    // otherwise we just move to the next cell
                    editNextCell = false;
                }
                var foundCell = this.rowRenderer.moveFocusToNextCell(this.rowIndex, this.column, this.node.floating, event.shiftKey, editNextCell);
                // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default
                // to the normal tabbing so user can exit the grid.
                if (foundCell) {
                    event.preventDefault();
                }
            };
            RenderedCell.prototype.onBackspaceOrDeleteKeyPressed = function (key) {
                if (!this.editingCell) {
                    this.startEditingIfEnabled(key);
                }
            };
            RenderedCell.prototype.onSpaceKeyPressed = function (event) {
                if (!this.editingCell && this.gridOptionsWrapper.isRowSelection()) {
                    var selected = this.node.isSelected();
                    this.node.setSelected(!selected);
                }
                // prevent default as space key, by default, moves browser scroll down
                event.preventDefault();
            };
            RenderedCell.prototype.onNavigationKeyPressed = function (event, key) {
                if (this.editingCell) {
                    this.stopEditing();
                }
                this.rowRenderer.navigateToNextCell(key, this.rowIndex, this.column, this.node.floating);
                // if we don't prevent default, the grid will scroll with the navigation keys
                event.preventDefault();
            };
            RenderedCell.prototype.addKeyPressListener = function () {
                var _this = this;
                var keyPressListener = function keyPressListener(event) {
                    // check this, in case focus is on a (for example) a text field inside the cell,
                    // in which cse we should not be listening for these key pressed
                    var eventTarget = utils_1.Utils.getTarget(event);
                    var eventOnChildComponent = eventTarget !== _this.getGui();
                    if (eventOnChildComponent) {
                        return;
                    }
                    if (!_this.editingCell) {
                        var pressedChar = String.fromCharCode(event.charCode);
                        if (pressedChar === ' ') {
                            _this.onSpaceKeyPressed(event);
                        } else {
                            if (RenderedCell.PRINTABLE_CHARACTERS.indexOf(pressedChar) >= 0) {
                                _this.startEditingIfEnabled(null, pressedChar);
                                // if we don't prevent default, then the keypress also gets applied to the text field
                                // (at least when doing the default editor), but we need to allow the editor to decide
                                // what it wants to do. we only do this IF editing was started - otherwise it messes
                                // up when the use is not doing editing, but using rendering with text fields in cellRenderer
                                // (as it would block the the user from typing into text fields).
                                event.preventDefault();
                            }
                        }
                    }
                };
                this.eGridCell.addEventListener('keypress', keyPressListener);
                this.addDestroyFunc(function () {
                    _this.eGridCell.removeEventListener('keypress', keyPressListener);
                });
            };
            RenderedCell.prototype.onKeyDown = function (event) {
                var key = event.which || event.keyCode;
                switch (key) {
                    case constants_1.Constants.KEY_ENTER:
                        this.onEnterKeyDown();
                        break;
                    case constants_1.Constants.KEY_F2:
                        this.onF2KeyDown();
                        break;
                    case constants_1.Constants.KEY_ESCAPE:
                        this.onEscapeKeyDown();
                        break;
                    case constants_1.Constants.KEY_TAB:
                        this.onTabKeyDown(event);
                        break;
                    case constants_1.Constants.KEY_BACKSPACE:
                    case constants_1.Constants.KEY_DELETE:
                        this.onBackspaceOrDeleteKeyPressed(key);
                        break;
                    case constants_1.Constants.KEY_DOWN:
                    case constants_1.Constants.KEY_UP:
                    case constants_1.Constants.KEY_RIGHT:
                    case constants_1.Constants.KEY_LEFT:
                        this.onNavigationKeyPressed(event, key);
                        break;
                }
            };
            RenderedCell.prototype.addKeyDownListener = function () {
                var _this = this;
                var editingKeyListener = this.onKeyDown.bind(this);
                this.eGridCell.addEventListener('keydown', editingKeyListener);
                this.addDestroyFunc(function () {
                    _this.eGridCell.removeEventListener('keydown', editingKeyListener);
                });
            };
            RenderedCell.prototype.createCellEditorParams = function (keyPress, charPress) {
                var params = {
                    value: this.getValue(),
                    keyPress: keyPress,
                    charPress: charPress,
                    column: this.column,
                    node: this.node,
                    api: this.gridOptionsWrapper.getApi(),
                    columnApi: this.gridOptionsWrapper.getColumnApi(),
                    context: this.gridOptionsWrapper.getContext(),
                    onKeyDown: this.onKeyDown.bind(this),
                    stopEditing: this.stopEditingAndFocus.bind(this),
                    eGridCell: this.eGridCell
                };
                var colDef = this.column.getColDef();
                if (colDef.cellEditorParams) {
                    utils_1.Utils.assign(params, colDef.cellEditorParams);
                }
                return params;
            };
            RenderedCell.prototype.createCellEditor = function (keyPress, charPress) {
                var params = this.createCellEditorParams(keyPress, charPress);
                var cellEditor = this.cellEditorFactory.createCellEditor(this.column.getCellEditor(), params);
                return cellEditor;
            };
            // cell editors call this, when they want to stop for reasons other
            // than what we pick up on. eg selecting from a dropdown ends editing.
            RenderedCell.prototype.stopEditingAndFocus = function () {
                this.stopEditing();
                this.focusCell(true);
            };
            // called by rowRenderer when user navigates via tab key
            RenderedCell.prototype.startEditingIfEnabled = function (keyPress, charPress) {
                if (!this.isCellEditable()) {
                    return;
                }
                var cellEditor = this.createCellEditor(keyPress, charPress);
                if (cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart()) {
                    if (cellEditor.destroy) {
                        cellEditor.destroy();
                    }
                    return;
                }
                if (!cellEditor.getGui) {
                    console.warn("ag-Grid: cellEditor for column " + this.column.getId() + " is missing getGui() method");
                    // no getGui, for React guys, see if they attached a react component directly
                    if (cellEditor.render) {
                        console.warn("ag-Grid: we found 'render' on the component, are you trying to set a React renderer but added it as colDef.cellEditor instead of colDef.cellEditorFmk?");
                    }
                    return;
                }
                this.cellEditor = cellEditor;
                this.editingCell = true;
                this.cellEditorInPopup = this.cellEditor.isPopup && this.cellEditor.isPopup();
                this.setInlineEditingClass();
                if (this.cellEditorInPopup) {
                    this.addPopupCellEditor();
                } else {
                    this.addInCellEditor();
                }
                if (cellEditor.afterGuiAttached) {
                    cellEditor.afterGuiAttached();
                }
            };
            RenderedCell.prototype.addInCellEditor = function () {
                utils_1.Utils.removeAllChildren(this.eGridCell);
                this.eGridCell.appendChild(this.cellEditor.getGui());
                if (this.gridOptionsWrapper.isAngularCompileRows()) {
                    this.$compile(this.eGridCell)(this.scope);
                }
            };
            RenderedCell.prototype.addPopupCellEditor = function () {
                var _this = this;
                var ePopupGui = this.cellEditor.getGui();
                this.hideEditorPopup = this.popupService.addAsModalPopup(ePopupGui, true,
                    // callback for when popup disappears
                    function () {
                        // we only call stopEditing if we are editing, as
                        // it's possible the popup called 'stop editing'
                        // before this, eg if 'enter key' was pressed on
                        // the editor
                        if (_this.editingCell) {
                            _this.onPopupEditorClosed();
                        }
                    });
                this.popupService.positionPopupOverComponent({
                    eventSource: this.eGridCell,
                    ePopup: ePopupGui,
                    keepWithinBounds: true
                });
                if (this.gridOptionsWrapper.isAngularCompileRows()) {
                    this.$compile(ePopupGui)(this.scope);
                }
            };
            RenderedCell.prototype.focusCell = function (forceBrowserFocus) {
                this.focusedCellController.setFocusedCell(this.rowIndex, this.column, this.node.floating, forceBrowserFocus);
            };
            // pass in 'true' to cancel the editing.
            RenderedCell.prototype.stopEditing = function (cancel) {
                if (cancel === void 0) {
                    cancel = false;
                }
                if (!this.editingCell) {
                    return;
                }
                this.editingCell = false;
                // also have another option here to cancel after editing, so for example user could have a popup editor and
                // it is closed by user clicking outside the editor. then the editor will close automatically (with false
                // passed above) and we need to see if the editor wants to accept the new value.
                var cancelAfterEnd = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();
                var acceptNewValue = !cancel && !cancelAfterEnd;
                if (acceptNewValue) {
                    var newValue = this.cellEditor.getValue();
                    this.valueService.setValue(this.node, this.column, newValue);
                    this.value = this.getValue();
                }
                if (this.cellEditor.destroy) {
                    this.cellEditor.destroy();
                }
                if (this.cellEditorInPopup) {
                    this.hideEditorPopup();
                    this.hideEditorPopup = null;
                } else {
                    utils_1.Utils.removeAllChildren(this.eGridCell);
                    // put the cell back the way it was before editing
                    if (this.checkboxSelection) {
                        // if wrapper, then put the wrapper back
                        this.eGridCell.appendChild(this.eCellWrapper);
                    } else {
                        // if cellRenderer, then put the gui back in. if the renderer has
                        // a refresh, it will be called. however if it doesn't, then later
                        // the renderer will be destroyed and a new one will be created.
                        if (this.cellRenderer) {
                            this.eGridCell.appendChild(this.cellRenderer.getGui());
                        }
                    }
                }
                this.setInlineEditingClass();
                this.refreshCell();
            };
            RenderedCell.prototype.createParams = function () {
                var params = {
                    node: this.node,
                    data: this.node.data,
                    value: this.value,
                    rowIndex: this.rowIndex,
                    colDef: this.column.getColDef(),
                    $scope: this.scope,
                    context: this.gridOptionsWrapper.getContext(),
                    api: this.gridApi,
                    columnApi: this.columnApi
                };
                return params;
            };
            RenderedCell.prototype.createEvent = function (event) {
                var agEvent = this.createParams();
                agEvent.event = event;
                return agEvent;
            };
            RenderedCell.prototype.isCellEditable = function () {
                if (this.editingCell) {
                    return false;
                }
                // never allow editing of groups
                if (this.node.group) {
                    return false;
                }
                return this.column.isCellEditable(this.node);
            };
            RenderedCell.prototype.onMouseEvent = function (eventName, mouseEvent) {
                switch (eventName) {
                    case 'click':
                        this.onCellClicked(mouseEvent);
                        break;
                    case 'mousedown':
                        this.onMouseDown();
                        break;
                    case 'dblclick':
                        this.onCellDoubleClicked(mouseEvent);
                        break;
                    case 'contextmenu':
                        this.onContextMenu(mouseEvent);
                        break;
                }
            };
            RenderedCell.prototype.onContextMenu = function (mouseEvent) {
                // to allow us to debug in chrome, we ignore the event if ctrl is pressed,
                // thus the normal menu is displayed
                if (mouseEvent.ctrlKey || mouseEvent.metaKey) {
                    return;
                }
                var colDef = this.column.getColDef();
                var agEvent = this.createEvent(mouseEvent);
                this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_CONTEXT_MENU, agEvent);
                if (colDef.onCellContextMenu) {
                    colDef.onCellContextMenu(agEvent);
                }
                if (this.contextMenuFactory && !this.gridOptionsWrapper.isSuppressContextMenu()) {
                    this.contextMenuFactory.showMenu(this.node, this.column, this.value, mouseEvent);
                    mouseEvent.preventDefault();
                }
            };
            RenderedCell.prototype.onCellDoubleClicked = function (mouseEvent) {
                var colDef = this.column.getColDef();
                // always dispatch event to eventService
                var agEvent = this.createEvent(mouseEvent);
                this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_DOUBLE_CLICKED, agEvent);
                // check if colDef also wants to handle event
                if (typeof colDef.onCellDoubleClicked === 'function') {
                    colDef.onCellDoubleClicked(agEvent);
                }
                if (!this.gridOptionsWrapper.isSingleClickEdit()) {
                    this.startEditingIfEnabled();
                }
            };
            RenderedCell.prototype.onMouseDown = function () {
                // we pass false to focusCell, as we don't want the cell to focus
                // also get the browser focus. if we did, then the cellRenderer could
                // have a text field in it, for example, and as the user clicks on the
                // text field, the text field, the focus doesn't get to the text
                // field, instead to goes to the div behind, making it impossible to
                // select the text field.
                this.focusCell(false);
                // if it's a right click, then if the cell is already in range,
                // don't change the range, however if the cell is not in a range,
                // we set a new range
                if (this.rangeController) {
                    var thisCell = this.gridCell;
                    var cellAlreadyInRange = this.rangeController.isCellInAnyRange(thisCell);
                    if (!cellAlreadyInRange) {
                        this.rangeController.setRangeToCell(thisCell);
                    }
                }
            };
            RenderedCell.prototype.onCellClicked = function (mouseEvent) {
                var agEvent = this.createEvent(mouseEvent);
                this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_CLICKED, agEvent);
                var colDef = this.column.getColDef();
                if (colDef.onCellClicked) {
                    colDef.onCellClicked(agEvent);
                }
                if (this.gridOptionsWrapper.isSingleClickEdit()) {
                    this.startEditingIfEnabled();
                }
            };
            // if we are editing inline, then we don't have the padding in the cell (set in the themes)
            // to allow the text editor full access to the entire cell
            RenderedCell.prototype.setInlineEditingClass = function () {
                var editingInline = this.editingCell && !this.cellEditorInPopup;
                utils_1.Utils.addOrRemoveCssClass(this.eGridCell, 'ag-cell-inline-editing', editingInline);
                utils_1.Utils.addOrRemoveCssClass(this.eGridCell, 'ag-cell-not-inline-editing', !editingInline);
            };
            RenderedCell.prototype.populateCell = function () {
                // populate
                this.putDataIntoCell();
                // style
                this.addStylesFromColDef();
                this.addClassesFromColDef();
                this.addClassesFromRules();
            };
            RenderedCell.prototype.addStylesFromColDef = function () {
                var colDef = this.column.getColDef();
                if (colDef.cellStyle) {
                    var cssToUse;
                    if (typeof colDef.cellStyle === 'function') {
                        var cellStyleParams = {
                            value: this.value,
                            data: this.node.data,
                            node: this.node,
                            colDef: colDef,
                            column: this.column,
                            $scope: this.scope,
                            context: this.gridOptionsWrapper.getContext(),
                            api: this.gridOptionsWrapper.getApi()
                        };
                        var cellStyleFunc = colDef.cellStyle;
                        cssToUse = cellStyleFunc(cellStyleParams);
                    } else {
                        cssToUse = colDef.cellStyle;
                    }
                    if (cssToUse) {
                        utils_1.Utils.addStylesToElement(this.eGridCell, cssToUse);
                    }
                }
            };
            RenderedCell.prototype.addClassesFromColDef = function () {
                var _this = this;
                var colDef = this.column.getColDef();
                if (colDef.cellClass) {
                    var classToUse;
                    if (typeof colDef.cellClass === 'function') {
                        var cellClassParams = {
                            value: this.value,
                            data: this.node.data,
                            node: this.node,
                            colDef: colDef,
                            $scope: this.scope,
                            context: this.gridOptionsWrapper.getContext(),
                            api: this.gridOptionsWrapper.getApi()
                        };
                        var cellClassFunc = colDef.cellClass;
                        classToUse = cellClassFunc(cellClassParams);
                    } else {
                        classToUse = colDef.cellClass;
                    }
                    if (typeof classToUse === 'string') {
                        utils_1.Utils.addCssClass(this.eGridCell, classToUse);
                    } else if (Array.isArray(classToUse)) {
                        classToUse.forEach(function (cssClassItem) {
                            utils_1.Utils.addCssClass(_this.eGridCell, cssClassItem);
                        });
                    }
                }
            };
            RenderedCell.prototype.addClassesFromRules = function () {
                var colDef = this.column.getColDef();
                var classRules = colDef.cellClassRules;
                if ((typeof classRules === "undefined" ? "undefined" : _typeof(classRules)) === 'object' && classRules !== null) {
                    var params = {
                        value: this.value,
                        data: this.node.data,
                        node: this.node,
                        colDef: colDef,
                        rowIndex: this.rowIndex,
                        api: this.gridOptionsWrapper.getApi(),
                        context: this.gridOptionsWrapper.getContext()
                    };
                    var classNames = Object.keys(classRules);
                    for (var i = 0; i < classNames.length; i++) {
                        var className = classNames[i];
                        var rule = classRules[className];
                        var resultOfRule;
                        if (typeof rule === 'string') {
                            resultOfRule = this.expressionService.evaluate(rule, params);
                        } else if (typeof rule === 'function') {
                            resultOfRule = rule(params);
                        }
                        if (resultOfRule) {
                            utils_1.Utils.addCssClass(this.eGridCell, className);
                        } else {
                            utils_1.Utils.removeCssClass(this.eGridCell, className);
                        }
                    }
                }
            };
            RenderedCell.prototype.createParentOfValue = function () {
                if (this.checkboxSelection) {
                    this.eCellWrapper = document.createElement('span');
                    utils_1.Utils.addCssClass(this.eCellWrapper, 'ag-cell-wrapper');
                    this.eGridCell.appendChild(this.eCellWrapper);
                    var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();
                    this.context.wireBean(cbSelectionComponent);
                    cbSelectionComponent.init({ rowNode: this.node });
                    this.eCellWrapper.appendChild(cbSelectionComponent.getGui());
                    this.addDestroyFunc(function () {
                        return cbSelectionComponent.destroy();
                    });
                    // eventually we call eSpanWithValue.innerHTML = xxx, so cannot include the checkbox (above) in this span
                    this.eSpanWithValue = document.createElement('span');
                    utils_1.Utils.addCssClass(this.eSpanWithValue, 'ag-cell-value');
                    this.eCellWrapper.appendChild(this.eSpanWithValue);
                    this.eParentOfValue = this.eSpanWithValue;
                } else {
                    utils_1.Utils.addCssClass(this.eGridCell, 'ag-cell-value');
                    this.eParentOfValue = this.eGridCell;
                }
            };
            RenderedCell.prototype.isVolatile = function () {
                return this.column.getColDef().volatile;
            };
            RenderedCell.prototype.refreshCell = function (animate, newData) {
                if (animate === void 0) {
                    animate = false;
                }
                if (newData === void 0) {
                    newData = false;
                }
                this.value = this.getValue();
                var refreshFailed = false;
                var that = this;
                // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.
                // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')
                // then we are not showing a movement in the stock price, rather we are showing different stock.
                var attemptRefresh = !newData && this.cellRenderer && this.cellRenderer.refresh;
                if (attemptRefresh) {
                    try {
                        doRefresh();
                    } catch (e) {
                        if (e instanceof methodNotImplementedException_1.MethodNotImplementedException) {
                            refreshFailed = true;
                        } else {
                            throw e;
                        }
                    }
                }
                // we do the replace if not doing refresh, or if refresh was unsuccessful.
                // the refresh can be unsuccessful if we are using a framework (eg ng2 or react) and the framework
                // wrapper has the refresh method, but the underlying component doesn't
                if (!attemptRefresh || refreshFailed) {
                    doReplace();
                }
                if (animate) {
                    this.animateCellWithDataChanged();
                }
                function doRefresh() {
                    // if the cell renderer has a refresh method, we call this instead of doing a refresh
                    // note: should pass in params here instead of value?? so that client has formattedValue
                    var valueFormatted = that.formatValue(this.value);
                    var cellRendererParams = that.column.getColDef().cellRendererParams;
                    var params = that.createRendererAndRefreshParams(valueFormatted, cellRendererParams);
                    that.cellRenderer.refresh(params);
                    // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static
                    that.addClassesFromRules();
                }
                function doReplace() {
                    // otherwise we rip out the cell and replace it
                    utils_1.Utils.removeAllChildren(that.eParentOfValue);
                    // remove old renderer component if it exists
                    if (that.cellRenderer && that.cellRenderer.destroy) {
                        that.cellRenderer.destroy();
                    }
                    that.cellRenderer = null;
                    that.populateCell();
                    // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)
                    if (that.gridOptionsWrapper.isAngularCompileRows()) {
                        that.$compile(that.eGridCell)(that.scope);
                    }
                }
            };
            RenderedCell.prototype.putDataIntoCell = function () {
                // template gets preference, then cellRenderer, then do it ourselves
                var colDef = this.column.getColDef();
                var cellRenderer = this.column.getCellRenderer();
                var floatingCellRenderer = this.column.getFloatingCellRenderer();
                var valueFormatted = this.valueFormatterService.formatValue(this.column, this.node, this.scope, this.rowIndex, this.value);
                if (colDef.template) {
                    // template is really only used for angular 1 - as people using ng1 are used to providing templates with
                    // bindings in it. in ng2, people will hopefully want to provide components, not templates.
                    this.eParentOfValue.innerHTML = colDef.template;
                } else if (colDef.templateUrl) {
                    // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.
                    // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would
                    // not do these, but would follow a pattern that was friendly towards components, not templates.
                    var template = this.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));
                    if (template) {
                        this.eParentOfValue.innerHTML = template;
                    }
                } else if (floatingCellRenderer && this.node.floating) {
                    // if floating, then give preference to floating cell renderer
                    this.useCellRenderer(floatingCellRenderer, colDef.floatingCellRendererParams, valueFormatted);
                } else if (cellRenderer) {
                    // use normal cell renderer
                    this.useCellRenderer(cellRenderer, colDef.cellRendererParams, valueFormatted);
                } else {
                    // if we insert undefined, then it displays as the string 'undefined', ugly!
                    var valueToRender = utils_1.Utils.exists(valueFormatted) ? valueFormatted : this.value;
                    if (utils_1.Utils.exists(valueToRender) && valueToRender !== '') {
                        // not using innerHTML to prevent injection of HTML
                        // https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#Security_considerations
                        this.eParentOfValue.textContent = valueToRender.toString();
                    }
                }
                if (colDef.tooltipField) {
                    var data = this.getDataForRow();
                    if (utils_1.Utils.exists(data)) {
                        var tooltip = utils_1.Utils.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());
                        this.eParentOfValue.setAttribute('title', tooltip);
                    }
                }
            };
            RenderedCell.prototype.formatValue = function (value) {
                return this.valueFormatterService.formatValue(this.column, this.node, this.scope, this.rowIndex, value);
            };
            RenderedCell.prototype.createRendererAndRefreshParams = function (valueFormatted, cellRendererParams) {
                var params = {
                    value: this.value,
                    valueFormatted: valueFormatted,
                    valueGetter: this.getValue,
                    formatValue: this.formatValue.bind(this),
                    data: this.node.data,
                    node: this.node,
                    colDef: this.column.getColDef(),
                    column: this.column,
                    $scope: this.scope,
                    rowIndex: this.rowIndex,
                    api: this.gridOptionsWrapper.getApi(),
                    columnApi: this.gridOptionsWrapper.getColumnApi(),
                    context: this.gridOptionsWrapper.getContext(),
                    refreshCell: this.refreshCell.bind(this),
                    eGridCell: this.eGridCell,
                    eParentOfValue: this.eParentOfValue,
                    addRenderedRowListener: this.renderedRow.addEventListener.bind(this.renderedRow)
                };
                if (cellRendererParams) {
                    utils_1.Utils.assign(params, cellRendererParams);
                }
                return params;
            };
            RenderedCell.prototype.useCellRenderer = function (cellRendererKey, cellRendererParams, valueFormatted) {
                var params = this.createRendererAndRefreshParams(valueFormatted, cellRendererParams);
                this.cellRenderer = this.cellRendererService.useCellRenderer(cellRendererKey, this.eParentOfValue, params);
            };
            RenderedCell.prototype.addClasses = function () {
                utils_1.Utils.addCssClass(this.eGridCell, 'ag-cell');
                this.eGridCell.setAttribute("colId", this.column.getColId());
                if (this.node.group && this.node.footer) {
                    utils_1.Utils.addCssClass(this.eGridCell, 'ag-footer-cell');
                }
                if (this.node.group && !this.node.footer) {
                    utils_1.Utils.addCssClass(this.eGridCell, 'ag-group-cell');
                }
            };
            RenderedCell.PRINTABLE_CHARACTERS = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890!"$%^&*()_+-=[];\'#,./\|<>?:@~{}';
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], RenderedCell.prototype, "context", void 0);
            __decorate([context_1.Autowired('columnApi'), __metadata('design:type', columnController_1.ColumnApi)], RenderedCell.prototype, "columnApi", void 0);
            __decorate([context_1.Autowired('gridApi'), __metadata('design:type', gridApi_1.GridApi)], RenderedCell.prototype, "gridApi", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], RenderedCell.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('expressionService'), __metadata('design:type', expressionService_1.ExpressionService)], RenderedCell.prototype, "expressionService", void 0);
            __decorate([context_1.Autowired('rowRenderer'), __metadata('design:type', rowRenderer_1.RowRenderer)], RenderedCell.prototype, "rowRenderer", void 0);
            __decorate([context_1.Autowired('$compile'), __metadata('design:type', Object)], RenderedCell.prototype, "$compile", void 0);
            __decorate([context_1.Autowired('templateService'), __metadata('design:type', templateService_1.TemplateService)], RenderedCell.prototype, "templateService", void 0);
            __decorate([context_1.Autowired('valueService'), __metadata('design:type', valueService_1.ValueService)], RenderedCell.prototype, "valueService", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], RenderedCell.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], RenderedCell.prototype, "columnController", void 0);
            __decorate([context_1.Optional('rangeController'), __metadata('design:type', Object)], RenderedCell.prototype, "rangeController", void 0);
            __decorate([context_1.Autowired('focusedCellController'), __metadata('design:type', focusedCellController_1.FocusedCellController)], RenderedCell.prototype, "focusedCellController", void 0);
            __decorate([context_1.Optional('contextMenuFactory'), __metadata('design:type', Object)], RenderedCell.prototype, "contextMenuFactory", void 0);
            __decorate([context_1.Autowired('focusService'), __metadata('design:type', focusService_1.FocusService)], RenderedCell.prototype, "focusService", void 0);
            __decorate([context_1.Autowired('cellEditorFactory'), __metadata('design:type', cellEditorFactory_1.CellEditorFactory)], RenderedCell.prototype, "cellEditorFactory", void 0);
            __decorate([context_1.Autowired('cellRendererFactory'), __metadata('design:type', cellRendererFactory_1.CellRendererFactory)], RenderedCell.prototype, "cellRendererFactory", void 0);
            __decorate([context_1.Autowired('popupService'), __metadata('design:type', popupService_1.PopupService)], RenderedCell.prototype, "popupService", void 0);
            __decorate([context_1.Autowired('cellRendererService'), __metadata('design:type', cellRendererService_1.CellRendererService)], RenderedCell.prototype, "cellRendererService", void 0);
            __decorate([context_1.Autowired('valueFormatterService'), __metadata('design:type', valueFormatterService_1.ValueFormatterService)], RenderedCell.prototype, "valueFormatterService", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RenderedCell.prototype, "init", null);
            return RenderedCell;
        }(component_1.Component);
        exports.RenderedCell = RenderedCell;

        /***/ },
    /* 277 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var utils_1 = __webpack_require__(245);
        var gridCore_1 = __webpack_require__(278);
        var columnController_1 = __webpack_require__(251);
        var constants_1 = __webpack_require__(246);
        var gridCell_1 = __webpack_require__(271);
        // tracks when focus goes into a cell. cells listen to this, so they know to stop editing
        // if focus goes into another cell.
        var FocusService = function () {
            function FocusService() {
                this.destroyMethods = [];
                this.listeners = [];
            }
            FocusService.prototype.addListener = function (listener) {
                this.listeners.push(listener);
            };
            FocusService.prototype.removeListener = function (listener) {
                utils_1.Utils.removeFromArray(this.listeners, listener);
            };
            FocusService.prototype.init = function () {
                var _this = this;
                var focusListener = function focusListener(focusEvent) {
                    var gridCell = _this.getCellForFocus(focusEvent);
                    if (gridCell) {
                        _this.informListeners({ gridCell: gridCell });
                    }
                };
                var eRootGui = this.gridCore.getRootGui();
                eRootGui.addEventListener('focus', focusListener, true);
                this.destroyMethods.push(function () {
                    eRootGui.removeEventListener('focus', focusListener);
                });
            };
            FocusService.prototype.getCellForFocus = function (focusEvent) {
                var column = null;
                var row = null;
                var floating = null;
                var that = this;
                var eTarget = focusEvent.target;
                while (eTarget) {
                    checkRow(eTarget);
                    checkColumn(eTarget);
                    eTarget = eTarget.parentNode;
                }
                if (utils_1.Utils.exists(column) && utils_1.Utils.exists(row)) {
                    var gridCell = new gridCell_1.GridCell(row, floating, column);
                    return gridCell;
                } else {
                    return null;
                }
                function checkRow(eTarget) {
                    // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
                    var rowId = utils_1.Utils.getElementAttribute(eTarget, 'row');
                    if (utils_1.Utils.exists(rowId) && utils_1.Utils.containsClass(eTarget, 'ag-row')) {
                        if (rowId.indexOf('ft') === 0) {
                            floating = constants_1.Constants.FLOATING_TOP;
                            rowId = rowId.substr(3);
                        } else if (rowId.indexOf('fb') === 0) {
                            floating = constants_1.Constants.FLOATING_BOTTOM;
                            rowId = rowId.substr(3);
                        } else {
                            floating = null;
                        }
                        row = parseInt(rowId);
                    }
                }
                function checkColumn(eTarget) {
                    // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
                    var colId = utils_1.Utils.getElementAttribute(eTarget, 'colid');
                    if (utils_1.Utils.exists(colId) && utils_1.Utils.containsClass(eTarget, 'ag-cell')) {
                        var foundColumn = that.columnController.getGridColumn(colId);
                        if (foundColumn) {
                            column = foundColumn;
                        }
                    }
                }
            };
            FocusService.prototype.informListeners = function (event) {
                this.listeners.forEach(function (listener) {
                    return listener(event);
                });
            };
            FocusService.prototype.destroy = function () {
                this.destroyMethods.forEach(function (destroyMethod) {
                    return destroyMethod();
                });
            };
            __decorate([context_1.Autowired('gridCore'), __metadata('design:type', gridCore_1.GridCore)], FocusService.prototype, "gridCore", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], FocusService.prototype, "columnController", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], FocusService.prototype, "init", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], FocusService.prototype, "destroy", null);
            FocusService = __decorate([context_1.Bean('focusService'), __metadata('design:paramtypes', [])], FocusService);
            return FocusService;
        }();
        exports.FocusService = FocusService;

        /***/ },
    /* 278 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var paginationController_1 = __webpack_require__(279);
        var columnController_1 = __webpack_require__(251);
        var rowRenderer_1 = __webpack_require__(261);
        var filterManager_1 = __webpack_require__(281);
        var eventService_1 = __webpack_require__(242);
        var gridPanel_1 = __webpack_require__(262);
        var logger_1 = __webpack_require__(243);
        var constants_1 = __webpack_require__(246);
        var popupService_1 = __webpack_require__(282);
        var events_1 = __webpack_require__(248);
        var borderLayout_1 = __webpack_require__(268);
        var context_1 = __webpack_require__(244);
        var focusedCellController_1 = __webpack_require__(273);
        var component_1 = __webpack_require__(285);
        var GridCore = function () {
            function GridCore(loggerFactory) {
                this.destroyFunctions = [];
                this.logger = loggerFactory.create('GridCore');
            }
            GridCore.prototype.init = function () {
                var _this = this;
                // and the last bean, done in it's own section, as it's optional
                var toolPanelGui;
                var eSouthPanel = this.createSouthPanel();
                if (this.toolPanel && !this.gridOptionsWrapper.isForPrint()) {
                    toolPanelGui = this.toolPanel.getGui();
                }
                var createTopPanelGui = this.createNorthPanel();
                this.eRootPanel = new borderLayout_1.BorderLayout({
                    center: this.gridPanel.getLayout(),
                    east: toolPanelGui,
                    north: createTopPanelGui,
                    south: eSouthPanel,
                    dontFill: this.gridOptionsWrapper.isForPrint(),
                    name: 'eRootPanel'
                });
                // see what the grid options are for default of toolbar
                this.showToolPanel(this.gridOptionsWrapper.isShowToolPanel());
                this.eGridDiv.appendChild(this.eRootPanel.getGui());
                // if using angular, watch for quickFilter changes
                if (this.$scope) {
                    this.$scope.$watch(this.quickFilterOnScope, function (newFilter) {
                        return _this.filterManager.setQuickFilter(newFilter);
                    });
                }
                if (!this.gridOptionsWrapper.isForPrint()) {
                    this.addWindowResizeListener();
                }
                this.doLayout();
                this.finished = false;
                this.periodicallyDoLayout();
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onRowGroupChanged.bind(this));
                this.onRowGroupChanged();
                this.logger.log('ready');
            };
            GridCore.prototype.createNorthPanel = function () {
                var _this = this;
                if (!this.gridOptionsWrapper.isEnterprise()) {
                    return null;
                }
                var topPanelGui = document.createElement('div');
                var dropPanelVisibleListener = this.onDropPanelVisible.bind(this);
                this.rowGroupComp = this.rowGroupCompFactory.create();
                this.pivotComp = this.pivotCompFactory.create();
                topPanelGui.appendChild(this.rowGroupComp.getGui());
                topPanelGui.appendChild(this.pivotComp.getGui());
                this.rowGroupComp.addEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
                this.pivotComp.addEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
                this.destroyFunctions.push(function () {
                    _this.rowGroupComp.removeEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
                    _this.pivotComp.removeEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
                });
                this.onDropPanelVisible();
                return topPanelGui;
            };
            GridCore.prototype.onDropPanelVisible = function () {
                var bothVisible = this.rowGroupComp.isVisible() && this.pivotComp.isVisible();
                this.rowGroupComp.addOrRemoveCssClass('ag-width-half', bothVisible);
                this.pivotComp.addOrRemoveCssClass('ag-width-half', bothVisible);
            };
            GridCore.prototype.getRootGui = function () {
                return this.eRootPanel.getGui();
            };
            GridCore.prototype.createSouthPanel = function () {
                if (!this.statusBar && this.gridOptionsWrapper.isEnableStatusBar()) {
                    console.warn('ag-Grid: status bar is only available in ag-Grid-Enterprise');
                }
                var statusBarEnabled = this.statusBar && this.gridOptionsWrapper.isEnableStatusBar();
                var paginationPanelEnabled = this.gridOptionsWrapper.isRowModelPagination() && !this.gridOptionsWrapper.isForPrint();
                if (!statusBarEnabled && !paginationPanelEnabled) {
                    return null;
                }
                var eSouthPanel = document.createElement('div');
                if (statusBarEnabled) {
                    eSouthPanel.appendChild(this.statusBar.getGui());
                }
                if (paginationPanelEnabled) {
                    eSouthPanel.appendChild(this.paginationController.getGui());
                }
                return eSouthPanel;
            };
            GridCore.prototype.onRowGroupChanged = function () {
                if (!this.rowGroupComp) {
                    return;
                }
                var rowGroupPanelShow = this.gridOptionsWrapper.getRowGroupPanelShow();
                if (rowGroupPanelShow === constants_1.Constants.ALWAYS) {
                    this.rowGroupComp.setVisible(true);
                } else if (rowGroupPanelShow === constants_1.Constants.ONLY_WHEN_GROUPING) {
                    var grouping = !this.columnController.isRowGroupEmpty();
                    this.rowGroupComp.setVisible(grouping);
                } else {
                    this.rowGroupComp.setVisible(false);
                }
                this.eRootPanel.doLayout();
            };
            GridCore.prototype.addWindowResizeListener = function () {
                var eventListener = this.doLayout.bind(this);
                window.addEventListener('resize', eventListener);
                this.destroyFunctions.push(function () {
                    return window.removeEventListener('resize', eventListener);
                });
            };
            GridCore.prototype.periodicallyDoLayout = function () {
                var _this = this;
                if (!this.finished) {
                    var intervalMillis = this.gridOptionsWrapper.getLayoutInterval();
                    // if interval is negative, this stops the layout from happening
                    if (intervalMillis > 0) {
                        setTimeout(function () {
                            _this.doLayout();
                            _this.gridPanel.periodicallyCheck();
                            _this.periodicallyDoLayout();
                        }, intervalMillis);
                    } else {
                        // if user provided negative number, we still do the check every 5 seconds,
                        // in case the user turns the number positive again
                        setTimeout(function () {
                            _this.periodicallyDoLayout();
                        }, 5000);
                    }
                }
            };
            GridCore.prototype.showToolPanel = function (show) {
                if (show && !this.toolPanel) {
                    console.warn('ag-Grid: toolPanel is only available in ag-Grid Enterprise');
                    this.toolPanelShowing = false;
                    return;
                }
                this.toolPanelShowing = show;
                if (this.toolPanel) {
                    this.toolPanel.setVisible(show);
                    this.eRootPanel.doLayout();
                }
            };
            GridCore.prototype.isToolPanelShowing = function () {
                return this.toolPanelShowing;
            };
            GridCore.prototype.destroy = function () {
                this.finished = true;
                this.eGridDiv.removeChild(this.eRootPanel.getGui());
                this.logger.log('Grid DOM removed');
                this.destroyFunctions.forEach(function (func) {
                    return func();
                });
            };
            GridCore.prototype.ensureNodeVisible = function (comparator) {
                if (this.doingVirtualPaging) {
                    throw 'Cannot use ensureNodeVisible when doing virtual paging, as we cannot check rows that are not in memory';
                }
                // look for the node index we want to display
                var rowCount = this.rowModel.getRowCount();
                var comparatorIsAFunction = typeof comparator === 'function';
                var indexToSelect = -1;
                // go through all the nodes, find the one we want to show
                for (var i = 0; i < rowCount; i++) {
                    var node = this.rowModel.getRow(i);
                    if (comparatorIsAFunction) {
                        if (comparator(node)) {
                            indexToSelect = i;
                            break;
                        }
                    } else {
                        // check object equality against node and data
                        if (comparator === node || comparator === node.data) {
                            indexToSelect = i;
                            break;
                        }
                    }
                }
                if (indexToSelect >= 0) {
                    this.gridPanel.ensureIndexVisible(indexToSelect);
                }
            };
            GridCore.prototype.doLayout = function () {
                // need to do layout first, as drawVirtualRows and setPinnedColHeight
                // need to know the result of the resizing of the panels.
                var sizeChanged = this.eRootPanel.doLayout();
                // both of the two below should be done in gridPanel, the gridPanel should register 'resize' to the panel
                if (sizeChanged) {
                    this.rowRenderer.drawVirtualRows();
                    var event = {
                        clientWidth: this.eRootPanel.getGui().clientWidth,
                        clientHeight: this.eRootPanel.getGui().clientHeight
                    };
                    this.eventService.dispatchEvent(events_1.Events.EVENT_GRID_SIZE_CHANGED, event);
                }
            };
            __decorate([context_1.Autowired('gridOptions'), __metadata('design:type', Object)], GridCore.prototype, "gridOptions", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], GridCore.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('paginationController'), __metadata('design:type', paginationController_1.PaginationController)], GridCore.prototype, "paginationController", void 0);
            __decorate([context_1.Autowired('rowModel'), __metadata('design:type', Object)], GridCore.prototype, "rowModel", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], GridCore.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('rowRenderer'), __metadata('design:type', rowRenderer_1.RowRenderer)], GridCore.prototype, "rowRenderer", void 0);
            __decorate([context_1.Autowired('filterManager'), __metadata('design:type', filterManager_1.FilterManager)], GridCore.prototype, "filterManager", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], GridCore.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], GridCore.prototype, "gridPanel", void 0);
            __decorate([context_1.Autowired('eGridDiv'), __metadata('design:type', HTMLElement)], GridCore.prototype, "eGridDiv", void 0);
            __decorate([context_1.Autowired('$scope'), __metadata('design:type', Object)], GridCore.prototype, "$scope", void 0);
            __decorate([context_1.Autowired('quickFilterOnScope'), __metadata('design:type', String)], GridCore.prototype, "quickFilterOnScope", void 0);
            __decorate([context_1.Autowired('popupService'), __metadata('design:type', popupService_1.PopupService)], GridCore.prototype, "popupService", void 0);
            __decorate([context_1.Autowired('focusedCellController'), __metadata('design:type', focusedCellController_1.FocusedCellController)], GridCore.prototype, "focusedCellController", void 0);
            __decorate([context_1.Optional('rowGroupCompFactory'), __metadata('design:type', Object)], GridCore.prototype, "rowGroupCompFactory", void 0);
            __decorate([context_1.Optional('pivotCompFactory'), __metadata('design:type', Object)], GridCore.prototype, "pivotCompFactory", void 0);
            __decorate([context_1.Optional('toolPanel'), __metadata('design:type', component_1.Component)], GridCore.prototype, "toolPanel", void 0);
            __decorate([context_1.Optional('statusBar'), __metadata('design:type', component_1.Component)], GridCore.prototype, "statusBar", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], GridCore.prototype, "init", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], GridCore.prototype, "destroy", null);
            GridCore = __decorate([context_1.Bean('gridCore'), __param(0, context_1.Qualifier('loggerFactory')), __metadata('design:paramtypes', [logger_1.LoggerFactory])], GridCore);
            return GridCore;
        }();
        exports.GridCore = GridCore;

        /***/ },
    /* 279 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var context_1 = __webpack_require__(244);
        var gridPanel_1 = __webpack_require__(262);
        var selectionController_1 = __webpack_require__(266);
        var sortController_1 = __webpack_require__(280);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var filterManager_1 = __webpack_require__(281);
        var constants_1 = __webpack_require__(246);
        var template = '<div class="ag-paging-panel ag-font-style">' + '<span id="pageRowSummaryPanel" class="ag-paging-row-summary-panel">' + '<span id="firstRowOnPage"></span>' + ' [TO] ' + '<span id="lastRowOnPage"></span>' + ' [OF] ' + '<span id="recordCount"></span>' + '</span>' + '<span class="ag-paging-page-summary-panel">' + '<button type="button" class="ag-paging-button" id="btFirst">[FIRST]</button>' + '<button type="button" class="ag-paging-button" id="btPrevious">[PREVIOUS]</button>' + '[PAGE] ' + '<span id="current"></span>' + ' [OF] ' + '<span id="total"></span>' + '<button type="button" class="ag-paging-button" id="btNext">[NEXT]</button>' + '<button type="button" class="ag-paging-button" id="btLast">[LAST]</button>' + '</span>' + '</div>';
        var PaginationController = function () {
            function PaginationController() {}
            PaginationController.prototype.init = function () {
                var _this = this;
                // if we are doing pagination, we are guaranteed that the model type
                // is normal. if it is not, then this paginationController service
                // will never be called.
                if (this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
                    this.inMemoryRowModel = this.rowModel;
                }
                this.setupComponents();
                this.callVersion = 0;
                var paginationEnabled = this.gridOptionsWrapper.isRowModelPagination();
                this.eventService.addEventListener(events_1.Events.EVENT_FILTER_CHANGED, function () {
                    if (paginationEnabled && _this.gridOptionsWrapper.isEnableServerSideFilter()) {
                        _this.reset(false);
                    }
                });
                this.eventService.addEventListener(events_1.Events.EVENT_SORT_CHANGED, function () {
                    if (paginationEnabled && _this.gridOptionsWrapper.isEnableServerSideSorting()) {
                        _this.reset(false);
                    }
                });
                if (paginationEnabled && this.gridOptionsWrapper.getDatasource()) {
                    this.setDatasource(this.gridOptionsWrapper.getDatasource());
                }
            };
            PaginationController.prototype.setDatasource = function (datasource) {
                this.datasource = datasource;
                if (!datasource) {
                    // only continue if we have a valid datasource to work with
                    return;
                }
                this.reset(true);
            };
            PaginationController.prototype.checkForDeprecated = function () {
                var ds = this.datasource;
                if (utils_1.Utils.exists(ds.pageSize)) {
                    console.error('ag-Grid: since version 5.1.x, pageSize is replaced with grid property paginationPageSize');
                }
            };
            PaginationController.prototype.reset = function (freshDatasource) {
                // important to return here, as the user could be setting filter or sort before
                // data-source is set
                if (utils_1.Utils.missing(this.datasource)) {
                    return;
                }
                this.checkForDeprecated();
                // if user is providing id's, then this means we can keep the selection between datsource hits,
                // as the rows will keep their unique id's even if, for example, server side sorting or filtering
                // is done. if it's a new datasource, then always clear the selection.
                var userGeneratingRows = utils_1.Utils.exists(this.gridOptionsWrapper.getRowNodeIdFunc());
                var resetSelectionController = freshDatasource || !userGeneratingRows;
                if (resetSelectionController) {
                    this.selectionController.reset();
                }
                // copy pageSize, to guard against it changing the the datasource between calls
                this.pageSize = this.gridOptionsWrapper.getPaginationPageSize();
                if (!(this.pageSize >= 1)) {
                    this.pageSize = 100;
                }
                // see if we know the total number of pages, or if it's 'to be decided'
                if (typeof this.datasource.rowCount === 'number' && this.datasource.rowCount >= 0) {
                    this.rowCount = this.datasource.rowCount;
                    this.foundMaxRow = true;
                    this.calculateTotalPages();
                } else {
                    this.rowCount = 0;
                    this.foundMaxRow = false;
                    this.totalPages = null;
                }
                this.currentPage = 0;
                // hide the summary panel until something is loaded
                this.ePageRowSummaryPanel.style.visibility = 'hidden';
                this.setTotalLabels();
                this.loadPage();
            };
            // the native method number.toLocaleString(undefined, {minimumFractionDigits: 0}) puts in decimal places in IE
            PaginationController.prototype.myToLocaleString = function (input) {
                if (typeof input !== 'number') {
                    return '';
                } else {
                    // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript
                    return input.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
                }
            };
            PaginationController.prototype.setTotalLabels = function () {
                if (this.foundMaxRow) {
                    this.lbTotal.innerHTML = this.myToLocaleString(this.totalPages);
                    this.lbRecordCount.innerHTML = this.myToLocaleString(this.rowCount);
                } else {
                    var moreText = this.gridOptionsWrapper.getLocaleTextFunc()('more', 'more');
                    this.lbTotal.innerHTML = moreText;
                    this.lbRecordCount.innerHTML = moreText;
                }
            };
            PaginationController.prototype.calculateTotalPages = function () {
                this.totalPages = Math.floor((this.rowCount - 1) / this.pageSize) + 1;
            };
            PaginationController.prototype.pageLoaded = function (rows, lastRowIndex) {
                var firstId = this.currentPage * this.pageSize;
                this.inMemoryRowModel.setRowData(rows, true, firstId);
                // see if we hit the last row
                if (!this.foundMaxRow && typeof lastRowIndex === 'number' && lastRowIndex >= 0) {
                    this.foundMaxRow = true;
                    this.rowCount = lastRowIndex;
                    this.calculateTotalPages();
                    this.setTotalLabels();
                    // if overshot pages, go back
                    if (this.currentPage > this.totalPages) {
                        this.currentPage = this.totalPages - 1;
                        this.loadPage();
                    }
                }
                this.enableOrDisableButtons();
                this.updateRowLabels();
            };
            PaginationController.prototype.updateRowLabels = function () {
                var startRow;
                var endRow;
                if (this.isZeroPagesToDisplay()) {
                    startRow = 0;
                    endRow = 0;
                } else {
                    startRow = this.pageSize * this.currentPage + 1;
                    endRow = startRow + this.pageSize - 1;
                    if (this.foundMaxRow && endRow > this.rowCount) {
                        endRow = this.rowCount;
                    }
                }
                this.lbFirstRowOnPage.innerHTML = this.myToLocaleString(startRow);
                this.lbLastRowOnPage.innerHTML = this.myToLocaleString(endRow);
                // show the summary panel, when first shown, this is blank
                this.ePageRowSummaryPanel.style.visibility = "";
            };
            PaginationController.prototype.loadPage = function () {
                var _this = this;
                this.enableOrDisableButtons();
                var startRow = this.currentPage * this.pageSize;
                var endRow = (this.currentPage + 1) * this.pageSize;
                this.lbCurrent.innerHTML = this.myToLocaleString(this.currentPage + 1);
                this.callVersion++;
                var callVersionCopy = this.callVersion;
                var that = this;
                this.gridPanel.showLoadingOverlay();
                var sortModel;
                if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
                    sortModel = this.sortController.getSortModel();
                }
                var filterModel;
                if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
                    filterModel = this.filterManager.getFilterModel();
                }
                var params = {
                    startRow: startRow,
                    endRow: endRow,
                    successCallback: successCallback,
                    failCallback: failCallback,
                    sortModel: sortModel,
                    filterModel: filterModel,
                    context: this.gridOptionsWrapper.getContext()
                };
                // check if old version of datasource used
                var getRowsParams = utils_1.Utils.getFunctionParameters(this.datasource.getRows);
                if (getRowsParams.length > 1) {
                    console.warn('ag-grid: It looks like your paging datasource is of the old type, taking more than one parameter.');
                    console.warn('ag-grid: From ag-grid 1.9.0, now the getRows takes one parameter. See the documentation for details.');
                }
                // put in timeout, to force result to be async
                setTimeout(function () {
                    _this.datasource.getRows(params);
                }, 0);
                function successCallback(rows, lastRowIndex) {
                    if (that.isCallDaemon(callVersionCopy)) {
                        return;
                    }
                    that.pageLoaded(rows, lastRowIndex);
                }
                function failCallback() {
                    if (that.isCallDaemon(callVersionCopy)) {
                        return;
                    }
                    // set in an empty set of rows, this will at
                    // least get rid of the loading panel, and
                    // stop blocking things
                    that.inMemoryRowModel.setRowData([], true);
                }
            };
            PaginationController.prototype.isCallDaemon = function (versionCopy) {
                return versionCopy !== this.callVersion;
            };
            PaginationController.prototype.onBtNext = function () {
                this.currentPage++;
                this.loadPage();
            };
            PaginationController.prototype.onBtPrevious = function () {
                this.currentPage--;
                this.loadPage();
            };
            PaginationController.prototype.onBtFirst = function () {
                this.currentPage = 0;
                this.loadPage();
            };
            PaginationController.prototype.onBtLast = function () {
                this.currentPage = this.totalPages - 1;
                this.loadPage();
            };
            PaginationController.prototype.isZeroPagesToDisplay = function () {
                return this.foundMaxRow && this.totalPages === 0;
            };
            PaginationController.prototype.enableOrDisableButtons = function () {
                var disablePreviousAndFirst = this.currentPage === 0;
                this.btPrevious.disabled = disablePreviousAndFirst;
                this.btFirst.disabled = disablePreviousAndFirst;
                var zeroPagesToDisplay = this.isZeroPagesToDisplay();
                var onLastPage = this.foundMaxRow && this.currentPage === this.totalPages - 1;
                var disableNext = onLastPage || zeroPagesToDisplay;
                this.btNext.disabled = disableNext;
                var disableLast = !this.foundMaxRow || zeroPagesToDisplay || this.currentPage === this.totalPages - 1;
                this.btLast.disabled = disableLast;
            };
            PaginationController.prototype.createTemplate = function () {
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                return template.replace('[PAGE]', localeTextFunc('page', 'Page')).replace('[TO]', localeTextFunc('to', 'to')).replace('[OF]', localeTextFunc('of', 'of')).replace('[OF]', localeTextFunc('of', 'of')).replace('[FIRST]', localeTextFunc('first', 'First')).replace('[PREVIOUS]', localeTextFunc('previous', 'Previous')).replace('[NEXT]', localeTextFunc('next', 'Next')).replace('[LAST]', localeTextFunc('last', 'Last'));
            };
            PaginationController.prototype.getGui = function () {
                return this.eGui;
            };
            PaginationController.prototype.setupComponents = function () {
                this.eGui = utils_1.Utils.loadTemplate(this.createTemplate());
                this.btNext = this.eGui.querySelector('#btNext');
                this.btPrevious = this.eGui.querySelector('#btPrevious');
                this.btFirst = this.eGui.querySelector('#btFirst');
                this.btLast = this.eGui.querySelector('#btLast');
                this.lbCurrent = this.eGui.querySelector('#current');
                this.lbTotal = this.eGui.querySelector('#total');
                this.lbRecordCount = this.eGui.querySelector('#recordCount');
                this.lbFirstRowOnPage = this.eGui.querySelector('#firstRowOnPage');
                this.lbLastRowOnPage = this.eGui.querySelector('#lastRowOnPage');
                this.ePageRowSummaryPanel = this.eGui.querySelector('#pageRowSummaryPanel');
                var that = this;
                this.btNext.addEventListener('click', function () {
                    that.onBtNext();
                });
                this.btPrevious.addEventListener('click', function () {
                    that.onBtPrevious();
                });
                this.btFirst.addEventListener('click', function () {
                    that.onBtFirst();
                });
                this.btLast.addEventListener('click', function () {
                    that.onBtLast();
                });
            };
            __decorate([context_1.Autowired('filterManager'), __metadata('design:type', filterManager_1.FilterManager)], PaginationController.prototype, "filterManager", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], PaginationController.prototype, "gridPanel", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], PaginationController.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('selectionController'), __metadata('design:type', selectionController_1.SelectionController)], PaginationController.prototype, "selectionController", void 0);
            __decorate([context_1.Autowired('sortController'), __metadata('design:type', sortController_1.SortController)], PaginationController.prototype, "sortController", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], PaginationController.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('rowModel'), __metadata('design:type', Object)], PaginationController.prototype, "rowModel", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], PaginationController.prototype, "init", null);
            PaginationController = __decorate([context_1.Bean('paginationController'), __metadata('design:paramtypes', [])], PaginationController);
            return PaginationController;
        }();
        exports.PaginationController = PaginationController;

        /***/ },
    /* 280 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var column_1 = __webpack_require__(253);
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnController_1 = __webpack_require__(251);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var context_2 = __webpack_require__(244);
        var utils_1 = __webpack_require__(245);
        var SortController = function () {
            function SortController() {}
            SortController.prototype.progressSort = function (column, multiSort) {
                // update sort on current col
                column.setSort(this.getNextSortDirection(column));
                // sortedAt used for knowing order of cols when multi-col sort
                if (column.getSort()) {
                    column.setSortedAt(new Date().valueOf());
                } else {
                    column.setSortedAt(null);
                }
                var doingMultiSort = multiSort && !this.gridOptionsWrapper.isSuppressMultiSort();
                // clear sort on all columns except this one, and update the icons
                if (!doingMultiSort) {
                    this.clearSortBarThisColumn(column);
                }
                this.dispatchSortChangedEvents();
            };
            SortController.prototype.dispatchSortChangedEvents = function () {
                this.eventService.dispatchEvent(events_1.Events.EVENT_BEFORE_SORT_CHANGED);
                this.eventService.dispatchEvent(events_1.Events.EVENT_SORT_CHANGED);
                this.eventService.dispatchEvent(events_1.Events.EVENT_AFTER_SORT_CHANGED);
            };
            SortController.prototype.clearSortBarThisColumn = function (columnToSkip) {
                this.columnController.getPrimaryAndSecondaryAndAutoColumns().forEach(function (columnToClear) {
                    // Do not clear if either holding shift, or if column in question was clicked
                    if (!(columnToClear === columnToSkip)) {
                        columnToClear.setSort(null);
                    }
                });
            };
            SortController.prototype.getNextSortDirection = function (column) {
                var sortingOrder;
                if (column.getColDef().sortingOrder) {
                    sortingOrder = column.getColDef().sortingOrder;
                } else if (this.gridOptionsWrapper.getSortingOrder()) {
                    sortingOrder = this.gridOptionsWrapper.getSortingOrder();
                } else {
                    sortingOrder = SortController.DEFAULT_SORTING_ORDER;
                }
                if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
                    console.warn('ag-grid: sortingOrder must be an array with at least one element, currently it\'s ' + sortingOrder);
                    return;
                }
                var currentIndex = sortingOrder.indexOf(column.getSort());
                var notInArray = currentIndex < 0;
                var lastItemInArray = currentIndex == sortingOrder.length - 1;
                var result;
                if (notInArray || lastItemInArray) {
                    result = sortingOrder[0];
                } else {
                    result = sortingOrder[currentIndex + 1];
                }
                // verify the sort type exists, as the user could provide the sortOrder, need to make sure it's valid
                if (SortController.DEFAULT_SORTING_ORDER.indexOf(result) < 0) {
                    console.warn('ag-grid: invalid sort type ' + result);
                    return null;
                }
                return result;
            };
            // used by the public api, for saving the sort model
            SortController.prototype.getSortModel = function () {
                var columnsWithSorting = this.getColumnsWithSortingOrdered();
                return utils_1.Utils.map(columnsWithSorting, function (column) {
                    return {
                        colId: column.getColId(),
                        sort: column.getSort()
                    };
                });
            };
            SortController.prototype.setSortModel = function (sortModel) {
                if (!this.gridOptionsWrapper.isEnableSorting()) {
                    console.warn('ag-grid: You are setting the sort model on a grid that does not have sorting enabled');
                    return;
                }
                // first up, clear any previous sort
                var sortModelProvided = sortModel && sortModel.length > 0;
                var allColumnsIncludingAuto = this.columnController.getPrimaryAndSecondaryAndAutoColumns();
                allColumnsIncludingAuto.forEach(function (column) {
                    var sortForCol = null;
                    var sortedAt = -1;
                    if (sortModelProvided && !column.getColDef().suppressSorting) {
                        for (var j = 0; j < sortModel.length; j++) {
                            var sortModelEntry = sortModel[j];
                            if (typeof sortModelEntry.colId === 'string' && typeof column.getColId() === 'string' && sortModelEntry.colId === column.getColId()) {
                                sortForCol = sortModelEntry.sort;
                                sortedAt = j;
                            }
                        }
                    }
                    if (sortForCol) {
                        column.setSort(sortForCol);
                        column.setSortedAt(sortedAt);
                    } else {
                        column.setSort(null);
                        column.setSortedAt(null);
                    }
                });
                this.dispatchSortChangedEvents();
            };
            SortController.prototype.getColumnsWithSortingOrdered = function () {
                // pull out all the columns that have sorting set
                var allColumnsIncludingAuto = this.columnController.getPrimaryAndSecondaryAndAutoColumns();
                var columnsWithSorting = utils_1.Utils.filter(allColumnsIncludingAuto, function (column) {
                    return !!column.getSort();
                });
                // put the columns in order of which one got sorted first
                columnsWithSorting.sort(function (a, b) {
                    return a.sortedAt - b.sortedAt;
                });
                return columnsWithSorting;
            };
            // used by row controller, when doing the sorting
            SortController.prototype.getSortForRowController = function () {
                var columnsWithSorting = this.getColumnsWithSortingOrdered();
                return utils_1.Utils.map(columnsWithSorting, function (column) {
                    var ascending = column.getSort() === column_1.Column.SORT_ASC;
                    return {
                        inverter: ascending ? 1 : -1,
                        column: column
                    };
                });
            };
            SortController.DEFAULT_SORTING_ORDER = [column_1.Column.SORT_ASC, column_1.Column.SORT_DESC, null];
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], SortController.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], SortController.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], SortController.prototype, "eventService", void 0);
            SortController = __decorate([context_2.Bean('sortController'), __metadata('design:paramtypes', [])], SortController);
            return SortController;
        }();
        exports.SortController = SortController;

        /***/ },
    /* 281 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var popupService_1 = __webpack_require__(282);
        var valueService_1 = __webpack_require__(267);
        var columnController_1 = __webpack_require__(251);
        var textFilter_1 = __webpack_require__(283);
        var numberFilter_1 = __webpack_require__(284);
        var context_1 = __webpack_require__(244);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var FilterManager = function () {
            function FilterManager() {
                this.allFilters = {};
                this.quickFilter = null;
                this.availableFilters = {
                    'text': textFilter_1.TextFilter,
                    'number': numberFilter_1.NumberFilter
                };
            }
            FilterManager.prototype.init = function () {
                this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.onNewRowsLoaded.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));
                this.quickFilter = this.parseQuickFilter(this.gridOptionsWrapper.getQuickFilterText());
                // check this here, in case there is a filter from the start
                this.checkExternalFilter();
            };
            FilterManager.prototype.registerFilter = function (key, Filter) {
                this.availableFilters[key] = Filter;
            };
            FilterManager.prototype.setFilterModel = function (model) {
                var _this = this;
                if (model) {
                    // mark the filters as we set them, so any active filters left over we stop
                    var modelKeys = Object.keys(model);
                    utils_1.Utils.iterateObject(this.allFilters, function (colId, filterWrapper) {
                        utils_1.Utils.removeFromArray(modelKeys, colId);
                        var newModel = model[colId];
                        _this.setModelOnFilterWrapper(filterWrapper.filter, newModel);
                        _this.setModelOnFilterWrapper(filterWrapper.filter, newModel);
                    });
                    // at this point, processedFields contains data for which we don't have a filter working yet
                    utils_1.Utils.iterateArray(modelKeys, function (colId) {
                        var column = _this.columnController.getPrimaryColumn(colId);
                        if (!column) {
                            console.warn('Warning ag-grid setFilterModel - no column found for colId ' + colId);
                            return;
                        }
                        var filterWrapper = _this.getOrCreateFilterWrapper(column);
                        _this.setModelOnFilterWrapper(filterWrapper.filter, model[colId]);
                    });
                } else {
                    utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
                        _this.setModelOnFilterWrapper(filterWrapper.filter, null);
                    });
                }
                this.onFilterChanged();
            };
            FilterManager.prototype.setModelOnFilterWrapper = function (filter, newModel) {
                if (typeof filter.setModel !== 'function') {
                    console.warn('Warning ag-grid - filter missing setModel method, which is needed for setFilterModel');
                    return;
                }
                filter.setModel(newModel);
            };
            FilterManager.prototype.getFilterModel = function () {
                var result = {};
                utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
                    // because user can provide filters, we provide useful error checking and messages
                    var filter = filterWrapper.filter;
                    if (typeof filter.getModel !== 'function') {
                        console.warn('Warning ag-grid - filter API missing getModel method, which is needed for getFilterModel');
                        return;
                    }
                    var model = filter.getModel();
                    if (utils_1.Utils.exists(model)) {
                        result[key] = model;
                    }
                });
                return result;
            };
            // returns true if any advanced filter (ie not quick filter) active
            FilterManager.prototype.isAdvancedFilterPresent = function () {
                var atLeastOneActive = false;
                utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
                    if (!filterWrapper.filter.isFilterActive) {
                        console.error('Filter is missing method isFilterActive');
                    }
                    if (filterWrapper.filter.isFilterActive()) {
                        atLeastOneActive = true;
                        filterWrapper.column.setFilterActive(true);
                    } else {
                        filterWrapper.column.setFilterActive(false);
                    }
                });
                return atLeastOneActive;
            };
            // returns true if quickFilter or advancedFilter
            FilterManager.prototype.isAnyFilterPresent = function () {
                return this.isQuickFilterPresent() || this.advancedFilterPresent || this.externalFilterPresent;
            };
            FilterManager.prototype.doesFilterPass = function (node, filterToSkip) {
                var data = node.data;
                var colKeys = Object.keys(this.allFilters);
                for (var i = 0, l = colKeys.length; i < l; i++) {
                    var colId = colKeys[i];
                    var filterWrapper = this.allFilters[colId];
                    // if no filter, always pass
                    if (filterWrapper === undefined) {
                        continue;
                    }
                    if (filterWrapper.filter === filterToSkip) {
                        continue;
                    }
                    // don't bother with filters that are not active
                    if (!filterWrapper.filter.isFilterActive()) {
                        continue;
                    }
                    if (!filterWrapper.filter.doesFilterPass) {
                        console.error('Filter is missing method doesFilterPass');
                    }
                    var params = {
                        node: node,
                        data: data
                    };
                    if (!filterWrapper.filter.doesFilterPass(params)) {
                        return false;
                    }
                }
                // all filters passed
                return true;
            };
            FilterManager.prototype.parseQuickFilter = function (newFilter) {
                if (utils_1.Utils.missing(newFilter) || newFilter === "") {
                    return null;
                }
                if (this.gridOptionsWrapper.isRowModelVirtual()) {
                    console.warn('ag-grid: cannot do quick filtering when doing virtual paging');
                    return null;
                }
                return newFilter.toUpperCase();
            };
            // returns true if it has changed (not just same value again)
            FilterManager.prototype.setQuickFilter = function (newFilter) {
                var parsedFilter = this.parseQuickFilter(newFilter);
                if (this.quickFilter !== parsedFilter) {
                    this.quickFilter = parsedFilter;
                    this.onFilterChanged();
                }
            };
            FilterManager.prototype.checkExternalFilter = function () {
                this.externalFilterPresent = this.gridOptionsWrapper.isExternalFilterPresent();
            };
            FilterManager.prototype.onFilterChanged = function () {
                this.eventService.dispatchEvent(events_1.Events.EVENT_BEFORE_FILTER_CHANGED);
                this.advancedFilterPresent = this.isAdvancedFilterPresent();
                this.checkExternalFilter();
                utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
                    if (filterWrapper.filter.onAnyFilterChanged) {
                        filterWrapper.filter.onAnyFilterChanged();
                    }
                });
                this.eventService.dispatchEvent(events_1.Events.EVENT_FILTER_CHANGED);
                this.eventService.dispatchEvent(events_1.Events.EVENT_AFTER_FILTER_CHANGED);
            };
            FilterManager.prototype.isQuickFilterPresent = function () {
                return this.quickFilter !== null;
            };
            FilterManager.prototype.doesRowPassOtherFilters = function (filterToSkip, node) {
                return this.doesRowPassFilter(node, filterToSkip);
            };
            FilterManager.prototype.doesRowPassFilter = function (node, filterToSkip) {
                //first up, check quick filter
                if (this.isQuickFilterPresent()) {
                    if (!node.quickFilterAggregateText) {
                        this.aggregateRowForQuickFilter(node);
                    }
                    if (node.quickFilterAggregateText.indexOf(this.quickFilter) < 0) {
                        //quick filter fails, so skip item
                        return false;
                    }
                }
                //secondly, give the client a chance to reject this row
                if (this.externalFilterPresent) {
                    if (!this.gridOptionsWrapper.doesExternalFilterPass(node)) {
                        return false;
                    }
                }
                //lastly, check our internal advanced filter
                if (this.advancedFilterPresent) {
                    if (!this.doesFilterPass(node, filterToSkip)) {
                        return false;
                    }
                }
                //got this far, all filters pass
                return true;
            };
            FilterManager.prototype.aggregateRowForQuickFilter = function (node) {
                var aggregatedText = '';
                var that = this;
                this.columnController.getAllPrimaryColumns().forEach(function (column) {
                    var value = that.valueService.getValue(column, node);
                    if (value && value !== '') {
                        aggregatedText = aggregatedText + value.toString().toUpperCase() + "_";
                    }
                });
                node.quickFilterAggregateText = aggregatedText;
            };
            FilterManager.prototype.onNewRowsLoaded = function () {
                var that = this;
                Object.keys(this.allFilters).forEach(function (field) {
                    var filter = that.allFilters[field].filter;
                    if (filter.onNewRowsLoaded) {
                        filter.onNewRowsLoaded();
                    }
                });
            };
            FilterManager.prototype.createValueGetter = function (column) {
                var that = this;
                return function valueGetter(node) {
                    return that.valueService.getValue(column, node);
                };
            };
            FilterManager.prototype.getFilterComponent = function (column) {
                var filterWrapper = this.getOrCreateFilterWrapper(column);
                return filterWrapper.filter;
            };
            FilterManager.prototype.getOrCreateFilterWrapper = function (column) {
                var filterWrapper = this.allFilters[column.getColId()];
                if (!filterWrapper) {
                    filterWrapper = this.createFilterWrapper(column);
                    this.allFilters[column.getColId()] = filterWrapper;
                }
                return filterWrapper;
            };
            FilterManager.prototype.createFilterInstance = function (column) {
                var filter = column.getFilter();
                var filterIsComponent = typeof filter === 'function';
                var filterIsName = utils_1.Utils.missing(filter) || typeof filter === 'string';
                var FilterClass;
                if (filterIsComponent) {
                    // if user provided a filter, just use it
                    FilterClass = filter;
                    // now create filter (had to cast to any to get 'new' working)
                    this.assertMethodHasNoParameters(FilterClass);
                } else if (filterIsName) {
                    var filterName = filter;
                    FilterClass = this.getFilterFromCache(filterName);
                } else {
                    console.error('ag-Grid: colDef.filter should be function or a string');
                    return null;
                }
                var filterInstance = new FilterClass();
                this.context.wireBean(filterInstance);
                // help the user, check the mandatory methods exist
                ['getGui', 'isFilterActive', 'doesFilterPass', 'getModel', 'setModel'].forEach(function (methodName) {
                    var methodIsMissing = !filterInstance[methodName];
                    if (methodIsMissing) {
                        throw "Filter for column " + column.getColId() + " is missing method " + methodName;
                    }
                });
                return filterInstance;
            };
            FilterManager.prototype.createParams = function (filterWrapper) {
                var _this = this;
                var filterChangedCallback = this.onFilterChanged.bind(this);
                var filterModifiedCallback = function filterModifiedCallback() {
                    return _this.eventService.dispatchEvent(events_1.Events.EVENT_FILTER_MODIFIED);
                };
                var doesRowPassOtherFilters = this.doesRowPassOtherFilters.bind(this, filterWrapper.filter);
                var colDef = filterWrapper.column.getColDef();
                var params = {
                    column: filterWrapper.column,
                    colDef: colDef,
                    rowModel: this.rowModel,
                    filterChangedCallback: filterChangedCallback,
                    filterModifiedCallback: filterModifiedCallback,
                    valueGetter: this.createValueGetter(filterWrapper.column),
                    doesRowPassOtherFilter: doesRowPassOtherFilters,
                    context: this.gridOptionsWrapper.getContext(),
                    $scope: filterWrapper.scope
                };
                if (colDef.filterParams) {
                    utils_1.Utils.assign(params, colDef.filterParams);
                }
                return params;
            };
            FilterManager.prototype.createFilterWrapper = function (column) {
                var filterWrapper = {
                    column: column,
                    filter: null,
                    scope: null,
                    gui: null
                };
                filterWrapper.filter = this.createFilterInstance(column);
                this.initialiseFilterAndPutIntoGui(filterWrapper);
                return filterWrapper;
            };
            FilterManager.prototype.initialiseFilterAndPutIntoGui = function (filterWrapper) {
                // first up, create child scope if needed
                if (this.gridOptionsWrapper.isAngularCompileFilters()) {
                    filterWrapper.scope = this.$scope.$new();
                    filterWrapper.scope.context = this.gridOptionsWrapper.getContext();
                }
                var params = this.createParams(filterWrapper);
                filterWrapper.filter.init(params);
                var eFilterGui = document.createElement('div');
                eFilterGui.className = 'ag-filter';
                var guiFromFilter = filterWrapper.filter.getGui();
                if (utils_1.Utils.isNodeOrElement(guiFromFilter)) {
                    //a dom node or element was returned, so add child
                    eFilterGui.appendChild(guiFromFilter);
                } else {
                    //otherwise assume it was html, so just insert
                    var eTextSpan = document.createElement('span');
                    eTextSpan.innerHTML = guiFromFilter;
                    eFilterGui.appendChild(eTextSpan);
                }
                if (filterWrapper.scope) {
                    filterWrapper.gui = this.$compile(eFilterGui)(filterWrapper.scope)[0];
                } else {
                    filterWrapper.gui = eFilterGui;
                }
            };
            FilterManager.prototype.getFilterFromCache = function (filterType) {
                var defaultFilterType = this.enterprise ? 'set' : 'text';
                var defaultFilter = this.availableFilters[defaultFilterType];
                if (utils_1.Utils.missing(filterType)) {
                    return defaultFilter;
                }
                if (!this.enterprise && filterType === 'set') {
                    console.warn('ag-Grid: Set filter is only available in Enterprise ag-Grid');
                    filterType = 'text';
                }
                if (this.availableFilters[filterType]) {
                    return this.availableFilters[filterType];
                } else {
                    console.error('ag-Grid: Could not find filter type ' + filterType);
                    return this.availableFilters[defaultFilter];
                }
            };
            FilterManager.prototype.onNewColumnsLoaded = function () {
                this.destroy();
            };
            // destroys the filter, so it not longer takes part
            FilterManager.prototype.destroyFilter = function (column) {
                var filterWrapper = this.allFilters[column.getColId()];
                if (filterWrapper) {
                    this.disposeFilterWrapper(filterWrapper);
                    this.onFilterChanged();
                }
            };
            FilterManager.prototype.disposeFilterWrapper = function (filterWrapper) {
                if (filterWrapper.filter.destroy) {
                    filterWrapper.filter.destroy();
                }
                filterWrapper.column.setFilterActive(false);
                delete this.allFilters[filterWrapper.column.getColId()];
            };
            FilterManager.prototype.destroy = function () {
                var _this = this;
                utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
                    _this.disposeFilterWrapper(filterWrapper);
                });
            };
            FilterManager.prototype.assertMethodHasNoParameters = function (theMethod) {
                var getRowsParams = utils_1.Utils.getFunctionParameters(theMethod);
                if (getRowsParams.length > 0) {
                    console.warn('ag-grid: It looks like your filter is of the old type and expecting parameters in the constructor.');
                    console.warn('ag-grid: From ag-grid 1.14, the constructor should take no parameters and init() used instead.');
                }
            };
            __decorate([context_1.Autowired('$compile'), __metadata('design:type', Object)], FilterManager.prototype, "$compile", void 0);
            __decorate([context_1.Autowired('$scope'), __metadata('design:type', Object)], FilterManager.prototype, "$scope", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], FilterManager.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('gridCore'), __metadata('design:type', Object)], FilterManager.prototype, "gridCore", void 0);
            __decorate([context_1.Autowired('popupService'), __metadata('design:type', popupService_1.PopupService)], FilterManager.prototype, "popupService", void 0);
            __decorate([context_1.Autowired('valueService'), __metadata('design:type', valueService_1.ValueService)], FilterManager.prototype, "valueService", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], FilterManager.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('rowModel'), __metadata('design:type', Object)], FilterManager.prototype, "rowModel", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], FilterManager.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('enterprise'), __metadata('design:type', Boolean)], FilterManager.prototype, "enterprise", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], FilterManager.prototype, "context", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], FilterManager.prototype, "init", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], FilterManager.prototype, "destroy", null);
            FilterManager = __decorate([context_1.Bean('filterManager'), __metadata('design:paramtypes', [])], FilterManager);
            return FilterManager;
        }();
        exports.FilterManager = FilterManager;

        /***/ },
    /* 282 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var constants_1 = __webpack_require__(246);
        var context_1 = __webpack_require__(244);
        var gridCore_1 = __webpack_require__(278);
        var PopupService = function () {
            function PopupService() {}
            // this.popupService.setPopupParent(this.eRootPanel.getGui());
            PopupService.prototype.getPopupParent = function () {
                return this.gridCore.getRootGui();
            };
            PopupService.prototype.positionPopupForMenu = function (params) {
                var sourceRect = params.eventSource.getBoundingClientRect();
                var parentRect = this.getPopupParent().getBoundingClientRect();
                var x = sourceRect.right - parentRect.left - 2;
                var y = sourceRect.top - parentRect.top;
                var minWidth;
                if (params.ePopup.clientWidth > 0) {
                    minWidth = params.ePopup.clientWidth;
                } else {
                    minWidth = 200;
                }
                var widthOfParent = parentRect.right - parentRect.left;
                var maxX = widthOfParent - minWidth;
                if (x > maxX) {
                    // try putting menu to the left
                    x = sourceRect.left - parentRect.left - minWidth;
                }
                if (x < 0) {
                    x = 0;
                }
                params.ePopup.style.left = x + "px";
                params.ePopup.style.top = y + "px";
            };
            PopupService.prototype.positionPopupUnderMouseEvent = function (params) {
                var parentRect = this.getPopupParent().getBoundingClientRect();
                this.positionPopup({
                    ePopup: params.ePopup,
                    x: params.mouseEvent.clientX - parentRect.left,
                    y: params.mouseEvent.clientY - parentRect.top,
                    keepWithinBounds: true
                });
            };
            PopupService.prototype.positionPopupUnderComponent = function (params) {
                var sourceRect = params.eventSource.getBoundingClientRect();
                var parentRect = this.getPopupParent().getBoundingClientRect();
                this.positionPopup({
                    ePopup: params.ePopup,
                    minWidth: params.minWidth,
                    nudgeX: params.nudgeX,
                    nudgeY: params.nudgeY,
                    x: sourceRect.left - parentRect.left,
                    y: sourceRect.top - parentRect.top + sourceRect.height,
                    keepWithinBounds: params.keepWithinBounds
                });
            };
            PopupService.prototype.positionPopupOverComponent = function (params) {
                var sourceRect = params.eventSource.getBoundingClientRect();
                var parentRect = this.getPopupParent().getBoundingClientRect();
                this.positionPopup({
                    ePopup: params.ePopup,
                    minWidth: params.minWidth,
                    nudgeX: params.nudgeX,
                    nudgeY: params.nudgeY,
                    x: sourceRect.left - parentRect.left,
                    y: sourceRect.top - parentRect.top,
                    keepWithinBounds: params.keepWithinBounds
                });
            };
            PopupService.prototype.positionPopup = function (params) {
                var parentRect = this.getPopupParent().getBoundingClientRect();
                var x = params.x;
                var y = params.y;
                if (params.nudgeX) {
                    x += params.nudgeX;
                }
                if (params.nudgeY) {
                    y += params.nudgeY;
                }
                // if popup is overflowing to the bottom, move it up
                if (params.keepWithinBounds) {
                    checkHorizontalOverflow();
                    checkVerticalOverflow();
                }
                params.ePopup.style.left = x + "px";
                params.ePopup.style.top = y + "px";
                function checkHorizontalOverflow() {
                    var minWidth;
                    if (params.minWidth > 0) {
                        minWidth = params.minWidth;
                    } else if (params.ePopup.clientWidth > 0) {
                        minWidth = params.ePopup.clientWidth;
                    } else {
                        minWidth = 200;
                    }
                    var widthOfParent = parentRect.right - parentRect.left;
                    var maxX = widthOfParent - minWidth - 5;
                    if (x > maxX) {
                        x = maxX;
                    }
                    if (x < 0) {
                        x = 0;
                    }
                }
                function checkVerticalOverflow() {
                    var minHeight;
                    if (params.ePopup.clientWidth > 0) {
                        minHeight = params.ePopup.clientHeight;
                    } else {
                        minHeight = 200;
                    }
                    var heightOfParent = parentRect.bottom - parentRect.top;
                    var maxY = heightOfParent - minHeight - 5;
                    if (y > maxY) {
                        y = maxY;
                    }
                    if (y < 0) {
                        y = 0;
                    }
                }
            };
            //adds an element to a div, but also listens to background checking for clicks,
            //so that when the background is clicked, the child is removed again, giving
            //a model look to popups.
            PopupService.prototype.addAsModalPopup = function (eChild, closeOnEsc, closedCallback) {
                var eBody = document.body;
                if (!eBody) {
                    console.warn('ag-grid: could not find the body of the document, document.body is empty');
                    return;
                }
                eChild.style.top = '0px';
                eChild.style.left = '0px';
                var popupAlreadyShown = utils_1.Utils.isVisible(eChild);
                if (popupAlreadyShown) {
                    return;
                }
                this.getPopupParent().appendChild(eChild);
                var that = this;
                var popupHidden = false;
                // if we add these listeners now, then the current mouse
                // click will be included, which we don't want
                setTimeout(function () {
                    if (closeOnEsc) {
                        eBody.addEventListener('keydown', hidePopupOnEsc);
                    }
                    eBody.addEventListener('click', hidePopup);
                    eBody.addEventListener('contextmenu', hidePopup);
                    //eBody.addEventListener('mousedown', hidePopup);
                    eChild.addEventListener('click', consumeClick);
                    //eChild.addEventListener('mousedown', consumeClick);
                }, 0);
                var eventFromChild = null;
                function hidePopupOnEsc(event) {
                    var key = event.which || event.keyCode;
                    if (key === constants_1.Constants.KEY_ESCAPE) {
                        hidePopup(null);
                    }
                }
                function hidePopup(event) {
                    if (event && event === eventFromChild) {
                        return;
                    }
                    // this method should only be called once. the client can have different
                    // paths, each one wanting to close, so this method may be called multiple
                    // times.
                    if (popupHidden) {
                        return;
                    }
                    popupHidden = true;
                    that.getPopupParent().removeChild(eChild);
                    eBody.removeEventListener('keydown', hidePopupOnEsc);
                    //eBody.removeEventListener('mousedown', hidePopupOnEsc);
                    eBody.removeEventListener('click', hidePopup);
                    eBody.removeEventListener('contextmenu', hidePopup);
                    eChild.removeEventListener('click', consumeClick);
                    //eChild.removeEventListener('mousedown', consumeClick);
                    if (closedCallback) {
                        closedCallback();
                    }
                }
                function consumeClick(event) {
                    eventFromChild = event;
                }
                return hidePopup;
            };
            __decorate([context_1.Autowired('gridCore'), __metadata('design:type', gridCore_1.GridCore)], PopupService.prototype, "gridCore", void 0);
            PopupService = __decorate([context_1.Bean('popupService'), __metadata('design:paramtypes', [])], PopupService);
            return PopupService;
        }();
        exports.PopupService = PopupService;

        /***/ },
    /* 283 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var TextFilter = function () {
            function TextFilter() {}
            TextFilter.prototype.init = function (params) {
                this.filterParams = params;
                this.applyActive = params.apply === true;
                this.newRowsActionKeep = params.newRowsAction === 'keep';
                this.filterText = null;
                this.filterType = TextFilter.CONTAINS;
                this.createGui();
            };
            TextFilter.prototype.onNewRowsLoaded = function () {
                if (!this.newRowsActionKeep) {
                    this.setType(TextFilter.CONTAINS);
                    this.setFilter(null);
                }
            };
            TextFilter.prototype.afterGuiAttached = function () {
                this.eFilterTextField.focus();
            };
            TextFilter.prototype.doesFilterPass = function (params) {
                if (!this.filterText) {
                    return true;
                }
                var value = this.filterParams.valueGetter(params.node);
                if (!value) {
                    return false;
                }
                var valueLowerCase = value.toString().toLowerCase();
                switch (this.filterType) {
                    case TextFilter.CONTAINS:
                        return valueLowerCase.indexOf(this.filterText) >= 0;
                    case TextFilter.EQUALS:
                        return valueLowerCase === this.filterText;
                    case TextFilter.NOT_EQUALS:
                        return valueLowerCase != this.filterText;
                    case TextFilter.STARTS_WITH:
                        return valueLowerCase.indexOf(this.filterText) === 0;
                    case TextFilter.ENDS_WITH:
                        var index = valueLowerCase.lastIndexOf(this.filterText);
                        return index >= 0 && index === valueLowerCase.length - this.filterText.length;
                    default:
                        // should never happen
                        console.warn('invalid filter type ' + this.filterType);
                        return false;
                }
            };
            TextFilter.prototype.getGui = function () {
                return this.eGui;
            };
            TextFilter.prototype.isFilterActive = function () {
                return this.filterText !== null;
            };
            TextFilter.prototype.createTemplate = function () {
                var translate = this.gridOptionsWrapper.getLocaleTextFunc();
                return "<div>\n                    <div>\n                        <select class=\"ag-filter-select\" id=\"filterType\">\n                        <option value=\"" + TextFilter.CONTAINS + "\">" + translate('contains', 'Contains') + "</option>\n                        <option value=\"" + TextFilter.EQUALS + "\">" + translate('equals', 'Equals') + "</option>\n                        <option value=\"" + TextFilter.NOT_EQUALS + "\">" + translate('notEquals', 'Not equals') + "</option>\n                        <option value=\"" + TextFilter.STARTS_WITH + "\">" + translate('startsWith', 'Starts with') + "</option>\n                        <option value=\"" + TextFilter.ENDS_WITH + "\">" + translate('endsWith', 'Ends with') + "</option>\n                        </select>\n                    </div>\n                    <div>\n                        <input class=\"ag-filter-filter\" id=\"filterText\" type=\"text\" placeholder=\"" + translate('filterOoo', 'Filter...') + "\"/>\n                    </div>\n                    <div class=\"ag-filter-apply-panel\" id=\"applyPanel\">\n                        <button type=\"button\" id=\"applyButton\">" + translate('applyFilter', 'Apply Filter') + "</button>\n                    </div>\n                </div>";
            };
            TextFilter.prototype.createGui = function () {
                this.eGui = utils_1.Utils.loadTemplate(this.createTemplate());
                this.eFilterTextField = this.eGui.querySelector("#filterText");
                this.eTypeSelect = this.eGui.querySelector("#filterType");
                utils_1.Utils.addChangeListener(this.eFilterTextField, this.onFilterChanged.bind(this));
                this.eTypeSelect.addEventListener("change", this.onTypeChanged.bind(this));
                this.setupApply();
            };
            TextFilter.prototype.setupApply = function () {
                var _this = this;
                if (this.applyActive) {
                    this.eApplyButton = this.eGui.querySelector('#applyButton');
                    this.eApplyButton.addEventListener('click', function () {
                        _this.filterParams.filterChangedCallback();
                    });
                } else {
                    utils_1.Utils.removeElement(this.eGui, '#applyPanel');
                }
            };
            TextFilter.prototype.onTypeChanged = function () {
                this.filterType = this.eTypeSelect.value;
                this.filterChanged();
            };
            TextFilter.prototype.onFilterChanged = function () {
                var filterText = utils_1.Utils.makeNull(this.eFilterTextField.value);
                if (filterText && filterText.trim() === '') {
                    filterText = null;
                }
                var newFilterText;
                if (filterText !== null && filterText !== undefined) {
                    newFilterText = filterText.toLowerCase();
                } else {
                    newFilterText = null;
                }
                if (this.filterText !== newFilterText) {
                    this.filterText = newFilterText;
                    this.filterChanged();
                }
            };
            TextFilter.prototype.filterChanged = function () {
                this.filterParams.filterModifiedCallback();
                if (!this.applyActive) {
                    this.filterParams.filterChangedCallback();
                }
            };
            TextFilter.prototype.setType = function (type) {
                this.filterType = type;
                this.eTypeSelect.value = type;
            };
            TextFilter.prototype.setFilter = function (filter) {
                filter = utils_1.Utils.makeNull(filter);
                if (filter) {
                    this.filterText = filter.toLowerCase();
                    this.eFilterTextField.value = filter;
                } else {
                    this.filterText = null;
                    this.eFilterTextField.value = null;
                }
            };
            TextFilter.prototype.getType = function () {
                return this.filterType;
            };
            TextFilter.prototype.getFilter = function () {
                return this.filterText;
            };
            TextFilter.prototype.getModel = function () {
                if (this.isFilterActive()) {
                    return {
                        type: this.filterType,
                        filter: this.filterText
                    };
                } else {
                    return null;
                }
            };
            TextFilter.prototype.setModel = function (model) {
                if (model) {
                    this.setType(model.type);
                    this.setFilter(model.filter);
                } else {
                    this.setFilter(null);
                }
            };
            TextFilter.CONTAINS = 'contains'; //1;
            TextFilter.EQUALS = 'equals'; //2;
            TextFilter.NOT_EQUALS = 'notEquals'; //3;
            TextFilter.STARTS_WITH = 'startsWith'; //4;
            TextFilter.ENDS_WITH = 'endsWith'; //5;
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], TextFilter.prototype, "gridOptionsWrapper", void 0);
            return TextFilter;
        }();
        exports.TextFilter = TextFilter;

        /***/ },
    /* 284 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var NumberFilter = function () {
            function NumberFilter() {}
            NumberFilter.prototype.init = function (params) {
                this.filterParams = params;
                this.applyActive = params.apply === true;
                this.newRowsActionKeep = params.newRowsAction === 'keep';
                this.filterNumber = null;
                this.filterType = NumberFilter.EQUALS;
                this.createGui();
            };
            NumberFilter.prototype.onNewRowsLoaded = function () {
                if (!this.newRowsActionKeep) {
                    this.setType(NumberFilter.EQUALS);
                    this.setFilter(null);
                }
            };
            NumberFilter.prototype.afterGuiAttached = function () {
                this.eFilterTextField.focus();
            };
            NumberFilter.prototype.doesFilterPass = function (params) {
                if (this.filterNumber === null) {
                    return true;
                }
                var value = this.filterParams.valueGetter(params.node);
                if (!value && value !== 0) {
                    return false;
                }
                var valueAsNumber;
                if (typeof value === 'number') {
                    valueAsNumber = value;
                } else {
                    valueAsNumber = parseFloat(value);
                }
                switch (this.filterType) {
                    case NumberFilter.EQUALS:
                        return valueAsNumber === this.filterNumber;
                    case NumberFilter.LESS_THAN:
                        return valueAsNumber < this.filterNumber;
                    case NumberFilter.GREATER_THAN:
                        return valueAsNumber > this.filterNumber;
                    case NumberFilter.LESS_THAN_OR_EQUAL:
                        return valueAsNumber <= this.filterNumber;
                    case NumberFilter.GREATER_THAN_OR_EQUAL:
                        return valueAsNumber >= this.filterNumber;
                    case NumberFilter.NOT_EQUAL:
                        return valueAsNumber != this.filterNumber;
                    default:
                        // should never happen
                        console.warn('invalid filter type ' + this.filterType);
                        return false;
                }
            };
            NumberFilter.prototype.getGui = function () {
                return this.eGui;
            };
            NumberFilter.prototype.isFilterActive = function () {
                return this.filterNumber !== null;
            };
            NumberFilter.prototype.createTemplate = function () {
                var translate = this.gridOptionsWrapper.getLocaleTextFunc();
                return "<div>\n                    <div>\n                        <select class=\"ag-filter-select\" id=\"filterType\">\n                            <option value=\"" + NumberFilter.EQUALS + "\">" + translate('equals', 'Equals') + "</option>\n                            <option value=\"" + NumberFilter.NOT_EQUAL + "\">" + translate('notEqual', 'Not equal') + "</option>\n                            <option value=\"" + NumberFilter.LESS_THAN + "\">" + translate('lessThan', 'Less than') + "</option>\n                            <option value=\"" + NumberFilter.LESS_THAN_OR_EQUAL + "\">" + translate('lessThanOrEqual', 'Less than or equal') + "</option>\n                            <option value=\"" + NumberFilter.GREATER_THAN + "\">" + translate('greaterThan', 'Greater than') + "</option>\n                            <option value=\"" + NumberFilter.GREATER_THAN_OR_EQUAL + "\">" + translate('greaterThanOrEqual', 'Greater than or equal') + "</option>\n                        </select>\n                    </div>\n                    <div>\n                        <input class=\"ag-filter-filter\" id=\"filterText\" type=\"text\" placeholder=\"" + translate('filterOoo', 'Filter...') + "\"/>\n                    </div>\n                    <div class=\"ag-filter-apply-panel\" id=\"applyPanel\">\n                        <button type=\"button\" id=\"applyButton\">" + translate('applyFilter', 'Apply Filter') + "</button>\n                    </div>\n                </div>";
            };
            NumberFilter.prototype.createGui = function () {
                this.eGui = utils_1.Utils.loadTemplate(this.createTemplate());
                this.eFilterTextField = this.eGui.querySelector("#filterText");
                this.eTypeSelect = this.eGui.querySelector("#filterType");
                utils_1.Utils.addChangeListener(this.eFilterTextField, this.onFilterChanged.bind(this));
                this.eTypeSelect.addEventListener("change", this.onTypeChanged.bind(this));
                this.setupApply();
            };
            NumberFilter.prototype.setupApply = function () {
                var _this = this;
                if (this.applyActive) {
                    this.eApplyButton = this.eGui.querySelector('#applyButton');
                    this.eApplyButton.addEventListener('click', function () {
                        _this.filterParams.filterChangedCallback();
                    });
                } else {
                    utils_1.Utils.removeElement(this.eGui, '#applyPanel');
                }
            };
            NumberFilter.prototype.onTypeChanged = function () {
                this.filterType = this.eTypeSelect.value;
                this.filterChanged();
            };
            NumberFilter.prototype.filterChanged = function () {
                this.filterParams.filterModifiedCallback();
                if (!this.applyActive) {
                    this.filterParams.filterChangedCallback();
                }
            };
            NumberFilter.prototype.onFilterChanged = function () {
                var filterText = utils_1.Utils.makeNull(this.eFilterTextField.value);
                if (filterText && filterText.trim() === '') {
                    filterText = null;
                }
                var newFilter;
                if (filterText !== null && filterText !== undefined) {
                    newFilter = parseFloat(filterText);
                } else {
                    newFilter = null;
                }
                if (this.filterNumber !== newFilter) {
                    this.filterNumber = newFilter;
                    this.filterChanged();
                }
            };
            NumberFilter.prototype.setType = function (type) {
                this.filterType = type;
                this.eTypeSelect.value = type;
            };
            NumberFilter.prototype.setFilter = function (filter) {
                filter = utils_1.Utils.makeNull(filter);
                if (filter !== null && !(typeof filter === 'number')) {
                    filter = parseFloat(filter);
                }
                this.filterNumber = filter;
                this.eFilterTextField.value = filter;
            };
            NumberFilter.prototype.getFilter = function () {
                return this.filterNumber;
            };
            NumberFilter.prototype.getModel = function () {
                if (this.isFilterActive()) {
                    return {
                        type: this.filterType,
                        filter: this.filterNumber
                    };
                } else {
                    return null;
                }
            };
            NumberFilter.prototype.setModel = function (model) {
                if (model) {
                    this.setType(model.type);
                    this.setFilter(model.filter);
                } else {
                    this.setFilter(null);
                }
            };
            NumberFilter.EQUALS = 'equals'; // 1;
            NumberFilter.NOT_EQUAL = 'notEqual'; //2;
            NumberFilter.LESS_THAN = 'lessThan'; //3;
            NumberFilter.LESS_THAN_OR_EQUAL = 'lessThanOrEqual'; //4;
            NumberFilter.GREATER_THAN = 'greaterThan'; //5;
            NumberFilter.GREATER_THAN_OR_EQUAL = 'greaterThanOrEqual'; //6;
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], NumberFilter.prototype, "gridOptionsWrapper", void 0);
            return NumberFilter;
        }();
        exports.NumberFilter = NumberFilter;

        /***/ },
    /* 285 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var utils_1 = __webpack_require__(245);
        var eventService_1 = __webpack_require__(242);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var Component = function () {
            function Component(template) {
                this.destroyFunctions = [];
                this.childComponents = [];
                this.annotatedEventListeners = [];
                this.visible = true;
                if (template) {
                    this.setTemplate(template);
                }
            }
            Component.prototype.instantiate = function (context) {
                this.instantiateRecurse(this.getGui(), context);
            };
            Component.prototype.instantiateRecurse = function (parentNode, context) {
                var childCount = parentNode.childNodes ? parentNode.childNodes.length : 0;
                for (var i = 0; i < childCount; i++) {
                    var childNode = parentNode.childNodes[i];
                    var newComponent = context.createComponent(childNode);
                    if (newComponent) {
                        this.swapComponentForNode(newComponent, parentNode, childNode);
                    } else {
                        if (childNode.childNodes) {
                            this.instantiateRecurse(childNode, context);
                        }
                    }
                }
            };
            Component.prototype.swapComponentForNode = function (newComponent, parentNode, childNode) {
                parentNode.replaceChild(newComponent.getGui(), childNode);
                this.childComponents.push(newComponent);
                this.swapInComponentForQuerySelectors(newComponent, childNode);
            };
            Component.prototype.swapInComponentForQuerySelectors = function (newComponent, childNode) {
                var metaData = this.__agComponentMetaData;
                if (!metaData || !metaData.querySelectors) {
                    return;
                }
                var thisNoType = this;
                metaData.querySelectors.forEach(function (querySelector) {
                    if (thisNoType[querySelector.attributeName] === childNode) {
                        thisNoType[querySelector.attributeName] = newComponent;
                    }
                });
            };
            Component.prototype.setTemplate = function (template) {
                this.eGui = utils_1.Utils.loadTemplate(template);
                this.eGui.__agComponent = this;
                this.addAnnotatedEventListeners();
                this.wireQuerySelectors();
            };
            Component.prototype.wireQuerySelectors = function () {
                var _this = this;
                var metaData = this.__agComponentMetaData;
                if (!metaData || !metaData.querySelectors) {
                    return;
                }
                if (!this.eGui) {
                    return;
                }
                var thisNoType = this;
                metaData.querySelectors.forEach(function (querySelector) {
                    var resultOfQuery = _this.eGui.querySelector(querySelector.querySelector);
                    if (resultOfQuery) {
                        var backingComponent = resultOfQuery.__agComponent;
                        if (backingComponent) {
                            thisNoType[querySelector.attributeName] = backingComponent;
                        } else {
                            thisNoType[querySelector.attributeName] = resultOfQuery;
                        }
                    } else {}
                });
            };
            Component.prototype.addAnnotatedEventListeners = function () {
                var _this = this;
                this.removeAnnotatedEventListeners();
                var metaData = this.__agComponentMetaData;
                if (!metaData || !metaData.listenerMethods) {
                    return;
                }
                if (!this.eGui) {
                    return;
                }
                if (!this.annotatedEventListeners) {
                    this.annotatedEventListeners = [];
                }
                metaData.listenerMethods.forEach(function (eventListener) {
                    var listener = _this[eventListener.methodName].bind(_this);
                    _this.eGui.addEventListener(eventListener.eventName, listener);
                    _this.annotatedEventListeners.push({ eventName: eventListener.eventName, listener: listener });
                });
            };
            Component.prototype.removeAnnotatedEventListeners = function () {
                var _this = this;
                if (!this.annotatedEventListeners) {
                    return;
                }
                if (!this.eGui) {
                    return;
                }
                this.annotatedEventListeners.forEach(function (eventListener) {
                    _this.eGui.removeEventListener(eventListener.eventName, eventListener.listener);
                });
                this.annotatedEventListeners = null;
            };
            Component.prototype.addEventListener = function (eventType, listener) {
                if (!this.localEventService) {
                    this.localEventService = new eventService_1.EventService();
                }
                this.localEventService.addEventListener(eventType, listener);
            };
            Component.prototype.removeEventListener = function (eventType, listener) {
                if (this.localEventService) {
                    this.localEventService.removeEventListener(eventType, listener);
                }
            };
            Component.prototype.dispatchEventAsync = function (eventType, event) {
                var _this = this;
                setTimeout(function () {
                    return _this.dispatchEvent(eventType, event);
                }, 0);
            };
            Component.prototype.dispatchEvent = function (eventType, event) {
                if (this.localEventService) {
                    this.localEventService.dispatchEvent(eventType, event);
                }
            };
            Component.prototype.getGui = function () {
                return this.eGui;
            };
            Component.prototype.queryForHtmlElement = function (cssSelector) {
                return this.eGui.querySelector(cssSelector);
            };
            Component.prototype.queryForHtmlInputElement = function (cssSelector) {
                return this.eGui.querySelector(cssSelector);
            };
            Component.prototype.appendChild = function (newChild) {
                if (utils_1.Utils.isNodeOrElement(newChild)) {
                    this.eGui.appendChild(newChild);
                } else {
                    var childComponent = newChild;
                    this.eGui.appendChild(childComponent.getGui());
                    this.childComponents.push(childComponent);
                }
            };
            Component.prototype.isVisible = function () {
                return this.visible;
            };
            Component.prototype.setVisible = function (visible) {
                if (visible !== this.visible) {
                    this.visible = visible;
                    utils_1.Utils.addOrRemoveCssClass(this.eGui, 'ag-hidden', !visible);
                    this.dispatchEvent(Component.EVENT_VISIBLE_CHANGED, { visible: this.visible });
                }
            };
            Component.prototype.addOrRemoveCssClass = function (className, addOrRemove) {
                utils_1.Utils.addOrRemoveCssClass(this.eGui, className, addOrRemove);
            };
            Component.prototype.destroy = function () {
                this.childComponents.forEach(function (childComponent) {
                    return childComponent.destroy();
                });
                this.destroyFunctions.forEach(function (func) {
                    return func();
                });
                this.removeAnnotatedEventListeners();
            };
            Component.prototype.addGuiEventListener = function (event, listener) {
                var _this = this;
                this.getGui().addEventListener(event, listener);
                this.destroyFunctions.push(function () {
                    return _this.getGui().removeEventListener(event, listener);
                });
            };
            Component.prototype.addDestroyableEventListener = function (eElement, event, listener) {
                if (eElement instanceof HTMLElement) {
                    eElement.addEventListener(event, listener);
                } else if (eElement instanceof gridOptionsWrapper_1.GridOptionsWrapper) {
                    eElement.addEventListener(event, listener);
                } else {
                    eElement.addEventListener(event, listener);
                }
                this.destroyFunctions.push(function () {
                    if (eElement instanceof HTMLElement) {
                        eElement.removeEventListener(event, listener);
                    } else if (eElement instanceof gridOptionsWrapper_1.GridOptionsWrapper) {
                        eElement.removeEventListener(event, listener);
                    } else {
                        eElement.removeEventListener(event, listener);
                    }
                });
            };
            Component.prototype.addDestroyFunc = function (func) {
                this.destroyFunctions.push(func);
            };
            Component.prototype.addCssClass = function (className) {
                utils_1.Utils.addCssClass(this.getGui(), className);
            };
            Component.prototype.getAttribute = function (key) {
                var eGui = this.getGui();
                if (eGui) {
                    return eGui.getAttribute(key);
                } else {
                    return null;
                }
            };
            Component.EVENT_VISIBLE_CHANGED = 'visibleChanged';
            return Component;
        }();
        exports.Component = Component;

        /***/ },
    /* 286 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var utils_1 = __webpack_require__(245);
        var textCellEditor_1 = __webpack_require__(287);
        var selectCellEditor_1 = __webpack_require__(288);
        var popupEditorWrapper_1 = __webpack_require__(289);
        var popupTextCellEditor_1 = __webpack_require__(290);
        var popupSelectCellEditor_1 = __webpack_require__(291);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var largeTextCellEditor_1 = __webpack_require__(292);
        var CellEditorFactory = function () {
            function CellEditorFactory() {
                this.cellEditorMap = {};
            }
            CellEditorFactory.prototype.init = function () {
                this.cellEditorMap[CellEditorFactory.TEXT] = textCellEditor_1.TextCellEditor;
                this.cellEditorMap[CellEditorFactory.SELECT] = selectCellEditor_1.SelectCellEditor;
                this.cellEditorMap[CellEditorFactory.POPUP_TEXT] = popupTextCellEditor_1.PopupTextCellEditor;
                this.cellEditorMap[CellEditorFactory.POPUP_SELECT] = popupSelectCellEditor_1.PopupSelectCellEditor;
                this.cellEditorMap[CellEditorFactory.LARGE_TEXT] = largeTextCellEditor_1.LargeTextCellEditor;
            };
            CellEditorFactory.prototype.addCellEditor = function (key, cellEditor) {
                this.cellEditorMap[key] = cellEditor;
            };
            // private registerEditorsFromGridOptions(): void {
            //     var userProvidedCellEditors = this.gridOptionsWrapper.getCellEditors();
            //     _.iterateObject(userProvidedCellEditors, (key: string, cellEditor: {new(): ICellEditor})=> {
            //         this.addCellEditor(key, cellEditor);
            //     });
            // }
            CellEditorFactory.prototype.createCellEditor = function (key, params) {
                var CellEditorClass;
                if (utils_1.Utils.missing(key)) {
                    CellEditorClass = this.cellEditorMap[CellEditorFactory.TEXT];
                } else if (typeof key === 'string') {
                    CellEditorClass = this.cellEditorMap[key];
                    if (utils_1.Utils.missing(CellEditorClass)) {
                        console.warn('ag-Grid: unable to find cellEditor for key ' + key);
                        CellEditorClass = this.cellEditorMap[CellEditorFactory.TEXT];
                    }
                } else {
                    CellEditorClass = key;
                }
                var cellEditor = new CellEditorClass();
                this.context.wireBean(cellEditor);
                // we have to call init first, otherwise when using the frameworks, the wrapper
                // classes won't be set up
                if (cellEditor.init) {
                    cellEditor.init(params);
                }
                if (cellEditor.isPopup && cellEditor.isPopup()) {
                    cellEditor = new popupEditorWrapper_1.PopupEditorWrapper(cellEditor);
                    cellEditor.init(params);
                }
                return cellEditor;
            };
            CellEditorFactory.TEXT = 'text';
            CellEditorFactory.SELECT = 'select';
            CellEditorFactory.POPUP_TEXT = 'popupText';
            CellEditorFactory.POPUP_SELECT = 'popupSelect';
            CellEditorFactory.LARGE_TEXT = 'largeText';
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], CellEditorFactory.prototype, "context", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], CellEditorFactory.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], CellEditorFactory.prototype, "init", null);
            CellEditorFactory = __decorate([context_1.Bean('cellEditorFactory'), __metadata('design:paramtypes', [])], CellEditorFactory);
            return CellEditorFactory;
        }();
        exports.CellEditorFactory = CellEditorFactory;

        /***/ },
    /* 287 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var constants_1 = __webpack_require__(246);
        var component_1 = __webpack_require__(285);
        var utils_1 = __webpack_require__(245);
        var TextCellEditor = function (_super) {
            __extends(TextCellEditor, _super);
            function TextCellEditor() {
                _super.call(this, TextCellEditor.TEMPLATE);
            }
            TextCellEditor.prototype.init = function (params) {
                var eInput = this.getGui();
                var startValue;
                var keyPressBackspaceOrDelete = params.keyPress === constants_1.Constants.KEY_BACKSPACE || params.keyPress === constants_1.Constants.KEY_DELETE;
                if (keyPressBackspaceOrDelete) {
                    startValue = '';
                } else if (params.charPress) {
                    startValue = params.charPress;
                } else {
                    startValue = params.value;
                    if (params.keyPress === constants_1.Constants.KEY_F2) {
                        this.putCursorAtEndOnFocus = true;
                    } else {
                        this.highlightAllOnFocus = true;
                    }
                }
                if (utils_1.Utils.exists(startValue)) {
                    eInput.value = startValue;
                }
                this.addDestroyableEventListener(eInput, 'keydown', function (event) {
                    var isNavigationKey = event.keyCode === constants_1.Constants.KEY_LEFT || event.keyCode === constants_1.Constants.KEY_RIGHT;
                    if (isNavigationKey) {
                        event.stopPropagation();
                    }
                });
            };
            TextCellEditor.prototype.afterGuiAttached = function () {
                var eInput = this.getGui();
                eInput.focus();
                if (this.highlightAllOnFocus) {
                    eInput.select();
                } else {
                    // when we started editing, we want the carot at the end, not the start.
                    // this comes into play in two scenarios: a) when user hits F2 and b)
                    // when user hits a printable character, then on IE (and only IE) the carot
                    // was placed after the first character, thus 'apply' would end up as 'pplea'
                    var length = eInput.value ? eInput.value.length : 0;
                    if (length > 0) {
                        eInput.setSelectionRange(length, length);
                    }
                }
            };
            TextCellEditor.prototype.getValue = function () {
                var eInput = this.getGui();
                return eInput.value;
            };
            TextCellEditor.TEMPLATE = '<input class="ag-cell-edit-input" type="text"/>';
            return TextCellEditor;
        }(component_1.Component);
        exports.TextCellEditor = TextCellEditor;

        /***/ },
    /* 288 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var component_1 = __webpack_require__(285);
        var utils_1 = __webpack_require__(245);
        var constants_1 = __webpack_require__(246);
        var SelectCellEditor = function (_super) {
            __extends(SelectCellEditor, _super);
            function SelectCellEditor() {
                _super.call(this, '<div class="ag-cell-edit-input"><select class="ag-cell-edit-input"/></div>');
            }
            SelectCellEditor.prototype.init = function (params) {
                var eSelect = this.getGui().querySelector('select');
                if (utils_1.Utils.missing(params.values)) {
                    console.log('ag-Grid: no values found for select cellEditor');
                    return;
                }
                params.values.forEach(function (value) {
                    var option = document.createElement('option');
                    option.value = value;
                    option.text = value;
                    if (params.value === value) {
                        option.selected = true;
                    }
                    eSelect.appendChild(option);
                });
                this.addDestroyableEventListener(eSelect, 'change', function () {
                    return params.stopEditing();
                });
                this.addDestroyableEventListener(eSelect, 'keydown', function (event) {
                    var isNavigationKey = event.keyCode === constants_1.Constants.KEY_UP || event.keyCode === constants_1.Constants.KEY_DOWN;
                    if (isNavigationKey) {
                        event.stopPropagation();
                    }
                });
                this.addDestroyableEventListener(eSelect, 'mousedown', function (event) {
                    event.stopPropagation();
                });
            };
            SelectCellEditor.prototype.afterGuiAttached = function () {
                var eSelect = this.getGui().querySelector('select');
                eSelect.focus();
            };
            SelectCellEditor.prototype.getValue = function () {
                var eSelect = this.getGui().querySelector('select');
                return eSelect.value;
            };
            return SelectCellEditor;
        }(component_1.Component);
        exports.SelectCellEditor = SelectCellEditor;

        /***/ },
    /* 289 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var component_1 = __webpack_require__(285);
        var PopupEditorWrapper = function (_super) {
            __extends(PopupEditorWrapper, _super);
            function PopupEditorWrapper(cellEditor) {
                _super.call(this, '<div class="ag-popup-editor"/>');
                this.getGuiCalledOnChild = false;
                this.cellEditor = cellEditor;
                this.addDestroyFunc(function () {
                    return cellEditor.destroy();
                });
                this.addDestroyableEventListener(
                    // this needs to be 'super' and not 'this' as if we call 'this',
                    // it ends up called 'getGui()' on the child before 'init' was called,
                    // which is not good
                    _super.prototype.getGui.call(this), 'keydown', this.onKeyDown.bind(this));
            }
            PopupEditorWrapper.prototype.onKeyDown = function (event) {
                this.params.onKeyDown(event);
            };
            PopupEditorWrapper.prototype.getGui = function () {
                // we call getGui() on child here (rather than in the constructor)
                // as we should wait for 'init' to be called on child first.
                if (!this.getGuiCalledOnChild) {
                    this.appendChild(this.cellEditor.getGui());
                    this.getGuiCalledOnChild = true;
                }
                return _super.prototype.getGui.call(this);
            };
            PopupEditorWrapper.prototype.init = function (params) {
                this.params = params;
            };
            PopupEditorWrapper.prototype.afterGuiAttached = function () {
                if (this.cellEditor.afterGuiAttached) {
                    this.cellEditor.afterGuiAttached();
                }
            };
            PopupEditorWrapper.prototype.getValue = function () {
                return this.cellEditor.getValue();
            };
            PopupEditorWrapper.prototype.isPopup = function () {
                return true;
            };
            PopupEditorWrapper.prototype.isCancelBeforeStart = function () {
                if (this.cellEditor.isCancelBeforeStart) {
                    return this.cellEditor.isCancelBeforeStart();
                }
            };
            PopupEditorWrapper.prototype.isCancelAfterEnd = function () {
                if (this.cellEditor.isCancelAfterEnd) {
                    return this.cellEditor.isCancelAfterEnd();
                }
            };
            return PopupEditorWrapper;
        }(component_1.Component);
        exports.PopupEditorWrapper = PopupEditorWrapper;

        /***/ },
    /* 290 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var textCellEditor_1 = __webpack_require__(287);
        var PopupTextCellEditor = function (_super) {
            __extends(PopupTextCellEditor, _super);
            function PopupTextCellEditor() {
                _super.apply(this, arguments);
            }
            PopupTextCellEditor.prototype.isPopup = function () {
                return true;
            };
            return PopupTextCellEditor;
        }(textCellEditor_1.TextCellEditor);
        exports.PopupTextCellEditor = PopupTextCellEditor;

        /***/ },
    /* 291 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var selectCellEditor_1 = __webpack_require__(288);
        var PopupSelectCellEditor = function (_super) {
            __extends(PopupSelectCellEditor, _super);
            function PopupSelectCellEditor() {
                _super.apply(this, arguments);
            }
            PopupSelectCellEditor.prototype.isPopup = function () {
                return true;
            };
            return PopupSelectCellEditor;
        }(selectCellEditor_1.SelectCellEditor);
        exports.PopupSelectCellEditor = PopupSelectCellEditor;

        /***/ },
    /* 292 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var component_1 = __webpack_require__(285);
        var constants_1 = __webpack_require__(246);
        var utils_1 = __webpack_require__(245);
        var LargeTextCellEditor = function (_super) {
            __extends(LargeTextCellEditor, _super);
            function LargeTextCellEditor() {
                _super.call(this, LargeTextCellEditor.TEMPLATE);
            }
            LargeTextCellEditor.prototype.init = function (params) {
                this.params = params;
                this.textarea = document.createElement("textarea");
                this.textarea.maxLength = params.maxLength ? params.maxLength : "200";
                this.textarea.cols = params.cols ? params.cols : "60";
                this.textarea.rows = params.rows ? params.rows : "10";
                if (utils_1.Utils.exists(params.value)) {
                    this.textarea.value = params.value.toString();
                }
                this.getGui().querySelector('.ag-large-textarea').appendChild(this.textarea);
                this.addGuiEventListener('keydown', this.onKeyDown.bind(this));
            };
            LargeTextCellEditor.prototype.onKeyDown = function (event) {
                var key = event.which || event.keyCode;
                if (key == constants_1.Constants.KEY_LEFT || key == constants_1.Constants.KEY_UP || key == constants_1.Constants.KEY_RIGHT || key == constants_1.Constants.KEY_DOWN || event.shiftKey && key == constants_1.Constants.KEY_ENTER) {
                    event.stopPropagation();
                }
            };
            LargeTextCellEditor.prototype.afterGuiAttached = function () {
                this.textarea.focus();
            };
            LargeTextCellEditor.prototype.getValue = function () {
                return this.textarea.value;
            };
            LargeTextCellEditor.prototype.isPopup = function () {
                return true;
            };
            LargeTextCellEditor.TEMPLATE =
                // tab index is needed so we can focus, which is needed for keyboard events
                '<div class="ag-large-text" tabindex="0">' + '<div class="ag-large-textarea"></div>' + '</div>';
            return LargeTextCellEditor;
        }(component_1.Component);
        exports.LargeTextCellEditor = LargeTextCellEditor;

        /***/ },
    /* 293 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var utils_1 = __webpack_require__(245);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var eventService_1 = __webpack_require__(242);
        var expressionService_1 = __webpack_require__(256);
        var animateSlideCellRenderer_1 = __webpack_require__(294);
        var animateShowChangeCellRenderer_1 = __webpack_require__(295);
        var groupCellRenderer_1 = __webpack_require__(296);
        var CellRendererFactory = function () {
            function CellRendererFactory() {
                this.cellRendererMap = {};
            }
            CellRendererFactory.prototype.init = function () {
                this.cellRendererMap[CellRendererFactory.ANIMATE_SLIDE] = animateSlideCellRenderer_1.AnimateSlideCellRenderer;
                this.cellRendererMap[CellRendererFactory.ANIMATE_SHOW_CHANGE] = animateShowChangeCellRenderer_1.AnimateShowChangeCellRenderer;
                this.cellRendererMap[CellRendererFactory.GROUP] = groupCellRenderer_1.GroupCellRenderer;
                // this.registerRenderersFromGridOptions();
            };
            // private registerRenderersFromGridOptions(): void {
            //     var userProvidedCellRenderers = this.gridOptionsWrapper.getCellRenderers();
            //     _.iterateObject(userProvidedCellRenderers, (key: string, cellRenderer: {new(): ICellRenderer} | ICellRendererFunc)=> {
            //         this.addCellRenderer(key, cellRenderer);
            //     });
            // }
            CellRendererFactory.prototype.addCellRenderer = function (key, cellRenderer) {
                this.cellRendererMap[key] = cellRenderer;
            };
            CellRendererFactory.prototype.getCellRenderer = function (key) {
                var result = this.cellRendererMap[key];
                if (utils_1.Utils.missing(result)) {
                    console.warn('ag-Grid: unable to find cellRenderer for key ' + key);
                    return null;
                }
                return result;
            };
            CellRendererFactory.ANIMATE_SLIDE = 'animateSlide';
            CellRendererFactory.ANIMATE_SHOW_CHANGE = 'animateShowChange';
            CellRendererFactory.GROUP = 'group';
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], CellRendererFactory.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('expressionService'), __metadata('design:type', expressionService_1.ExpressionService)], CellRendererFactory.prototype, "expressionService", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], CellRendererFactory.prototype, "eventService", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], CellRendererFactory.prototype, "init", null);
            CellRendererFactory = __decorate([context_1.Bean('cellRendererFactory'), __metadata('design:paramtypes', [])], CellRendererFactory);
            return CellRendererFactory;
        }();
        exports.CellRendererFactory = CellRendererFactory;

        /***/ },
    /* 294 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var utils_1 = __webpack_require__(245);
        var component_1 = __webpack_require__(285);
        var AnimateSlideCellRenderer = function (_super) {
            __extends(AnimateSlideCellRenderer, _super);
            function AnimateSlideCellRenderer() {
                _super.call(this, AnimateSlideCellRenderer.TEMPLATE);
                this.refreshCount = 0;
                this.eCurrent = this.queryForHtmlElement('.ag-value-slide-current');
            }
            AnimateSlideCellRenderer.prototype.init = function (params) {
                this.params = params;
                this.refresh(params);
            };
            AnimateSlideCellRenderer.prototype.addSlideAnimation = function () {
                var _this = this;
                this.refreshCount++;
                // below we keep checking this, and stop working on the animation
                // if it no longer matches - this means another animation has started
                // and this one is stale.
                var refreshCountCopy = this.refreshCount;
                // if old animation, remove it
                if (this.ePrevious) {
                    this.getGui().removeChild(this.ePrevious);
                }
                this.ePrevious = utils_1.Utils.loadTemplate('<span class="ag-value-slide-previous ag-fade-out"></span>');
                this.ePrevious.innerHTML = this.eCurrent.innerHTML;
                this.getGui().insertBefore(this.ePrevious, this.eCurrent);
                // having timeout of 0 allows use to skip to the next css turn,
                // so we know the previous css classes have been applied. so the
                // complex set of setTimeout below creates the animation
                setTimeout(function () {
                    if (refreshCountCopy !== _this.refreshCount) {
                        return;
                    }
                    utils_1.Utils.addCssClass(_this.ePrevious, 'ag-fade-out-end');
                }, 50);
                setTimeout(function () {
                    if (refreshCountCopy !== _this.refreshCount) {
                        return;
                    }
                    _this.getGui().removeChild(_this.ePrevious);
                    _this.ePrevious = null;
                }, 3000);
            };
            AnimateSlideCellRenderer.prototype.refresh = function (params) {
                var value = params.value;
                if (utils_1.Utils.missing(value)) {
                    value = '';
                }
                if (value === this.lastValue) {
                    return;
                }
                this.addSlideAnimation();
                this.lastValue = value;
                if (utils_1.Utils.exists(params.valueFormatted)) {
                    this.eCurrent.innerHTML = params.valueFormatted;
                } else if (utils_1.Utils.exists(params.value)) {
                    this.eCurrent.innerHTML = value;
                } else {
                    this.eCurrent.innerHTML = '';
                }
            };
            AnimateSlideCellRenderer.TEMPLATE = '<span>' + '<span class="ag-value-slide-current"></span>' + '</span>';
            return AnimateSlideCellRenderer;
        }(component_1.Component);
        exports.AnimateSlideCellRenderer = AnimateSlideCellRenderer;

        /***/ },
    /* 295 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var utils_1 = __webpack_require__(245);
        var component_1 = __webpack_require__(285);
        var ARROW_UP = '&#65514;';
        var ARROW_DOWN = '&#65516;';
        var AnimateShowChangeCellRenderer = function (_super) {
            __extends(AnimateShowChangeCellRenderer, _super);
            function AnimateShowChangeCellRenderer() {
                _super.call(this, AnimateShowChangeCellRenderer.TEMPLATE);
                this.refreshCount = 0;
            }
            AnimateShowChangeCellRenderer.prototype.init = function (params) {
                this.params = params;
                this.eValue = this.queryForHtmlElement('.ag-value-change-value');
                this.eDelta = this.queryForHtmlElement('.ag-value-change-delta');
                this.refresh(params);
            };
            AnimateShowChangeCellRenderer.prototype.showDelta = function (params, delta) {
                var absDelta = Math.abs(delta);
                var valueFormatted = params.formatValue(absDelta);
                var valueToUse = utils_1.Utils.exists(valueFormatted) ? valueFormatted : absDelta;
                var deltaUp = delta >= 0;
                if (deltaUp) {
                    this.eDelta.innerHTML = ARROW_UP + valueToUse;
                } else {
                    // because negative, use ABS to remove sign
                    this.eDelta.innerHTML = ARROW_DOWN + valueToUse;
                }
                // class makes it green (in ag-fresh)
                utils_1.Utils.addOrRemoveCssClass(this.eDelta, 'ag-value-change-delta-up', deltaUp);
                // class makes it red (in ag-fresh)
                utils_1.Utils.addOrRemoveCssClass(this.eDelta, 'ag-value-change-delta-down', !deltaUp);
            };
            AnimateShowChangeCellRenderer.prototype.setTimerToRemoveDelta = function () {
                var _this = this;
                // the refreshCount makes sure that if the value updates again while
                // the below timer is waiting, then the below timer will realise it
                // is not the most recent and will not try to remove the delta value.
                this.refreshCount++;
                var refreshCountCopy = this.refreshCount;
                setTimeout(function () {
                    if (refreshCountCopy === _this.refreshCount) {
                        _this.hideDeltaValue();
                    }
                }, 2000);
            };
            AnimateShowChangeCellRenderer.prototype.hideDeltaValue = function () {
                utils_1.Utils.removeCssClass(this.eValue, 'ag-value-change-value-highlight');
                this.eDelta.innerHTML = '';
            };
            AnimateShowChangeCellRenderer.prototype.refresh = function (params) {
                var value = params.value;
                if (value === this.lastValue) {
                    return;
                }
                if (utils_1.Utils.exists(params.valueFormatted)) {
                    this.eValue.innerHTML = params.valueFormatted;
                } else if (utils_1.Utils.exists(params.value)) {
                    this.eValue.innerHTML = value;
                } else {
                    this.eValue.innerHTML = '';
                }
                if (typeof value === 'number' && typeof this.lastValue === 'number') {
                    var delta = value - this.lastValue;
                    this.showDelta(params, delta);
                }
                // highlight the current value, but only if it's not new, otherwise it
                // would get highlighted first time the value is shown
                if (this.lastValue) {
                    utils_1.Utils.addCssClass(this.eValue, 'ag-value-change-value-highlight');
                }
                this.setTimerToRemoveDelta();
                this.lastValue = value;
            };
            AnimateShowChangeCellRenderer.TEMPLATE = '<span>' + '<span class="ag-value-change-delta"></span>' + '<span class="ag-value-change-value"></span>' + '</span>';
            return AnimateShowChangeCellRenderer;
        }(component_1.Component);
        exports.AnimateShowChangeCellRenderer = AnimateShowChangeCellRenderer;

        /***/ },
    /* 296 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var svgFactory_1 = __webpack_require__(297);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var expressionService_1 = __webpack_require__(256);
        var eventService_1 = __webpack_require__(242);
        var constants_1 = __webpack_require__(246);
        var utils_1 = __webpack_require__(245);
        var events_1 = __webpack_require__(248);
        var context_1 = __webpack_require__(244);
        var component_1 = __webpack_require__(285);
        var cellRendererService_1 = __webpack_require__(298);
        var valueFormatterService_1 = __webpack_require__(299);
        var checkboxSelectionComponent_1 = __webpack_require__(300);
        var columnController_1 = __webpack_require__(251);
        var svgFactory = svgFactory_1.SvgFactory.getInstance();
        var GroupCellRenderer = function (_super) {
            __extends(GroupCellRenderer, _super);
            function GroupCellRenderer() {
                _super.call(this, GroupCellRenderer.TEMPLATE);
                this.eExpanded = this.queryForHtmlElement('.ag-group-expanded');
                this.eContracted = this.queryForHtmlElement('.ag-group-contracted');
                this.eCheckbox = this.queryForHtmlElement('.ag-group-checkbox');
                this.eValue = this.queryForHtmlElement('.ag-group-value');
                this.eChildCount = this.queryForHtmlElement('.ag-group-child-count');
            }
            GroupCellRenderer.prototype.init = function (params) {
                this.rowNode = params.node;
                this.rowIndex = params.rowIndex;
                this.gridApi = params.api;
                this.addExpandAndContract(params.eGridCell);
                this.addCheckboxIfNeeded(params);
                this.addValueElement(params);
                this.addPadding(params);
            };
            GroupCellRenderer.prototype.addPadding = function (params) {
                // only do this if an indent - as this overwrites the padding that
                // the theme set, which will make things look 'not aligned' for the
                // first group level.
                var node = this.rowNode;
                var suppressPadding = params.suppressPadding;
                if (!suppressPadding && (node.footer || node.level > 0)) {
                    var paddingFactor;
                    if (params.colDef && params.padding >= 0) {
                        paddingFactor = params.padding;
                    } else {
                        paddingFactor = 10;
                    }
                    var paddingPx = node.level * paddingFactor;
                    var reducedLeafNode = this.columnController.isPivotMode() && this.rowNode.leafGroup;
                    if (node.footer) {
                        paddingPx += 15;
                    } else if (!node.isExpandable() || reducedLeafNode) {
                        paddingPx += 10;
                    }
                    this.getGui().style.paddingLeft = paddingPx + 'px';
                }
            };
            GroupCellRenderer.prototype.addValueElement = function (params) {
                if (params.innerRenderer) {
                    this.createFromInnerRenderer(params);
                } else if (this.rowNode.footer) {
                    this.createFooterCell(params);
                } else if (this.rowNode.group) {
                    this.createGroupCell(params);
                    this.addChildCount(params);
                } else {
                    this.createLeafCell(params);
                }
            };
            GroupCellRenderer.prototype.createFromInnerRenderer = function (params) {
                this.cellRendererService.useCellRenderer(params.innerRenderer, this.eValue, params);
            };
            GroupCellRenderer.prototype.createFooterCell = function (params) {
                var footerValue;
                var groupName = this.getGroupName(params);
                if (params.footerValueGetter) {
                    var footerValueGetter = params.footerValueGetter;
                    // params is same as we were given, except we set the value as the item to display
                    var paramsClone = utils_1.Utils.cloneObject(params);
                    paramsClone.value = groupName;
                    if (typeof footerValueGetter === 'function') {
                        footerValue = footerValueGetter(paramsClone);
                    } else if (typeof footerValueGetter === 'string') {
                        footerValue = this.expressionService.evaluate(footerValueGetter, paramsClone);
                    } else {
                        console.warn('ag-Grid: footerValueGetter should be either a function or a string (expression)');
                    }
                } else {
                    footerValue = 'Total ' + groupName;
                }
                this.eValue.innerHTML = footerValue;
            };
            GroupCellRenderer.prototype.createGroupCell = function (params) {
                // pull out the column that the grouping is on
                var rowGroupColumns = params.columnApi.getRowGroupColumns();
                // if we are using in memory grid grouping, then we try to look up the column that
                // we did the grouping on. however if it is not possible (happens when user provides
                // the data already grouped) then we just the current col, ie use cellrenderer of current col
                var columnOfGroupedCol = rowGroupColumns[params.node.level];
                if (utils_1.Utils.missing(columnOfGroupedCol)) {
                    columnOfGroupedCol = params.column;
                }
                var colDefOfGroupedCol = columnOfGroupedCol.getColDef();
                var groupName = this.getGroupName(params);
                var valueFormatted = this.valueFormatterService.formatValue(columnOfGroupedCol, params.node, params.scope, this.rowIndex, groupName);
                // reuse the params but change the value
                if (colDefOfGroupedCol && typeof colDefOfGroupedCol.cellRenderer === 'function') {
                    // reuse the params but change the value
                    params.value = groupName;
                    params.valueFormatted = valueFormatted;
                    // because we are talking about the different column to the original, any user provided params
                    // are for the wrong column, so need to copy them in again.
                    if (colDefOfGroupedCol.cellRendererParams) {
                        utils_1.Utils.assign(params, colDefOfGroupedCol.cellRendererParams);
                    }
                    this.cellRendererService.useCellRenderer(colDefOfGroupedCol.cellRenderer, this.eValue, params);
                } else {
                    var valueToRender = utils_1.Utils.exists(valueFormatted) ? valueFormatted : groupName;
                    if (utils_1.Utils.exists(valueToRender) && valueToRender !== '') {
                        this.eValue.appendChild(document.createTextNode(valueToRender));
                    }
                }
            };
            GroupCellRenderer.prototype.addChildCount = function (params) {
                // only include the child count if it's included, eg if user doing custom aggregation,
                // then this could be left out, or set to -1, ie no child count
                var suppressCount = params.suppressCount;
                if (!suppressCount && params.node.allChildrenCount >= 0) {
                    this.eChildCount.innerHTML = "(" + params.node.allChildrenCount + ")";
                }
            };
            GroupCellRenderer.prototype.getGroupName = function (params) {
                if (params.keyMap && _typeof(params.keyMap) === 'object') {
                    var valueFromMap = params.keyMap[params.node.key];
                    if (valueFromMap) {
                        return valueFromMap;
                    } else {
                        return params.node.key;
                    }
                } else {
                    return params.node.key;
                }
            };
            GroupCellRenderer.prototype.createLeafCell = function (params) {
                if (utils_1.Utils.exists(params.value)) {
                    this.eValue.innerHTML = params.value;
                }
            };
            GroupCellRenderer.prototype.addCheckboxIfNeeded = function (params) {
                var checkboxNeeded = params.checkbox && !this.rowNode.footer && !this.rowNode.floating && !this.rowNode.flower;
                if (checkboxNeeded) {
                    var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();
                    this.context.wireBean(cbSelectionComponent);
                    cbSelectionComponent.init({ rowNode: this.rowNode });
                    this.eCheckbox.appendChild(cbSelectionComponent.getGui());
                    this.addDestroyFunc(function () {
                        return cbSelectionComponent.destroy();
                    });
                }
            };
            GroupCellRenderer.prototype.addExpandAndContract = function (eGroupCell) {
                var eExpandedIcon = utils_1.Utils.createIconNoSpan('groupExpanded', this.gridOptionsWrapper, null, svgFactory.createGroupContractedIcon);
                var eContractedIcon = utils_1.Utils.createIconNoSpan('groupContracted', this.gridOptionsWrapper, null, svgFactory.createGroupExpandedIcon);
                this.eExpanded.appendChild(eExpandedIcon);
                this.eContracted.appendChild(eContractedIcon);
                this.addDestroyableEventListener(this.eExpanded, 'click', this.onExpandOrContract.bind(this));
                this.addDestroyableEventListener(this.eContracted, 'click', this.onExpandOrContract.bind(this));
                this.addDestroyableEventListener(eGroupCell, 'dblclick', this.onExpandOrContract.bind(this));
                // expand / contract as the user hits enter
                this.addDestroyableEventListener(eGroupCell, 'keydown', this.onKeyDown.bind(this));
                this.showExpandAndContractIcons();
            };
            GroupCellRenderer.prototype.onKeyDown = function (event) {
                if (utils_1.Utils.isKeyPressed(event, constants_1.Constants.KEY_ENTER)) {
                    this.onExpandOrContract();
                    event.preventDefault();
                }
            };
            GroupCellRenderer.prototype.onExpandOrContract = function () {
                this.rowNode.expanded = !this.rowNode.expanded;
                var refreshIndex = this.getRefreshFromIndex();
                this.gridApi.onGroupExpandedOrCollapsed(refreshIndex);
                this.showExpandAndContractIcons();
                var event = { node: this.rowNode };
                this.eventService.dispatchEvent(events_1.Events.EVENT_ROW_GROUP_OPENED, event);
            };
            GroupCellRenderer.prototype.showExpandAndContractIcons = function () {
                var reducedLeafNode = this.columnController.isPivotMode() && this.rowNode.leafGroup;
                var expandable = this.rowNode.isExpandable() && !this.rowNode.footer && !reducedLeafNode;
                if (expandable) {
                    // if expandable, show one based on expand state
                    utils_1.Utils.setVisible(this.eExpanded, this.rowNode.expanded);
                    utils_1.Utils.setVisible(this.eContracted, !this.rowNode.expanded);
                } else {
                    // it not expandable, show neither
                    utils_1.Utils.setVisible(this.eExpanded, false);
                    utils_1.Utils.setVisible(this.eContracted, false);
                }
            };
            // if we are showing footers, then opening / closing the group also changes the group
            // row, as the 'summaries' move to and from the header and footer. if not using footers,
            // then we only need to refresh from this row down.
            GroupCellRenderer.prototype.getRefreshFromIndex = function () {
                if (this.gridOptionsWrapper.isGroupIncludeFooter()) {
                    return this.rowIndex;
                } else {
                    return this.rowIndex + 1;
                }
            };
            GroupCellRenderer.TEMPLATE = '<span>' + '<span class="ag-group-expanded"></span>' + '<span class="ag-group-contracted"></span>' + '<span class="ag-group-checkbox"></span>' + '<span class="ag-group-value"></span>' + '<span class="ag-group-child-count"></span>' + '</span>';
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], GroupCellRenderer.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('expressionService'), __metadata('design:type', expressionService_1.ExpressionService)], GroupCellRenderer.prototype, "expressionService", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], GroupCellRenderer.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('cellRendererService'), __metadata('design:type', cellRendererService_1.CellRendererService)], GroupCellRenderer.prototype, "cellRendererService", void 0);
            __decorate([context_1.Autowired('valueFormatterService'), __metadata('design:type', valueFormatterService_1.ValueFormatterService)], GroupCellRenderer.prototype, "valueFormatterService", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], GroupCellRenderer.prototype, "context", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], GroupCellRenderer.prototype, "columnController", void 0);
            return GroupCellRenderer;
        }(component_1.Component);
        exports.GroupCellRenderer = GroupCellRenderer;

        /***/ },
    /* 297 */
    /***/ function(module, exports) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var SVG_NS = "http://www.w3.org/2000/svg";
        var SvgFactory = function () {
            function SvgFactory() {}
            SvgFactory.getInstance = function () {
                if (!this.theInstance) {
                    this.theInstance = new SvgFactory();
                }
                return this.theInstance;
            };
            SvgFactory.prototype.createFilterSvg = function () {
                var eSvg = createIconSvg();
                var eFunnel = document.createElementNS(SVG_NS, "polygon");
                eFunnel.setAttribute("points", "0,0 4,4 4,10 6,10 6,4 10,0");
                eFunnel.setAttribute("class", "ag-header-icon");
                eSvg.appendChild(eFunnel);
                return eSvg;
            };
            SvgFactory.prototype.createFilterSvg12 = function () {
                var eSvg = createIconSvg(12);
                var eFunnel = document.createElementNS(SVG_NS, "polygon");
                eFunnel.setAttribute("points", "0,0 5,5 5,12 7,12 7,5 12,0");
                eFunnel.setAttribute("class", "ag-header-icon");
                eSvg.appendChild(eFunnel);
                return eSvg;
            };
            SvgFactory.prototype.createMenuSvg = function () {
                var eSvg = document.createElementNS(SVG_NS, "svg");
                var size = "12";
                eSvg.setAttribute("width", size);
                eSvg.setAttribute("height", size);
                ["0", "5", "10"].forEach(function (y) {
                    var eLine = document.createElementNS(SVG_NS, "rect");
                    eLine.setAttribute("y", y);
                    eLine.setAttribute("width", size);
                    eLine.setAttribute("height", "2");
                    eLine.setAttribute("class", "ag-header-icon");
                    eSvg.appendChild(eLine);
                });
                return eSvg;
            };
            SvgFactory.prototype.createColumnsSvg12 = function () {
                var eSvg = createIconSvg(12);
                [0, 4, 8].forEach(function (y) {
                    [0, 7].forEach(function (x) {
                        var eBar = document.createElementNS(SVG_NS, "rect");
                        eBar.setAttribute("y", y.toString());
                        eBar.setAttribute("x", x.toString());
                        eBar.setAttribute("width", "5");
                        eBar.setAttribute("height", "3");
                        eBar.setAttribute("class", "ag-header-icon");
                        eSvg.appendChild(eBar);
                    });
                });
                return eSvg;
            };
            SvgFactory.prototype.createArrowUpSvg = function () {
                return createPolygonSvg("0,10 5,0 10,10");
            };
            SvgFactory.prototype.createArrowLeftSvg = function () {
                return createPolygonSvg("10,0 0,5 10,10");
            };
            SvgFactory.prototype.createArrowDownSvg = function () {
                return createPolygonSvg("0,0 5,10 10,0");
            };
            SvgFactory.prototype.createArrowRightSvg = function () {
                return createPolygonSvg("0,0 10,5 0,10");
            };
            SvgFactory.prototype.createSmallArrowRightSvg = function () {
                return createPolygonSvg("0,0 6,3 0,6", 6);
            };
            SvgFactory.prototype.createSmallArrowDownSvg = function () {
                return createPolygonSvg("0,0 3,6 6,0", 6);
            };
            //public createOpenSvg() {
            //    return createPlusMinus(true);
            //}
            //
            //public createCloseSvg() {
            //    return createPlusMinus(false);
            //}
            // UnSort Icon SVG
            SvgFactory.prototype.createArrowUpDownSvg = function () {
                var svg = createIconSvg();
                var eAscIcon = document.createElementNS(SVG_NS, "polygon");
                eAscIcon.setAttribute("points", '0,4 5,0 10,4');
                svg.appendChild(eAscIcon);
                var eDescIcon = document.createElementNS(SVG_NS, "polygon");
                eDescIcon.setAttribute("points", '0,6 5,10 10,6');
                svg.appendChild(eDescIcon);
                return svg;
            };
            //public createFolderOpen(size: number): HTMLElement {
            //    var svg = `<svg width="${size}" height="${size}" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1717 931q0-35-53-35h-1088q-40 0-85.5 21.5t-71.5 52.5l-294 363q-18 24-18 40 0 35 53 35h1088q40 0 86-22t71-53l294-363q18-22 18-39zm-1141-163h768v-160q0-40-28-68t-68-28h-576q-40 0-68-28t-28-68v-64q0-40-28-68t-68-28h-320q-40 0-68 28t-28 68v853l256-315q44-53 116-87.5t140-34.5zm1269 163q0 62-46 120l-295 363q-43 53-116 87.5t-140 34.5h-1088q-92 0-158-66t-66-158v-960q0-92 66-158t158-66h320q92 0 158 66t66 158v32h544q92 0 158 66t66 158v160h192q54 0 99 24.5t67 70.5q15 32 15 68z"/></svg>`;
            //    return _.loadTemplate(svg);
            //}
            //
            //public createFolderClosed(size: number): HTMLElement {
            //    var svg = `<svg width="${size}" height="${size}" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1600 1312v-704q0-40-28-68t-68-28h-704q-40 0-68-28t-28-68v-64q0-40-28-68t-68-28h-320q-40 0-68 28t-28 68v960q0 40 28 68t68 28h1216q40 0 68-28t28-68zm128-704v704q0 92-66 158t-158 66h-1216q-92 0-158-66t-66-158v-960q0-92 66-158t158-66h320q92 0 158 66t66 158v32h672q92 0 158 66t66 158z"/></svg>`;
            //    return _.loadTemplate(svg);
            //}
            SvgFactory.prototype.createFolderOpen = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAZpJREFUeNqkU0tLQkEUPjN3ShAzF66CaNGiaNEviFpLgbSpXf2ACIqgFkELaVFhtAratQ8qokU/oFVbMQtJvWpWGvYwtet9TWfu1QorvOGBb84M5/WdOTOEcw7tCKHBlT8sMIhr4BfLGXC4BrALM8QUoveHG9oPQ/NhwVCQbOjp0C5F6zDiwE7Aed/p5tKWruufTlY8bkqliqVN8wvH6wvhydWd5UYdkYCqqgaKotQTCEewnJuDBSqVmshOrWhKgCJVqeHcKtiGKdqTgGIOQmwGum7AxVUKinXKzX1/1y5Xp6g8gpe8iBxuGZhcKjyXQZIkmBkfczS62YnRQCKX75/b3t8QDNhD8QX83V5Ipe7Bybug2Pt5NJ7A4nEqGOQKT+Bzu0HTDNB1syUYYxCJy0kwzIRogb0rKjAiQVXXHLVQrqqvsZtsFu8hbyXwe73WeMQtO5GonJGxuiyeC+Oa4fF5PEirw9nbx9FdxtN5eMwkzcgRnoeCa9DVM/CvH/R2l+axkz3clQguOFjw1f+FUzEQCqJG2v3OHwIMAOW1JPnAAAJxAAAAAElFTkSuQmCC';
                return eImg;
            };
            SvgFactory.prototype.createFolderClosed = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAARlJREFUeNqsUz1PwzAUPDtOUASpYKkQVWcQA/+DhbLA32CoKAMSTAwgFsQfQWLoX4GRDFXGIiqiyk4e7wUWmg8phJPOtvzunc6WrYgIXaD06KKhij0eD2uqUxBeDC9OmcNKCYd7ujm7ryodXz5ong6UPpqcP9+O76y1vwS+7yOOY1jr0OttlQyiaB0n148TAyK9XFqkaboiSTEYDNnkDUkyKxkkiSQkzQbwsiyHcBXz+Tv6/W1m+QiSEDT1igTO5RBWYbH4rNwPw/AnQU5ek0EdCj33SgLjHEHYzoAkgfmHBDmZuktsQqHPvxN0MyCbbWjtIQjWWhlIj/QqtT+6QrSz+6ef9DF7VTwFzE2madnu5K2prt/5S4ABADcIlSf6Ag8YAAAAAElFTkSuQmCC';
                return eImg;
            };
            SvgFactory.prototype.createColumnIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAOCAYAAAAMn20lAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTcwQ0JFMzlENjZEMTFFNUFEQ0U5RDRCNjFFRENGMUMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTcwQ0JFM0FENjZEMTFFNUFEQ0U5RDRCNjFFRENGMUMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpFNzBDQkUzN0Q2NkQxMUU1QURDRTlENEI2MUVEQ0YxQyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpFNzBDQkUzOEQ2NkQxMUU1QURDRTlENEI2MUVEQ0YxQyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqDOrJYAAABxSURBVHjalJBBDsAgCAQXxXvj2/o/X9Cvmd4lUpV4MXroJMTAuihQSklVMSCysxSBW4uWKzjG6zZLDxrlWis5EVEThoWmi3N+nxAYs2WnXQY34L3HisMWPQlHB+2FPtNW6D/8+ziBRcroOXc0B/wEGABY6TPS1FU0bwAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createColumnsIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENFQkI4NDhENzJDMTFFNUJDNEVFRjgwRDI3MkU1Q0EiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENFQkI4NDlENzJDMTFFNUJDNEVFRjgwRDI3MkU1Q0EiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0VCQjg0NkQ3MkMxMUU1QkM0RUVGODBEMjcyRTVDQSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0VCQjg0N0Q3MkMxMUU1QkM0RUVGODBEMjcyRTVDQSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj6ozGQAAAAuSURBVHjaYmRgYPjPgBswQml8anBK/idGDQsxNpCghnTAOBoGo2EwGgZgABBgAHbrH/l4grETAAAAAElFTkSuQmCC';
                return eImg;
            };
            SvgFactory.prototype.createPinIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAedJREFUeNqkUktLG1EYPTN31CIN0oWbIAWhKJR0FXcG6gOqkKGKVvEXCKULC91YSBcK7jXgQoIbFxn3ErFgFlIfCxUsQsCoIJYEm9LWNsGmJjPTM+Oo44Aa6IUzd+bec77H+UYyTRP/s5SsLFfCCxEjOhD9CXw64ccXJj7nLleYaMSvaa/+Au9Y73P3RUUBDIuXyaAxGu35A7xnkM57A7icCZXIO8/nkVleRn1/f9cv0xzjfVclFdi9N8ZivfnDQxQKBTwoFvFicLCVQSesJIpHMEY8dSqQWa54Eov1fF9ZQVHXsZNMblhnNE/wPmJPIX1zjOG2+fkgslnozHR2eopLcSIe3yoD48y45FbIxoVJNjimyMehoW3T58PvdBq53V18zeWwFo+vUfyBlCVvj0Li4/M1DnaAUtXCQkNDR4f/294eaoTAwdHRCROMWlzJZfC+1cKcJF07b5o+btWvV1eDyVBouyUcDj5UFDg924tVYtERpz0mCkmSulOp1GQgEIj0yvKPYiKBlwMDQXfPU47walEEmb8z0a5p2qaiKMPEoz6ezQLdM8DWNDDzltym24YthHimquoshSoDicvzZkK9S+h48pjCN4ZhrBPHTptlD0qevezwdCtAHVHrMti4A7rr3eb+E2AAoGnGkgkzpg8AAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createPlusIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAatJREFUeNqkU71KA0EQ/vaiib+lWCiordidpSg+QHwDBSt7n8DGhwhYCPoEgqCCINomARuLVIqgYKFG5f6z68xOzrvzYuXA3P7MzLffN7unjDH4jw3xx91bQXuxU4woNDjUX7VgsFOIH3/BnHgC0J65AzwFjDpZgoG7vb7lMsPDq6MiuK+B+kjGwFpCUjwK1DIQ3/dl0ssVh5TTM0UJP8aBgBKGleSGIWyP0oKYRm3KPSgYJ0Q0EpEgCASA2WmWZQY3kazBmjP9UhBFEbTWAgA0f9W2yHeG+vrd+tqGy5r5xNTT9erSqpvfdxwHN7fXOQZ0QhzH1oWArLsfXXieJ/KTGEZLcbVaTVn9ALTOLk9L+mYX5lxd0Xh6eGyVgspK6APwI8n3x9hmNpORJOuBo5ah8GcTc7dAHmkhNpYQlpHr47Hq2NspA1yEwHkoO/MVYLMmWJNarjEUQBzQw7rPvardFC8tZuOEwwB4p9PHqXgCdm738sUDJPB8mnwKj7qCTtJ527+XyAs6tOf2Bb6SP0OeGxRTVMp2h9nweWMoKS20l3+QT/vwqfZbgAEAUCrnlLQ+w4QAAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createMinusIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAKVJREFUeNpi/P//PwMlgImBQjBqAAMDy3JGRgZGBoaZQGxMikZg3J0F4nSWHxC+cUBamvHXr18Zfv36Bca/f/8G43///oExKLphmImJieHagQMQF7QDiSwg/vnzJ8P3799RDPj79y+KRhhmBLr6I1DPNJABtxkYZM4xMFx7uXAhSX5/CtQD0gv0OgMfyCAgZgViZiL1/wXi30D8h3E0KVNuAECAAQDr51qtGxzf1wAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createMoveIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAoZJREFUeNpsU81rE0EUf7uzu2lNVJL6Eb0IBWusepqcKm3wEFkvxqDgQbwUtYeeg5cccwj4F7QKChEPipRcdMGDiaAoJAexLYViwYsfbU1JYkx3Zz98b8220Wbg7ez7vXm/mffmN9Kh1G2QGQOmMDiRyYEkSaCoKjDGdAAooOUdxzFsIcDzPPhSvgeO7YDrOLBRmQdlJHULVE0DNRSCvqFjUuHqhWP8+etvhR5m0CeengVhmiAsywdl2Dt03K1wZSrO220XaCaf8AFrQel32s0mrDcaWfovrq3Vc9OTvHj/Tb0Xzh6JxQwNyxtIgPXpqqJk94fDM+1Oh6CaEF4QTiIOGJ/DdQtBObsEmGxbll/rkCyDPDwMzW4XhHD88EH0NcRxDUeX4/qdnsi0s8Aas+kEp8Zg82pMkmpDigKbjSbQTD7hFL94/jin9ZRHBNLo3Wrt+uUkbzQsiEZVMPGKfv76DaawodnahkhY86+PNnXxs77ZgVOjMahWVuufi1NJRZhWvvT0beHGtQn++Nm7en+DzqXO8vfVxX+wsYnT/JWxWEe95P0eILsvkkdPKn4PUEBJmunILab5992PLVU++skoNmOniT7JX2Fkt5GM1EjqbMohXzQmqo7KwCQ6zYKiabu30PpQAnZ0HKSRMcMRwnBddw4ZOO4GLRYKFFdDhrrteTMMdWB9/QTdH8sIp0EKmNT4GWDjGZAPJ3TcrbBv+ibfwtwDqBvzYck/truxYjjLZRDflwLt7JUmEoAymdPV7INa5IXn0Uw+4f8PIqATMLQIWpQ0E/RFTmQ4nLx0B1Zfzrsr5eAmbLQW2hYpHwkcqfegNBJhzwY9sGC4aCZaF81CAvePAAMAcwtApJX/Wo0AAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createLeftIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAe9JREFUeNqkUz1oE2EYfu7uuyRKLCFt6g+4VNQWWod+mQRRR1En0UFOHKoNCMKNju4SEQsOzsFNcRGl4CS42AzaKhKcsqhk0Etj7u+773y/6+USbOLSF5574b33eX+e906L4xh7MaYeC/c/IFcowMznEzDTBGPMoldnqEFtkPy708mIqvHHe0s7BcaYJYSwRwPu9vbYRH1XJI4tEYb2jYtHOHko9LvdxE9cYZQcBoF9+9oJ7jgRQt+HFAJSyv9rkO6UkGvXF3mr9QelkpkUINsYR6T8Jrkay8i+b9+5yfnmppMmSFw6e4yrIynBBsdS3jQ1PH/zeTiBIt+9dZpvbTlZh1+Oh/Z3F33XRUj7R1GUxA3DwMx0EYHnDUUMPe9Rfe1tc26uiL6M8aXno+UH6O7PIShPIapMQx6sQMxW4JbL+MkKCKhwNgGN2FD7Pnz82j63coF/aoc4ekDHtxfrzUniaZrW/FfEBomI9Scv7fnVq7zdBwIqajBWpeTd99d3vgBNCaQSzMOLyJ+6ApSPWxSzD61a/MfThupSjVuvxk2A3sazYYGBGbML0OcvW9rMyeRLFO8eVGXnKyacMiug5ikSplLs05dXzqNQWpbv6/URjpK+m6JH3GhQQI2QI+RTmBO0EwQ/RUBcqe31d/4rwAB0lPTXqN6HzgAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createRightIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAfBJREFUeNqkUz1s00AU/hwSh1SEhiFCYuhCVSExgHRiYKjEVCEyMMGAsjCxZunesWM7dIgEA8JISPyoUhFDFoZOSE2GgtrSIAYWSEPb1HUS23c+8+7iuE5/JKQ+6fOdz/e+970fG2EY4jyWVo9b819hGEZ8WCgW4z2dV2lZFUJYgnNwz9PwXRebc3cGBMfN6XSQy+eHryyCMuv43dRpBCpSz7b1qlB+cI3RWkEYlv+LQFkgBLxuV8s9OAhQLk0w7vsnSHQKVMhqQuYRSRBouK5AqyXwpHSdvfywUYkKb8UEFIU9fXybOY6A+jbszGAP7O/7RBKg2eR4dH+KvV5ej0k0gaqobXO0214c3acUDnt99Pp9cKqDUqLsx68LuHd3gtU+b1eOCOiSaaZQKJjgMsSOy7EnJcSYCZnLwKbojic1weTVMXz81KhTexeSKdSXqrUzh2X84Qxr9SQmx1P48q6mnTPZrJUs4jMp5QlHlSd1Y203fRGFK8DPV28HzqZpjXShW3+D00bamCrpNU9DuvvcGsjea1rO+nvw39+AxRCGckyO8ciQFG8gPT27ptX8/b4gt1asYGdzRGE6MVCXCJcj5NShbG9B/NnYhttpyMYL5XmTYEdw1KgMFSgJJiEbIXNGPQXBi+CTrzTO+zv/E2AA3Y8Nbp4Kn1sAAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createColumnVisibleIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAdhJREFUeNrUk01LAlEUhu845QdRUxZBhIIWtFBso2AwRAVNLqKltHCb63b9A/9AixZCELhyYdAmEyYCBcOlNa1CSQoxog/DMY3x9p5B27Zw1YGH8XrO+55759wROOdsmLCwIWNoAwFh/ugfZQKsAQV4gbNf9woqIAeuQHOgGxgIMNix2Wx7iqIsxmKxWU3TxgqFgpWSsix3fT5fK5VKPedyuftOp5OE7oz60hHsYD8UCh3k83k5k8ksGYYx5XK5rK2WzgiIrPQf5aiGakljakVRjKDrZaPR6Oi6zglVVTlFMnnMZXmdK8o2x674IE+1pCHtCFx2w+GwE9u3drtd81yJRAKdDXZ4eGSuFxb87PHxjg3yVEsaNNolg5NSqTTVbDaX7Agq8Hg8TFWLbGVl0xTY7TY2Our5NfhCQPNAWtFisdSr1WqvWCwawWBwRpKkcZyXadoN83qXmSQ50V1jGxurpnGlUqnH4/FzvItTmoo5ApjQNMIOh2MrEon4o9Gov1arzZXL5XHKBwKBT7fbXU+n07fZbPa23W5f4BVd93o9TgYimATTMHHCbB5PN9ZSf0LmrsEHRDWInvB8w/oFvAv920iFDkBzF/64fHTjvoFOxsL//5h+BBgAwjbgRLl5ImwAAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createColumnHiddenIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0ZGNDRBMkJENkU3MTFFNUIwOTBGRTc0MTA3OTI2OEYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0ZGNDRBMkNENkU3MTFFNUIwOTBGRTc0MTA3OTI2OEYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3RkY0NEEyOUQ2RTcxMUU1QjA5MEZFNzQxMDc5MjY4RiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3RkY0NEEyQUQ2RTcxMUU1QjA5MEZFNzQxMDc5MjY4RiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PjQ0mkwAAACISURBVHjaYvz//z8DJYCJgUIwDAxgKSwspMwAIOYDYlcgtgNiJSBWBGJhIGaHyoHAJyD+CcRvgfg+EN8D4kNAvBtkwGEg1iNgkSCUlgBibSg7D4gvgwywRXKBChArALEIELMCsQBU8Qcg/g3Eb4D4ARDfBeKDMBeAnLcWikkGjKMpcRAYABBgACqXGpPEq63VAAAAAElFTkSuQmCC';
                return eImg;
            };
            SvgFactory.prototype.createColumnIndeterminateIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUY1QTkyNDUxRTkzMTFFNkFEQzVDNjE1NDE4RDlEQUMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUY1QTkyNDYxRTkzMTFFNkFEQzVDNjE1NDE4RDlEQUMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5RjVBOTI0MzFFOTMxMUU2QURDNUM2MTU0MThEOURBQyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5RjVBOTI0NDFFOTMxMUU2QURDNUM2MTU0MThEOURBQyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Por9Q7gAAAGzSURBVHja1JOxSwJRHMffqXcqSoVBQ0FDNN7iIBxO5WA3NYoEjm0u/T2Bkw2ONZlgNEk4Bw6GiGiippmRnp76+n4PbWhpcOoHH57P+36/7/e8n4qUUmxSLrFhbRygoJwPq6tsgRMQB0cgtNINQA0UwCMYrX3rAAUB516v9zIejx+nUqm90WgUDIfDaq1WE9PpdK6q6mc2m+0WCoUX7K/hu+O5TPCBq0gkUiqXy0PbtqVlWXK5XDqwuE4mEzmfzyU11NJDr3C73SZOfeh0OtPxeCyR7oixlzhdVqtV2ev1nCB+Tw219NDrQRtJwzBCaF+bzWbsSGQyGVEsFoWmacLj8YjBYCBisZhIp9MC3Qhq6YEmyQ5OTdO8bTQak263K8m69d+FIOc5tfTQywAvTrmIRqM3pVLptd1uy3q9/nN3slgsZLPZlHxGDbX00Ou8ApfLxbdh+P3+MyTriURC7/f7+7hCsFKpCF3XvwKBQCuXyz3n8/ln/Bb3yH9iOAPcYAfsIiSEsAOsh9hvA99qDizwAVMDphbWd+zfwFBZTSOFfqBxJv4YPk6cDcYMVv7/n+lbgAEAtdcjOjP715MAAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createGroupIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUVCNUI1OUNENkYwMTFFNThGNjJDNUE3ODIwMEZERDciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUVCNUI1OURENkYwMTFFNThGNjJDNUE3ODIwMEZERDciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1RUI1QjU5QUQ2RjAxMUU1OEY2MkM1QTc4MjAwRkRENyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1RUI1QjU5QkQ2RjAxMUU1OEY2MkM1QTc4MjAwRkRENyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PlkCTGoAAACDSURBVHjaYmRgYPjPgBswQun/+BT8X3x5DoZErG4KCj/3/DcMNZMNuRiYGPADRiRX4HYBJV5AB0QrhAGW//8hehgZES6FiaGLYzUAq7sxNf0nxQCsinHFAguegCPKBYxoYfAfWQxNnPgwINJVYMDEQCEYfLHASGoKRQlxPN7BqQggwAAN+SopPnDCwgAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createPivotIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAitJREFUeNqcU01rE1EUPfPVJjFqdYw2pJQkNS2hYhQUiwj+AaugKFYUBWutG3HjokgNrroRKYKbglBBFF0o1IW404qClGIDxpYKTQgULZJmmpiYkPnwvmtNspPmweOcmXnnvPPufSOdjsf7AfjR3PiOU6OjV50mh9CqtmVJDlkNjWU3tPXEiA6hlS3Lkm3HQbFYxO5hnTF0pQ3Bwa3MAxc98F9wMd95TsOOswpzoRFa1TJNyaKHtTUD07cNdv9wx6jtNDNW53N369xyOiC0qmmanMAwcjh+/yimrr/D28kjf8WLizjY3c38YzKJw729zKcTCU4gtLUE+Xwejy+94gWfl5agKQr8uo4Eccu2USr48SWVQq5QWE/gcAJZuIgF5XIF5yf7GfcGg9Cos4O3UoiFw2jFLrx+/wtRet+3nkJoOAEbkJtty5g484I+yUivrODekxb4tmuInZhCuFPHyHAXZubnUTXNWgKhlc1qlY+gaZsw9PwkY4fPhxsDXvxcrWL25TE8G+8DFAOxSAQHotG6AWlrRXS52vD08ifGr5kM1+BBPIBkOo3flQpaNA2zCwug+8MGdkMCPoLbvQ0DDw8xRgIBBNvbsUoF6yK+h+pQJpN91JH9PT2NCWS1Ui4rNhtswZubPxi/LS9TTWxemKTK/9t1jtramEBo1Vw226pRvEfj3oaL6v3vVRYaoZXcodA12ePpbOZXtEuljEToprmZprpBvehn4Y8AAwDB0mLL0M405wAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createAggregationIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAMZJREFUeNpi/P//PwMlgImBQjDwBrCgmMYENq8RiLVxqL8KxPX//v1DiIACEYYZGRlBmBOIe4B4PRDrQMUYoGyQGIoebAbADJkAxFuAWA9JXJdYA0CYC4inAPFOINZHlkPWgxKIcFMhQA0aFveB+DbOUERxDhQAbTEC4qNAPBfqEmRx3F6AAhOgojNAvBikGckumDiKHhY0B3ECcTVQQhRIg/B1NNeeB1IgQ7/BXYvmdE6oAnYcPv4NxF+BerAbMDTzAkCAAQChYIl8b86M1gAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createDropNotAllowedIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjUyQ0MxNDY0NjBDMTFFNkEzMUVGQUE3NkQzQzU4MjYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjUyQ0MxNDc0NjBDMTFFNkEzMUVGQUE3NkQzQzU4MjYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyNTJDQzE0NDQ2MEMxMUU2QTMxRUZBQTc2RDNDNTgyNiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoyNTJDQzE0NTQ2MEMxMUU2QTMxRUZBQTc2RDNDNTgyNiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PstpFisAAAGLSURBVHjalJNPKERRFMbnvRmKpAnjhURKWXjJLNQsqDE7KxI1NhYU2cjKxtbGZpSNqSFT/qxkYafmLWyU2LElCwYLo0SS8J36rk7XbJz61f33nXPuuec6ad8PWdYHJsEAaOPaDTgGeXCqD0cs8TqYCf21bjIHsmC2nIMCGOT4C3yCV44rQRXPS4BOkNIOchTL4RI4A0fggvtdYAj0g2qeFc10hKlNUXwF1sAOeALfdHCuxMZEsyoOFrjwTK8bTN3YMGvjcf7BzF3RukxHIl2DfSVuALvgQIn3wCJ44zwpDpqY/i2458YouARpzmV9BEyAExWk2RTRARUgxiuMqytsg3nWRCzMgL/PWATtoJfVr+PeHd/70OoJ6bxajotyhYCTmBJv8XVssdRljD0hFoiDDCcyfgcrjFyyxFGwBBI8K5YJ+573iEEriHOjBdSr55KoSbDM4ppekFrlHPWZCupJpcoP4IWCRt7bRA5MK7sqxRQ/irxIDegAPez7qDqbNeJyv1Huvvmf7/wjwABtLlYtICx9HQAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createGroupIcon12 = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTNFQzE0NTdEOTk1MTFFNUI4MjJGMjBFRDk4MkMxNjAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTNFQzE0NThEOTk1MTFFNUI4MjJGMjBFRDk4MkMxNjAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxM0VDMTQ1NUQ5OTUxMUU1QjgyMkYyMEVEOTgyQzE2MCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxM0VDMTQ1NkQ5OTUxMUU1QjgyMkYyMEVEOTgyQzE2MCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PiInRbAAAAEjSURBVHjaYuTi5XqkpKvI9/fXHwZWDlaGZ/eeM7x59raDAQj4pOQrBBUVGP78+MfAzMbE8PLKhU8Mhnb6/6//P/f/8N/d/x8AWUn1cf+BaleCsFPt5P/T/v//3/zj//8JQFrB1vM/I5IN3EAbfgBt+Au0QRBqw3sMG0DiQMwPxFuB2BzKZmLAAViA+BOU/QOI7wPxRyhfCIhT0NT/ZETi7AZiZiD+DOXL6EdlGdkWFzF8evaDgUuIg2F9eiTYBrhuIJ4NxHegfDsgnobuJGQbNgBxMRDfhfLFgDgB3UnInPVALMxAACDbcBGItwDxAyhfCRismejBiuyHiUBsDMQmUL6cSXIJf0hTDsNboEN42RkYJth58TPisV0eaMNFdBsAAgwANVJzd8zQrUcAAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createCutIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAlRJREFUeNqkU09okmEcfj6ThNRhjUEJDhxDZ1t4sI3lDrKDhESHpC6x6yBoh52GfcdBJDvtElEUdKhOSq1JjF0SabSton9OmIeRxVKIrUgdU5xvv8e+hXXYpRcefv+e5/mh7/tpSin8z9Gi0Sg0TTsv+edarfa+Wq2iUqmgXC6DudVqhd1uh81ma+UWi8Uv3G5ZPJ9MJmGq1+twOBynBOek6T9oG+fkkU8djymVSiGTyWBiYuL6QSb7YvLIp679+D0ej57NZpX8JD0QCPj7+vrgcrnAyJp9zskj3zD928Tr9er5fF5FIhFdiH4aMLJmn/N98R+Dq5qGSUFQwKFs1AuFggqFQrrT6bzIyJp9zoMGn7qWQU6ST4JNQeK3kd/n8+nFYlGFw+HFdDqtWLOfMHjk5wwDjckRwGYGeJVnBMdXgaNrbveJKysr/etu91pHtVo8BnyXWUnwsgHM7wAVX7MJ0cEmjWvW4eGzjpGRXnNnZ8cFeRi9pRI+dnXtjMbj/cLp57rG1tbPH0tLwd3l5QHp3RBU8E7Txr4MDb1V8bh60tOzfhN4vTc9rRYkCm4tGDX7nJNHPnWt/+CFpt1rF9emptScxKfA2DNZwThn9NtNWjoxMH1Tqru+va02NzbK47FY4PHMzJtdYPYD8OChGDCyZp9z8sinrnWXt4E7q4ODRbrelw0x2Xjyn1fImn3OySOfutYt+IDRSeCycAZeAYm7wKLkshR87A1+cILDAss4EDkNXJI8Ows8yin1nENn+5MXNA3hnpHzHBKYjWhqe4lffwkwAMRcPMqRQZ4vAAAAAElFTkSuQmCC';
                return eImg;
            };
            SvgFactory.prototype.createCopyIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgBJREFUeNqMk79rFEEcxd/M7V2QAzVFEOMFGwNiIGCjEdIEhYODmEawsFf8G4QQSCPYyqUWCdhY2qSQECSpInvFJYT8Ki6dZO8Sb2P29pfvu+4sm+UKv/AYZna/b95ndla9WFyEUmoewG0Mr+9hGB5EYYhypZIseO0fCHa3sP/LhxVFkazd+by0tOIFAQac+3w5imPYto1Pa2tv+VxR+8bRuv8EevIRxn5uQoszpWI2RjSIBgMMLi/hui76/T6+Li+v8Pkz9k0Wo409pFHAJooUCiWqYlk46nTQ2ttD+/gY75pNPKjVmmfd7gf2vKbu5U0sMWBpzWatNcAkv7n789lZ1GdmMqQ3cbxApIUikg58H5S0JgkSE/L/L1JmoNJmMZEDzCNdK5cxwtFxHHxcXcXTqalm27Zf7rRaRKBBhkAhxcgjiYlUo16HfKlqtYpv29u95Az81EClCFLyaQ0SCib/dtNJ6qsGfDmJnRqoXIKiyVUDz8sSSGy5VnI3ikh5k1KplBnog/V19BxnRCZmV15dGCSdO1wziphcS3rrT7d71zk5Ob8+Pf3eMN4aH3/8qtGYM0hp7iyJbO0bBOrMPTz8kl6OpGoTEzEncwapaCLrRNfu6Wli0Etl6mbfdb0MiYrlXsjZyAUTE0qwOxsbo9aQ3/dGEWlYRRcX5xxG/wowAC8cIjzfyA4lAAAAAElFTkSuQmCC';
                return eImg;
            };
            SvgFactory.prototype.createPasteIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAadJREFUeNpinGLPAAaMjAxwcJ9Tk+0Bt7YPkCkKFXqt8PXqFsXv13/B1Pz/D6FZENoYZgKxMYgh9OI6i567q5hFUp4kiH9i3qTnT3auqWPgZ/gDVXsWiNPBFk+2hxtwxi0syfjy5csM0vFzGTg42Bj4+XnAEh8/fmH48eMXw9OFyQy6uroMu1bNAxlgAnbB338IJ6hlzWU4uXgJw6FDO4Ga+Rl4eXkZWFlZGb58/crw6eNHBjG7Iga1yAiG7SvmwfWw/P2LMADkraiYaIb79+4xYAOKSkpgNch6UFzwFxgy//79Y5BTUMBqwF+g3H8mJgZkPSgu+Ac04M+/fwz4AAswulBc8Ocfqg1/kGWxAEagAch6WP78RfUCIQOYmJkZ/qC44A+qAb8JeIEZZMkfXC4gwgsQNUgG/CbRC2BXIhvw8AsDgzQnkgEEvACxBMJ++h0YJmufMTA8ABry8xckGkFOxIdBakBqQXpAekGZiXPTSwbeUAEgB5hsObm58acDoJp3nxkYNn1gEANyP4MNAGKxh18ZbsXxsjMQA97/Z7gF0gPEfwACDAB/y9xB1I3/FQAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createMenuIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjM3MUVBMzlERkJEMTFFNUEwMjFFNDJDMDlCMUY3OTciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjM3MUVBM0FERkJEMTFFNUEwMjFFNDJDMDlCMUY3OTciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCMzcxRUEzN0RGQkQxMUU1QTAyMUU0MkMwOUIxRjc5NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCMzcxRUEzOERGQkQxMUU1QTAyMUU0MkMwOUIxRjc5NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pux7nZcAAAGtSURBVHjalFM9a8JQFL0veYkfYJUQEYuIIF07uToVpGuHOgid3dJN+i+K4C6CXQqFjplcCoKbXZ0EqRUFP/CTxCS9NzTdNOmBx32P3Nx3zj33sXq9/tRqtbRYLCaLomhBANi2La5WK7NSqTRYNpt1LMsCLACO47iLMXY2CoIAm80GZFkGoVQqfWy3WzBNE6gQVveNhmHAbreDYrHYZaPRKKTr+i0ykTDBPnUzgfYEvFkYDAZWoVDQWb/fB9QD6XQajscjBCkQDodhOBzCcrkEVq1WXfoEL9EPlEdSZrMZ8Pl8frVYLO7QgRB+sPx+/GUk4qUGNvOdYSO+JpPJJdHyc8ADnUluIpH45vv9XiFbiFIQC71IjuBe5ZlM5gYlPHLOL7C4AcEgofXbXC7X4PF4vKuqahf+AWJxOBwgEokA6/V67kFRFFcGLU/SqShJkusATSNbr9fQ6XSuU6mUQP3BBIaJZyM6BuPx2Mnn85+sVqu9ttvt+2QyGXgOqInT6RTK5fIbwwl0iFI0Gv2btCA9QPdcOVzTtOdms/mAnnKkaAexES0UcG/hc375EWAA94tOP0vEOEcAAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createCheckboxCheckedIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFQ0VGQkU3ODM4MTFFNjExQjlCQzhERUVDNkNGMzFDMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBRkJCRDU1MTEyM0ExMUU2ODE4MUUyOTNBNTRGQkIxNyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBRkJCRDU1MDEyM0ExMUU2ODE4MUUyOTNBNTRGQkIxNyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjIzMkM4M0M1M0MxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVDRUZCRTc4MzgxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+riMaEQAAAL5JREFUeNqUks0JhDAQhSd7tgtLMDUIyTXF2IdNWIE3c0ruYg9LtgcPzvpEF8SfHR8MGR75hpcwRERmrjQXCyutDKUQAkuFu2AUpsyiJ1JK0UtycRgGMsbsPBFYVRVZaw/+7Zu895znOY/j+PPWT7oGp2lirTU3TbPz/4IAAGLALeic47Ztlx7RELHrusPAAwgoy7LlrOuay7I8TXIadYOLouC+7+XgBiP2lTbw0crFGAF9ANq1kS75G8xXgAEAiqu9OeWZ/voAAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createCheckboxCheckedReadOnlyIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTZENDVDNkY0NDVFMTFFNkI1MjZCRkJDQ0FEMUEyNDMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTZENDVDNzA0NDVFMTFFNkI1MjZCRkJDQ0FEMUEyNDMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1NkQ0NUM2RDQ0NUUxMUU2QjUyNkJGQkNDQUQxQTI0MyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1NkQ0NUM2RTQ0NUUxMUU2QjUyNkJGQkNDQUQxQTI0MyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PiE1TFsAAAGLSURBVHjadJI9a8JQFIbfSFBBakDaDg5O0nay4OSPsEFoCq4JODhUShd3F9emFreKqJOlS6Xg4OB/cIkZijjXwRa/uthzLokESS683I+cJ+fec15pv9/DHfP5/JSmR1KedOEcW6QP0nMqlfp2YyUXJOiWpleSAv/xQzIIfudNyAO9+UHr9Rrtdhuz2SzOMU4sQrQ4o7nF2f3SDIdD1Ot19Ho9ODEtYs454z0p7gdNp1OYpontdot0Ou0ec+wDgyrvlsslxuPxAdpsNmg0GnxFVCoVaJrm/WeewSte9ft9lMtljEYj8YWvNhgMkMvloOs6ZFn2gpeHnaIoohDNZhO73Q7dbhfRaBTVahWJROL4FX+y06frQqGAyWSCTqcDy7KwWq1Qq9WQzWb9nv8VcpqLcDgsrprJZASkqiqKxWJAS/HJ4IvTXCSTSRiGISpYKpUQiUSCjPAknOMxgLRYLGDbtsgci8WOIbbZHbvHaznNMcJJwPV+SbprOSnA5Ddccq4eyeY3kUyvyf8FGAAA/p3KIKgjXwAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createCheckboxUncheckedIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFQ0VGQkU3ODM4MTFFNjExQjlCQzhERUVDNkNGMzFDMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2MkU1Rjk1NDExNDExMUU2ODhEQkMyRTJGOUNGODYyQyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2MkU1Rjk1MzExNDExMUU2ODhEQkMyRTJGOUNGODYyQyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjI1MkM4M0M1M0MxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVDRUZCRTc4MzgxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+t+CXswAAAFBJREFUeNrsksENwDAIA023a9YGNqlItkixlAFIn1VOMv5wvACAOxOZWUwsB6Gqswp36QivJNhBRHDhI0f8j9jNrCy4O2twNMobT/7QeQUYAFaKU1yE2OfhAAAAAElFTkSuQmCC';
                return eImg;
            };
            SvgFactory.prototype.createCheckboxUncheckedReadOnlyIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjE4MjE1MTc0NDVFMTFFNjgyNzA5QzQ5MjBBRTM0QTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NjE4MjE1MTg0NDVFMTFFNjgyNzA5QzQ5MjBBRTM0QTkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2MTgyMTUxNTQ0NUUxMUU2ODI3MDlDNDkyMEFFMzRBOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2MTgyMTUxNjQ0NUUxMUU2ODI3MDlDNDkyMEFFMzRBOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PoIZc5kAAADFSURBVHjaYvz//z8DDDx69EgESBUBsQ8Qq0GFbwDxJiCeJCcn9wamlhGmEagpGEjNBWJ+BuzgExAnATWvhWuEaloN4jPgByBbQkGaGR8+fCgK5NwBYj4G4gDIZlUmIJFLgiYGqNoCkEY/BtKBD0ijBhka1ZkYyAO/mKDxRCq4xwSNXFLBVlB0iAEZt0mODmBkvgKlCGjkMhCRAECp5xU4cKDJKAyIP+PR9BmWalDSKloi9wUFOSj0gPgWyE9APBE5kQMEGAD0/UBfnjaiGAAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createCheckboxIndeterminateIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFQ0VGQkU3ODM4MTFFNjExQjlCQzhERUVDNkNGMzFDMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGMjU4MzhGQjEyM0ExMUU2QjAxM0Q2QjZFQ0IzNzM4NiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGMjU4MzhGQTEyM0ExMUU2QjAxM0Q2QjZFQ0IzNzM4NiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjIzMkM4M0M1M0MxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVDRUZCRTc4MzgxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+2Xml2QAAAGBJREFUeNpiYGBg8ATiZ0D8n0j8DKqH4dnhw4f/EwtAakF6GEGmAAEDKYCRkZGBiYFMQH+NLNjcjw2ghwMLIQWDx48Do/H5kSNHiNZw9OhREPUCRHiBNJOQyJ+A9AAEGACqkFldNkPUwwAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createCheckboxIndeterminateReadOnlyIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Nzg3RjczNTA0NDVFMTFFNkE4Q0NDN0E3NUI3Qjk5QjIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Nzg3RjczNTE0NDVFMTFFNkE4Q0NDN0E3NUI3Qjk5QjIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3ODdGNzM0RTQ0NUUxMUU2QThDQ0M3QTc1QjdCOTlCMiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3ODdGNzM0RjQ0NUUxMUU2QThDQ0M3QTc1QjdCOTlCMiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhD2+R8AAADRSURBVHjaYvz//z8DDDx69EgESBUBsQ8Qq0GFbwDxJiCeJCcn9wamlhGmEagpGEjNBWJ+BuzgExAnATWvhWuEaloN4jPgByBbQkGaGR8+fCgK5NwBYj4G4gDIZlUmIJFLgiYGqNoCkEY/BtKBDwuQ0IDx5OXl8aoGegvGVGdiIA/8YoHGkz6aiYTAPSZo5JIKtoKiQwzIuE1ydAAj8xUoRUAjl4GIBABKPa/AgQNNRmFA/BmPps+wVIOSVtESuS8oyEGhB8S3QH4C4onIiRwgwABzikY1hHfO+QAAAABJRU5ErkJggg==';
                return eImg;
            };
            SvgFactory.prototype.createGroupExpandedIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NzBBODQ4M0ExMjM4MTFFNkFDNEJDMjUzQUJBQ0I2QjkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzBBODQ4M0IxMjM4MTFFNkFDNEJDMjUzQUJBQ0I2QjkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MEE4NDgzODEyMzgxMUU2QUM0QkMyNTNBQkFDQjZCOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3MEE4NDgzOTEyMzgxMUU2QUM0QkMyNTNBQkFDQjZCOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhKAo60AAADVSURBVHjajFC9DkRgEJzzFhqiligURKcjR+UFJK7wGN7jOq+glXgCvSgUCnyVn47GHsVdcURsss3s7OzOPEzTdB3HeTPGeMMw0DQNOI4Dz/PI8xyWZSGO4y4MwxeSJGnruqarGseRNE1r4fv+YSgIwgErioJwpgrggHmeR7Bt+xZ5GAbCNE2/0zvpv78v6bpOUFX1lvK6roQz92dkWZYJiqLcSmOeZ9qDb6uqusx5WRaSJIlBFEUnTdNuC536vifXdaksSwqCgLIsoyiKdnNs23l+BBgAK/54I/P5bhMAAAAASUVORK5CYII=';
                return eImg;
            };
            SvgFactory.prototype.createGroupContractedIcon = function () {
                var eImg = document.createElement('img');
                eImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0U2QUVBRDYxMjM4MTFFNjk3NjVBRUM0MUJDRjFCODgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0U2QUVBRDcxMjM4MTFFNjk3NjVBRUM0MUJDRjFCODgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3RTZBRUFENDEyMzgxMUU2OTc2NUFFQzQxQkNGMUI4OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3RTZBRUFENTEyMzgxMUU2OTc2NUFFQzQxQkNGMUI4OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhjzsKsAAADSSURBVHjajJAvioVgFMXPuAuLYhYMBsVmU54mNyA4wWW4j2luwSq4ArsYDAZ9X/JP0+KZ58CkgTffD264l3MPnPPh+34cRdGXEEL1PA/TNEFRFKiqirZtEQQByrJ85nn+iaqq5nEc+Y5t2+g4zow0TSlD13XEf66/JElChGEoJV7Xldj3/WfRNI0A/sx9v3Fdl7BtW8r5ui6CkpimSViWJSU+joN38fMwDG+F53nSMAwBXdejuq6fr9K5LAvjOGbf98yyjE3TsCiKO5x4/Ty+BRgA3R6JXc/jqsQAAAAASUVORK5CYII=';
                return eImg;
            };
            return SvgFactory;
        }();
        exports.SvgFactory = SvgFactory;
        // i couldn't figure out how to not make these blurry
        /*function createPlusMinus(plus: boolean) {
         var eSvg = document.createElementNS(SVG_NS, "svg");
         var size = "14";
         eSvg.setAttribute("width", size);
         eSvg.setAttribute("height", size);

         var eRect = document.createElementNS(SVG_NS, "rect");
         eRect.setAttribute('x', '1');
         eRect.setAttribute('y', '1');
         eRect.setAttribute('width', '12');
         eRect.setAttribute('height', '12');
         eRect.setAttribute('rx', '2');
         eRect.setAttribute('ry', '2');
         eRect.setAttribute('fill', 'none');
         eRect.setAttribute('stroke', 'black');
         eRect.setAttribute('stroke-width', '1');
         eRect.setAttribute('stroke-linecap', 'butt');
         eSvg.appendChild(eRect);

         var eLineAcross = document.createElementNS(SVG_NS, "line");
         eLineAcross.setAttribute('x1','2');
         eLineAcross.setAttribute('x2','12');
         eLineAcross.setAttribute('y1','7');
         eLineAcross.setAttribute('y2','7');
         eLineAcross.setAttribute('stroke','black');
         eLineAcross.setAttribute('stroke-width', '1');
         eLineAcross.setAttribute('stroke-linecap', 'butt');
         eSvg.appendChild(eLineAcross);

         if (plus) {
         var eLineDown = document.createElementNS(SVG_NS, "line");
         eLineDown.setAttribute('x1','7');
         eLineDown.setAttribute('x2','7');
         eLineDown.setAttribute('y1','2');
         eLineDown.setAttribute('y2','12');
         eLineDown.setAttribute('stroke','black');
         eLineDown.setAttribute('stroke-width', '1');
         eLineDown.setAttribute('stroke-linecap', 'butt');
         eSvg.appendChild(eLineDown);
         }

         return eSvg;
         }*/
        function createPolygonSvg(points, width) {
            var eSvg = createIconSvg(width);
            var eDescIcon = document.createElementNS(SVG_NS, "polygon");
            eDescIcon.setAttribute("points", points);
            eSvg.appendChild(eDescIcon);
            return eSvg;
        }
        // util function for the above
        function createIconSvg(width) {
            var eSvg = document.createElementNS(SVG_NS, "svg");
            if (width > 0) {
                eSvg.setAttribute("width", width);
                eSvg.setAttribute("height", width);
            } else {
                eSvg.setAttribute("width", "10");
                eSvg.setAttribute("height", "10");
            }
            return eSvg;
        }
        function createCircle(fill) {
            var eSvg = createIconSvg();
            var eCircle = document.createElementNS(SVG_NS, "circle");
            eCircle.setAttribute("cx", "5");
            eCircle.setAttribute("cy", "5");
            eCircle.setAttribute("r", "5");
            eCircle.setAttribute("stroke", "black");
            eCircle.setAttribute("stroke-width", "2");
            if (fill) {
                eCircle.setAttribute("fill", "black");
            } else {
                eCircle.setAttribute("fill", "none");
            }
            eSvg.appendChild(eCircle);
            return eSvg;
        }

        /***/ },
    /* 298 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var context_1 = __webpack_require__(244);
        var cellRendererFactory_1 = __webpack_require__(293);
        /** Class to use a cellRenderer. */
        var CellRendererService = function () {
            function CellRendererService() {}
            /** Uses a cellRenderer, and returns the cellRenderer object if it is a class implementing ICellRenderer.
             * @cellRendererKey: The cellRenderer to use. Can be: a) a class that we call 'new' on b) a function we call
             *                   or c) a string that we use to look up the cellRenderer.
             * @params: The params to pass to the cell renderer if it's a function or a class.
             * @eTarget: The DOM element we will put the results of the html element into *
             * @return: If options a, it returns the created class instance */
            CellRendererService.prototype.useCellRenderer = function (cellRendererKey, eTarget, params) {
                var cellRenderer = this.lookUpCellRenderer(cellRendererKey);
                if (utils_1.Utils.missing(cellRenderer)) {
                    // this is a bug in users config, they specified a cellRenderer that doesn't exist,
                    // the factory already printed to console, so here we just skip
                    return;
                }
                var resultFromRenderer;
                var iCellRendererInstance = null;
                this.checkForDeprecatedItems(cellRenderer);
                // we check if the class has the 'getGui' method to know if it's a component
                var rendererIsAComponent = this.doesImplementICellRenderer(cellRenderer);
                // if it's a component, we create and initialise it
                if (rendererIsAComponent) {
                    var CellRendererClass = cellRenderer;
                    iCellRendererInstance = new CellRendererClass();
                    this.context.wireBean(iCellRendererInstance);
                    if (iCellRendererInstance.init) {
                        iCellRendererInstance.init(params);
                    }
                    resultFromRenderer = iCellRendererInstance.getGui();
                } else {
                    // otherwise it's a function, so we just use it
                    var cellRendererFunc = cellRenderer;
                    resultFromRenderer = cellRendererFunc(params);
                }
                if (resultFromRenderer === null || resultFromRenderer === '') {
                    return;
                }
                if (utils_1.Utils.isNodeOrElement(resultFromRenderer)) {
                    // a dom node or element was returned, so add child
                    eTarget.appendChild(resultFromRenderer);
                } else {
                    // otherwise assume it was html, so just insert
                    eTarget.innerHTML = resultFromRenderer;
                }
                return iCellRendererInstance;
            };
            CellRendererService.prototype.checkForDeprecatedItems = function (cellRenderer) {
                if (cellRenderer && cellRenderer.renderer) {
                    console.warn('ag-grid: colDef.cellRenderer should not be an object, it should be a string, function or class. this ' + 'changed in v4.1.x, please check the documentation on Cell Rendering, or if you are doing grouping, look at the grouping examples.');
                }
            };
            CellRendererService.prototype.doesImplementICellRenderer = function (cellRenderer) {
                // see if the class has a prototype that defines a getGui method. this is very rough,
                // but javascript doesn't have types, so is the only way!
                return cellRenderer.prototype && 'getGui' in cellRenderer.prototype;
            };
            CellRendererService.prototype.lookUpCellRenderer = function (cellRendererKey) {
                if (typeof cellRendererKey === 'string') {
                    return this.cellRendererFactory.getCellRenderer(cellRendererKey);
                } else {
                    return cellRendererKey;
                }
            };
            __decorate([context_1.Autowired('cellRendererFactory'), __metadata('design:type', cellRendererFactory_1.CellRendererFactory)], CellRendererService.prototype, "cellRendererFactory", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], CellRendererService.prototype, "context", void 0);
            CellRendererService = __decorate([context_1.Bean('cellRendererService'), __metadata('design:paramtypes', [])], CellRendererService);
            return CellRendererService;
        }();
        exports.CellRendererService = CellRendererService;

        /***/ },
    /* 299 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var ValueFormatterService = function () {
            function ValueFormatterService() {}
            ValueFormatterService.prototype.formatValue = function (column, rowNode, $scope, rowIndex, value) {
                var formatter;
                var colDef = column.getColDef();
                // if floating, give preference to the floating formatter
                if (rowNode.floating) {
                    formatter = colDef.floatingCellFormatter ? colDef.floatingCellFormatter : colDef.cellFormatter;
                } else {
                    formatter = colDef.cellFormatter;
                }
                var result = null;
                if (formatter) {
                    var params = {
                        value: value,
                        node: rowNode,
                        column: column,
                        $scope: $scope,
                        rowIndex: rowIndex,
                        api: this.gridOptionsWrapper.getApi(),
                        context: this.gridOptionsWrapper.getContext()
                    };
                    result = formatter(params);
                }
                return result;
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], ValueFormatterService.prototype, "gridOptionsWrapper", void 0);
            ValueFormatterService = __decorate([context_1.Bean('valueFormatterService'), __metadata('design:paramtypes', [])], ValueFormatterService);
            return ValueFormatterService;
        }();
        exports.ValueFormatterService = ValueFormatterService;

        /***/ },
    /* 300 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var component_1 = __webpack_require__(285);
        var rowNode_1 = __webpack_require__(265);
        var utils_1 = __webpack_require__(245);
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var svgFactory_1 = __webpack_require__(297);
        var svgFactory = svgFactory_1.SvgFactory.getInstance();
        var CheckboxSelectionComponent = function (_super) {
            __extends(CheckboxSelectionComponent, _super);
            function CheckboxSelectionComponent() {
                _super.call(this, "<span class=\"ag-selection-checkbox\"/>");
            }
            CheckboxSelectionComponent.prototype.createAndAddIcons = function () {
                this.eCheckedIcon = utils_1.Utils.createIconNoSpan('checkboxChecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxCheckedIcon);
                this.eUncheckedIcon = utils_1.Utils.createIconNoSpan('checkboxUnchecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxUncheckedIcon);
                this.eIndeterminateIcon = utils_1.Utils.createIconNoSpan('checkboxIndeterminate', this.gridOptionsWrapper, null, svgFactory.createCheckboxIndeterminateIcon);
                var eGui = this.getGui();
                eGui.appendChild(this.eCheckedIcon);
                eGui.appendChild(this.eUncheckedIcon);
                eGui.appendChild(this.eIndeterminateIcon);
            };
            CheckboxSelectionComponent.prototype.onSelectionChanged = function () {
                var state = this.rowNode.isSelected();
                utils_1.Utils.setVisible(this.eCheckedIcon, state === true);
                utils_1.Utils.setVisible(this.eUncheckedIcon, state === false);
                utils_1.Utils.setVisible(this.eIndeterminateIcon, typeof state !== 'boolean');
            };
            CheckboxSelectionComponent.prototype.onCheckedClicked = function () {
                this.rowNode.setSelected(false);
            };
            CheckboxSelectionComponent.prototype.onUncheckedClicked = function (event) {
                this.rowNode.setSelectedParams({ newValue: true, rangeSelect: event.shiftKey });
            };
            CheckboxSelectionComponent.prototype.onIndeterminateClicked = function (event) {
                this.rowNode.setSelectedParams({ newValue: true, rangeSelect: event.shiftKey });
            };
            CheckboxSelectionComponent.prototype.init = function (params) {
                this.createAndAddIcons();
                this.rowNode = params.rowNode;
                this.onSelectionChanged();
                // we don't want the row clicked event to fire when selecting the checkbox, otherwise the row
                // would possibly get selected twice
                this.addGuiEventListener('click', function (event) {
                    return event.stopPropagation();
                });
                // likewise we don't want double click on this icon to open a group
                this.addGuiEventListener('dblclick', function (event) {
                    return event.stopPropagation();
                });
                this.addDestroyableEventListener(this.eCheckedIcon, 'click', this.onCheckedClicked.bind(this));
                this.addDestroyableEventListener(this.eUncheckedIcon, 'click', this.onUncheckedClicked.bind(this));
                this.addDestroyableEventListener(this.eIndeterminateIcon, 'click', this.onIndeterminateClicked.bind(this));
                this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this));
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], CheckboxSelectionComponent.prototype, "gridOptionsWrapper", void 0);
            return CheckboxSelectionComponent;
        }(component_1.Component);
        exports.CheckboxSelectionComponent = CheckboxSelectionComponent;

        /***/ },
    /* 301 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var utils_1 = __webpack_require__(245);
        var column_1 = __webpack_require__(253);
        var SetLeftFeature = function () {
            function SetLeftFeature(columnOrGroup, eCell) {
                this.destroyFunctions = [];
                this.columnOrGroup = columnOrGroup;
                this.eCell = eCell;
                this.init();
            }
            SetLeftFeature.prototype.init = function () {
                var _this = this;
                var listener = this.onLeftChanged.bind(this);
                this.columnOrGroup.addEventListener(column_1.Column.EVENT_LEFT_CHANGED, listener);
                this.destroyFunctions.push(function () {
                    _this.columnOrGroup.removeEventListener(column_1.Column.EVENT_LEFT_CHANGED, listener);
                });
                this.onLeftChanged();
            };
            SetLeftFeature.prototype.onLeftChanged = function () {
                var newLeft = this.columnOrGroup.getLeft();
                if (utils_1.Utils.exists(newLeft)) {
                    this.eCell.style.left = this.columnOrGroup.getLeft() + 'px';
                } else {
                    this.eCell.style.left = '';
                }
            };
            SetLeftFeature.prototype.destroy = function () {
                this.destroyFunctions.forEach(function (func) {
                    func();
                });
            };
            return SetLeftFeature;
        }();
        exports.SetLeftFeature = SetLeftFeature;

        /***/ },
    /* 302 */
    /***/ function(module, exports) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var MethodNotImplementedException = function () {
            function MethodNotImplementedException() {}
            return MethodNotImplementedException;
        }();
        exports.MethodNotImplementedException = MethodNotImplementedException;

        /***/ },
    /* 303 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var constants_1 = __webpack_require__(246);
        var columnController_1 = __webpack_require__(251);
        var floatingRowModel_1 = __webpack_require__(264);
        var utils_1 = __webpack_require__(245);
        var gridRow_1 = __webpack_require__(272);
        var gridCell_1 = __webpack_require__(271);
        var CellNavigationService = function () {
            function CellNavigationService() {}
            CellNavigationService.prototype.getNextCellToFocus = function (key, lastCellToFocus) {
                switch (key) {
                    case constants_1.Constants.KEY_UP:
                        return this.getCellAbove(lastCellToFocus);
                    case constants_1.Constants.KEY_DOWN:
                        return this.getCellBelow(lastCellToFocus);
                    case constants_1.Constants.KEY_RIGHT:
                        return this.getCellToRight(lastCellToFocus);
                    case constants_1.Constants.KEY_LEFT:
                        return this.getCellToLeft(lastCellToFocus);
                    default:
                        console.log('ag-Grid: unknown key for navigation ' + key);
                }
            };
            CellNavigationService.prototype.getCellToLeft = function (lastCell) {
                var colToLeft = this.columnController.getDisplayedColBefore(lastCell.column);
                if (!colToLeft) {
                    return null;
                } else {
                    return new gridCell_1.GridCell(lastCell.rowIndex, lastCell.floating, colToLeft);
                }
            };
            CellNavigationService.prototype.getCellToRight = function (lastCell) {
                var colToRight = this.columnController.getDisplayedColAfter(lastCell.column);
                // if already on right, do nothing
                if (!colToRight) {
                    return null;
                } else {
                    return new gridCell_1.GridCell(lastCell.rowIndex, lastCell.floating, colToRight);
                }
            };
            CellNavigationService.prototype.getRowBelow = function (lastRow) {
                // if already on top row, do nothing
                if (this.isLastRowInContainer(lastRow)) {
                    if (lastRow.isFloatingBottom()) {
                        return null;
                    } else if (lastRow.isNotFloating()) {
                        if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_BOTTOM)) {
                            return new gridRow_1.GridRow(0, constants_1.Constants.FLOATING_BOTTOM);
                        } else {
                            return null;
                        }
                    } else {
                        if (this.rowModel.isRowsToRender()) {
                            return new gridRow_1.GridRow(0, null);
                        } else if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_BOTTOM)) {
                            return new gridRow_1.GridRow(0, constants_1.Constants.FLOATING_BOTTOM);
                        } else {
                            return null;
                        }
                    }
                } else {
                    return new gridRow_1.GridRow(lastRow.rowIndex + 1, lastRow.floating);
                }
            };
            CellNavigationService.prototype.getCellBelow = function (lastCell) {
                var rowBelow = this.getRowBelow(lastCell.getGridRow());
                if (rowBelow) {
                    return new gridCell_1.GridCell(rowBelow.rowIndex, rowBelow.floating, lastCell.column);
                } else {
                    return null;
                }
            };
            CellNavigationService.prototype.isLastRowInContainer = function (gridRow) {
                if (gridRow.isFloatingTop()) {
                    var lastTopIndex = this.floatingRowModel.getFloatingTopRowData().length - 1;
                    return lastTopIndex === gridRow.rowIndex;
                } else if (gridRow.isFloatingBottom()) {
                    var lastBottomIndex = this.floatingRowModel.getFloatingBottomRowData().length - 1;
                    return lastBottomIndex === gridRow.rowIndex;
                } else {
                    var lastBodyIndex = this.rowModel.getRowCount() - 1;
                    return lastBodyIndex === gridRow.rowIndex;
                }
            };
            CellNavigationService.prototype.getRowAbove = function (lastRow) {
                // if already on top row, do nothing
                if (lastRow.rowIndex === 0) {
                    if (lastRow.isFloatingTop()) {
                        return null;
                    } else if (lastRow.isNotFloating()) {
                        if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_TOP)) {
                            return this.getLastFloatingTopRow();
                        } else {
                            return null;
                        }
                    } else {
                        // last floating bottom
                        if (this.rowModel.isRowsToRender()) {
                            return this.getLastBodyCell();
                        } else if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_TOP)) {
                            return this.getLastFloatingTopRow();
                        } else {
                            return null;
                        }
                    }
                } else {
                    return new gridRow_1.GridRow(lastRow.rowIndex - 1, lastRow.floating);
                }
            };
            CellNavigationService.prototype.getCellAbove = function (lastCell) {
                var rowAbove = this.getRowAbove(lastCell.getGridRow());
                if (rowAbove) {
                    return new gridCell_1.GridCell(rowAbove.rowIndex, rowAbove.floating, lastCell.column);
                } else {
                    return null;
                }
            };
            CellNavigationService.prototype.getLastBodyCell = function () {
                var lastBodyRow = this.rowModel.getRowCount() - 1;
                return new gridRow_1.GridRow(lastBodyRow, null);
            };
            CellNavigationService.prototype.getLastFloatingTopRow = function () {
                var lastFloatingRow = this.floatingRowModel.getFloatingTopRowData().length - 1;
                return new gridRow_1.GridRow(lastFloatingRow, constants_1.Constants.FLOATING_TOP);
            };
            CellNavigationService.prototype.getNextTabbedCell = function (gridCell, backwards) {
                if (backwards) {
                    return this.getNextTabbedCellBackwards(gridCell);
                } else {
                    return this.getNextTabbedCellForwards(gridCell);
                }
            };
            CellNavigationService.prototype.getNextTabbedCellForwards = function (gridCell) {
                var displayedColumns = this.columnController.getAllDisplayedColumns();
                var newRowIndex = gridCell.rowIndex;
                var newFloating = gridCell.floating;
                // move along to the next cell
                var newColumn = this.columnController.getDisplayedColAfter(gridCell.column);
                // check if end of the row, and if so, go forward a row
                if (!newColumn) {
                    newColumn = displayedColumns[0];
                    var rowBelow = this.getRowBelow(gridCell.getGridRow());
                    if (utils_1.Utils.missing(rowBelow)) {
                        return;
                    }
                    newRowIndex = rowBelow.rowIndex;
                    newFloating = rowBelow.floating;
                }
                return new gridCell_1.GridCell(newRowIndex, newFloating, newColumn);
            };
            CellNavigationService.prototype.getNextTabbedCellBackwards = function (gridCell) {
                var displayedColumns = this.columnController.getAllDisplayedColumns();
                var newRowIndex = gridCell.rowIndex;
                var newFloating = gridCell.floating;
                // move along to the next cell
                var newColumn = this.columnController.getDisplayedColBefore(gridCell.column);
                // check if end of the row, and if so, go forward a row
                if (!newColumn) {
                    newColumn = displayedColumns[displayedColumns.length - 1];
                    var rowAbove = this.getRowAbove(gridCell.getGridRow());
                    if (utils_1.Utils.missing(rowAbove)) {
                        return;
                    }
                    newRowIndex = rowAbove.rowIndex;
                    newFloating = rowAbove.floating;
                }
                return new gridCell_1.GridCell(newRowIndex, newFloating, newColumn);
            };
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], CellNavigationService.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('rowModel'), __metadata('design:type', Object)], CellNavigationService.prototype, "rowModel", void 0);
            __decorate([context_1.Autowired('floatingRowModel'), __metadata('design:type', floatingRowModel_1.FloatingRowModel)], CellNavigationService.prototype, "floatingRowModel", void 0);
            CellNavigationService = __decorate([context_1.Bean('cellNavigationService'), __metadata('design:paramtypes', [])], CellNavigationService);
            return CellNavigationService;
        }();
        exports.CellNavigationService = CellNavigationService;

        /***/ },
    /* 304 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnController_1 = __webpack_require__(251);
        var gridPanel_1 = __webpack_require__(262);
        var column_1 = __webpack_require__(253);
        var context_1 = __webpack_require__(244);
        var headerContainer_1 = __webpack_require__(305);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var HeaderRenderer = function () {
            function HeaderRenderer() {}
            HeaderRenderer.prototype.init = function () {
                var _this = this;
                this.eHeaderViewport = this.gridPanel.getHeaderViewport();
                this.eRoot = this.gridPanel.getRoot();
                this.eHeaderOverlay = this.gridPanel.getHeaderOverlay();
                this.centerContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getHeaderContainer(), this.gridPanel.getHeaderViewport(), this.eRoot, null);
                this.childContainers = [this.centerContainer];
                if (!this.gridOptionsWrapper.isForPrint()) {
                    this.pinnedLeftContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getPinnedLeftHeader(), null, this.eRoot, column_1.Column.PINNED_LEFT);
                    this.pinnedRightContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getPinnedRightHeader(), null, this.eRoot, column_1.Column.PINNED_RIGHT);
                    this.childContainers.push(this.pinnedLeftContainer);
                    this.childContainers.push(this.pinnedRightContainer);
                }
                this.childContainers.forEach(function (container) {
                    return _this.context.wireBean(container);
                });
                // when grid columns change, it means the number of rows in the header has changed and it's all new columns
                this.eventService.addEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
                // shotgun way to get labels to change, eg from sum(amount) to avg(amount)
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.refreshHeader.bind(this));
                // for resized, the individual cells take care of this, so don't need to refresh everything
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.setPinnedColContainerWidth.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.setPinnedColContainerWidth.bind(this));
                if (this.columnController.isReady()) {
                    this.refreshHeader();
                }
            };
            HeaderRenderer.prototype.forEachHeaderElement = function (callback) {
                this.childContainers.forEach(function (childContainer) {
                    return childContainer.forEachHeaderElement(callback);
                });
            };
            HeaderRenderer.prototype.destroy = function () {
                this.childContainers.forEach(function (container) {
                    return container.destroy();
                });
            };
            HeaderRenderer.prototype.onGridColumnsChanged = function () {
                this.setHeight();
            };
            // this is called from the API and refreshes everything, should be broken out
            // into refresh everything vs just something changed
            HeaderRenderer.prototype.refreshHeader = function () {
                this.setHeight();
                this.childContainers.forEach(function (container) {
                    return container.refresh();
                });
                this.setPinnedColContainerWidth();
            };
            HeaderRenderer.prototype.setHeight = function () {
                // if forPrint, overlay is missing
                if (this.eHeaderOverlay) {
                    var rowHeight = this.gridOptionsWrapper.getHeaderHeight();
                    // we can probably get rid of this when we no longer need the overlay
                    var dept = this.columnController.getHeaderRowCount();
                    this.eHeaderOverlay.style.height = rowHeight + 'px';
                    this.eHeaderOverlay.style.top = (dept - 1) * rowHeight + 'px';
                }
            };
            HeaderRenderer.prototype.setPinnedColContainerWidth = function () {
                // pinned col doesn't exist when doing forPrint
                if (this.gridOptionsWrapper.isForPrint()) {
                    return;
                }
                var pinnedLeftWidth = this.columnController.getPinnedLeftContainerWidth();
                this.eHeaderViewport.style.marginLeft = pinnedLeftWidth + 'px';
                this.pinnedLeftContainer.setWidth(pinnedLeftWidth);
                var pinnedRightWidth = this.columnController.getPinnedRightContainerWidth();
                this.eHeaderViewport.style.marginRight = pinnedRightWidth + 'px';
                this.pinnedRightContainer.setWidth(pinnedRightWidth);
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], HeaderRenderer.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], HeaderRenderer.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], HeaderRenderer.prototype, "gridPanel", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], HeaderRenderer.prototype, "context", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], HeaderRenderer.prototype, "eventService", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], HeaderRenderer.prototype, "init", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], HeaderRenderer.prototype, "destroy", null);
            HeaderRenderer = __decorate([context_1.Bean('headerRenderer'), __metadata('design:paramtypes', [])], HeaderRenderer);
            return HeaderRenderer;
        }();
        exports.HeaderRenderer = HeaderRenderer;

        /***/ },
    /* 305 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var context_1 = __webpack_require__(244);
        var dragAndDropService_1 = __webpack_require__(306);
        var columnController_1 = __webpack_require__(251);
        var gridPanel_1 = __webpack_require__(262);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var headerRowComp_1 = __webpack_require__(307);
        var bodyDropTarget_1 = __webpack_require__(313);
        var HeaderContainer = function () {
            function HeaderContainer(eContainer, eViewport, eRoot, pinned) {
                this.headerRowComps = [];
                this.eContainer = eContainer;
                this.eRoot = eRoot;
                this.pinned = pinned;
                this.eViewport = eViewport;
            }
            HeaderContainer.prototype.setWidth = function (width) {
                this.eContainer.style.width = width + 'px';
            };
            HeaderContainer.prototype.forEachHeaderElement = function (callback) {
                this.headerRowComps.forEach(function (headerRowComp) {
                    return headerRowComp.forEachHeaderElement(callback);
                });
            };
            HeaderContainer.prototype.init = function () {
                this.setupDragAndDrop();
                // if value changes, then if not pivoting, we at least need to change the label eg from sum() to avg(),
                // if pivoting, then the columns have changed
                this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onGridColumnsChanged.bind(this));
                this.eventService.addEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
            };
            HeaderContainer.prototype.destroy = function () {
                this.removeHeaderRowComps();
            };
            // grid cols have changed - this also means the number of rows in the header can have
            // changed. so we remove all the old rows and insert new ones for a complete refresh
            HeaderContainer.prototype.onGridColumnsChanged = function () {
                this.removeHeaderRowComps();
                this.createHeaderRowComps();
            };
            // we expose this for gridOptions.api.refreshHeader() to call
            HeaderContainer.prototype.refresh = function () {
                this.onGridColumnsChanged();
            };
            HeaderContainer.prototype.setupDragAndDrop = function () {
                var dropContainer = this.eViewport ? this.eViewport : this.eContainer;
                var bodyDropTarget = new bodyDropTarget_1.BodyDropTarget(this.pinned, dropContainer);
                this.context.wireBean(bodyDropTarget);
            };
            HeaderContainer.prototype.removeHeaderRowComps = function () {
                this.headerRowComps.forEach(function (headerRowComp) {
                    headerRowComp.destroy();
                });
                this.headerRowComps.length = 0;
                utils_1.Utils.removeAllChildren(this.eContainer);
            };
            HeaderContainer.prototype.createHeaderRowComps = function () {
                // if we are displaying header groups, then we have many rows here.
                // go through each row of the header, one by one.
                var rowCount = this.columnController.getHeaderRowCount();
                for (var dept = 0; dept < rowCount; dept++) {
                    var groupRow = dept !== rowCount - 1;
                    var headerRowComp = new headerRowComp_1.HeaderRowComp(dept, groupRow, this.pinned, this.eRoot, this.dropTarget);
                    this.context.wireBean(headerRowComp);
                    this.headerRowComps.push(headerRowComp);
                    this.eContainer.appendChild(headerRowComp.getGui());
                }
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], HeaderContainer.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], HeaderContainer.prototype, "context", void 0);
            __decorate([context_1.Autowired('$scope'), __metadata('design:type', Object)], HeaderContainer.prototype, "$scope", void 0);
            __decorate([context_1.Autowired('dragAndDropService'), __metadata('design:type', dragAndDropService_1.DragAndDropService)], HeaderContainer.prototype, "dragAndDropService", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], HeaderContainer.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], HeaderContainer.prototype, "gridPanel", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], HeaderContainer.prototype, "eventService", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], HeaderContainer.prototype, "init", null);
            return HeaderContainer;
        }();
        exports.HeaderContainer = HeaderContainer;

        /***/ },
    /* 306 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var logger_1 = __webpack_require__(243);
        var context_1 = __webpack_require__(244);
        var utils_1 = __webpack_require__(245);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var svgFactory_1 = __webpack_require__(297);
        var dragService_1 = __webpack_require__(269);
        var columnController_1 = __webpack_require__(251);
        var svgFactory = svgFactory_1.SvgFactory.getInstance();
        (function (DragSourceType) {
            DragSourceType[DragSourceType["ToolPanel"] = 0] = "ToolPanel";
            DragSourceType[DragSourceType["HeaderCell"] = 1] = "HeaderCell";
        })(exports.DragSourceType || (exports.DragSourceType = {}));
        var DragSourceType = exports.DragSourceType;
        var DragAndDropService = function () {
            function DragAndDropService() {
                this.dropTargets = [];
            }
            DragAndDropService.prototype.init = function () {
                this.ePinnedIcon = utils_1.Utils.createIcon('columnMovePin', this.gridOptionsWrapper, null, svgFactory.createPinIcon);
                this.ePlusIcon = utils_1.Utils.createIcon('columnMoveAdd', this.gridOptionsWrapper, null, svgFactory.createPlusIcon);
                this.eHiddenIcon = utils_1.Utils.createIcon('columnMoveHide', this.gridOptionsWrapper, null, svgFactory.createColumnHiddenIcon);
                this.eMoveIcon = utils_1.Utils.createIcon('columnMoveMove', this.gridOptionsWrapper, null, svgFactory.createMoveIcon);
                this.eLeftIcon = utils_1.Utils.createIcon('columnMoveLeft', this.gridOptionsWrapper, null, svgFactory.createLeftIcon);
                this.eRightIcon = utils_1.Utils.createIcon('columnMoveRight', this.gridOptionsWrapper, null, svgFactory.createRightIcon);
                this.eGroupIcon = utils_1.Utils.createIcon('columnMoveGroup', this.gridOptionsWrapper, null, svgFactory.createGroupIcon);
                this.eAggregateIcon = utils_1.Utils.createIcon('columnMoveValue', this.gridOptionsWrapper, null, svgFactory.createAggregationIcon);
                this.ePivotIcon = utils_1.Utils.createIcon('columnMovePivot', this.gridOptionsWrapper, null, svgFactory.createPivotIcon);
                this.eDropNotAllowedIcon = utils_1.Utils.createIcon('dropNotAllowed', this.gridOptionsWrapper, null, svgFactory.createDropNotAllowedIcon);
            };
            DragAndDropService.prototype.setBeans = function (loggerFactory) {
                this.logger = loggerFactory.create('OldToolPanelDragAndDropService');
                this.eBody = document.querySelector('body');
                if (!this.eBody) {
                    console.warn('ag-Grid: could not find document body, it is needed for dragging columns');
                }
            };
            // we do not need to clean up drag sources, as we are just adding a listener to the element.
            // when the element is disposed, the drag source is also disposed, even though this service
            // remains. this is a bit different to normal 'addListener' methods
            DragAndDropService.prototype.addDragSource = function (dragSource) {
                this.dragService.addDragSource({
                    eElement: dragSource.eElement,
                    onDragStart: this.onDragStart.bind(this, dragSource),
                    onDragStop: this.onDragStop.bind(this),
                    onDragging: this.onDragging.bind(this)
                });
            };
            DragAndDropService.prototype.nudge = function () {
                if (this.dragging) {
                    this.onDragging(this.eventLastTime, true);
                }
            };
            DragAndDropService.prototype.onDragStart = function (dragSource, mouseEvent) {
                this.dragging = true;
                this.dragSource = dragSource;
                this.eventLastTime = mouseEvent;
                this.dragSource.dragItem.forEach(function (column) {
                    return column.setMoving(true);
                });
                this.dragItem = this.dragSource.dragItem;
                this.lastDropTarget = this.dragSource.dragSourceDropTarget;
                this.createGhost();
            };
            DragAndDropService.prototype.onDragStop = function (mouseEvent) {
                this.eventLastTime = null;
                this.dragging = false;
                this.dragItem.forEach(function (column) {
                    return column.setMoving(false);
                });
                if (this.lastDropTarget && this.lastDropTarget.onDragStop) {
                    var draggingEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, null, false);
                    this.lastDropTarget.onDragStop(draggingEvent);
                }
                this.lastDropTarget = null;
                this.dragItem = null;
                this.removeGhost();
            };
            DragAndDropService.prototype.onDragging = function (mouseEvent, fromNudge) {
                var direction = this.workOutDirection(mouseEvent);
                this.eventLastTime = mouseEvent;
                this.positionGhost(mouseEvent);
                // check if mouseEvent intersects with any of the drop targets
                var dropTarget = utils_1.Utils.find(this.dropTargets, this.isMouseOnDropTarget.bind(this, mouseEvent));
                if (dropTarget !== this.lastDropTarget) {
                    this.leaveLastTargetIfExists(mouseEvent, direction, fromNudge);
                    this.enterDragTargetIfExists(dropTarget, mouseEvent, direction, fromNudge);
                    this.lastDropTarget = dropTarget;
                } else if (dropTarget) {
                    var draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, direction, fromNudge);
                    dropTarget.onDragging(draggingEvent);
                }
            };
            DragAndDropService.prototype.enterDragTargetIfExists = function (dropTarget, mouseEvent, direction, fromNudge) {
                if (!dropTarget) {
                    return;
                }
                var dragEnterEvent = this.createDropTargetEvent(dropTarget, mouseEvent, direction, fromNudge);
                dropTarget.onDragEnter(dragEnterEvent);
                this.setGhostIcon(dropTarget.getIconName ? dropTarget.getIconName() : null);
            };
            DragAndDropService.prototype.leaveLastTargetIfExists = function (mouseEvent, direction, fromNudge) {
                if (!this.lastDropTarget) {
                    return;
                }
                var dragLeaveEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, direction, fromNudge);
                this.lastDropTarget.onDragLeave(dragLeaveEvent);
                this.setGhostIcon(null);
            };
            DragAndDropService.prototype.getAllContainersFromDropTarget = function (dropTarget) {
                var containers = [dropTarget.getContainer()];
                var secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
                if (secondaryContainers) {
                    containers = containers.concat(secondaryContainers);
                }
                return containers;
            };
            // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
            DragAndDropService.prototype.isMouseOnDropTarget = function (mouseEvent, dropTarget) {
                var allContainers = this.getAllContainersFromDropTarget(dropTarget);
                var gotMatch = false;
                allContainers.forEach(function (eContainer) {
                    if (!eContainer) {
                        return;
                    } // secondary can be missing
                    var rect = eContainer.getBoundingClientRect();
                    // if element is not visible, then width and height are zero
                    if (rect.width === 0 || rect.height === 0) {
                        return;
                    }
                    var horizontalFit = mouseEvent.clientX >= rect.left && mouseEvent.clientX <= rect.right;
                    var verticalFit = mouseEvent.clientY >= rect.top && mouseEvent.clientY <= rect.bottom;
                    //console.log(`rect.width = ${rect.width} || rect.height = ${rect.height} ## verticalFit = ${verticalFit}, horizontalFit = ${horizontalFit}, `);
                    if (horizontalFit && verticalFit) {
                        gotMatch = true;
                    }
                });
                return gotMatch;
            };
            DragAndDropService.prototype.addDropTarget = function (dropTarget) {
                this.dropTargets.push(dropTarget);
            };
            DragAndDropService.prototype.workOutDirection = function (event) {
                var direction;
                if (this.eventLastTime.clientX > event.clientX) {
                    direction = DragAndDropService.DIRECTION_LEFT;
                } else if (this.eventLastTime.clientX < event.clientX) {
                    direction = DragAndDropService.DIRECTION_RIGHT;
                } else {
                    direction = null;
                }
                return direction;
            };
            DragAndDropService.prototype.createDropTargetEvent = function (dropTarget, event, direction, fromNudge) {
                // localise x and y to the target component
                var rect = dropTarget.getContainer().getBoundingClientRect();
                var x = event.clientX - rect.left;
                var y = event.clientY - rect.top;
                var dropTargetEvent = {
                    event: event,
                    x: x,
                    y: y,
                    direction: direction,
                    dragSource: this.dragSource,
                    fromNudge: fromNudge
                };
                return dropTargetEvent;
            };
            DragAndDropService.prototype.positionGhost = function (event) {
                var ghostRect = this.eGhost.getBoundingClientRect();
                var ghostHeight = ghostRect.height;
                // for some reason, without the '-2', it still overlapped by 1 or 2 pixels, which
                // then brought in scrollbars to the browser. no idea why, but putting in -2 here
                // works around it which is good enough for me.
                var browserWidth = utils_1.Utils.getBodyWidth() - 2;
                var browserHeight = utils_1.Utils.getBodyHeight() - 2;
                // put ghost vertically in middle of cursor
                var top = event.pageY - ghostHeight / 2;
                // horizontally, place cursor just right of icon
                var left = event.pageX - 30;
                var windowScrollY = window.pageYOffset || document.documentElement.scrollTop;
                var windowScrollX = window.pageXOffset || document.documentElement.scrollLeft;
                // check ghost is not positioned outside of the browser
                if (browserWidth > 0) {
                    if (left + this.eGhost.clientWidth > browserWidth + windowScrollX) {
                        left = browserWidth + windowScrollX - this.eGhost.clientWidth;
                    }
                }
                if (left < 0) {
                    left = 0;
                }
                if (browserHeight > 0) {
                    if (top + this.eGhost.clientHeight > browserHeight + windowScrollY) {
                        top = browserHeight + windowScrollY - this.eGhost.clientHeight;
                    }
                }
                if (top < 0) {
                    top = 0;
                }
                this.eGhost.style.left = left + 'px';
                this.eGhost.style.top = top + 'px';
            };
            DragAndDropService.prototype.removeGhost = function () {
                if (this.eGhost) {
                    this.eBody.removeChild(this.eGhost);
                }
                this.eGhost = null;
            };
            DragAndDropService.prototype.createGhost = function () {
                this.eGhost = utils_1.Utils.loadTemplate(DragAndDropService.GHOST_TEMPLATE);
                this.eGhostIcon = this.eGhost.querySelector('.ag-dnd-ghost-icon');
                if (this.lastDropTarget) {
                    this.setGhostIcon(this.lastDropTarget.getIconName ? this.lastDropTarget.getIconName() : null);
                }
                var eText = this.eGhost.querySelector('.ag-dnd-ghost-label');
                eText.innerHTML = this.dragSource.dragItemName;
                this.eGhost.style.height = this.gridOptionsWrapper.getHeaderHeight() + 'px';
                this.eGhost.style.top = '20px';
                this.eGhost.style.left = '20px';
                this.eBody.appendChild(this.eGhost);
            };
            DragAndDropService.prototype.setGhostIcon = function (iconName, shake) {
                if (shake === void 0) {
                    shake = false;
                }
                utils_1.Utils.removeAllChildren(this.eGhostIcon);
                var eIcon;
                switch (iconName) {
                    case DragAndDropService.ICON_ADD:
                        eIcon = this.ePlusIcon;
                        break;
                    case DragAndDropService.ICON_PINNED:
                        eIcon = this.ePinnedIcon;
                        break;
                    case DragAndDropService.ICON_MOVE:
                        eIcon = this.eMoveIcon;
                        break;
                    case DragAndDropService.ICON_LEFT:
                        eIcon = this.eLeftIcon;
                        break;
                    case DragAndDropService.ICON_RIGHT:
                        eIcon = this.eRightIcon;
                        break;
                    case DragAndDropService.ICON_GROUP:
                        eIcon = this.eGroupIcon;
                        break;
                    case DragAndDropService.ICON_AGGREGATE:
                        eIcon = this.eAggregateIcon;
                        break;
                    case DragAndDropService.ICON_PIVOT:
                        eIcon = this.ePivotIcon;
                        break;
                    case DragAndDropService.ICON_NOT_ALLOWED:
                        eIcon = this.eDropNotAllowedIcon;
                        break;
                    default:
                        eIcon = this.eHiddenIcon;
                        break;
                }
                this.eGhostIcon.appendChild(eIcon);
                utils_1.Utils.addOrRemoveCssClass(this.eGhostIcon, 'ag-shake-left-to-right', shake);
            };
            DragAndDropService.DIRECTION_LEFT = 'left';
            DragAndDropService.DIRECTION_RIGHT = 'right';
            DragAndDropService.ICON_PINNED = 'pinned';
            DragAndDropService.ICON_ADD = 'add';
            DragAndDropService.ICON_MOVE = 'move';
            DragAndDropService.ICON_LEFT = 'left';
            DragAndDropService.ICON_RIGHT = 'right';
            DragAndDropService.ICON_GROUP = 'group';
            DragAndDropService.ICON_AGGREGATE = 'aggregate';
            DragAndDropService.ICON_PIVOT = 'pivot';
            DragAndDropService.ICON_NOT_ALLOWED = 'notAllowed';
            DragAndDropService.GHOST_TEMPLATE = '<div class="ag-dnd-ghost">' + '  <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>' + '  <div class="ag-dnd-ghost-label">' + '  </div>' + '</div>';
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], DragAndDropService.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('dragService'), __metadata('design:type', dragService_1.DragService)], DragAndDropService.prototype, "dragService", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], DragAndDropService.prototype, "columnController", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], DragAndDropService.prototype, "init", null);
            __decorate([__param(0, context_1.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], DragAndDropService.prototype, "setBeans", null);
            DragAndDropService = __decorate([context_1.Bean('dragAndDropService'), __metadata('design:paramtypes', [])], DragAndDropService);
            return DragAndDropService;
        }();
        exports.DragAndDropService = DragAndDropService;

        /***/ },
    /* 307 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var component_1 = __webpack_require__(285);
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnGroup_1 = __webpack_require__(252);
        var columnController_1 = __webpack_require__(251);
        var renderedHeaderGroupCell_1 = __webpack_require__(308);
        var renderedHeaderCell_1 = __webpack_require__(311);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var utils_1 = __webpack_require__(245);
        var HeaderRowComp = function (_super) {
            __extends(HeaderRowComp, _super);
            function HeaderRowComp(dept, showingGroups, pinned, eRoot, dropTarget) {
                _super.call(this, "<div class=\"ag-header-row\"/>");
                this.headerElements = {};
                this.dept = dept;
                this.showingGroups = showingGroups;
                this.pinned = pinned;
                this.eRoot = eRoot;
                this.dropTarget = dropTarget;
            }
            HeaderRowComp.prototype.forEachHeaderElement = function (callback) {
                var _this = this;
                Object.keys(this.headerElements).forEach(function (key) {
                    var headerElement = _this.headerElements[key];
                    callback(headerElement);
                });
            };
            HeaderRowComp.prototype.destroy = function () {
                var idsOfAllChildren = Object.keys(this.headerElements);
                this.removeAndDestroyChildComponents(idsOfAllChildren);
                _super.prototype.destroy.call(this);
            };
            HeaderRowComp.prototype.removeAndDestroyChildComponents = function (idsToDestroy) {
                var _this = this;
                idsToDestroy.forEach(function (id) {
                    var child = _this.headerElements[id];
                    _this.getGui().removeChild(child.getGui());
                    child.destroy();
                    delete _this.headerElements[id];
                });
            };
            HeaderRowComp.prototype.onRowHeightChanged = function () {
                var rowHeight = this.gridOptionsWrapper.getHeaderHeight();
                this.getGui().style.top = this.dept * rowHeight + 'px';
                this.getGui().style.height = rowHeight + 'px';
            };
            HeaderRowComp.prototype.init = function () {
                this.onRowHeightChanged();
                this.onVirtualColumnsChanged();
                this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this));
                this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this));
                this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
            };
            HeaderRowComp.prototype.onDisplayedColumnsChanged = function () {
                // because column groups are created and destroyed on the fly as groups are opened / closed and columns are moved,
                // we have to throw away all of the components when columns are changed, as the references to the old groups
                // are no longer value. this is not true for columns where columns do not get destroyed between open / close
                // or moving actions.
                if (this.showingGroups) {
                    var idsOfAllChildren = Object.keys(this.headerElements);
                    this.removeAndDestroyChildComponents(idsOfAllChildren);
                }
                this.onVirtualColumnsChanged();
            };
            HeaderRowComp.prototype.onVirtualColumnsChanged = function () {
                var _this = this;
                var currentChildIds = Object.keys(this.headerElements);
                var nodesAtDept = this.columnController.getVirtualHeaderGroupRow(this.pinned, this.dept);
                nodesAtDept.forEach(function (child) {
                    var idOfChild = child.getUniqueId();
                    // if we already have this cell rendered, do nothing
                    if (currentChildIds.indexOf(idOfChild) >= 0) {
                        utils_1.Utils.removeFromArray(currentChildIds, idOfChild);
                        return;
                    }
                    // skip groups that have no displayed children. this can happen when the group is broken,
                    // and this section happens to have nothing to display for the open / closed state
                    if (child instanceof columnGroup_1.ColumnGroup && child.getDisplayedChildren().length === 0) {
                        return;
                    }
                    var renderedHeaderElement = _this.createHeaderElement(child);
                    _this.headerElements[idOfChild] = renderedHeaderElement;
                    _this.getGui().appendChild(renderedHeaderElement.getGui());
                });
                // at this point, anything left in currentChildIds is an element that is no longer in the viewport
                this.removeAndDestroyChildComponents(currentChildIds);
            };
            HeaderRowComp.prototype.createHeaderElement = function (columnGroupChild) {
                var result;
                if (columnGroupChild instanceof columnGroup_1.ColumnGroup) {
                    result = new renderedHeaderGroupCell_1.RenderedHeaderGroupCell(columnGroupChild, this.eRoot, this.dropTarget);
                } else {
                    result = new renderedHeaderCell_1.RenderedHeaderCell(columnGroupChild, this.eRoot, this.dropTarget);
                }
                this.context.wireBean(result);
                return result;
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], HeaderRowComp.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], HeaderRowComp.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], HeaderRowComp.prototype, "context", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], HeaderRowComp.prototype, "eventService", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], HeaderRowComp.prototype, "init", null);
            return HeaderRowComp;
        }(component_1.Component);
        exports.HeaderRowComp = HeaderRowComp;

        /***/ },
    /* 308 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var svgFactory_1 = __webpack_require__(297);
        var columnController_1 = __webpack_require__(251);
        var filterManager_1 = __webpack_require__(281);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var column_1 = __webpack_require__(253);
        var horizontalDragService_1 = __webpack_require__(309);
        var context_1 = __webpack_require__(244);
        var cssClassApplier_1 = __webpack_require__(310);
        var dragAndDropService_1 = __webpack_require__(306);
        var setLeftFeature_1 = __webpack_require__(301);
        var svgFactory = svgFactory_1.SvgFactory.getInstance();
        var RenderedHeaderGroupCell = function () {
            function RenderedHeaderGroupCell(columnGroup, eRoot, dragSourceDropTarget) {
                this.destroyFunctions = [];
                this.columnGroup = columnGroup;
                this.eRoot = eRoot;
                this.dragSourceDropTarget = dragSourceDropTarget;
            }
            RenderedHeaderGroupCell.prototype.getGui = function () {
                return this.eHeaderGroupCell;
            };
            RenderedHeaderGroupCell.prototype.onIndividualColumnResized = function (column) {
                if (this.columnGroup.isChildInThisGroupDeepSearch(column)) {
                    this.setWidth();
                }
            };
            RenderedHeaderGroupCell.prototype.init = function () {
                this.eHeaderGroupCell = document.createElement('div');
                cssClassApplier_1.CssClassApplier.addHeaderClassesFromCollDef(this.columnGroup.getColGroupDef(), this.eHeaderGroupCell, this.gridOptionsWrapper);
                this.displayName = this.columnGroup.getHeaderName();
                this.setupResize();
                this.addClasses();
                this.setupLabel();
                this.setupMove();
                this.setWidth();
                var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.columnGroup, this.eHeaderGroupCell);
                this.destroyFunctions.push(setLeftFeature.destroy.bind(setLeftFeature));
            };
            RenderedHeaderGroupCell.prototype.setupLabel = function () {
                // no renderer, default text render
                if (this.displayName && this.displayName !== '') {
                    var eGroupCellLabel = document.createElement("div");
                    eGroupCellLabel.className = 'ag-header-group-cell-label';
                    this.eHeaderGroupCell.appendChild(eGroupCellLabel);
                    if (utils_1.Utils.isBrowserSafari()) {
                        eGroupCellLabel.style.display = 'table-cell';
                    }
                    var eInnerText = document.createElement("span");
                    eInnerText.className = 'ag-header-group-text';
                    eInnerText.innerHTML = this.displayName;
                    eGroupCellLabel.appendChild(eInnerText);
                    if (this.columnGroup.isExpandable()) {
                        this.addGroupExpandIcon(eGroupCellLabel);
                    }
                }
            };
            RenderedHeaderGroupCell.prototype.addClasses = function () {
                utils_1.Utils.addCssClass(this.eHeaderGroupCell, 'ag-header-group-cell');
                // having different classes below allows the style to not have a bottom border
                // on the group header, if no group is specified
                if (this.columnGroup.getColGroupDef()) {
                    utils_1.Utils.addCssClass(this.eHeaderGroupCell, 'ag-header-group-cell-with-group');
                } else {
                    utils_1.Utils.addCssClass(this.eHeaderGroupCell, 'ag-header-group-cell-no-group');
                }
            };
            RenderedHeaderGroupCell.prototype.setupResize = function () {
                var _this = this;
                if (!this.gridOptionsWrapper.isEnableColResize()) {
                    return;
                }
                this.eHeaderCellResize = document.createElement("div");
                this.eHeaderCellResize.className = "ag-header-cell-resize";
                this.eHeaderGroupCell.appendChild(this.eHeaderCellResize);
                this.dragService.addDragHandling({
                    eDraggableElement: this.eHeaderCellResize,
                    eBody: this.eRoot,
                    cursor: 'col-resize',
                    startAfterPixels: 0,
                    onDragStart: this.onDragStart.bind(this),
                    onDragging: this.onDragging.bind(this)
                });
                if (!this.gridOptionsWrapper.isSuppressAutoSize()) {
                    this.eHeaderCellResize.addEventListener('dblclick', function (event) {
                        // get list of all the column keys we are responsible for
                        var keys = [];
                        _this.columnGroup.getDisplayedLeafColumns().forEach(function (column) {
                            // not all cols in the group may be participating with auto-resize
                            if (!column.getColDef().suppressAutoSize) {
                                keys.push(column.getColId());
                            }
                        });
                        if (keys.length > 0) {
                            _this.columnController.autoSizeColumns(keys);
                        }
                    });
                }
            };
            RenderedHeaderGroupCell.prototype.isSuppressMoving = function () {
                // if any child is fixed, then don't allow moving
                var childSuppressesMoving = false;
                this.columnGroup.getLeafColumns().forEach(function (column) {
                    if (column.getColDef().suppressMovable) {
                        childSuppressesMoving = true;
                    }
                });
                var result = childSuppressesMoving || this.gridOptionsWrapper.isSuppressMovableColumns() || this.gridOptionsWrapper.isForPrint();
                // || this.columnController.isPivotMode();
                return result;
            };
            RenderedHeaderGroupCell.prototype.setupMove = function () {
                var eLabel = this.eHeaderGroupCell.querySelector('.ag-header-group-cell-label');
                if (!eLabel) {
                    return;
                }
                if (this.isSuppressMoving()) {
                    return;
                }
                if (eLabel) {
                    var dragSource = {
                        type: dragAndDropService_1.DragSourceType.HeaderCell,
                        eElement: eLabel,
                        dragItemName: this.displayName,
                        // we add in the original group leaf columns, so we move both visible and non-visible items
                        dragItem: this.getAllColumnsInThisGroup(),
                        dragSourceDropTarget: this.dragSourceDropTarget
                    };
                    this.dragAndDropService.addDragSource(dragSource);
                }
            };
            // when moving the columns, we want to move all the columns in this group in one go, and in the order they
            // are currently in the screen.
            RenderedHeaderGroupCell.prototype.getAllColumnsInThisGroup = function () {
                var allColumnsOriginalOrder = this.columnGroup.getOriginalColumnGroup().getLeafColumns();
                var allColumnsCurrentOrder = [];
                this.columnController.getAllDisplayedColumns().forEach(function (column) {
                    if (allColumnsOriginalOrder.indexOf(column) >= 0) {
                        allColumnsCurrentOrder.push(column);
                        utils_1.Utils.removeFromArray(allColumnsOriginalOrder, column);
                    }
                });
                // we are left with non-visible columns, stick these in at the end
                allColumnsOriginalOrder.forEach(function (column) {
                    return allColumnsCurrentOrder.push(column);
                });
                return allColumnsCurrentOrder;
            };
            RenderedHeaderGroupCell.prototype.setWidth = function () {
                var _this = this;
                var widthChangedListener = function widthChangedListener() {
                    _this.eHeaderGroupCell.style.width = _this.columnGroup.getActualWidth() + 'px';
                };
                this.columnGroup.getLeafColumns().forEach(function (column) {
                    column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
                    _this.destroyFunctions.push(function () {
                        column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
                    });
                });
                widthChangedListener();
            };
            RenderedHeaderGroupCell.prototype.destroy = function () {
                this.destroyFunctions.forEach(function (func) {
                    func();
                });
            };
            RenderedHeaderGroupCell.prototype.addGroupExpandIcon = function (eGroupCellLabel) {
                var eGroupIcon;
                if (this.columnGroup.isExpanded()) {
                    eGroupIcon = utils_1.Utils.createIcon('columnGroupOpened', this.gridOptionsWrapper, null, svgFactory.createGroupContractedIcon);
                } else {
                    eGroupIcon = utils_1.Utils.createIcon('columnGroupClosed', this.gridOptionsWrapper, null, svgFactory.createGroupExpandedIcon);
                }
                eGroupIcon.className = 'ag-header-expand-icon';
                eGroupCellLabel.appendChild(eGroupIcon);
                var that = this;
                eGroupIcon.onclick = function () {
                    var newExpandedValue = !that.columnGroup.isExpanded();
                    that.columnController.setColumnGroupOpened(that.columnGroup, newExpandedValue);
                };
            };
            RenderedHeaderGroupCell.prototype.onDragStart = function () {
                var _this = this;
                this.groupWidthStart = this.columnGroup.getActualWidth();
                this.childrenWidthStarts = [];
                this.columnGroup.getDisplayedLeafColumns().forEach(function (column) {
                    _this.childrenWidthStarts.push(column.getActualWidth());
                });
            };
            RenderedHeaderGroupCell.prototype.onDragging = function (dragChange, finished) {
                var _this = this;
                var newWidth = this.groupWidthStart + dragChange;
                var minWidth = this.columnGroup.getMinWidth();
                if (newWidth < minWidth) {
                    newWidth = minWidth;
                }
                // distribute the new width to the child headers
                var changeRatio = newWidth / this.groupWidthStart;
                // keep track of pixels used, and last column gets the remaining,
                // to cater for rounding errors, and min width adjustments
                var pixelsToDistribute = newWidth;
                var displayedColumns = this.columnGroup.getDisplayedLeafColumns();
                displayedColumns.forEach(function (column, index) {
                    var notLastCol = index !== displayedColumns.length - 1;
                    var newChildSize;
                    if (notLastCol) {
                        // if not the last col, calculate the column width as normal
                        var startChildSize = _this.childrenWidthStarts[index];
                        newChildSize = startChildSize * changeRatio;
                        if (newChildSize < column.getMinWidth()) {
                            newChildSize = column.getMinWidth();
                        }
                        pixelsToDistribute -= newChildSize;
                    } else {
                        // if last col, give it the remaining pixels
                        newChildSize = pixelsToDistribute;
                    }
                    _this.columnController.setColumnWidth(column, newChildSize, finished);
                });
            };
            __decorate([context_1.Autowired('filterManager'), __metadata('design:type', filterManager_1.FilterManager)], RenderedHeaderGroupCell.prototype, "filterManager", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], RenderedHeaderGroupCell.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('horizontalDragService'), __metadata('design:type', horizontalDragService_1.HorizontalDragService)], RenderedHeaderGroupCell.prototype, "dragService", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], RenderedHeaderGroupCell.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('dragAndDropService'), __metadata('design:type', dragAndDropService_1.DragAndDropService)], RenderedHeaderGroupCell.prototype, "dragAndDropService", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RenderedHeaderGroupCell.prototype, "init", null);
            return RenderedHeaderGroupCell;
        }();
        exports.RenderedHeaderGroupCell = RenderedHeaderGroupCell;

        /***/ },
    /* 309 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var HorizontalDragService = function () {
            function HorizontalDragService() {}
            HorizontalDragService.prototype.addDragHandling = function (params) {
                params.eDraggableElement.addEventListener('mousedown', function (startEvent) {
                    new DragInstance(params, startEvent);
                });
            };
            HorizontalDragService = __decorate([context_1.Bean('horizontalDragService'), __metadata('design:paramtypes', [])], HorizontalDragService);
            return HorizontalDragService;
        }();
        exports.HorizontalDragService = HorizontalDragService;
        var DragInstance = function () {
            function DragInstance(params, startEvent) {
                this.mouseMove = this.onMouseMove.bind(this);
                this.mouseUp = this.onMouseUp.bind(this);
                this.mouseLeave = this.onMouseLeave.bind(this);
                this.lastDelta = 0;
                this.params = params;
                this.eDragParent = document.querySelector('body');
                this.dragStartX = startEvent.clientX;
                this.startEvent = startEvent;
                this.eDragParent.addEventListener('mousemove', this.mouseMove);
                this.eDragParent.addEventListener('mouseup', this.mouseUp);
                this.eDragParent.addEventListener('mouseleave', this.mouseLeave);
                this.draggingStarted = false;
                var startAfterPixelsExist = typeof params.startAfterPixels === 'number' && params.startAfterPixels > 0;
                if (!startAfterPixelsExist) {
                    this.startDragging();
                }
            }
            DragInstance.prototype.startDragging = function () {
                this.draggingStarted = true;
                this.oldBodyCursor = this.params.eBody.style.cursor;
                this.oldParentCursor = this.eDragParent.style.cursor;
                this.oldMsUserSelect = this.eDragParent.style.msUserSelect;
                this.oldWebkitUserSelect = this.eDragParent.style.webkitUserSelect;
                // change the body cursor, so when drag moves out of the drag bar, the cursor is still 'resize' (or 'move'
                this.params.eBody.style.cursor = this.params.cursor;
                // same for outside the grid, we want to keep the resize (or move) cursor
                this.eDragParent.style.cursor = this.params.cursor;
                // we don't want text selection outside the grid (otherwise it looks weird as text highlights when we move)
                this.eDragParent.style.msUserSelect = 'none';
                this.eDragParent.style.webkitUserSelect = 'none';
                this.params.onDragStart(this.startEvent);
            };
            DragInstance.prototype.onMouseMove = function (moveEvent) {
                var newX = moveEvent.clientX;
                this.lastDelta = newX - this.dragStartX;
                if (!this.draggingStarted) {
                    var dragExceededStartAfterPixels = Math.abs(this.lastDelta) >= this.params.startAfterPixels;
                    if (dragExceededStartAfterPixels) {
                        this.startDragging();
                    }
                }
                if (this.draggingStarted) {
                    this.params.onDragging(this.lastDelta, false);
                }
            };
            DragInstance.prototype.onMouseUp = function () {
                this.stopDragging();
            };
            DragInstance.prototype.onMouseLeave = function () {
                this.stopDragging();
            };
            DragInstance.prototype.stopDragging = function () {
                // reset cursor back to original cursor, if they were changed in the first place
                if (this.draggingStarted) {
                    this.params.eBody.style.cursor = this.oldBodyCursor;
                    this.eDragParent.style.cursor = this.oldParentCursor;
                    this.eDragParent.style.msUserSelect = this.oldMsUserSelect;
                    this.eDragParent.style.webkitUserSelect = this.oldWebkitUserSelect;
                    this.params.onDragging(this.lastDelta, true);
                }
                // always remove the listeners, as these are always added
                this.eDragParent.removeEventListener('mousemove', this.mouseMove);
                this.eDragParent.removeEventListener('mouseup', this.mouseUp);
                this.eDragParent.removeEventListener('mouseleave', this.mouseLeave);
            };
            return DragInstance;
        }();

        /***/ },
    /* 310 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var utils_1 = __webpack_require__(245);
        var CssClassApplier = function () {
            function CssClassApplier() {}
            CssClassApplier.addHeaderClassesFromCollDef = function (abstractColDef, eHeaderCell, gridOptionsWrapper) {
                if (abstractColDef && abstractColDef.headerClass) {
                    var classToUse;
                    if (typeof abstractColDef.headerClass === 'function') {
                        var params = {
                            // bad naming, as colDef here can be a group or a column,
                            // however most people won't appreciate the difference,
                            // so keeping it as colDef to avoid confusion.
                            colDef: abstractColDef,
                            context: gridOptionsWrapper.getContext(),
                            api: gridOptionsWrapper.getApi()
                        };
                        var headerClassFunc = abstractColDef.headerClass;
                        classToUse = headerClassFunc(params);
                    } else {
                        classToUse = abstractColDef.headerClass;
                    }
                    if (typeof classToUse === 'string') {
                        utils_1.Utils.addCssClass(eHeaderCell, classToUse);
                    } else if (Array.isArray(classToUse)) {
                        classToUse.forEach(function (cssClassItem) {
                            utils_1.Utils.addCssClass(eHeaderCell, cssClassItem);
                        });
                    }
                }
            };
            return CssClassApplier;
        }();
        exports.CssClassApplier = CssClassApplier;

        /***/ },
    /* 311 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var column_1 = __webpack_require__(253);
        var filterManager_1 = __webpack_require__(281);
        var columnController_1 = __webpack_require__(251);
        var headerTemplateLoader_1 = __webpack_require__(312);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var horizontalDragService_1 = __webpack_require__(309);
        var gridCore_1 = __webpack_require__(278);
        var context_1 = __webpack_require__(244);
        var cssClassApplier_1 = __webpack_require__(310);
        var dragAndDropService_1 = __webpack_require__(306);
        var sortController_1 = __webpack_require__(280);
        var setLeftFeature_1 = __webpack_require__(301);
        var RenderedHeaderCell = function () {
            function RenderedHeaderCell(column, eRoot, dragSourceDropTarget) {
                // for better structured code, anything we need to do when this column gets destroyed,
                // we put a function in here. otherwise we would have a big destroy function with lots
                // of 'if / else' mapping to things that got created.
                this.destroyFunctions = [];
                this.column = column;
                this.eRoot = eRoot;
                this.dragSourceDropTarget = dragSourceDropTarget;
            }
            RenderedHeaderCell.prototype.getColumn = function () {
                return this.column;
            };
            RenderedHeaderCell.prototype.init = function () {
                this.eHeaderCell = this.headerTemplateLoader.createHeaderElement(this.column);
                utils_1.Utils.addCssClass(this.eHeaderCell, 'ag-header-cell');
                this.createScope();
                this.addAttributes();
                cssClassApplier_1.CssClassApplier.addHeaderClassesFromCollDef(this.column.getColDef(), this.eHeaderCell, this.gridOptionsWrapper);
                // label div
                var eHeaderCellLabel = this.eHeaderCell.querySelector('#agHeaderCellLabel');
                this.displayName = this.columnController.getDisplayNameForCol(this.column, true);
                this.setupMovingCss();
                this.setupTooltip();
                this.setupResize();
                this.setupMove(eHeaderCellLabel);
                this.setupMenu();
                this.setupSort(eHeaderCellLabel);
                this.setupFilterIcon();
                this.setupText();
                this.setupWidth();
                var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.column, this.eHeaderCell);
                this.destroyFunctions.push(setLeftFeature.destroy.bind(setLeftFeature));
            };
            RenderedHeaderCell.prototype.setupTooltip = function () {
                var colDef = this.column.getColDef();
                // add tooltip if exists
                if (colDef.headerTooltip) {
                    this.eHeaderCell.title = colDef.headerTooltip;
                }
            };
            RenderedHeaderCell.prototype.setupText = function () {
                var colDef = this.column.getColDef();
                // render the cell, use a renderer if one is provided
                var headerCellRenderer;
                if (colDef.headerCellRenderer) {
                    headerCellRenderer = colDef.headerCellRenderer;
                } else if (this.gridOptionsWrapper.getHeaderCellRenderer()) {
                    headerCellRenderer = this.gridOptionsWrapper.getHeaderCellRenderer();
                }
                var eText = this.eHeaderCell.querySelector('#agText');
                if (eText) {
                    if (headerCellRenderer) {
                        this.useRenderer(this.displayName, headerCellRenderer, eText);
                    } else {
                        // no renderer, default text render
                        eText.className = 'ag-header-cell-text';
                        eText.innerHTML = this.displayName;
                    }
                }
            };
            RenderedHeaderCell.prototype.setupFilterIcon = function () {
                var _this = this;
                var eFilterIcon = this.eHeaderCell.querySelector('#agFilter');
                if (!eFilterIcon) {
                    return;
                }
                var filterChangedListener = function filterChangedListener() {
                    var filterPresent = _this.column.isFilterActive();
                    utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-filtered', filterPresent);
                    utils_1.Utils.addOrRemoveCssClass(eFilterIcon, 'ag-hidden', !filterPresent);
                };
                this.column.addEventListener(column_1.Column.EVENT_FILTER_CHANGED, filterChangedListener);
                this.destroyFunctions.push(function () {
                    _this.column.removeEventListener(column_1.Column.EVENT_FILTER_CHANGED, filterChangedListener);
                });
                filterChangedListener();
            };
            RenderedHeaderCell.prototype.setupWidth = function () {
                var _this = this;
                var widthChangedListener = function widthChangedListener() {
                    _this.eHeaderCell.style.width = _this.column.getActualWidth() + 'px';
                };
                this.column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
                this.destroyFunctions.push(function () {
                    _this.column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
                });
                widthChangedListener();
            };
            RenderedHeaderCell.prototype.getGui = function () {
                return this.eHeaderCell;
            };
            RenderedHeaderCell.prototype.destroy = function () {
                this.destroyFunctions.forEach(function (func) {
                    func();
                });
            };
            RenderedHeaderCell.prototype.createScope = function () {
                var _this = this;
                if (this.gridOptionsWrapper.isAngularCompileHeaders()) {
                    this.childScope = this.$scope.$new();
                    this.childScope.colDef = this.column.getColDef();
                    this.childScope.colDefWrapper = this.column;
                    this.childScope.context = this.gridOptionsWrapper.getContext();
                    this.destroyFunctions.push(function () {
                        _this.childScope.$destroy();
                    });
                }
            };
            RenderedHeaderCell.prototype.addAttributes = function () {
                this.eHeaderCell.setAttribute("colId", this.column.getColId());
            };
            RenderedHeaderCell.prototype.setupMenu = function () {
                var _this = this;
                var eMenu = this.eHeaderCell.querySelector('#agMenu');
                // if no menu provided in template, do nothing
                if (!eMenu) {
                    return;
                }
                var skipMenu = !this.menuFactory.isMenuEnabled(this.column) || this.column.getColDef().suppressMenu;
                if (skipMenu) {
                    utils_1.Utils.removeFromParent(eMenu);
                    return;
                }
                eMenu.addEventListener('click', function () {
                    return _this.showMenu(eMenu);
                });
                if (!this.gridOptionsWrapper.isSuppressMenuHide()) {
                    eMenu.style.opacity = '0';
                    this.eHeaderCell.addEventListener('mouseover', function () {
                        eMenu.style.opacity = '1';
                    });
                    this.eHeaderCell.addEventListener('mouseout', function () {
                        eMenu.style.opacity = '0';
                    });
                }
                var style = eMenu.style;
                style['transition'] = 'opacity 0.2s, border 0.2s';
                style['-webkit-transition'] = 'opacity 0.2s, border 0.2s';
            };
            RenderedHeaderCell.prototype.showMenu = function (eventSource) {
                this.menuFactory.showMenuAfterButtonClick(this.column, eventSource);
            };
            RenderedHeaderCell.prototype.setupMovingCss = function () {
                var _this = this;
                // this function adds or removes the moving css, based on if the col is moving
                var addMovingCssFunc = function addMovingCssFunc() {
                    if (_this.column.isMoving()) {
                        utils_1.Utils.addCssClass(_this.eHeaderCell, 'ag-header-cell-moving');
                    } else {
                        utils_1.Utils.removeCssClass(_this.eHeaderCell, 'ag-header-cell-moving');
                    }
                };
                // call it now once, so the col is set up correctly
                addMovingCssFunc();
                // then call it every time we are informed of a moving state change in the col
                this.column.addEventListener(column_1.Column.EVENT_MOVING_CHANGED, addMovingCssFunc);
                // finally we remove the listener when this cell is no longer rendered
                this.destroyFunctions.push(function () {
                    _this.column.removeEventListener(column_1.Column.EVENT_MOVING_CHANGED, addMovingCssFunc);
                });
            };
            RenderedHeaderCell.prototype.setupMove = function (eHeaderCellLabel) {
                var suppressMove = this.gridOptionsWrapper.isSuppressMovableColumns() || this.column.getColDef().suppressMovable || this.gridOptionsWrapper.isForPrint();
                // || this.columnController.isPivotMode();
                if (suppressMove) {
                    return;
                }
                if (eHeaderCellLabel) {
                    var dragSource = {
                        type: dragAndDropService_1.DragSourceType.HeaderCell,
                        eElement: eHeaderCellLabel,
                        dragItem: [this.column],
                        dragItemName: this.displayName,
                        dragSourceDropTarget: this.dragSourceDropTarget
                    };
                    this.dragAndDropService.addDragSource(dragSource);
                }
            };
            RenderedHeaderCell.prototype.setupResize = function () {
                var _this = this;
                var colDef = this.column.getColDef();
                var eResize = this.eHeaderCell.querySelector('#agResizeBar');
                // if no eResize in template, do nothing
                if (!eResize) {
                    return;
                }
                var weWantResize = this.gridOptionsWrapper.isEnableColResize() && !colDef.suppressResize;
                if (!weWantResize) {
                    utils_1.Utils.removeFromParent(eResize);
                    return;
                }
                this.horizontalDragService.addDragHandling({
                    eDraggableElement: eResize,
                    eBody: this.eRoot,
                    cursor: 'col-resize',
                    startAfterPixels: 0,
                    onDragStart: this.onDragStart.bind(this),
                    onDragging: this.onDragging.bind(this)
                });
                var weWantAutoSize = !this.gridOptionsWrapper.isSuppressAutoSize() && !colDef.suppressAutoSize;
                if (weWantAutoSize) {
                    eResize.addEventListener('dblclick', function () {
                        _this.columnController.autoSizeColumn(_this.column);
                    });
                }
            };
            RenderedHeaderCell.prototype.useRenderer = function (headerNameValue, headerCellRenderer, eText) {
                // renderer provided, use it
                var cellRendererParams = {
                    colDef: this.column.getColDef(),
                    $scope: this.childScope,
                    context: this.gridOptionsWrapper.getContext(),
                    value: headerNameValue,
                    api: this.gridOptionsWrapper.getApi(),
                    eHeaderCell: this.eHeaderCell
                };
                var cellRendererResult = headerCellRenderer(cellRendererParams);
                var childToAppend;
                if (utils_1.Utils.isNodeOrElement(cellRendererResult)) {
                    // a dom node or element was returned, so add child
                    childToAppend = cellRendererResult;
                } else {
                    // otherwise assume it was html, so just insert
                    var eTextSpan = document.createElement("span");
                    eTextSpan.innerHTML = cellRendererResult;
                    childToAppend = eTextSpan;
                }
                // angular compile header if option is turned on
                if (this.gridOptionsWrapper.isAngularCompileHeaders()) {
                    var childToAppendCompiled = this.$compile(childToAppend)(this.childScope)[0];
                    eText.appendChild(childToAppendCompiled);
                } else {
                    eText.appendChild(childToAppend);
                }
            };
            RenderedHeaderCell.prototype.setupSort = function (eHeaderCellLabel) {
                var _this = this;
                var enableSorting = this.gridOptionsWrapper.isEnableSorting() && !this.column.getColDef().suppressSorting;
                if (!enableSorting) {
                    utils_1.Utils.removeFromParent(this.eHeaderCell.querySelector('#agSortAsc'));
                    utils_1.Utils.removeFromParent(this.eHeaderCell.querySelector('#agSortDesc'));
                    utils_1.Utils.removeFromParent(this.eHeaderCell.querySelector('#agNoSort'));
                    return;
                }
                // add sortable class for styling
                utils_1.Utils.addCssClass(this.eHeaderCell, 'ag-header-cell-sortable');
                // add the event on the header, so when clicked, we do sorting
                if (eHeaderCellLabel) {
                    eHeaderCellLabel.addEventListener("click", function (event) {
                        _this.sortController.progressSort(_this.column, event.shiftKey);
                    });
                }
                // add listener for sort changing, and update the icons accordingly
                var eSortAsc = this.eHeaderCell.querySelector('#agSortAsc');
                var eSortDesc = this.eHeaderCell.querySelector('#agSortDesc');
                var eSortNone = this.eHeaderCell.querySelector('#agNoSort');
                var sortChangedListener = function sortChangedListener() {
                    utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-sorted-asc', _this.column.isSortAscending());
                    utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-sorted-desc', _this.column.isSortDescending());
                    utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-sorted-none', _this.column.isSortNone());
                    if (eSortAsc) {
                        utils_1.Utils.addOrRemoveCssClass(eSortAsc, 'ag-hidden', !_this.column.isSortAscending());
                    }
                    if (eSortDesc) {
                        utils_1.Utils.addOrRemoveCssClass(eSortDesc, 'ag-hidden', !_this.column.isSortDescending());
                    }
                    if (eSortNone) {
                        var alwaysHideNoSort = !_this.column.getColDef().unSortIcon && !_this.gridOptionsWrapper.isUnSortIcon();
                        utils_1.Utils.addOrRemoveCssClass(eSortNone, 'ag-hidden', alwaysHideNoSort || !_this.column.isSortNone());
                    }
                };
                this.column.addEventListener(column_1.Column.EVENT_SORT_CHANGED, sortChangedListener);
                this.destroyFunctions.push(function () {
                    _this.column.removeEventListener(column_1.Column.EVENT_SORT_CHANGED, sortChangedListener);
                });
                sortChangedListener();
            };
            RenderedHeaderCell.prototype.onDragStart = function () {
                this.startWidth = this.column.getActualWidth();
            };
            RenderedHeaderCell.prototype.onDragging = function (dragChange, finished) {
                var newWidth = this.startWidth + dragChange;
                this.columnController.setColumnWidth(this.column, newWidth, finished);
            };
            RenderedHeaderCell.prototype.onIndividualColumnResized = function (column) {
                if (this.column !== column) {
                    return;
                }
                var newWidthPx = column.getActualWidth() + "px";
                this.eHeaderCell.style.width = newWidthPx;
            };
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], RenderedHeaderCell.prototype, "context", void 0);
            __decorate([context_1.Autowired('filterManager'), __metadata('design:type', filterManager_1.FilterManager)], RenderedHeaderCell.prototype, "filterManager", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], RenderedHeaderCell.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('$compile'), __metadata('design:type', Object)], RenderedHeaderCell.prototype, "$compile", void 0);
            __decorate([context_1.Autowired('gridCore'), __metadata('design:type', gridCore_1.GridCore)], RenderedHeaderCell.prototype, "gridCore", void 0);
            __decorate([context_1.Autowired('headerTemplateLoader'), __metadata('design:type', headerTemplateLoader_1.HeaderTemplateLoader)], RenderedHeaderCell.prototype, "headerTemplateLoader", void 0);
            __decorate([context_1.Autowired('horizontalDragService'), __metadata('design:type', horizontalDragService_1.HorizontalDragService)], RenderedHeaderCell.prototype, "horizontalDragService", void 0);
            __decorate([context_1.Autowired('menuFactory'), __metadata('design:type', Object)], RenderedHeaderCell.prototype, "menuFactory", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], RenderedHeaderCell.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('dragAndDropService'), __metadata('design:type', dragAndDropService_1.DragAndDropService)], RenderedHeaderCell.prototype, "dragAndDropService", void 0);
            __decorate([context_1.Autowired('sortController'), __metadata('design:type', sortController_1.SortController)], RenderedHeaderCell.prototype, "sortController", void 0);
            __decorate([context_1.Autowired('$scope'), __metadata('design:type', Object)], RenderedHeaderCell.prototype, "$scope", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RenderedHeaderCell.prototype, "init", null);
            return RenderedHeaderCell;
        }();
        exports.RenderedHeaderCell = RenderedHeaderCell;

        /***/ },
    /* 312 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var svgFactory_1 = __webpack_require__(297);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var context_1 = __webpack_require__(244);
        var svgFactory = svgFactory_1.SvgFactory.getInstance();
        var HeaderTemplateLoader = function () {
            function HeaderTemplateLoader() {}
            HeaderTemplateLoader.prototype.createHeaderElement = function (column) {
                var params = {
                    column: column,
                    colDef: column.getColDef,
                    context: this.gridOptionsWrapper.getContext(),
                    api: this.gridOptionsWrapper.getApi()
                };
                // option 1 - see if user provided a template in colDef
                var userProvidedTemplate = column.getColDef().headerCellTemplate;
                if (typeof userProvidedTemplate === 'function') {
                    var colDefFunc = userProvidedTemplate;
                    userProvidedTemplate = colDefFunc(params);
                }
                // option 2 - check the gridOptions for cellTemplate
                if (!userProvidedTemplate && this.gridOptionsWrapper.getHeaderCellTemplate()) {
                    userProvidedTemplate = this.gridOptionsWrapper.getHeaderCellTemplate();
                }
                // option 3 - check the gridOptions for templateFunction
                if (!userProvidedTemplate && this.gridOptionsWrapper.getHeaderCellTemplateFunc()) {
                    var gridOptionsFunc = this.gridOptionsWrapper.getHeaderCellTemplateFunc();
                    userProvidedTemplate = gridOptionsFunc(params);
                }
                // finally, if still no template, use the default
                if (!userProvidedTemplate) {
                    userProvidedTemplate = this.createDefaultHeaderElement(column);
                }
                // template can be a string or a dom element, if string we need to convert to a dom element
                var result;
                if (typeof userProvidedTemplate === 'string') {
                    result = utils_1.Utils.loadTemplate(userProvidedTemplate);
                } else if (utils_1.Utils.isNodeOrElement(userProvidedTemplate)) {
                    result = userProvidedTemplate;
                } else {
                    console.error('ag-Grid: header template must be a string or an HTML element');
                }
                return result;
            };
            HeaderTemplateLoader.prototype.createDefaultHeaderElement = function (column) {
                var eTemplate = utils_1.Utils.loadTemplate(HeaderTemplateLoader.HEADER_CELL_TEMPLATE);
                this.addInIcon(eTemplate, 'sortAscending', '#agSortAsc', column, svgFactory.createArrowUpSvg);
                this.addInIcon(eTemplate, 'sortDescending', '#agSortDesc', column, svgFactory.createArrowDownSvg);
                this.addInIcon(eTemplate, 'sortUnSort', '#agNoSort', column, svgFactory.createArrowUpDownSvg);
                this.addInIcon(eTemplate, 'menu', '#agMenu', column, svgFactory.createMenuSvg);
                this.addInIcon(eTemplate, 'filter', '#agFilter', column, svgFactory.createFilterSvg);
                return eTemplate;
            };
            HeaderTemplateLoader.prototype.addInIcon = function (eTemplate, iconName, cssSelector, column, defaultIconFactory) {
                var eIcon = utils_1.Utils.createIconNoSpan(iconName, this.gridOptionsWrapper, column, defaultIconFactory);
                eTemplate.querySelector(cssSelector).appendChild(eIcon);
            };
            HeaderTemplateLoader.HEADER_CELL_TEMPLATE = '<div class="ag-header-cell">' + '  <div id="agResizeBar" class="ag-header-cell-resize"></div>' + '  <span id="agMenu" class="ag-header-icon ag-header-cell-menu-button"></span>' + '  <div id="agHeaderCellLabel" class="ag-header-cell-label">' + '    <span id="agSortAsc" class="ag-header-icon ag-sort-ascending-icon"></span>' + '    <span id="agSortDesc" class="ag-header-icon ag-sort-descending-icon"></span>' + '    <span id="agNoSort" class="ag-header-icon ag-sort-none-icon"></span>' + '    <span id="agFilter" class="ag-header-icon ag-filter-icon"></span>' + '    <span id="agText" class="ag-header-cell-text"></span>' + '  </div>' + '</div>';
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], HeaderTemplateLoader.prototype, "gridOptionsWrapper", void 0);
            HeaderTemplateLoader = __decorate([context_1.Bean('headerTemplateLoader'), __metadata('design:paramtypes', [])], HeaderTemplateLoader);
            return HeaderTemplateLoader;
        }();
        exports.HeaderTemplateLoader = HeaderTemplateLoader;

        /***/ },
    /* 313 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var dragAndDropService_1 = __webpack_require__(306);
        var context_1 = __webpack_require__(244);
        var moveColumnController_1 = __webpack_require__(314);
        var column_1 = __webpack_require__(253);
        var gridPanel_1 = __webpack_require__(262);
        var bodyDropPivotTarget_1 = __webpack_require__(315);
        var columnController_1 = __webpack_require__(251);
        var BodyDropTarget = function () {
            function BodyDropTarget(pinned, eContainer) {
                this.pinned = pinned;
                this.eContainer = eContainer;
            }
            BodyDropTarget.prototype.getSecondaryContainers = function () {
                return this.eSecondaryContainers;
            };
            BodyDropTarget.prototype.getContainer = function () {
                return this.eContainer;
            };
            BodyDropTarget.prototype.init = function () {
                this.moveColumnController = new moveColumnController_1.MoveColumnController(this.pinned);
                this.context.wireBean(this.moveColumnController);
                this.bodyDropPivotTarget = new bodyDropPivotTarget_1.BodyDropPivotTarget(this.pinned);
                this.context.wireBean(this.bodyDropPivotTarget);
                switch (this.pinned) {
                    case column_1.Column.PINNED_LEFT:
                        this.eSecondaryContainers = this.gridPanel.getDropTargetLeftContainers();
                        break;
                    case column_1.Column.PINNED_RIGHT:
                        this.eSecondaryContainers = this.gridPanel.getDropTargetPinnedRightContainers();
                        break;
                    default:
                        this.eSecondaryContainers = this.gridPanel.getDropTargetBodyContainers();
                        break;
                }
                this.dragAndDropService.addDropTarget(this);
            };
            BodyDropTarget.prototype.getIconName = function () {
                return this.currentDropListener.getIconName();
            };
            // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
            // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
            // dropped into the grid's body.
            BodyDropTarget.prototype.isUseBodyDropPivotTarget = function (draggingEvent) {
                // if not in pivot mode, then we never use the pivot drop target
                if (!this.columnController.isPivotMode()) {
                    return false;
                }
                // otherwise we use the drop target if the column came from the toolPanel (ie not reordering)
                return draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.ToolPanel;
            };
            BodyDropTarget.prototype.onDragEnter = function (draggingEvent) {
                // we pick the drop listener depending on whether we are in pivot mode are not. if we are
                // in pivot mode, then dropping cols changes the row group, pivot, value stats. otherwise
                // we change visibility state and position.
                // if (this.columnController.isPivotMode()) {
                var useBodyDropPivotTarget = this.isUseBodyDropPivotTarget(draggingEvent);
                if (useBodyDropPivotTarget) {
                    this.currentDropListener = this.bodyDropPivotTarget;
                } else {
                    this.currentDropListener = this.moveColumnController;
                }
                this.currentDropListener.onDragEnter(draggingEvent);
            };
            BodyDropTarget.prototype.onDragLeave = function (params) {
                this.currentDropListener.onDragLeave(params);
            };
            BodyDropTarget.prototype.onDragging = function (params) {
                this.currentDropListener.onDragging(params);
            };
            BodyDropTarget.prototype.onDragStop = function (params) {
                this.currentDropListener.onDragStop(params);
            };
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], BodyDropTarget.prototype, "context", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], BodyDropTarget.prototype, "gridPanel", void 0);
            __decorate([context_1.Autowired('dragAndDropService'), __metadata('design:type', dragAndDropService_1.DragAndDropService)], BodyDropTarget.prototype, "dragAndDropService", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], BodyDropTarget.prototype, "columnController", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], BodyDropTarget.prototype, "init", null);
            return BodyDropTarget;
        }();
        exports.BodyDropTarget = BodyDropTarget;

        /***/ },
    /* 314 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var logger_1 = __webpack_require__(243);
        var columnController_1 = __webpack_require__(251);
        var column_1 = __webpack_require__(253);
        var utils_1 = __webpack_require__(245);
        var dragAndDropService_1 = __webpack_require__(306);
        var gridPanel_1 = __webpack_require__(262);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var MoveColumnController = function () {
            function MoveColumnController(pinned) {
                this.needToMoveLeft = false;
                this.needToMoveRight = false;
                this.pinned = pinned;
                this.centerContainer = !utils_1.Utils.exists(pinned);
            }
            MoveColumnController.prototype.init = function () {
                this.logger = this.loggerFactory.create('MoveColumnController');
            };
            MoveColumnController.prototype.getIconName = function () {
                return this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;
                ;
            };
            MoveColumnController.prototype.onDragEnter = function (draggingEvent) {
                // we do dummy drag, so make sure column appears in the right location when first placed
                var columns = draggingEvent.dragSource.dragItem;
                this.columnController.setColumnsVisible(columns, true);
                this.columnController.setColumnsPinned(columns, this.pinned);
                this.onDragging(draggingEvent, true);
            };
            MoveColumnController.prototype.onDragLeave = function (draggingEvent) {
                var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;
                if (hideColumnOnExit) {
                    var columns = draggingEvent.dragSource.dragItem;
                    this.columnController.setColumnsVisible(columns, false);
                }
                this.ensureIntervalCleared();
            };
            MoveColumnController.prototype.onDragStop = function () {
                this.ensureIntervalCleared();
            };
            MoveColumnController.prototype.adjustXForScroll = function (draggingEvent) {
                if (this.centerContainer) {
                    return draggingEvent.x + this.gridPanel.getHorizontalScrollPosition();
                } else {
                    return draggingEvent.x;
                }
            };
            MoveColumnController.prototype.workOutNewIndex = function (displayedColumns, allColumns, dragColumn, direction, xAdjustedForScroll) {
                if (direction === dragAndDropService_1.DragAndDropService.DIRECTION_LEFT) {
                    return this.getNewIndexForColMovingLeft(displayedColumns, allColumns, dragColumn, xAdjustedForScroll);
                } else {
                    return this.getNewIndexForColMovingRight(displayedColumns, allColumns, dragColumn, xAdjustedForScroll);
                }
            };
            MoveColumnController.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {
                if (this.centerContainer) {
                    // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)
                    // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen
                    var firstVisiblePixel = this.gridPanel.getHorizontalScrollPosition();
                    var lastVisiblePixel = firstVisiblePixel + this.gridPanel.getCenterWidth();
                    this.needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + 50;
                    this.needToMoveRight = xAdjustedForScroll > lastVisiblePixel - 50;
                    if (this.needToMoveLeft || this.needToMoveRight) {
                        this.ensureIntervalStarted();
                    } else {
                        this.ensureIntervalCleared();
                    }
                }
            };
            MoveColumnController.prototype.onDragging = function (draggingEvent, fromEnter) {
                if (fromEnter === void 0) {
                    fromEnter = false;
                }
                this.lastDraggingEvent = draggingEvent;
                // if moving up or down (ie not left or right) then do nothing
                if (!draggingEvent.direction) {
                    return;
                }
                var xAdjustedForScroll = this.adjustXForScroll(draggingEvent);
                // if the user is dragging into the panel, ie coming from the side panel into the main grid,
                // we don't want to scroll the grid this time, it would appear like the table is jumping
                // each time a column is dragged in.
                if (!fromEnter) {
                    this.checkCenterForScrolling(xAdjustedForScroll);
                }
                var columnsToMove = draggingEvent.dragSource.dragItem;
                this.attemptMoveColumns(columnsToMove, draggingEvent.direction, xAdjustedForScroll, fromEnter);
            };
            MoveColumnController.prototype.attemptMoveColumns = function (allMovingColumns, dragDirection, xAdjustedForScroll, fromEnter) {
                var displayedColumns = this.columnController.getDisplayedColumns(this.pinned);
                var gridColumns = this.columnController.getAllGridColumns();
                var draggingLeft = dragDirection === dragAndDropService_1.DragAndDropService.DIRECTION_LEFT;
                var draggingRight = dragDirection === dragAndDropService_1.DragAndDropService.DIRECTION_RIGHT;
                var dragColumn;
                var displayedMovingColumns = utils_1.Utils.filter(allMovingColumns, function (column) {
                    return displayedColumns.indexOf(column) >= 0;
                });
                // if dragging left, we want to use the left most column, ie move the left most column to
                // under the mouse pointer
                if (draggingLeft) {
                    dragColumn = displayedMovingColumns[0];
                } else {
                    dragColumn = displayedMovingColumns[displayedMovingColumns.length - 1];
                }
                var newIndex = this.workOutNewIndex(displayedColumns, gridColumns, dragColumn, dragDirection, xAdjustedForScroll);
                var oldIndex = gridColumns.indexOf(dragColumn);
                // the two check below stop an error when the user grabs a group my a middle column, then
                // it is possible the mouse pointer is to the right of a column while been dragged left.
                // so we need to make sure that the mouse pointer is actually left of the left most column
                // if moving left, and right of the right most column if moving right
                // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from
                // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should
                // place the column to the RHS even if the mouse is moving left and the column is already on
                // the LHS. otherwise we stick to the rule described above.
                // only allow left drag if this column is moving left
                if (!fromEnter && draggingLeft && newIndex >= oldIndex) {
                    return;
                }
                // only allow right drag if this column is moving right
                if (!fromEnter && draggingRight && newIndex <= oldIndex) {
                    return;
                }
                // if moving right, the new index is the index of the right most column, so adjust to first column
                if (draggingRight) {
                    newIndex = newIndex - allMovingColumns.length + 1;
                }
                this.columnController.moveColumns(allMovingColumns, newIndex);
            };
            MoveColumnController.prototype.getNewIndexForColMovingLeft = function (displayedColumns, allColumns, dragColumn, x) {
                var usedX = 0;
                var leftColumn = null;
                for (var i = 0; i < displayedColumns.length; i++) {
                    var currentColumn = displayedColumns[i];
                    if (currentColumn === dragColumn) {
                        continue;
                    }
                    usedX += currentColumn.getActualWidth();
                    if (usedX > x) {
                        break;
                    }
                    leftColumn = currentColumn;
                }
                var newIndex;
                if (leftColumn) {
                    newIndex = allColumns.indexOf(leftColumn) + 1;
                    var oldIndex = allColumns.indexOf(dragColumn);
                    if (oldIndex < newIndex) {
                        newIndex--;
                    }
                } else {
                    newIndex = 0;
                }
                return newIndex;
            };
            MoveColumnController.prototype.getNewIndexForColMovingRight = function (displayedColumns, allColumns, dragColumnOrGroup, x) {
                var dragColumn = dragColumnOrGroup;
                var usedX = dragColumn.getActualWidth();
                var leftColumn = null;
                for (var i = 0; i < displayedColumns.length; i++) {
                    if (usedX > x) {
                        break;
                    }
                    var currentColumn = displayedColumns[i];
                    if (currentColumn === dragColumn) {
                        continue;
                    }
                    usedX += currentColumn.getActualWidth();
                    leftColumn = currentColumn;
                }
                var newIndex;
                if (leftColumn) {
                    newIndex = allColumns.indexOf(leftColumn) + 1;
                    var oldIndex = allColumns.indexOf(dragColumn);
                    if (oldIndex < newIndex) {
                        newIndex--;
                    }
                } else {
                    newIndex = 0;
                }
                return newIndex;
            };
            MoveColumnController.prototype.ensureIntervalStarted = function () {
                if (!this.movingIntervalId) {
                    this.intervalCount = 0;
                    this.failedMoveAttempts = 0;
                    this.movingIntervalId = setInterval(this.moveInterval.bind(this), 100);
                    if (this.needToMoveLeft) {
                        this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_LEFT, true);
                    } else {
                        this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_RIGHT, true);
                    }
                }
            };
            MoveColumnController.prototype.ensureIntervalCleared = function () {
                if (this.moveInterval) {
                    clearInterval(this.movingIntervalId);
                    this.movingIntervalId = null;
                    this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_MOVE);
                }
            };
            MoveColumnController.prototype.moveInterval = function () {
                var pixelsToMove;
                this.intervalCount++;
                pixelsToMove = 10 + this.intervalCount * 5;
                if (pixelsToMove > 100) {
                    pixelsToMove = 100;
                }
                var pixelsMoved;
                if (this.needToMoveLeft) {
                    pixelsMoved = this.gridPanel.scrollHorizontally(-pixelsToMove);
                } else if (this.needToMoveRight) {
                    pixelsMoved = this.gridPanel.scrollHorizontally(pixelsToMove);
                }
                if (pixelsMoved !== 0) {
                    this.onDragging(this.lastDraggingEvent);
                    this.failedMoveAttempts = 0;
                } else {
                    this.failedMoveAttempts++;
                    this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_PINNED);
                    if (this.failedMoveAttempts > 7) {
                        var columns = this.lastDraggingEvent.dragSource.dragItem;
                        var pinType = this.needToMoveLeft ? column_1.Column.PINNED_LEFT : column_1.Column.PINNED_RIGHT;
                        this.columnController.setColumnsPinned(columns, pinType);
                        this.dragAndDropService.nudge();
                    }
                }
            };
            __decorate([context_1.Autowired('loggerFactory'), __metadata('design:type', logger_1.LoggerFactory)], MoveColumnController.prototype, "loggerFactory", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], MoveColumnController.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('gridPanel'), __metadata('design:type', gridPanel_1.GridPanel)], MoveColumnController.prototype, "gridPanel", void 0);
            __decorate([context_1.Autowired('dragAndDropService'), __metadata('design:type', dragAndDropService_1.DragAndDropService)], MoveColumnController.prototype, "dragAndDropService", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], MoveColumnController.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], MoveColumnController.prototype, "init", null);
            return MoveColumnController;
        }();
        exports.MoveColumnController = MoveColumnController;

        /***/ },
    /* 315 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var dragAndDropService_1 = __webpack_require__(306);
        var columnController_1 = __webpack_require__(251);
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var BodyDropPivotTarget = function () {
            function BodyDropPivotTarget(pinned) {
                this.columnsToAggregate = [];
                this.columnsToGroup = [];
                this.columnsToPivot = [];
                this.pinned = pinned;
            }
            /** Callback for when drag enters */
            BodyDropPivotTarget.prototype.onDragEnter = function (draggingEvent) {
                var _this = this;
                this.clearColumnsList();
                // in pivot mode, we don't accept any drops if functions are read only
                if (this.gridOptionsWrapper.isFunctionsReadOnly()) {
                    return;
                }
                var dragColumns = draggingEvent.dragSource.dragItem;
                dragColumns.forEach(function (column) {
                    // we don't allow adding secondary columns
                    if (!column.isPrimary()) {
                        return;
                    }
                    if (column.isAnyFunctionActive()) {
                        return;
                    }
                    if (column.isAllowValue()) {
                        _this.columnsToAggregate.push(column);
                    } else if (column.isAllowRowGroup()) {
                        _this.columnsToGroup.push(column);
                    } else if (column.isAllowRowGroup()) {
                        _this.columnsToPivot.push(column);
                    }
                });
            };
            BodyDropPivotTarget.prototype.getIconName = function () {
                var totalColumns = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
                if (totalColumns > 0) {
                    return this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;
                } else {
                    return null;
                }
            };
            /** Callback for when drag leaves */
            BodyDropPivotTarget.prototype.onDragLeave = function (draggingEvent) {
                // if we are taking columns out of the center, then we remove them from the report
                this.clearColumnsList();
            };
            BodyDropPivotTarget.prototype.clearColumnsList = function () {
                this.columnsToAggregate.length = 0;
                this.columnsToGroup.length = 0;
                this.columnsToPivot.length = 0;
            };
            /** Callback for when dragging */
            BodyDropPivotTarget.prototype.onDragging = function (draggingEvent) {};
            /** Callback for when drag stops */
            BodyDropPivotTarget.prototype.onDragStop = function (draggingEvent) {
                if (this.columnsToAggregate.length > 0) {
                    this.columnController.addValueColumns(this.columnsToAggregate);
                }
                if (this.columnsToGroup.length > 0) {
                    this.columnController.addRowGroupColumns(this.columnsToGroup);
                }
                if (this.columnsToPivot.length > 0) {
                    this.columnController.addPivotColumns(this.columnsToPivot);
                }
            };
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], BodyDropPivotTarget.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], BodyDropPivotTarget.prototype, "gridOptionsWrapper", void 0);
            return BodyDropPivotTarget;
        }();
        exports.BodyDropPivotTarget = BodyDropPivotTarget;

        /***/ },
    /* 316 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var ColumnChangeEvent = function () {
            function ColumnChangeEvent(type) {
                this.type = type;
            }
            ColumnChangeEvent.prototype.toString = function () {
                var result = 'ColumnChangeEvent {type: ' + this.type;
                if (this.column) {
                    result += ', column: ' + this.column.getColId();
                }
                if (this.columnGroup) {
                    result +=  true ? this.columnGroup.getColGroupDef().headerName : '(not defined]';
                }
                if (this.toIndex) {
                    result += ', toIndex: ' + this.toIndex;
                }
                if (this.visible) {
                    result += ', visible: ' + this.visible;
                }
                if (this.pinned) {
                    result += ', pinned: ' + this.pinned;
                }
                if (typeof this.finished == 'boolean') {
                    result += ', finished: ' + this.finished;
                }
                result += '}';
                return result;
            };
            ColumnChangeEvent.prototype.withPinned = function (pinned) {
                this.pinned = pinned;
                return this;
            };
            ColumnChangeEvent.prototype.withVisible = function (visible) {
                this.visible = visible;
                return this;
            };
            ColumnChangeEvent.prototype.isVisible = function () {
                return this.visible;
            };
            ColumnChangeEvent.prototype.getPinned = function () {
                return this.pinned;
            };
            ColumnChangeEvent.prototype.withColumn = function (column) {
                this.column = column;
                return this;
            };
            ColumnChangeEvent.prototype.withColumns = function (columns) {
                this.columns = columns;
                return this;
            };
            ColumnChangeEvent.prototype.withFinished = function (finished) {
                this.finished = finished;
                return this;
            };
            ColumnChangeEvent.prototype.withColumnGroup = function (columnGroup) {
                this.columnGroup = columnGroup;
                return this;
            };
            ColumnChangeEvent.prototype.withToIndex = function (toIndex) {
                this.toIndex = toIndex;
                return this;
            };
            ColumnChangeEvent.prototype.getToIndex = function () {
                return this.toIndex;
            };
            ColumnChangeEvent.prototype.getType = function () {
                return this.type;
            };
            ColumnChangeEvent.prototype.getColumn = function () {
                return this.column;
            };
            ColumnChangeEvent.prototype.getColumns = function () {
                return this.columns;
            };
            ColumnChangeEvent.prototype.getColumnGroup = function () {
                return this.columnGroup;
            };
            ColumnChangeEvent.prototype.isFinished = function () {
                return this.finished;
            };
            return ColumnChangeEvent;
        }();
        exports.ColumnChangeEvent = ColumnChangeEvent;

        /***/ },
    /* 317 */
    /***/ function(module, exports) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
            // class returns unique instance id's for columns.
            // eg, the following calls (in this order) will result in:
            //
            // getInstanceIdForKey('country') => 0
            // getInstanceIdForKey('country') => 1
            // getInstanceIdForKey('country') => 2
            // getInstanceIdForKey('country') => 3
            // getInstanceIdForKey('age') => 0
            // getInstanceIdForKey('age') => 1
            // getInstanceIdForKey('country') => 4
        var GroupInstanceIdCreator = function () {
                function GroupInstanceIdCreator() {
                    // this map contains keys to numbers, so we remember what the last call was
                    this.existingIds = {};
                }
                GroupInstanceIdCreator.prototype.getInstanceIdForKey = function (key) {
                    var lastResult = this.existingIds[key];
                    var result;
                    if (typeof lastResult !== 'number') {
                        // first time this key
                        result = 0;
                    } else {
                        result = lastResult + 1;
                    }
                    this.existingIds[key] = result;
                    return result;
                };
                return GroupInstanceIdCreator;
            }();
        exports.GroupInstanceIdCreator = GroupInstanceIdCreator;

        /***/ },
    /* 318 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var utils_1 = __webpack_require__(245);
        function defaultGroupComparator(valueA, valueB, nodeA, nodeB) {
            var nodeAIsGroup = utils_1.Utils.exists(nodeA) && nodeA.group;
            var nodeBIsGroup = utils_1.Utils.exists(nodeB) && nodeB.group;
            var bothAreGroups = nodeAIsGroup && nodeBIsGroup;
            var bothAreNormal = !nodeAIsGroup && !nodeBIsGroup;
            if (bothAreGroups) {
                return utils_1.Utils.defaultComparator(nodeA.key, nodeB.key);
            } else if (bothAreNormal) {
                return utils_1.Utils.defaultComparator(valueA, valueB);
            } else if (nodeAIsGroup) {
                return 1;
            } else {
                return -1;
            }
        }
        exports.defaultGroupComparator = defaultGroupComparator;

        /***/ },
    /* 319 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var utils_1 = __webpack_require__(245);
        var logger_1 = __webpack_require__(243);
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        /** Functionality for internal DnD functionality between GUI widgets. Eg this service is used to drag columns
         * from the 'available columns' list and putting them into the 'grouped columns' in the tool panel.
         * This service is NOT used by the column headers for resizing and moving, that is a different use case. */
        var OldToolPanelDragAndDropService = function () {
            function OldToolPanelDragAndDropService() {
                this.destroyFunctions = [];
            }
            OldToolPanelDragAndDropService.prototype.agWire = function (loggerFactory) {
                this.logger = loggerFactory.create('OldToolPanelDragAndDropService');
                // need to clean this up, add to 'finished' logic in grid
                var mouseUpListener = this.stopDragging.bind(this);
                document.addEventListener('mouseup', mouseUpListener);
                this.destroyFunctions.push(function () {
                    document.removeEventListener('mouseup', mouseUpListener);
                });
            };
            OldToolPanelDragAndDropService.prototype.destroy = function () {
                this.destroyFunctions.forEach(function (func) {
                    return func();
                });
                document.removeEventListener('mouseup', this.mouseUpEventListener);
            };
            OldToolPanelDragAndDropService.prototype.stopDragging = function () {
                if (this.dragItem) {
                    this.setDragCssClasses(this.dragItem.eDragSource, false);
                    this.dragItem = null;
                }
            };
            OldToolPanelDragAndDropService.prototype.setDragCssClasses = function (eListItem, dragging) {
                utils_1.Utils.addOrRemoveCssClass(eListItem, 'ag-dragging', dragging);
                utils_1.Utils.addOrRemoveCssClass(eListItem, 'ag-not-dragging', !dragging);
            };
            OldToolPanelDragAndDropService.prototype.addDragSource = function (eDragSource, dragSourceCallback) {
                this.setDragCssClasses(eDragSource, false);
                eDragSource.addEventListener('mousedown', this.onMouseDownDragSource.bind(this, eDragSource, dragSourceCallback));
            };
            OldToolPanelDragAndDropService.prototype.onMouseDownDragSource = function (eDragSource, dragSourceCallback) {
                if (this.dragItem) {
                    this.stopDragging();
                }
                var data;
                if (dragSourceCallback.getData) {
                    data = dragSourceCallback.getData();
                }
                var containerId;
                if (dragSourceCallback.getContainerId) {
                    containerId = dragSourceCallback.getContainerId();
                }
                this.dragItem = {
                    eDragSource: eDragSource,
                    data: data,
                    containerId: containerId
                };
                this.setDragCssClasses(this.dragItem.eDragSource, true);
            };
            OldToolPanelDragAndDropService.prototype.addDropTarget = function (eDropTarget, dropTargetCallback) {
                var _this = this;
                var mouseIn = false;
                var acceptDrag = false;
                eDropTarget.addEventListener('mouseover', function () {
                    if (!mouseIn) {
                        mouseIn = true;
                        if (_this.dragItem) {
                            acceptDrag = dropTargetCallback.acceptDrag(_this.dragItem);
                        } else {
                            acceptDrag = false;
                        }
                    }
                });
                eDropTarget.addEventListener('mouseout', function () {
                    if (acceptDrag) {
                        dropTargetCallback.noDrop();
                    }
                    mouseIn = false;
                    acceptDrag = false;
                });
                eDropTarget.addEventListener('mouseup', function () {
                    // dragItem should never be null, checking just in case
                    if (acceptDrag && _this.dragItem) {
                        dropTargetCallback.drop(_this.dragItem);
                    }
                });
            };
            __decorate([__param(0, context_2.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], OldToolPanelDragAndDropService.prototype, "agWire", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], OldToolPanelDragAndDropService.prototype, "destroy", null);
            OldToolPanelDragAndDropService = __decorate([context_1.Bean('oldToolPanelDragAndDropService'), __metadata('design:paramtypes', [])], OldToolPanelDragAndDropService);
            return OldToolPanelDragAndDropService;
        }();
        exports.OldToolPanelDragAndDropService = OldToolPanelDragAndDropService;

        /***/ },
    /* 320 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var filterManager_1 = __webpack_require__(281);
        var utils_1 = __webpack_require__(245);
        var popupService_1 = __webpack_require__(282);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var StandardMenuFactory = function () {
            function StandardMenuFactory() {}
            StandardMenuFactory.prototype.showMenuAfterMouseEvent = function (column, mouseEvent) {
                var _this = this;
                this.showPopup(column, function (eMenu) {
                    _this.popupService.positionPopupUnderMouseEvent({
                        mouseEvent: mouseEvent,
                        ePopup: eMenu
                    });
                });
            };
            StandardMenuFactory.prototype.showMenuAfterButtonClick = function (column, eventSource) {
                var _this = this;
                this.showPopup(column, function (eMenu) {
                    _this.popupService.positionPopupUnderComponent({ eventSource: eventSource, ePopup: eMenu, keepWithinBounds: true });
                });
            };
            StandardMenuFactory.prototype.showPopup = function (column, positionCallback) {
                var filterWrapper = this.filterManager.getOrCreateFilterWrapper(column);
                var eMenu = document.createElement('div');
                utils_1.Utils.addCssClass(eMenu, 'ag-menu');
                eMenu.appendChild(filterWrapper.gui);
                // need to show filter before positioning, as only after filter
                // is visible can we find out what the width of it is
                var hidePopup = this.popupService.addAsModalPopup(eMenu, true);
                positionCallback(eMenu);
                if (filterWrapper.filter.afterGuiAttached) {
                    var params = {
                        hidePopup: hidePopup
                    };
                    filterWrapper.filter.afterGuiAttached(params);
                }
            };
            StandardMenuFactory.prototype.isMenuEnabled = function (column) {
                // for standard, we show menu if filter is enabled, and he menu is not suppressed
                return this.gridOptionsWrapper.isEnableFilter() && column.isFilterAllowed();
            };
            __decorate([context_1.Autowired('filterManager'), __metadata('design:type', filterManager_1.FilterManager)], StandardMenuFactory.prototype, "filterManager", void 0);
            __decorate([context_1.Autowired('popupService'), __metadata('design:type', popupService_1.PopupService)], StandardMenuFactory.prototype, "popupService", void 0);
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], StandardMenuFactory.prototype, "gridOptionsWrapper", void 0);
            StandardMenuFactory = __decorate([context_1.Bean('menuFactory'), __metadata('design:paramtypes', [])], StandardMenuFactory);
            return StandardMenuFactory;
        }();
        exports.StandardMenuFactory = StandardMenuFactory;

        /***/ },
    /* 321 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var context_2 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var filterManager_1 = __webpack_require__(281);
        var FilterStage = function () {
            function FilterStage() {}
            FilterStage.prototype.execute = function (rowNode) {
                var filterActive;
                if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
                    filterActive = false;
                } else {
                    filterActive = this.filterManager.isAnyFilterPresent();
                }
                this.recursivelyFilter(rowNode, filterActive);
            };
            FilterStage.prototype.recursivelyFilter = function (rowNode, filterActive) {
                var _this = this;
                // recursively get all children that are groups to also filter
                rowNode.childrenAfterGroup.forEach(function (child) {
                    if (child.group) {
                        _this.recursivelyFilter(child, filterActive);
                    }
                });
                // result of filter for this node
                var filterResult;
                if (filterActive) {
                    filterResult = [];
                    rowNode.childrenAfterGroup.forEach(function (childNode) {
                        if (childNode.group) {
                            // a group is included in the result if it has any children of it's own.
                            // by this stage, the child groups are already filtered
                            if (childNode.childrenAfterFilter.length > 0) {
                                filterResult.push(childNode);
                            }
                        } else {
                            // a leaf level node is included if it passes the filter
                            if (_this.filterManager.doesRowPassFilter(childNode)) {
                                filterResult.push(childNode);
                            }
                        }
                    });
                } else {
                    // if not filtering, the result is the original list
                    filterResult = rowNode.childrenAfterGroup;
                }
                rowNode.childrenAfterFilter = filterResult;
                this.setAllChildrenCount(rowNode);
            };
            FilterStage.prototype.setAllChildrenCount = function (rowNode) {
                var allChildrenCount = 0;
                rowNode.childrenAfterFilter.forEach(function (child) {
                    if (child.group) {
                        allChildrenCount += child.allChildrenCount;
                    } else {
                        allChildrenCount++;
                    }
                });
                rowNode.allChildrenCount = allChildrenCount;
            };
            __decorate([context_2.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], FilterStage.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_2.Autowired('filterManager'), __metadata('design:type', filterManager_1.FilterManager)], FilterStage.prototype, "filterManager", void 0);
            FilterStage = __decorate([context_1.Bean('filterStage'), __metadata('design:paramtypes', [])], FilterStage);
            return FilterStage;
        }();
        exports.FilterStage = FilterStage;

        /***/ },
    /* 322 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var sortController_1 = __webpack_require__(280);
        var valueService_1 = __webpack_require__(267);
        var utils_1 = __webpack_require__(245);
        var SortStage = function () {
            function SortStage() {}
            SortStage.prototype.execute = function (rowNode) {
                var sortOptions;
                // if the sorting is already done by the server, then we should not do it here
                if (!this.gridOptionsWrapper.isEnableServerSideSorting()) {
                    sortOptions = this.sortController.getSortForRowController();
                }
                this.sortRowNode(rowNode, sortOptions);
            };
            SortStage.prototype.sortRowNode = function (rowNode, sortOptions) {
                var _this = this;
                // sort any groups recursively
                rowNode.childrenAfterFilter.forEach(function (child) {
                    if (child.group) {
                        _this.sortRowNode(child, sortOptions);
                    }
                });
                rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0);
                var sortActive = utils_1.Utils.exists(sortOptions) && sortOptions.length > 0;
                if (sortActive) {
                    rowNode.childrenAfterSort.sort(this.compareRowNodes.bind(this, sortOptions));
                }
                this.updateChildIndexes(rowNode);
            };
            SortStage.prototype.compareRowNodes = function (sortOptions, nodeA, nodeB) {
                // Iterate columns, return the first that doesn't match
                for (var i = 0, len = sortOptions.length; i < len; i++) {
                    var sortOption = sortOptions[i];
                    // var compared = compare(nodeA, nodeB, sortOption.column, sortOption.inverter === -1);
                    var isInverted = sortOption.inverter === -1;
                    var valueA = this.valueService.getValue(sortOption.column, nodeA);
                    var valueB = this.valueService.getValue(sortOption.column, nodeB);
                    var comparatorResult;
                    if (sortOption.column.getColDef().comparator) {
                        //if comparator provided, use it
                        comparatorResult = sortOption.column.getColDef().comparator(valueA, valueB, nodeA, nodeB, isInverted);
                    } else {
                        //otherwise do our own comparison
                        comparatorResult = utils_1.Utils.defaultComparator(valueA, valueB);
                    }
                    if (comparatorResult !== 0) {
                        return comparatorResult * sortOption.inverter;
                    }
                }
                // All matched, these are identical as far as the sort is concerned:
                return 0;
            };
            SortStage.prototype.updateChildIndexes = function (rowNode) {
                if (utils_1.Utils.missing(rowNode.childrenAfterSort)) {
                    return;
                }
                rowNode.childrenAfterSort.forEach(function (child, index) {
                    child.firstChild = index === 0;
                    child.lastChild = index === rowNode.childrenAfterSort.length - 1;
                    child.childIndex = index;
                });
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], SortStage.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('sortController'), __metadata('design:type', sortController_1.SortController)], SortStage.prototype, "sortController", void 0);
            __decorate([context_1.Autowired('valueService'), __metadata('design:type', valueService_1.ValueService)], SortStage.prototype, "valueService", void 0);
            SortStage = __decorate([context_1.Bean('sortStage'), __metadata('design:paramtypes', [])], SortStage);
            return SortStage;
        }();
        exports.SortStage = SortStage;

        /***/ },
    /* 323 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var context_1 = __webpack_require__(244);
        var rowNode_1 = __webpack_require__(265);
        var utils_1 = __webpack_require__(245);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var selectionController_1 = __webpack_require__(266);
        var eventService_1 = __webpack_require__(242);
        var columnController_1 = __webpack_require__(251);
        var FlattenStage = function () {
            function FlattenStage() {}
            FlattenStage.prototype.execute = function (rootNode) {
                // even if not doing grouping, we do the mapping, as the client might
                // of passed in data that already has a grouping in it somewhere
                var result = [];
                // putting value into a wrapper so it's passed by reference
                var nextRowTop = { value: 0 };
                var pivotMode = this.columnController.isPivotMode();
                // if we are reducing, and not grouping, then we want to show the root node, as that
                // is where the pivot values are
                var showRootNode = pivotMode && rootNode.leafGroup;
                var topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;
                this.recursivelyAddToRowsToDisplay(topList, result, nextRowTop, pivotMode);
                return result;
            };
            FlattenStage.prototype.recursivelyAddToRowsToDisplay = function (rowsToFlatten, result, nextRowTop, reduce) {
                if (utils_1.Utils.missingOrEmpty(rowsToFlatten)) {
                    return;
                }
                var groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();
                for (var i = 0; i < rowsToFlatten.length; i++) {
                    var rowNode = rowsToFlatten[i];
                    var skipBecauseSuppressRow = groupSuppressRow && rowNode.group;
                    var skipBecauseReduce = reduce && !rowNode.group;
                    var skipGroupNode = skipBecauseReduce || skipBecauseSuppressRow;
                    if (!skipGroupNode) {
                        this.addRowNodeToRowsToDisplay(rowNode, result, nextRowTop);
                    }
                    if (rowNode.group && rowNode.expanded) {
                        this.recursivelyAddToRowsToDisplay(rowNode.childrenAfterSort, result, nextRowTop, reduce);
                        // put a footer in if user is looking for it
                        if (this.gridOptionsWrapper.isGroupIncludeFooter()) {
                            var footerNode = this.createFooterNode(rowNode);
                            this.addRowNodeToRowsToDisplay(footerNode, result, nextRowTop);
                        }
                    }
                    if (rowNode.canFlower && rowNode.expanded) {
                        var flowerNode = this.createFlowerNode(rowNode);
                        this.addRowNodeToRowsToDisplay(flowerNode, result, nextRowTop);
                    }
                }
            };
            // duplicated method, it's also in floatingRowModel
            FlattenStage.prototype.addRowNodeToRowsToDisplay = function (rowNode, result, nextRowTop) {
                result.push(rowNode);
                rowNode.rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);
                rowNode.rowTop = nextRowTop.value;
                nextRowTop.value += rowNode.rowHeight;
            };
            FlattenStage.prototype.createFooterNode = function (groupNode) {
                var footerNode = new rowNode_1.RowNode();
                this.context.wireBean(footerNode);
                Object.keys(groupNode).forEach(function (key) {
                    footerNode[key] = groupNode[key];
                });
                footerNode.footer = true;
                // get both header and footer to reference each other as siblings. this is never undone,
                // only overwritten. so if a group is expanded, then contracted, it will have a ghost
                // sibling - but that's fine, as we can ignore this if the header is contracted.
                footerNode.sibling = groupNode;
                groupNode.sibling = footerNode;
                return footerNode;
            };
            FlattenStage.prototype.createFlowerNode = function (parentNode) {
                var flowerNode = new rowNode_1.RowNode();
                this.context.wireBean(flowerNode);
                flowerNode.flower = true;
                flowerNode.parent = parentNode;
                flowerNode.data = parentNode.data;
                flowerNode.level = parentNode.level + 1;
                return flowerNode;
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], FlattenStage.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('selectionController'), __metadata('design:type', selectionController_1.SelectionController)], FlattenStage.prototype, "selectionController", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], FlattenStage.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], FlattenStage.prototype, "context", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], FlattenStage.prototype, "columnController", void 0);
            FlattenStage = __decorate([context_1.Bean('flattenStage'), __metadata('design:paramtypes', [])], FlattenStage);
            return FlattenStage;
        }();
        exports.FlattenStage = FlattenStage;

        /***/ },
    /* 324 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var context_1 = __webpack_require__(244);
        var eventService_1 = __webpack_require__(242);
        var selectionController_1 = __webpack_require__(266);
        var events_1 = __webpack_require__(248);
        var sortController_1 = __webpack_require__(280);
        var filterManager_1 = __webpack_require__(281);
        var constants_1 = __webpack_require__(246);
        var virtualPageCache_1 = __webpack_require__(325);
        var VirtualPageRowModel = function () {
            function VirtualPageRowModel() {
                this.destroyFunctions = [];
            }
            VirtualPageRowModel.prototype.init = function () {
                if (!this.gridOptionsWrapper.isRowModelVirtual()) {
                    return;
                }
                this.addEventListeners();
                this.setDatasource(this.gridOptionsWrapper.getDatasource());
            };
            VirtualPageRowModel.prototype.addEventListeners = function () {
                var _this = this;
                var onSortChangedListener = this.onSortChanged.bind(this);
                var onFilterChangedListener = this.onFilterChanged.bind(this);
                this.eventService.addEventListener(events_1.Events.EVENT_FILTER_CHANGED, onFilterChangedListener);
                this.eventService.addEventListener(events_1.Events.EVENT_SORT_CHANGED, onSortChangedListener);
                this.destroyFunctions.push(function () {
                    _this.eventService.removeEventListener(events_1.Events.EVENT_FILTER_CHANGED, onFilterChangedListener);
                    _this.eventService.removeEventListener(events_1.Events.EVENT_SORT_CHANGED, onSortChangedListener);
                });
            };
            VirtualPageRowModel.prototype.onFilterChanged = function () {
                if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
                    this.reset();
                }
            };
            VirtualPageRowModel.prototype.onSortChanged = function () {
                if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
                    this.reset();
                }
            };
            VirtualPageRowModel.prototype.destroy = function () {
                this.destroyFunctions.forEach(function (func) {
                    return func();
                });
            };
            VirtualPageRowModel.prototype.getType = function () {
                return constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL;
            };
            VirtualPageRowModel.prototype.setDatasource = function (datasource) {
                this.datasource = datasource;
                // only reset if we have a valid datasource to working with
                if (datasource) {
                    this.checkForDeprecated();
                    this.reset();
                }
            };
            VirtualPageRowModel.prototype.checkForDeprecated = function () {
                var ds = this.datasource;
                // the number of concurrent loads we are allowed to the server
                if (utils_1.Utils.exists(ds.maxConcurrentRequests)) {
                    console.error('ag-Grid: since version 5.1.x, maxConcurrentRequests is replaced with grid property maxConcurrentDatasourceRequests');
                }
                if (utils_1.Utils.exists(ds.maxPagesInCache)) {
                    console.error('ag-Grid: since version 5.1.x, maxPagesInCache is replaced with grid property maxPagesInPaginationCache');
                }
                if (utils_1.Utils.exists(ds.overflowSize)) {
                    console.error('ag-Grid: since version 5.1.x, overflowSize is replaced with grid property paginationOverflowSize');
                }
                if (utils_1.Utils.exists(ds.pageSize)) {
                    console.error('ag-Grid: since version 5.1.x, pageSize is replaced with grid property paginationPageSize');
                }
            };
            VirtualPageRowModel.prototype.isEmpty = function () {
                return utils_1.Utils.missing(this.virtualPageCache);
            };
            VirtualPageRowModel.prototype.isRowsToRender = function () {
                return utils_1.Utils.exists(this.virtualPageCache);
            };
            VirtualPageRowModel.prototype.reset = function () {
                // important to return here, as the user could be setting filter or sort before
                // data-source is set
                if (utils_1.Utils.missing(this.datasource)) {
                    return;
                }
                // if user is providing id's, then this means we can keep the selection between datsource hits,
                // as the rows will keep their unique id's even if, for example, server side sorting or filtering
                // is done.
                var userGeneratingRows = utils_1.Utils.exists(this.gridOptionsWrapper.getRowNodeIdFunc());
                if (!userGeneratingRows) {
                    this.selectionController.reset();
                }
                this.resetCache();
                this.eventService.dispatchEvent(events_1.Events.EVENT_MODEL_UPDATED);
            };
            VirtualPageRowModel.prototype.resetCache = function () {
                var cacheSettings = {
                    // the user provided datasource
                    datasource: this.datasource,
                    // sort and filter model
                    filterModel: this.filterManager.getFilterModel(),
                    sortModel: this.sortController.getSortModel(),
                    // properties - this way we take a snapshot of them, so if user changes any, they will be
                    // used next time we create a new cache, which is generally after a filter or sort change,
                    // or a new datasource is set
                    maxConcurrentDatasourceRequests: this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests(),
                    paginationOverflowSize: this.gridOptionsWrapper.getPaginationOverflowSize(),
                    paginationInitialRowCount: this.gridOptionsWrapper.getPaginationInitialRowCount(),
                    maxPagesInCache: this.gridOptionsWrapper.getMaxPagesInCache(),
                    pageSize: this.gridOptionsWrapper.getPaginationPageSize(),
                    rowHeight: this.gridOptionsWrapper.getRowHeightAsNumber(),
                    // the cache could create this, however it is also used by the pages, so handy to create it
                    // here as the settings are also passed to the pages
                    lastAccessedSequence: new utils_1.NumberSequence()
                };
                // set defaults
                if (!(cacheSettings.maxConcurrentDatasourceRequests >= 1)) {
                    cacheSettings.maxConcurrentDatasourceRequests = 2;
                }
                // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
                // server for one page at a time. so the default if not specified is 100.
                if (!(cacheSettings.pageSize >= 1)) {
                    cacheSettings.pageSize = 100;
                }
                // if user doesn't give initial rows to display, we assume zero
                if (!(cacheSettings.paginationInitialRowCount >= 1)) {
                    cacheSettings.paginationInitialRowCount = 0;
                }
                // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
                // the current page and request first row of next page
                if (!(cacheSettings.paginationOverflowSize >= 1)) {
                    cacheSettings.paginationOverflowSize = 1;
                }
                // if not first time creating a cache, need to destroy the old one
                if (this.virtualPageCache) {
                    this.virtualPageCache.destroy();
                }
                this.virtualPageCache = new virtualPageCache_1.VirtualPageCache(cacheSettings);
                this.context.wireBean(this.virtualPageCache);
            };
            VirtualPageRowModel.prototype.getRow = function (rowIndex) {
                return this.virtualPageCache ? this.virtualPageCache.getRow(rowIndex) : null;
            };
            VirtualPageRowModel.prototype.forEachNode = function (callback) {
                if (this.virtualPageCache) {
                    this.virtualPageCache.forEachNode(callback);
                }
            };
            VirtualPageRowModel.prototype.getRowCombinedHeight = function () {
                return this.virtualPageCache ? this.virtualPageCache.getRowCombinedHeight() : 0;
            };
            VirtualPageRowModel.prototype.getRowIndexAtPixel = function (pixel) {
                return this.virtualPageCache ? this.virtualPageCache.getRowIndexAtPixel(pixel) : -1;
            };
            VirtualPageRowModel.prototype.getRowCount = function () {
                return this.virtualPageCache ? this.virtualPageCache.getRowCount() : 0;
            };
            VirtualPageRowModel.prototype.insertItemsAtIndex = function (index, items) {
                if (this.virtualPageCache) {
                    this.virtualPageCache.insertItemsAtIndex(index, items);
                }
            };
            VirtualPageRowModel.prototype.removeItems = function (rowNodes) {
                console.log('ag-Grid: it is not possible to removeItems when using virtual pagination. Instead use the ' + 'API to refresh the cache');
            };
            VirtualPageRowModel.prototype.addItems = function (items) {
                console.log('ag-Grid: it is not possible to add items when using virtual pagination as the grid does not ' + 'know that last index of your data - instead either use insertItemsAtIndex OR refresh the cache.');
            };
            VirtualPageRowModel.prototype.refreshVirtualPageCache = function () {
                if (this.virtualPageCache) {
                    this.virtualPageCache.refreshVirtualPageCache();
                }
            };
            VirtualPageRowModel.prototype.purgeVirtualPageCache = function () {
                if (this.virtualPageCache) {
                    this.virtualPageCache.purgeVirtualPageCache();
                }
            };
            VirtualPageRowModel.prototype.getVirtualRowCount = function () {
                if (this.virtualPageCache) {
                    return this.virtualPageCache.getVirtualRowCount();
                } else {
                    return null;
                }
            };
            VirtualPageRowModel.prototype.isMaxRowFound = function () {
                if (this.virtualPageCache) {
                    return this.virtualPageCache.isMaxRowFound();
                }
            };
            VirtualPageRowModel.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {
                if (this.virtualPageCache) {
                    this.virtualPageCache.setVirtualRowCount(rowCount, maxRowFound);
                }
            };
            VirtualPageRowModel.prototype.getVirtualPageState = function () {
                if (this.virtualPageCache) {
                    return this.virtualPageCache.getPageState();
                } else {
                    return null;
                }
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], VirtualPageRowModel.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('filterManager'), __metadata('design:type', filterManager_1.FilterManager)], VirtualPageRowModel.prototype, "filterManager", void 0);
            __decorate([context_1.Autowired('sortController'), __metadata('design:type', sortController_1.SortController)], VirtualPageRowModel.prototype, "sortController", void 0);
            __decorate([context_1.Autowired('selectionController'), __metadata('design:type', selectionController_1.SelectionController)], VirtualPageRowModel.prototype, "selectionController", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], VirtualPageRowModel.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], VirtualPageRowModel.prototype, "context", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], VirtualPageRowModel.prototype, "init", null);
            __decorate([context_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], VirtualPageRowModel.prototype, "destroy", null);
            VirtualPageRowModel = __decorate([context_1.Bean('rowModel'), __metadata('design:paramtypes', [])], VirtualPageRowModel);
            return VirtualPageRowModel;
        }();
        exports.VirtualPageRowModel = VirtualPageRowModel;

        /***/ },
    /* 325 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };
        var utils_1 = __webpack_require__(245);
        var context_1 = __webpack_require__(244);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var logger_1 = __webpack_require__(243);
        var virtualPage_1 = __webpack_require__(326);
        var VirtualPageCache = function () {
            function VirtualPageCache(cacheSettings) {
                this.pages = {};
                this.activePageLoadsCount = 0;
                this.pagesInCacheCount = 0;
                this.maxRowFound = false;
                this.active = true;
                this.cacheParams = cacheSettings;
                this.virtualRowCount = cacheSettings.paginationInitialRowCount;
            }
            VirtualPageCache.prototype.setBeans = function (loggerFactory) {
                this.logger = loggerFactory.create('VirtualPageCache');
            };
            VirtualPageCache.prototype.init = function () {
                // start load of data, as the virtualRowCount will remain at 0 otherwise,
                // so we need this to kick things off, otherwise grid would never call getRow()
                this.getRow(0);
            };
            VirtualPageCache.prototype.getRowCombinedHeight = function () {
                return this.virtualRowCount * this.cacheParams.rowHeight;
            };
            VirtualPageCache.prototype.forEachNode = function (callback) {
                var _this = this;
                var index = 0;
                utils_1.Utils.iterateObject(this.pages, function (key, cachePage) {
                    var start = cachePage.getStartRow();
                    var end = cachePage.getEndRow();
                    for (var rowIndex = start; rowIndex < end; rowIndex++) {
                        // we check against virtualRowCount as this page may be the last one, and if it is, then
                        // it's probable that the last rows are not part of the set
                        if (rowIndex < _this.virtualRowCount) {
                            var rowNode = cachePage.getRow(rowIndex);
                            callback(rowNode, index);
                            index++;
                        }
                    }
                });
            };
            VirtualPageCache.prototype.getRowIndexAtPixel = function (pixel) {
                if (this.cacheParams.rowHeight !== 0) {
                    return Math.floor(pixel / this.cacheParams.rowHeight);
                } else {
                    return 0;
                }
            };
            VirtualPageCache.prototype.moveItemsDown = function (page, moveFromIndex, moveCount) {
                var startRow = page.getStartRow();
                var endRow = page.getEndRow();
                var indexOfLastRowToMove = moveFromIndex + moveCount;
                // all rows need to be moved down below the insertion index
                for (var currentRowIndex = endRow - 1; currentRowIndex >= startRow; currentRowIndex--) {
                    // don't move rows at or before the insertion index
                    if (currentRowIndex < indexOfLastRowToMove) {
                        continue;
                    }
                    var indexOfNodeWeWant = currentRowIndex - moveCount;
                    var nodeForThisIndex = this.getRow(indexOfNodeWeWant, true);
                    if (nodeForThisIndex) {
                        page.setRowNode(currentRowIndex, nodeForThisIndex);
                    } else {
                        page.setBlankRowNode(currentRowIndex);
                        page.setDirty();
                    }
                }
            };
            VirtualPageCache.prototype.insertItems = function (page, indexToInsert, items) {
                var pageStartRow = page.getStartRow();
                var pageEndRow = page.getEndRow();
                var newRowNodes = [];
                // next stage is insert the rows into this page, if applicable
                for (var index = 0; index < items.length; index++) {
                    var rowIndex = indexToInsert + index;
                    var currentRowInThisPage = rowIndex >= pageStartRow && rowIndex < pageEndRow;
                    if (currentRowInThisPage) {
                        var dataItem = items[index];
                        var newRowNode = page.setNewData(rowIndex, dataItem);
                        newRowNodes.push(newRowNode);
                    }
                }
                return newRowNodes;
            };
            VirtualPageCache.prototype.insertItemsAtIndex = function (indexToInsert, items) {
                var _this = this;
                // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order
                var pageIds = Object.keys(this.pages).map(function (str) {
                    return parseInt(str);
                }).sort().reverse();
                var newNodes = [];
                pageIds.forEach(function (pageId) {
                    var page = _this.pages[pageId];
                    var pageEndRow = page.getEndRow();
                    // if the insertion is after this page, then this page is not impacted
                    if (pageEndRow <= indexToInsert) {
                        return;
                    }
                    _this.moveItemsDown(page, indexToInsert, items.length);
                    var newNodesThisPage = _this.insertItems(page, indexToInsert, items);
                    newNodesThisPage.forEach(function (rowNode) {
                        return newNodes.push(rowNode);
                    });
                });
                if (this.maxRowFound) {
                    this.virtualRowCount += items.length;
                }
                this.dispatchModelUpdated();
                this.eventService.dispatchEvent(events_1.Events.EVENT_ITEMS_ADDED, newNodes);
            };
            VirtualPageCache.prototype.getRowCount = function () {
                return this.virtualRowCount;
            };
            VirtualPageCache.prototype.onPageLoaded = function (event) {
                // if we are not active, then we ignore all events, otherwise we could end up getting the
                // grid to refresh even though we are no longer the active cache
                if (!this.active) {
                    return;
                }
                this.logger.log("onPageLoaded: page = " + event.page.getPageNumber() + ", lastRow = " + event.lastRow);
                this.activePageLoadsCount--;
                this.checkPageToLoad();
                if (event.success) {
                    this.checkVirtualRowCount(event.page, event.lastRow);
                }
            };
            // as we are not a context managed bean, we cannot use @PreDestroy
            VirtualPageCache.prototype.destroy = function () {
                this.active = false;
            };
            // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
            // it will want new pages in teh cache as it asks for rows. only when we are inserting /
            // removing rows via the api is dontCreatePage set, where we move rows between the pages.
            VirtualPageCache.prototype.getRow = function (rowIndex, dontCreatePage) {
                if (dontCreatePage === void 0) {
                    dontCreatePage = false;
                }
                var pageNumber = Math.floor(rowIndex / this.cacheParams.pageSize);
                var page = this.pages[pageNumber];
                if (!page) {
                    if (dontCreatePage) {
                        return null;
                    } else {
                        page = this.createPage(pageNumber);
                    }
                }
                return page.getRow(rowIndex);
            };
            VirtualPageCache.prototype.createPage = function (pageNumber) {
                var newPage = new virtualPage_1.VirtualPage(pageNumber, this.cacheParams);
                this.context.wireBean(newPage);
                newPage.addEventListener(virtualPage_1.VirtualPage.EVENT_LOAD_COMPLETE, this.onPageLoaded.bind(this));
                this.pages[pageNumber] = newPage;
                this.pagesInCacheCount++;
                var needToPurge = utils_1.Utils.exists(this.cacheParams.maxPagesInCache) && this.pagesInCacheCount > this.cacheParams.maxPagesInCache;
                if (needToPurge) {
                    var lruPage = this.findLeastRecentlyUsedPage(newPage);
                    this.removePageFromCache(lruPage);
                }
                this.checkPageToLoad();
                return newPage;
            };
            VirtualPageCache.prototype.removePageFromCache = function (pageToRemove) {
                if (!pageToRemove) {
                    return;
                }
                delete this.pages[pageToRemove.getPageNumber()];
                this.pagesInCacheCount--;
                // we do not want to remove the 'loaded' event listener, as the
                // concurrent loads count needs to be updated when the load is complete
                // if the purged page is in loading state
            };
            VirtualPageCache.prototype.printCacheStatus = function () {
                this.logger.log("checkPageToLoad: activePageLoadsCount = " + this.activePageLoadsCount + ", pages = " + JSON.stringify(this.getPageState()));
            };
            VirtualPageCache.prototype.checkPageToLoad = function () {
                this.printCacheStatus();
                if (this.activePageLoadsCount >= this.cacheParams.maxConcurrentDatasourceRequests) {
                    this.logger.log("checkPageToLoad: max loads exceeded");
                    return;
                }
                var pageToLoad = null;
                utils_1.Utils.iterateObject(this.pages, function (key, cachePage) {
                    if (cachePage.getState() === virtualPage_1.VirtualPage.STATE_DIRTY) {
                        pageToLoad = cachePage;
                    }
                });
                if (pageToLoad) {
                    pageToLoad.load();
                    this.activePageLoadsCount++;
                    this.logger.log("checkPageToLoad: loading page " + pageToLoad.getPageNumber());
                    this.printCacheStatus();
                } else {
                    this.logger.log("checkPageToLoad: no pages to load");
                }
            };
            VirtualPageCache.prototype.findLeastRecentlyUsedPage = function (pageToExclude) {
                var lruPage = null;
                utils_1.Utils.iterateObject(this.pages, function (key, page) {
                    // we exclude checking for the page just created, as this has yet to be accessed and hence
                    // the lastAccessed stamp will not be updated for the first time yet
                    if (page === pageToExclude) {
                        return;
                    }
                    if (utils_1.Utils.missing(lruPage) || page.getLastAccessed() < lruPage.getLastAccessed()) {
                        lruPage = page;
                    }
                });
                return lruPage;
            };
            VirtualPageCache.prototype.checkVirtualRowCount = function (page, lastRow) {
                // if client provided a last row, we always use it, as it could change between server calls
                // if user deleted data and then called refresh on the grid.
                if (typeof lastRow === 'number' && lastRow >= 0) {
                    this.virtualRowCount = lastRow;
                    this.maxRowFound = true;
                    this.dispatchModelUpdated();
                } else if (!this.maxRowFound) {
                    // otherwise, see if we need to add some virtual rows
                    var lastRowIndex = (page.getPageNumber() + 1) * this.cacheParams.pageSize;
                    var lastRowIndexPlusOverflow = lastRowIndex + this.cacheParams.paginationOverflowSize;
                    if (this.virtualRowCount < lastRowIndexPlusOverflow) {
                        this.virtualRowCount = lastRowIndexPlusOverflow;
                        this.dispatchModelUpdated();
                    }
                }
            };
            VirtualPageCache.prototype.dispatchModelUpdated = function () {
                if (this.active) {
                    this.eventService.dispatchEvent(events_1.Events.EVENT_MODEL_UPDATED);
                }
            };
            VirtualPageCache.prototype.getPageState = function () {
                var result = [];
                utils_1.Utils.iterateObject(this.pages, function (pageNumber, page) {
                    result.push({ pageNumber: pageNumber, startRow: page.getStartRow(), endRow: page.getEndRow(), pageStatus: page.getState() });
                });
                return result;
            };
            VirtualPageCache.prototype.refreshVirtualPageCache = function () {
                utils_1.Utils.iterateObject(this.pages, function (pageId, page) {
                    page.setDirty();
                });
                this.checkPageToLoad();
            };
            VirtualPageCache.prototype.purgeVirtualPageCache = function () {
                var _this = this;
                var pagesList = utils_1.Utils.values(this.pages);
                pagesList.forEach(function (virtualPage) {
                    return _this.removePageFromCache(virtualPage);
                });
                this.dispatchModelUpdated();
            };
            VirtualPageCache.prototype.getVirtualRowCount = function () {
                return this.virtualRowCount;
            };
            VirtualPageCache.prototype.isMaxRowFound = function () {
                return this.maxRowFound;
            };
            VirtualPageCache.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {
                this.virtualRowCount = rowCount;
                // if undefined is passed, we do not set this value, if one of {true,false}
                // is passed, we do set the value.
                if (utils_1.Utils.exists(maxRowFound)) {
                    this.maxRowFound = maxRowFound;
                }
                // if we are still searching, then the row count must not end at the end
                // of a particular page, otherwise the searching will not pop into the
                // next page
                if (!this.maxRowFound) {
                    if (this.virtualRowCount % this.cacheParams.pageSize === 0) {
                        this.virtualRowCount++;
                    }
                }
                this.dispatchModelUpdated();
            };
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], VirtualPageCache.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], VirtualPageCache.prototype, "context", void 0);
            __decorate([__param(0, context_1.Qualifier('loggerFactory')), __metadata('design:type', Function), __metadata('design:paramtypes', [logger_1.LoggerFactory]), __metadata('design:returntype', void 0)], VirtualPageCache.prototype, "setBeans", null);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], VirtualPageCache.prototype, "init", null);
            return VirtualPageCache;
        }();
        exports.VirtualPageCache = VirtualPageCache;

        /***/ },
    /* 326 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var rowNode_1 = __webpack_require__(265);
        var context_1 = __webpack_require__(244);
        var eventService_1 = __webpack_require__(242);
        var VirtualPage = function () {
            function VirtualPage(pageNumber, cacheSettings) {
                this.state = VirtualPage.STATE_DIRTY;
                this.version = 0;
                this.localEventService = new eventService_1.EventService();
                this.pageNumber = pageNumber;
                this.cacheParams = cacheSettings;
                // we don't need to calculate these now, as the inputs don't change,
                // however it makes the code easier to read if we work them out up front
                this.startRow = pageNumber * cacheSettings.pageSize;
                this.endRow = this.startRow + cacheSettings.pageSize;
            }
            VirtualPage.prototype.setDirty = function () {
                // in case any current loads in progress, this will have their results ignored
                this.version++;
                this.state = VirtualPage.STATE_DIRTY;
            };
            VirtualPage.prototype.setDirtyAndPurge = function () {
                this.setDirty();
                this.rowNodes.forEach(function (rowNode) {
                    rowNode.setData(null);
                });
            };
            VirtualPage.prototype.getStartRow = function () {
                return this.startRow;
            };
            VirtualPage.prototype.getEndRow = function () {
                return this.endRow;
            };
            VirtualPage.prototype.getPageNumber = function () {
                return this.pageNumber;
            };
            VirtualPage.prototype.addEventListener = function (eventType, listener) {
                this.localEventService.addEventListener(eventType, listener);
            };
            VirtualPage.prototype.removeEventListener = function (eventType, listener) {
                this.localEventService.removeEventListener(eventType, listener);
            };
            VirtualPage.prototype.getLastAccessed = function () {
                return this.lastAccessed;
            };
            VirtualPage.prototype.getState = function () {
                return this.state;
            };
            VirtualPage.prototype.setRowNode = function (rowIndex, rowNode) {
                var localIndex = rowIndex - this.startRow;
                this.rowNodes[localIndex] = rowNode;
                this.setTopOnRowNode(rowNode, rowIndex);
            };
            VirtualPage.prototype.setBlankRowNode = function (rowIndex) {
                var localIndex = rowIndex - this.startRow;
                var newRowNode = this.createBlankRowNode(rowIndex);
                this.rowNodes[localIndex] = newRowNode;
                return newRowNode;
            };
            VirtualPage.prototype.setNewData = function (rowIndex, dataItem) {
                var newRowNode = this.setBlankRowNode(rowIndex);
                newRowNode.setDataAndId(dataItem, rowIndex.toString());
                return newRowNode;
            };
            VirtualPage.prototype.init = function () {
                this.createRowNodes();
            };
            // creates empty row nodes, data is missing as not loaded yet
            VirtualPage.prototype.createRowNodes = function () {
                this.rowNodes = [];
                for (var i = 0; i < this.cacheParams.pageSize; i++) {
                    var rowIndex = this.startRow + i;
                    var rowNode = this.createBlankRowNode(rowIndex);
                    this.rowNodes.push(rowNode);
                }
            };
            VirtualPage.prototype.setTopOnRowNode = function (rowNode, rowIndex) {
                rowNode.rowTop = this.cacheParams.rowHeight * rowIndex;
            };
            VirtualPage.prototype.createBlankRowNode = function (rowIndex) {
                var rowNode = new rowNode_1.RowNode();
                this.context.wireBean(rowNode);
                rowNode.rowHeight = this.cacheParams.rowHeight;
                this.setTopOnRowNode(rowNode, rowIndex);
                return rowNode;
            };
            VirtualPage.prototype.getRow = function (rowIndex) {
                this.lastAccessed = this.cacheParams.lastAccessedSequence.next();
                var localIndex = rowIndex - this.startRow;
                return this.rowNodes[localIndex];
            };
            VirtualPage.prototype.load = function () {
                var _this = this;
                this.state = VirtualPage.STATE_LOADING;
                var params = {
                    startRow: this.startRow,
                    endRow: this.endRow,
                    successCallback: this.pageLoaded.bind(this, this.version),
                    failCallback: this.pageLoadFailed.bind(this),
                    sortModel: this.cacheParams.sortModel,
                    filterModel: this.cacheParams.filterModel,
                    context: this.gridOptionsWrapper.getContext()
                };
                if (utils_1.Utils.missing(this.cacheParams.datasource.getRows)) {
                    console.warn("ag-Grid: datasource is missing getRows method");
                    return;
                }
                // check if old version of datasource used
                var getRowsParams = utils_1.Utils.getFunctionParameters(this.cacheParams.datasource.getRows);
                if (getRowsParams.length > 1) {
                    console.warn('ag-grid: It looks like your paging datasource is of the old type, taking more than one parameter.');
                    console.warn('ag-grid: From ag-grid 1.9.0, now the getRows takes one parameter. See the documentation for details.');
                }
                // put in timeout, to force result to be async
                setTimeout(function () {
                    _this.cacheParams.datasource.getRows(params);
                }, 0);
            };
            VirtualPage.prototype.pageLoadFailed = function () {
                this.state = VirtualPage.STATE_FAILED;
                var event = { success: true, page: this };
                this.localEventService.dispatchEvent(VirtualPage.EVENT_LOAD_COMPLETE, event);
            };
            VirtualPage.prototype.populateWithRowData = function (rows) {
                var _this = this;
                this.rowNodes.forEach(function (rowNode, index) {
                    var data = rows[index];
                    if (utils_1.Utils.exists(data)) {
                        // this means if the user is not providing id's we just use the
                        // index for the row. this will allow selection to work (that is based
                        // on index) as long user is not inserting or deleting rows,
                        // or wanting to keep selection between server side sorting or filtering
                        var indexOfRow = _this.startRow + index;
                        rowNode.setDataAndId(data, indexOfRow.toString());
                    } else {
                        rowNode.setDataAndId(undefined, undefined);
                    }
                });
            };
            VirtualPage.prototype.pageLoaded = function (version, rows, lastRow) {
                // we need to check the version, in case there was an old request
                // from the server that was sent before we refreshed the cache,
                // if the load was done as a result of a cache refresh
                if (version === this.version) {
                    this.state = VirtualPage.STATE_LOADED;
                    this.populateWithRowData(rows);
                }
                // check here if lastrow should be set
                var event = { success: true, page: this, lastRow: lastRow };
                this.localEventService.dispatchEvent(VirtualPage.EVENT_LOAD_COMPLETE, event);
            };
            VirtualPage.EVENT_LOAD_COMPLETE = 'loadComplete';
            VirtualPage.STATE_DIRTY = 'dirty';
            VirtualPage.STATE_LOADING = 'loading';
            VirtualPage.STATE_LOADED = 'loaded';
            VirtualPage.STATE_FAILED = 'failed';
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], VirtualPage.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], VirtualPage.prototype, "context", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], VirtualPage.prototype, "init", null);
            return VirtualPage;
        }();
        exports.VirtualPage = VirtualPage;

        /***/ },
    /* 327 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var utils_1 = __webpack_require__(245);
        var constants_1 = __webpack_require__(246);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var columnController_1 = __webpack_require__(251);
        var filterManager_1 = __webpack_require__(281);
        var rowNode_1 = __webpack_require__(265);
        var eventService_1 = __webpack_require__(242);
        var events_1 = __webpack_require__(248);
        var context_1 = __webpack_require__(244);
        var selectionController_1 = __webpack_require__(266);
        var inMemoryNodeManager_1 = __webpack_require__(328);
        var RecursionType;
        (function (RecursionType) {
            RecursionType[RecursionType["Normal"] = 0] = "Normal";
            RecursionType[RecursionType["AfterFilter"] = 1] = "AfterFilter";
            RecursionType[RecursionType["AfterFilterAndSort"] = 2] = "AfterFilterAndSort";
            RecursionType[RecursionType["PivotNodes"] = 3] = "PivotNodes";
        })(RecursionType || (RecursionType = {}));
        ;
        var InMemoryRowModel = function () {
            function InMemoryRowModel() {}
            InMemoryRowModel.prototype.init = function () {
                this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_EVERYTHING));
                this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_EVERYTHING));
                this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));
                this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_PIVOT));
                this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_FILTER_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_FILTER));
                this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_SORT_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_SORT));
                this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.refreshModel.bind(this, constants_1.Constants.STEP_PIVOT));
                this.rootNode = new rowNode_1.RowNode();
                this.nodeManager = new inMemoryNodeManager_1.InMemoryNodeManager(this.rootNode, this.gridOptionsWrapper, this.context, this.eventService);
                this.context.wireBean(this.rootNode);
                if (this.gridOptionsWrapper.isRowModelDefault()) {
                    this.setRowData(this.gridOptionsWrapper.getRowData(), this.columnController.isReady());
                }
            };
            InMemoryRowModel.prototype.getType = function () {
                return constants_1.Constants.ROW_MODEL_TYPE_NORMAL;
            };
            InMemoryRowModel.prototype.onValueChanged = function () {
                if (this.columnController.isPivotActive()) {
                    this.refreshModel(constants_1.Constants.STEP_PIVOT);
                } else {
                    this.refreshModel(constants_1.Constants.STEP_AGGREGATE);
                }
            };
            InMemoryRowModel.prototype.refreshModel = function (step, fromIndex, groupState) {
                // this goes through the pipeline of stages. what's in my head is similar
                // to the diagram on this page:
                // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html
                // however we want to keep the results of each stage, hence we manually call
                // each step rather than have them chain each other.
                var _this = this;
                // fallthrough in below switch is on purpose,
                // eg if STEP_FILTER, then all steps below this
                // step get done
                // var start: number;
                // console.log('======= start =======');
                switch (step) {
                    case constants_1.Constants.STEP_EVERYTHING:
                        // start = new Date().getTime();
                        this.doRowGrouping(groupState);
                    // console.log('rowGrouping = ' + (new Date().getTime() - start));
                    case constants_1.Constants.STEP_FILTER:
                        // start = new Date().getTime();
                        this.doFilter();
                    // console.log('filter = ' + (new Date().getTime() - start));
                    case constants_1.Constants.STEP_PIVOT:
                        this.doPivot();
                    case constants_1.Constants.STEP_AGGREGATE:
                        // start = new Date().getTime();
                        this.doAggregate();
                    // console.log('aggregation = ' + (new Date().getTime() - start));
                    case constants_1.Constants.STEP_SORT:
                        // start = new Date().getTime();
                        this.doSort();
                    // console.log('sort = ' + (new Date().getTime() - start));
                    case constants_1.Constants.STEP_MAP:
                        // start = new Date().getTime();
                        this.doRowsToDisplay();
                }
                this.eventService.dispatchEvent(events_1.Events.EVENT_MODEL_UPDATED, { fromIndex: fromIndex });
                if (this.$scope) {
                    setTimeout(function () {
                        _this.$scope.$apply();
                    }, 0);
                }
            };
            InMemoryRowModel.prototype.isEmpty = function () {
                return utils_1.Utils.missing(this.rootNode) || utils_1.Utils.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0 || !this.columnController.isReady();
            };
            InMemoryRowModel.prototype.isRowsToRender = function () {
                return utils_1.Utils.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
            };
            InMemoryRowModel.prototype.setDatasource = function (datasource) {
                console.error('ag-Grid: should never call setDatasource on inMemoryRowController');
            };
            InMemoryRowModel.prototype.getTopLevelNodes = function () {
                return this.rootNode ? this.rootNode.childrenAfterGroup : null;
            };
            InMemoryRowModel.prototype.getRow = function (index) {
                return this.rowsToDisplay[index];
            };
            InMemoryRowModel.prototype.getVirtualRowCount = function () {
                console.warn('ag-Grid: rowModel.getVirtualRowCount() is not longer a function, use rowModel.getRowCount() instead');
                return this.getRowCount();
            };
            InMemoryRowModel.prototype.getRowCount = function () {
                if (this.rowsToDisplay) {
                    return this.rowsToDisplay.length;
                } else {
                    return 0;
                }
            };
            InMemoryRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {
                if (this.isEmpty()) {
                    return -1;
                }
                // do binary search of tree
                // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/
                var bottomPointer = 0;
                var topPointer = this.rowsToDisplay.length - 1;
                // quick check, if the pixel is out of bounds, then return last row
                if (pixelToMatch <= 0) {
                    // if pixel is less than or equal zero, it's always the first row
                    return 0;
                }
                var lastNode = this.rowsToDisplay[this.rowsToDisplay.length - 1];
                if (lastNode.rowTop <= pixelToMatch) {
                    return this.rowsToDisplay.length - 1;
                }
                while (true) {
                    var midPointer = Math.floor((bottomPointer + topPointer) / 2);
                    var currentRowNode = this.rowsToDisplay[midPointer];
                    if (this.isRowInPixel(currentRowNode, pixelToMatch)) {
                        return midPointer;
                    } else if (currentRowNode.rowTop < pixelToMatch) {
                        bottomPointer = midPointer + 1;
                    } else if (currentRowNode.rowTop > pixelToMatch) {
                        topPointer = midPointer - 1;
                    }
                }
            };
            InMemoryRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {
                var topPixel = rowNode.rowTop;
                var bottomPixel = rowNode.rowTop + rowNode.rowHeight;
                var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
                return pixelInRow;
            };
            InMemoryRowModel.prototype.getRowCombinedHeight = function () {
                if (this.rowsToDisplay && this.rowsToDisplay.length > 0) {
                    var lastRow = this.rowsToDisplay[this.rowsToDisplay.length - 1];
                    var lastPixel = lastRow.rowTop + lastRow.rowHeight;
                    return lastPixel;
                } else {
                    return 0;
                }
            };
            InMemoryRowModel.prototype.forEachLeafNode = function (callback) {
                if (this.rootNode.allLeafChildren) {
                    this.rootNode.allLeafChildren.forEach(function (rowNode, index) {
                        return callback(rowNode, index);
                    });
                }
            };
            InMemoryRowModel.prototype.forEachNode = function (callback) {
                this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);
            };
            InMemoryRowModel.prototype.forEachNodeAfterFilter = function (callback) {
                this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);
            };
            InMemoryRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {
                this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);
            };
            InMemoryRowModel.prototype.forEachPivotNode = function (callback) {
                this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);
            };
            // iterates through each item in memory, and calls the callback function
            // nodes - the rowNodes to traverse
            // callback - the user provided callback
            // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
            // index - works similar to the index in forEach in javascripts array function
            InMemoryRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {
                if (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        callback(node, index++);
                        // go to the next level if it is a group
                        if (node.group) {
                            // depending on the recursion type, we pick a difference set of children
                            var nodeChildren;
                            switch (recursionType) {
                                case RecursionType.Normal:
                                    nodeChildren = node.childrenAfterGroup;
                                    break;
                                case RecursionType.AfterFilter:
                                    nodeChildren = node.childrenAfterFilter;
                                    break;
                                case RecursionType.AfterFilterAndSort:
                                    nodeChildren = node.childrenAfterSort;
                                    break;
                                case RecursionType.PivotNodes:
                                    // for pivot, we don't go below leafGroup levels
                                    nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;
                                    break;
                            }
                            if (nodeChildren) {
                                index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);
                            }
                        }
                    }
                }
                return index;
            };
            // it's possible to recompute the aggregate without doing the other parts
            // + gridApi.recomputeAggregates()
            InMemoryRowModel.prototype.doAggregate = function () {
                if (this.aggregationStage) {
                    this.aggregationStage.execute(this.rootNode);
                }
            };
            // + gridApi.expandAll()
            // + gridApi.collapseAll()
            InMemoryRowModel.prototype.expandOrCollapseAll = function (expand) {
                if (this.rootNode) {
                    recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);
                }
                function recursiveExpandOrCollapse(rowNodes) {
                    if (!rowNodes) {
                        return;
                    }
                    rowNodes.forEach(function (rowNode) {
                        if (rowNode.group) {
                            rowNode.expanded = expand;
                            recursiveExpandOrCollapse(rowNode.childrenAfterGroup);
                        }
                    });
                }
                this.refreshModel(constants_1.Constants.STEP_MAP);
            };
            InMemoryRowModel.prototype.doSort = function () {
                this.sortStage.execute(this.rootNode);
            };
            InMemoryRowModel.prototype.doRowGrouping = function (groupState) {
                // grouping is enterprise only, so if service missing, skip the step
                var rowsAlreadyGrouped = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
                if (rowsAlreadyGrouped) {
                    return;
                }
                if (this.groupStage) {
                    // remove old groups from the selection model, as we are about to replace them
                    // with new groups
                    this.selectionController.removeGroupsFromSelection();
                    this.groupStage.execute(this.rootNode);
                    this.restoreGroupState(groupState);
                    if (this.gridOptionsWrapper.isGroupSelectsChildren()) {
                        this.selectionController.updateGroupsFromChildrenSelections();
                    }
                } else {
                    this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;
                }
            };
            InMemoryRowModel.prototype.restoreGroupState = function (groupState) {
                if (!groupState) {
                    return;
                }
                utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {
                    // if the group was open last time, then open it this time. however
                    // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'
                    // setting will take effect.
                    if (typeof groupState[key] === 'boolean') {
                        node.expanded = groupState[key];
                    }
                });
            };
            InMemoryRowModel.prototype.doFilter = function () {
                this.filterStage.execute(this.rootNode);
            };
            InMemoryRowModel.prototype.doPivot = function () {
                if (this.pivotStage) {
                    this.pivotStage.execute(this.rootNode);
                }
            };
            InMemoryRowModel.prototype.getGroupState = function () {
                if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {
                    return null;
                }
                var result = {};
                utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {
                    return result[key] = node.expanded;
                });
                return result;
            };
            // rows: the rows to put into the model
            // firstId: the first id to use, used for paging, where we are not on the first page
            InMemoryRowModel.prototype.setRowData = function (rowData, refresh, firstId) {
                // remember group state, so we can expand groups that should be expanded
                var groupState = this.getGroupState();
                this.nodeManager.setRowData(rowData, firstId);
                // this event kicks off:
                // - clears selection
                // - updates filters
                // - shows 'no rows' overlay if needed
                this.eventService.dispatchEvent(events_1.Events.EVENT_ROW_DATA_CHANGED);
                if (refresh) {
                    this.refreshModel(constants_1.Constants.STEP_EVERYTHING, null, groupState);
                }
            };
            InMemoryRowModel.prototype.doRowsToDisplay = function () {
                this.rowsToDisplay = this.flattenStage.execute(this.rootNode);
            };
            InMemoryRowModel.prototype.insertItemsAtIndex = function (index, items) {
                // remember group state, so we can expand groups that should be expanded
                var groupState = this.getGroupState();
                var newNodes = this.nodeManager.insertItemsAtIndex(index, items);
                this.refreshAndFireEvent(events_1.Events.EVENT_ITEMS_ADDED, newNodes, groupState);
            };
            InMemoryRowModel.prototype.removeItems = function (rowNodes) {
                var groupState = this.getGroupState();
                var removedNodes = this.nodeManager.removeItems(rowNodes);
                this.refreshAndFireEvent(events_1.Events.EVENT_ITEMS_REMOVED, removedNodes, groupState);
            };
            InMemoryRowModel.prototype.addItems = function (items) {
                var groupState = this.getGroupState();
                var newNodes = this.nodeManager.addItems(items);
                this.refreshAndFireEvent(events_1.Events.EVENT_ITEMS_ADDED, newNodes, groupState);
            };
            InMemoryRowModel.prototype.refreshAndFireEvent = function (eventName, rowNodes, groupState) {
                if (rowNodes) {
                    this.refreshModel(constants_1.Constants.STEP_EVERYTHING, null, groupState);
                    this.eventService.dispatchEvent(eventName, { rowNodes: rowNodes });
                }
            };
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], InMemoryRowModel.prototype, "gridOptionsWrapper", void 0);
            __decorate([context_1.Autowired('columnController'), __metadata('design:type', columnController_1.ColumnController)], InMemoryRowModel.prototype, "columnController", void 0);
            __decorate([context_1.Autowired('filterManager'), __metadata('design:type', filterManager_1.FilterManager)], InMemoryRowModel.prototype, "filterManager", void 0);
            __decorate([context_1.Autowired('$scope'), __metadata('design:type', Object)], InMemoryRowModel.prototype, "$scope", void 0);
            __decorate([context_1.Autowired('selectionController'), __metadata('design:type', selectionController_1.SelectionController)], InMemoryRowModel.prototype, "selectionController", void 0);
            __decorate([context_1.Autowired('eventService'), __metadata('design:type', eventService_1.EventService)], InMemoryRowModel.prototype, "eventService", void 0);
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], InMemoryRowModel.prototype, "context", void 0);
            __decorate([context_1.Autowired('filterStage'), __metadata('design:type', Object)], InMemoryRowModel.prototype, "filterStage", void 0);
            __decorate([context_1.Autowired('sortStage'), __metadata('design:type', Object)], InMemoryRowModel.prototype, "sortStage", void 0);
            __decorate([context_1.Autowired('flattenStage'), __metadata('design:type', Object)], InMemoryRowModel.prototype, "flattenStage", void 0);
            __decorate([context_1.Optional('groupStage'), __metadata('design:type', Object)], InMemoryRowModel.prototype, "groupStage", void 0);
            __decorate([context_1.Optional('aggregationStage'), __metadata('design:type', Object)], InMemoryRowModel.prototype, "aggregationStage", void 0);
            __decorate([context_1.Optional('pivotStage'), __metadata('design:type', Object)], InMemoryRowModel.prototype, "pivotStage", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], InMemoryRowModel.prototype, "init", null);
            InMemoryRowModel = __decorate([context_1.Bean('rowModel'), __metadata('design:paramtypes', [])], InMemoryRowModel);
            return InMemoryRowModel;
        }();
        exports.InMemoryRowModel = InMemoryRowModel;

        /***/ },
    /* 328 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var rowNode_1 = __webpack_require__(265);
        var utils_1 = __webpack_require__(245);
        var InMemoryNodeManager = function () {
            function InMemoryNodeManager(rootNode, gridOptionsWrapper, context, eventService) {
                this.nextId = 0;
                this.rootNode = rootNode;
                this.gridOptionsWrapper = gridOptionsWrapper;
                this.context = context;
                this.eventService = eventService;
                this.rootNode.group = true;
                this.rootNode.level = -1;
                this.rootNode.allLeafChildren = [];
                this.rootNode.childrenAfterGroup = [];
                this.rootNode.childrenAfterSort = [];
                this.rootNode.childrenAfterFilter = [];
            }
            InMemoryNodeManager.prototype.setRowData = function (rowData, firstId) {
                this.rootNode.childrenAfterFilter = null;
                this.rootNode.childrenAfterGroup = null;
                this.rootNode.childrenAfterSort = null;
                this.rootNode.childrenMapped = null;
                this.nextId = utils_1.Utils.exists(firstId) ? firstId : 0;
                if (!rowData) {
                    this.rootNode.allLeafChildren = [];
                    this.rootNode.childrenAfterGroup = [];
                    return;
                }
                // func below doesn't have 'this' pointer, so need to pull out these bits
                this.getNodeChildDetails = this.gridOptionsWrapper.getNodeChildDetailsFunc();
                this.suppressParentsInRowNodes = this.gridOptionsWrapper.isSuppressParentsInRowNodes();
                this.doesDataFlower = this.gridOptionsWrapper.getDoesDataFlowerFunc();
                var rowsAlreadyGrouped = utils_1.Utils.exists(this.getNodeChildDetails);
                // kick off recursion
                var result = this.recursiveFunction(rowData, null, InMemoryNodeManager.TOP_LEVEL);
                if (rowsAlreadyGrouped) {
                    this.rootNode.childrenAfterGroup = result;
                    this.setLeafChildren(this.rootNode);
                } else {
                    this.rootNode.allLeafChildren = result;
                }
            };
            InMemoryNodeManager.prototype.recursiveFunction = function (rowData, parent, level) {
                var _this = this;
                // make sure the rowData is an array and not a string of json - this was a commonly reported problem on the forum
                if (typeof rowData === 'string') {
                    console.warn('ag-Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first');
                    return;
                }
                var rowNodes = [];
                rowData.forEach(function (dataItem) {
                    var node = _this.createNode(dataItem, parent, level);
                    var nodeChildDetails = _this.getNodeChildDetails ? _this.getNodeChildDetails(dataItem) : null;
                    if (nodeChildDetails && nodeChildDetails.group) {
                        node.group = true;
                        node.childrenAfterGroup = _this.recursiveFunction(nodeChildDetails.children, node, level + 1);
                        node.expanded = nodeChildDetails.expanded === true;
                        node.field = nodeChildDetails.field;
                        node.key = nodeChildDetails.key;
                        // pull out all the leaf children and add to our node
                        _this.setLeafChildren(node);
                    }
                    rowNodes.push(node);
                });
                return rowNodes;
            };
            InMemoryNodeManager.prototype.createNode = function (dataItem, parent, level) {
                var node = new rowNode_1.RowNode();
                this.context.wireBean(node);
                var nodeChildDetails = this.getNodeChildDetails ? this.getNodeChildDetails(dataItem) : null;
                if (nodeChildDetails && nodeChildDetails.group) {
                    node.group = true;
                    node.childrenAfterGroup = this.recursiveFunction(nodeChildDetails.children, node, level + 1);
                    node.expanded = nodeChildDetails.expanded === true;
                    node.field = nodeChildDetails.field;
                    node.key = nodeChildDetails.key;
                    node.canFlower = false;
                    // pull out all the leaf children and add to our node
                    this.setLeafChildren(node);
                } else {
                    node.group = false;
                    node.canFlower = this.doesDataFlower ? this.doesDataFlower(dataItem) : false;
                    if (node.canFlower) {
                        node.expanded = false;
                    }
                }
                if (parent && !this.suppressParentsInRowNodes) {
                    node.parent = parent;
                }
                node.level = level;
                node.setDataAndId(dataItem, this.nextId.toString());
                this.nextId++;
                return node;
            };
            InMemoryNodeManager.prototype.setLeafChildren = function (node) {
                node.allLeafChildren = [];
                if (node.childrenAfterGroup) {
                    node.childrenAfterGroup.forEach(function (childAfterGroup) {
                        if (childAfterGroup.group) {
                            if (childAfterGroup.allLeafChildren) {
                                childAfterGroup.allLeafChildren.forEach(function (leafChild) {
                                    return node.allLeafChildren.push(leafChild);
                                });
                            }
                        } else {
                            node.allLeafChildren.push(childAfterGroup);
                        }
                    });
                }
            };
            InMemoryNodeManager.prototype.insertItemsAtIndex = function (index, rowData) {
                var _this = this;
                if (this.isRowsAlreadyGrouped()) {
                    return null;
                }
                var nodeList = this.rootNode.allLeafChildren;
                if (index > nodeList.length) {
                    console.warn("ag-Grid: invalid index " + index + ", max index is " + nodeList.length);
                    return;
                }
                var newNodes = [];
                rowData.forEach(function (data) {
                    var newNode = _this.createNode(data, null, InMemoryNodeManager.TOP_LEVEL);
                    utils_1.Utils.insertIntoArray(nodeList, newNode, index);
                    newNodes.push(newNode);
                });
                return newNodes.length > 0 ? newNodes : null;
            };
            InMemoryNodeManager.prototype.removeItems = function (rowNodes) {
                if (this.isRowsAlreadyGrouped()) {
                    return;
                }
                var nodeList = this.rootNode.allLeafChildren;
                var removedNodes = [];
                rowNodes.forEach(function (rowNode) {
                    var indexOfNode = nodeList.indexOf(rowNode);
                    if (indexOfNode >= 0) {
                        rowNode.setSelected(false);
                        nodeList.splice(indexOfNode, 1);
                    }
                    removedNodes.push(rowNode);
                });
                return removedNodes.length > 0 ? removedNodes : null;
            };
            InMemoryNodeManager.prototype.addItems = function (items) {
                var nodeList = this.rootNode.allLeafChildren;
                return this.insertItemsAtIndex(nodeList.length, items);
            };
            InMemoryNodeManager.prototype.isRowsAlreadyGrouped = function () {
                var rowsAlreadyGrouped = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
                if (rowsAlreadyGrouped) {
                    console.warn('ag-Grid: adding and removing rows is not supported when using nodeChildDetailsFunc, ie it is not ' + 'supported if providing groups');
                    return true;
                } else {
                    return false;
                }
            };
            InMemoryNodeManager.TOP_LEVEL = 0;
            return InMemoryNodeManager;
        }();
        exports.InMemoryNodeManager = InMemoryNodeManager;

        /***/ },
    /* 329 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var component_1 = __webpack_require__(285);
        var componentAnnotations_1 = __webpack_require__(330);
        var utils_1 = __webpack_require__(245);
        var context_1 = __webpack_require__(244);
        var gridOptionsWrapper_1 = __webpack_require__(241);
        var svgFactory_1 = __webpack_require__(297);
        var svgFactory = svgFactory_1.SvgFactory.getInstance();
        var AgCheckbox = function (_super) {
            __extends(AgCheckbox, _super);
            function AgCheckbox() {
                _super.call(this, AgCheckbox.TEMPLATE);
                this.selected = false;
                this.readOnly = false;
                this.passive = false;
            }
            AgCheckbox.prototype.init = function () {
                this.loadIcons();
                this.updateIcons();
                var label = this.getAttribute('label');
                if (label) {
                    this.eLabel.innerText = label;
                }
            };
            AgCheckbox.prototype.loadIcons = function () {
                utils_1.Utils.removeAllChildren(this.eChecked);
                utils_1.Utils.removeAllChildren(this.eUnchecked);
                utils_1.Utils.removeAllChildren(this.eIndeterminate);
                if (this.readOnly) {
                    this.eChecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxCheckedReadOnly', this.gridOptionsWrapper, null, svgFactory.createCheckboxCheckedReadOnlyIcon));
                    this.eUnchecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxUncheckedReadOnly', this.gridOptionsWrapper, null, svgFactory.createCheckboxUncheckedReadOnlyIcon));
                    this.eIndeterminate.appendChild(utils_1.Utils.createIconNoSpan('checkboxIndeterminateReadOnly', this.gridOptionsWrapper, null, svgFactory.createCheckboxIndeterminateReadOnlyIcon));
                } else {
                    this.eChecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxChecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxCheckedIcon));
                    this.eUnchecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxUnchecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxUncheckedIcon));
                    this.eIndeterminate.appendChild(utils_1.Utils.createIconNoSpan('checkboxIndeterminate', this.gridOptionsWrapper, null, svgFactory.createCheckboxIndeterminateIcon));
                }
            };
            AgCheckbox.prototype.onClick = function () {
                if (!this.readOnly) {
                    this.toggle();
                }
            };
            AgCheckbox.prototype.getNextValue = function () {
                if (this.selected === undefined) {
                    return true;
                } else {
                    return !this.selected;
                }
            };
            AgCheckbox.prototype.setPassive = function (passive) {
                this.passive = passive;
            };
            AgCheckbox.prototype.setReadOnly = function (readOnly) {
                this.readOnly = readOnly;
                this.loadIcons();
            };
            AgCheckbox.prototype.isReadOnly = function () {
                return this.readOnly;
            };
            AgCheckbox.prototype.isSelected = function () {
                return this.selected;
            };
            AgCheckbox.prototype.toggle = function () {
                var nextValue = this.getNextValue();
                if (this.passive) {
                    this.dispatchEvent(AgCheckbox.EVENT_CHANGED, { selected: nextValue });
                } else {
                    this.setSelected(nextValue);
                }
            };
            AgCheckbox.prototype.setSelected = function (selected) {
                if (this.selected === selected) {
                    return;
                }
                if (selected === true) {
                    this.selected = true;
                } else if (selected === false) {
                    this.selected = false;
                } else {
                    this.selected = undefined;
                }
                this.updateIcons();
                this.dispatchEvent(AgCheckbox.EVENT_CHANGED, { selected: this.selected });
            };
            AgCheckbox.prototype.updateIcons = function () {
                utils_1.Utils.setVisible(this.eChecked, this.selected === true);
                utils_1.Utils.setVisible(this.eUnchecked, this.selected === false);
                utils_1.Utils.setVisible(this.eIndeterminate, this.selected === undefined);
            };
            AgCheckbox.EVENT_CHANGED = 'change';
            AgCheckbox.TEMPLATE = '<span class="ag-checkbox">' + '  <span class="ag-checkbox-checked"></span>' + '  <span class="ag-checkbox-unchecked"></span>' + '  <span class="ag-checkbox-indeterminate"></span>' + '  <span class="ag-checkbox-label"></span>' + '</span>';
            __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)], AgCheckbox.prototype, "gridOptionsWrapper", void 0);
            __decorate([componentAnnotations_1.QuerySelector('.ag-checkbox-checked'), __metadata('design:type', HTMLElement)], AgCheckbox.prototype, "eChecked", void 0);
            __decorate([componentAnnotations_1.QuerySelector('.ag-checkbox-unchecked'), __metadata('design:type', HTMLElement)], AgCheckbox.prototype, "eUnchecked", void 0);
            __decorate([componentAnnotations_1.QuerySelector('.ag-checkbox-indeterminate'), __metadata('design:type', HTMLElement)], AgCheckbox.prototype, "eIndeterminate", void 0);
            __decorate([componentAnnotations_1.QuerySelector('.ag-checkbox-label'), __metadata('design:type', HTMLElement)], AgCheckbox.prototype, "eLabel", void 0);
            __decorate([context_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], AgCheckbox.prototype, "init", null);
            __decorate([componentAnnotations_1.Listener('click'), __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], AgCheckbox.prototype, "onClick", null);
            return AgCheckbox;
        }(component_1.Component);
        exports.AgCheckbox = AgCheckbox;

        /***/ },
    /* 330 */
    /***/ function(module, exports) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        function QuerySelector(selector) {
            return querySelectorFunc.bind(this, selector);
        }
        exports.QuerySelector = QuerySelector;
        function querySelectorFunc(selector, classPrototype, methodOrAttributeName, index) {
            if (selector === null) {
                console.error('ag-Grid: QuerySelector selector should not be null');
                return;
            }
            if (typeof index === 'number') {
                console.error('ag-Grid: QuerySelector should be on an attribute');
                return;
            }
            // it's an attribute on the class
            var props = getOrCreateProps(classPrototype);
            if (!props.querySelectors) {
                props.querySelectors = [];
            }
            props.querySelectors.push({
                attributeName: methodOrAttributeName,
                querySelector: selector
            });
        }
        function Listener(eventName) {
            return listenerFunc.bind(this, eventName);
        }
        exports.Listener = Listener;
        function listenerFunc(eventName, target, methodName, descriptor) {
            if (eventName === null) {
                console.error('ag-Grid: EventListener eventName should not be null');
                return;
            }
            // it's an attribute on the class
            var props = getOrCreateProps(target);
            if (!props.listenerMethods) {
                props.listenerMethods = [];
            }
            props.listenerMethods.push({
                methodName: methodName,
                eventName: eventName
            });
        }
        function getOrCreateProps(target) {
            var props = target.__agComponentMetaData;
            if (!props) {
                props = {};
                target.__agComponentMetaData = props;
            }
            return props;
        }

        /***/ },
    /* 331 */
    /***/ function(module, exports) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        /** The base frameworks, eg React & Angular 2, override this bean with implementations specific to their requirement. */
        var BaseFrameworkFactory = function () {
            function BaseFrameworkFactory() {}
            BaseFrameworkFactory.prototype.colDefFloatingCellRenderer = function (colDef) {
                return colDef.floatingCellRenderer;
            };
            BaseFrameworkFactory.prototype.colDefCellRenderer = function (colDef) {
                return colDef.cellRenderer;
            };
            BaseFrameworkFactory.prototype.colDefCellEditor = function (colDef) {
                return colDef.cellEditor;
            };
            BaseFrameworkFactory.prototype.colDefFilter = function (colDef) {
                return colDef.filter;
            };
            BaseFrameworkFactory.prototype.gridOptionsFullWidthCellRenderer = function (gridOptions) {
                return gridOptions.fullWidthCellRenderer;
            };
            BaseFrameworkFactory.prototype.gridOptionsGroupRowRenderer = function (gridOptions) {
                return gridOptions.groupRowRenderer;
            };
            BaseFrameworkFactory.prototype.gridOptionsGroupRowInnerRenderer = function (gridOptions) {
                return gridOptions.groupRowInnerRenderer;
            };
            return BaseFrameworkFactory;
        }();
        exports.BaseFrameworkFactory = BaseFrameworkFactory;

        /***/ },
    /* 332 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var grid_1 = __webpack_require__(240);
        function initialiseAgGridWithAngular1(angular) {
            var angularModule = angular.module("agGrid", []);
            angularModule.directive("agGrid", function () {
                return {
                    restrict: "A",
                    controller: ['$element', '$scope', '$compile', '$attrs', AngularDirectiveController],
                    scope: true
                };
            });
        }
        exports.initialiseAgGridWithAngular1 = initialiseAgGridWithAngular1;
        function AngularDirectiveController($element, $scope, $compile, $attrs) {
            var gridOptions;
            var quickFilterOnScope;
            var keyOfGridInScope = $attrs.agGrid;
            quickFilterOnScope = keyOfGridInScope + '.quickFilterText';
            gridOptions = $scope.$eval(keyOfGridInScope);
            if (!gridOptions) {
                console.warn("WARNING - grid options for ag-Grid not found. Please ensure the attribute ag-grid points to a valid object on the scope");
                return;
            }
            var eGridDiv = $element[0];
            var gridParams = {
                $scope: $scope,
                $compile: $compile,
                quickFilterOnScope: quickFilterOnScope
            };
            var grid = new grid_1.Grid(eGridDiv, gridOptions, gridParams);
            $scope.$on("$destroy", function () {
                grid.destroy();
            });
        }

        /***/ },
    /* 333 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var componentUtil_1 = __webpack_require__(247);
        var grid_1 = __webpack_require__(240);
        var registered = false;
        function initialiseAgGridWithWebComponents() {
            // only register to WebComponents once
            if (registered) {
                return;
            }
            registered = true;
            if (typeof document === 'undefined' || !document.registerElement) {
                console.error('ag-Grid: unable to find document.registerElement() function, unable to initialise ag-Grid as a Web Component');
            }
            // i don't think this type of extension is possible in TypeScript, so back to
            // plain Javascript to create this object
            var AgileGridProto = Object.create(HTMLElement.prototype);
            // wrap each property with a get and set method, so we can track when changes are done
            componentUtil_1.ComponentUtil.ALL_PROPERTIES.forEach(function (key) {
                Object.defineProperty(AgileGridProto, key, {
                    set: function set(v) {
                        this.__agGridSetProperty(key, v);
                    },
                    get: function get() {
                        return this.__agGridGetProperty(key);
                    }
                });
            });
            AgileGridProto.__agGridSetProperty = function (key, value) {
                if (!this.__attributes) {
                    this.__attributes = {};
                }
                this.__attributes[key] = value;
                // keeping this consistent with the ng2 onChange, so I can reuse the handling code
                var changeObject = {};
                changeObject[key] = { currentValue: value };
                this.onChange(changeObject);
            };
            AgileGridProto.onChange = function (changes) {
                if (this._initialised) {
                    componentUtil_1.ComponentUtil.processOnChange(changes, this._gridOptions, this.api, this.columnApi);
                }
            };
            AgileGridProto.__agGridGetProperty = function (key) {
                if (!this.__attributes) {
                    this.__attributes = {};
                }
                return this.__attributes[key];
            };
            AgileGridProto.setGridOptions = function (options) {
                var globalEventListener = this.globalEventListener.bind(this);
                this._gridOptions = componentUtil_1.ComponentUtil.copyAttributesToGridOptions(options, this);
                var gridParams = {
                    globalEventListener: globalEventListener
                };
                this._agGrid = new grid_1.Grid(this, this._gridOptions, gridParams);
                this.api = options.api;
                this.columnApi = options.columnApi;
                this._initialised = true;
            };
            // copies all the attributes into this object
            AgileGridProto.createdCallback = function () {
                for (var i = 0; i < this.attributes.length; i++) {
                    var attribute = this.attributes[i];
                    this.setPropertyFromAttribute(attribute);
                }
            };
            AgileGridProto.setPropertyFromAttribute = function (attribute) {
                var name = toCamelCase(attribute.nodeName);
                var value = attribute.nodeValue;
                if (componentUtil_1.ComponentUtil.ALL_PROPERTIES.indexOf(name) >= 0) {
                    this[name] = value;
                }
            };
            AgileGridProto.attachedCallback = function (params) {};
            AgileGridProto.detachedCallback = function (params) {};
            AgileGridProto.attributeChangedCallback = function (attributeName) {
                var attribute = this.attributes[attributeName];
                this.setPropertyFromAttribute(attribute);
            };
            AgileGridProto.globalEventListener = function (eventType, event) {
                var eventLowerCase = eventType.toLowerCase();
                var browserEvent = new Event(eventLowerCase);
                var browserEventNoType = browserEvent;
                browserEventNoType.agGridDetails = event;
                this.dispatchEvent(browserEvent);
                var callbackMethod = 'on' + eventLowerCase;
                if (typeof this[callbackMethod] === 'function') {
                    this[callbackMethod](browserEvent);
                }
            };
            // finally, register
            document.registerElement('ag-grid', { prototype: AgileGridProto });
        }
        exports.initialiseAgGridWithWebComponents = initialiseAgGridWithWebComponents;
        function toCamelCase(myString) {
            if (typeof myString === 'string') {
                var result = myString.replace(/-([a-z])/g, function (g) {
                    return g[1].toUpperCase();
                });
                return result;
            } else {
                return myString;
            }
        }

        /***/ },
    /* 334 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var utils_1 = __webpack_require__(245);
        var TabbedLayout = function () {
            function TabbedLayout(params) {
                var _this = this;
                this.items = [];
                this.params = params;
                this.eGui = document.createElement('div');
                this.eGui.innerHTML = TabbedLayout.TEMPLATE;
                this.eHeader = this.eGui.querySelector('#tabHeader');
                this.eBody = this.eGui.querySelector('#tabBody');
                utils_1.Utils.addCssClass(this.eGui, params.cssClass);
                if (params.items) {
                    params.items.forEach(function (item) {
                        return _this.addItem(item);
                    });
                }
            }
            TabbedLayout.prototype.setAfterAttachedParams = function (params) {
                this.afterAttachedParams = params;
            };
            TabbedLayout.prototype.getMinWidth = function () {
                var eDummyContainer = document.createElement('span');
                // position fixed, so it isn't restricted to the boundaries of the parent
                eDummyContainer.style.position = 'fixed';
                // we put the dummy into the body container, so it will inherit all the
                // css styles that the real cells are inheriting
                this.eGui.appendChild(eDummyContainer);
                var minWidth = 0;
                this.items.forEach(function (itemWrapper) {
                    utils_1.Utils.removeAllChildren(eDummyContainer);
                    var eClone = itemWrapper.tabbedItem.body.cloneNode(true);
                    eDummyContainer.appendChild(eClone);
                    if (minWidth < eDummyContainer.offsetWidth) {
                        minWidth = eDummyContainer.offsetWidth;
                    }
                });
                this.eGui.removeChild(eDummyContainer);
                return minWidth;
            };
            TabbedLayout.prototype.showFirstItem = function () {
                if (this.items.length > 0) {
                    this.showItemWrapper(this.items[0]);
                }
            };
            TabbedLayout.prototype.addItem = function (item) {
                var eHeaderButton = document.createElement('span');
                eHeaderButton.appendChild(item.title);
                utils_1.Utils.addCssClass(eHeaderButton, 'ag-tab');
                this.eHeader.appendChild(eHeaderButton);
                var wrapper = {
                    tabbedItem: item,
                    eHeaderButton: eHeaderButton
                };
                this.items.push(wrapper);
                eHeaderButton.addEventListener('click', this.showItemWrapper.bind(this, wrapper));
            };
            TabbedLayout.prototype.showItem = function (tabbedItem) {
                var itemWrapper = utils_1.Utils.find(this.items, function (itemWrapper) {
                    return itemWrapper.tabbedItem === tabbedItem;
                });
                if (itemWrapper) {
                    this.showItemWrapper(itemWrapper);
                }
            };
            TabbedLayout.prototype.showItemWrapper = function (wrapper) {
                if (this.params.onItemClicked) {
                    this.params.onItemClicked({ item: wrapper.tabbedItem });
                }
                if (this.activeItem === wrapper) {
                    utils_1.Utils.callIfPresent(this.params.onActiveItemClicked);
                    return;
                }
                utils_1.Utils.removeAllChildren(this.eBody);
                this.eBody.appendChild(wrapper.tabbedItem.body);
                if (this.activeItem) {
                    utils_1.Utils.removeCssClass(this.activeItem.eHeaderButton, 'ag-tab-selected');
                }
                utils_1.Utils.addCssClass(wrapper.eHeaderButton, 'ag-tab-selected');
                this.activeItem = wrapper;
                if (wrapper.tabbedItem.afterAttachedCallback) {
                    wrapper.tabbedItem.afterAttachedCallback(this.afterAttachedParams);
                }
            };
            TabbedLayout.prototype.getGui = function () {
                return this.eGui;
            };
            TabbedLayout.TEMPLATE = '<div>' + '<div id="tabHeader" class="ag-tab-header"></div>' + '<div id="tabBody" class="ag-tab-body"></div>' + '</div>';
            return TabbedLayout;
        }();
        exports.TabbedLayout = TabbedLayout;

        /***/ },
    /* 335 */
    /***/ function(module, exports) {

        'use strict';

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var VerticalStack = function () {
            function VerticalStack() {
                this.isLayoutPanel = true;
                this.childPanels = [];
                this.eGui = document.createElement('div');
                this.eGui.style.height = '100%';
            }
            VerticalStack.prototype.addPanel = function (panel, height) {
                var component;
                if (panel.isLayoutPanel) {
                    this.childPanels.push(panel);
                    component = panel.getGui();
                } else {
                    component = panel;
                }
                if (height) {
                    component.style.height = height;
                }
                this.eGui.appendChild(component);
            };
            VerticalStack.prototype.getGui = function () {
                return this.eGui;
            };
            VerticalStack.prototype.doLayout = function () {
                for (var i = 0; i < this.childPanels.length; i++) {
                    this.childPanels[i].doLayout();
                }
            };
            return VerticalStack;
        }();
        exports.VerticalStack = VerticalStack;

        /***/ },
    /* 336 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var component_1 = __webpack_require__(285);
        var context_1 = __webpack_require__(244);
        var utils_1 = __webpack_require__(245);
        var popupService_1 = __webpack_require__(282);
        var menuItemComponent_1 = __webpack_require__(337);
        var MenuList = function (_super) {
            __extends(MenuList, _super);
            function MenuList() {
                _super.call(this, MenuList.TEMPLATE);
                this.timerCount = 0;
            }
            MenuList.prototype.clearActiveItem = function () {
                this.removeActiveItem();
                this.removeOldChildPopup();
            };
            MenuList.prototype.addMenuItems = function (menuItems, defaultMenuItems) {
                var _this = this;
                if (utils_1.Utils.missing(menuItems)) {
                    return;
                }
                menuItems.forEach(function (listItem) {
                    if (listItem === 'separator') {
                        _this.addSeparator();
                    } else {
                        var menuItem;
                        if (typeof listItem === 'string') {
                            menuItem = defaultMenuItems[listItem];
                        } else {
                            menuItem = listItem;
                        }
                        _this.addItem(menuItem);
                    }
                });
            };
            MenuList.prototype.addItem = function (params) {
                var _this = this;
                var cMenuItem = new menuItemComponent_1.MenuItemComponent(params);
                this.context.wireBean(cMenuItem);
                this.getGui().appendChild(cMenuItem.getGui());
                cMenuItem.addEventListener(menuItemComponent_1.MenuItemComponent.EVENT_ITEM_SELECTED, function (event) {
                    if (params.childMenu) {
                        _this.showChildMenu(params, cMenuItem);
                    } else {
                        _this.dispatchEvent(menuItemComponent_1.MenuItemComponent.EVENT_ITEM_SELECTED, event);
                    }
                });
                cMenuItem.addGuiEventListener('mouseenter', this.mouseEnterItem.bind(this, params, cMenuItem));
                cMenuItem.addGuiEventListener('mouseleave', function () {
                    return _this.timerCount++;
                });
                if (params.childMenu) {
                    this.addDestroyFunc(function () {
                        return params.childMenu.destroy();
                    });
                }
            };
            MenuList.prototype.mouseEnterItem = function (menuItemParams, menuItem) {
                if (menuItemParams.disabled) {
                    return;
                }
                if (this.activeMenuItemParams !== menuItemParams) {
                    this.removeOldChildPopup();
                }
                this.removeActiveItem();
                this.activeMenuItemParams = menuItemParams;
                this.activeMenuItem = menuItem;
                utils_1.Utils.addCssClass(this.activeMenuItem.getGui(), 'ag-menu-option-active');
                if (menuItemParams.childMenu) {
                    this.addHoverForChildPopup(menuItemParams, menuItem);
                }
            };
            MenuList.prototype.removeActiveItem = function () {
                if (this.activeMenuItem) {
                    utils_1.Utils.removeCssClass(this.activeMenuItem.getGui(), 'ag-menu-option-active');
                    this.activeMenuItem = null;
                    this.activeMenuItemParams = null;
                }
            };
            MenuList.prototype.addHoverForChildPopup = function (menuItemParams, menuItem) {
                var _this = this;
                var timerCountCopy = this.timerCount;
                setTimeout(function () {
                    var shouldShow = timerCountCopy === _this.timerCount;
                    var showingThisMenu = _this.showingChildMenu === menuItemParams.childMenu;
                    if (shouldShow && !showingThisMenu) {
                        _this.showChildMenu(menuItemParams, menuItem);
                    }
                }, 500);
            };
            MenuList.prototype.showChildMenu = function (menuItemParams, menuItem) {
                this.removeOldChildPopup();
                var ePopup = utils_1.Utils.loadTemplate('<div class="ag-menu"></div>');
                ePopup.appendChild(menuItemParams.childMenu.getGui());
                this.childPopupRemoveFunc = this.popupService.addAsModalPopup(ePopup, true);
                this.popupService.positionPopupForMenu({
                    eventSource: menuItem.getGui(),
                    ePopup: ePopup
                });
                this.showingChildMenu = menuItemParams.childMenu;
            };
            MenuList.prototype.addSeparator = function () {
                this.getGui().appendChild(utils_1.Utils.loadTemplate(MenuList.SEPARATOR_TEMPLATE));
            };
            MenuList.prototype.removeOldChildPopup = function () {
                if (this.childPopupRemoveFunc) {
                    this.showingChildMenu.clearActiveItem();
                    this.childPopupRemoveFunc();
                    this.childPopupRemoveFunc = null;
                    this.showingChildMenu = null;
                }
            };
            MenuList.prototype.destroy = function () {
                this.removeOldChildPopup();
                _super.prototype.destroy.call(this);
            };
            MenuList.TEMPLATE = '<div class="ag-menu-list"></div>';
            MenuList.SEPARATOR_TEMPLATE = '<div class="ag-menu-separator">' + '  <span class="ag-menu-separator-cell"></span>' + '  <span class="ag-menu-separator-cell"></span>' + '  <span class="ag-menu-separator-cell"></span>' + '  <span class="ag-menu-separator-cell"></span>' + '</div>';
            __decorate([context_1.Autowired('context'), __metadata('design:type', context_1.Context)], MenuList.prototype, "context", void 0);
            __decorate([context_1.Autowired('popupService'), __metadata('design:type', popupService_1.PopupService)], MenuList.prototype, "popupService", void 0);
            return MenuList;
        }(component_1.Component);
        exports.MenuList = MenuList;

        /***/ },
    /* 337 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
         * @version v5.5.0
         * @link http://www.ag-grid.com/
         * @license MIT
         */
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var component_1 = __webpack_require__(285);
        var context_1 = __webpack_require__(244);
        var popupService_1 = __webpack_require__(282);
        var utils_1 = __webpack_require__(245);
        var svgFactory_1 = __webpack_require__(297);
        var svgFactory = svgFactory_1.SvgFactory.getInstance();
        var MenuItemComponent = function (_super) {
            __extends(MenuItemComponent, _super);
            function MenuItemComponent(params) {
                _super.call(this, MenuItemComponent.TEMPLATE);
                this.params = params;
                if (params.checked) {
                    this.queryForHtmlElement('#eIcon').innerHTML = '&#10004;';
                } else if (params.icon) {
                    if (utils_1.Utils.isNodeOrElement(params.icon)) {
                        this.queryForHtmlElement('#eIcon').appendChild(params.icon);
                    } else if (typeof params.icon === 'string') {
                        this.queryForHtmlElement('#eIcon').innerHTML = params.icon;
                    } else {
                        console.log('ag-Grid: menu item icon must be DOM node or string');
                    }
                } else {
                    // if i didn't put space here, the alignment was messed up, probably
                    // fixable with CSS but i was spending to much time trying to figure
                    // it out.
                    this.queryForHtmlElement('#eIcon').innerHTML = '&nbsp;';
                }
                if (params.shortcut) {
                    this.queryForHtmlElement('#eShortcut').innerHTML = params.shortcut;
                }
                if (params.childMenu) {
                    this.queryForHtmlElement('#ePopupPointer').appendChild(svgFactory.createSmallArrowRightSvg());
                } else {
                    this.queryForHtmlElement('#ePopupPointer').innerHTML = '&nbsp;';
                }
                this.queryForHtmlElement('#eName').innerHTML = params.name;
                if (params.disabled) {
                    utils_1.Utils.addCssClass(this.getGui(), 'ag-menu-option-disabled');
                } else {
                    this.addGuiEventListener('click', this.onOptionSelected.bind(this));
                }
            }
            MenuItemComponent.prototype.onOptionSelected = function () {
                this.dispatchEvent(MenuItemComponent.EVENT_ITEM_SELECTED, this.params);
                if (this.params.action) {
                    this.params.action();
                }
            };
            MenuItemComponent.TEMPLATE = '<div class="ag-menu-option">' + '  <span id="eIcon" class="ag-menu-option-icon"></span>' + '  <span id="eName" class="ag-menu-option-text"></span>' + '  <span id="eShortcut" class="ag-menu-option-shortcut"></span>' + '  <span id="ePopupPointer" class="ag-menu-option-popup-pointer"></span>' + '</div>';
            MenuItemComponent.EVENT_ITEM_SELECTED = 'itemSelected';
            __decorate([context_1.Autowired('popupService'), __metadata('design:type', popupService_1.PopupService)], MenuItemComponent.prototype, "popupService", void 0);
            return MenuItemComponent;
        }(component_1.Component);
        exports.MenuItemComponent = MenuItemComponent;

        /***/ },
    /* 338 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        // ag-grid-react v5.5.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var ag_grid_1 = __webpack_require__(238);
        var agReactComponent_1 = __webpack_require__(339);
        function reactCellRendererFactory(reactComponent, parentComponent) {
            var ReactCellRenderer = function (_super) {
                __extends(ReactCellRenderer, _super);
                function ReactCellRenderer() {
                    _super.call(this, reactComponent, parentComponent);
                }
                ReactCellRenderer.prototype.refresh = function (params) {
                    var componentRef = this.getComponentRef();
                    if (componentRef.refresh) {
                        componentRef.refresh(params);
                    } else {
                        throw new ag_grid_1.MethodNotImplementedException();
                    }
                };
                return ReactCellRenderer;
            }(agReactComponent_1.AgReactComponent);
            return ReactCellRenderer;
        }
        exports.reactCellRendererFactory = reactCellRendererFactory;

        /***/ },
    /* 339 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        // ag-grid-react v5.5.0
        var React = __webpack_require__(222);
        var ReactDOM = __webpack_require__(77);
        var AgReactComponent = function () {
            function AgReactComponent(reactComponent, parentComponent) {
                this.reactComponent = reactComponent;
                this.parentComponent = parentComponent;
            }
            AgReactComponent.prototype.getComponentRef = function () {
                return this.componentRef;
            };
            AgReactComponent.prototype.init = function (params) {
                this.eParentElement = document.createElement('div');
                var ReactComponent = React.createElement(this.reactComponent, params);
                if (!this.parentComponent) {
                    this.componentRef = ReactDOM.render(ReactComponent, this.eParentElement);
                } else {
                    this.componentRef = ReactDOM.unstable_renderSubtreeIntoContainer(this.parentComponent, ReactComponent, this.eParentElement);
                }
            };
            AgReactComponent.prototype.getGui = function () {
                return this.eParentElement;
            };
            AgReactComponent.prototype.destroy = function () {
                ReactDOM.unmountComponentAtNode(this.eParentElement);
            };
            return AgReactComponent;
        }();
        exports.AgReactComponent = AgReactComponent;

        /***/ },
    /* 340 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        // ag-grid-react v5.5.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var agReactComponent_1 = __webpack_require__(339);
        function reactCellEditorFactory(reactComponent, parentComponent) {
            var ReactCellEditor = function (_super) {
                __extends(ReactCellEditor, _super);
                function ReactCellEditor() {
                    _super.call(this, reactComponent, parentComponent);
                }
                ReactCellEditor.prototype.getValue = function () {
                    var componentRef = this.getComponentRef();
                    if (componentRef.getValue) {
                        return componentRef.getValue();
                    } else {
                        console.log("ag-Grid: React cellEditor is missing the mandatory method getValue() method");
                        return null;
                    }
                };
                ReactCellEditor.prototype.afterGuiAttached = function () {
                    var componentRef = this.getComponentRef();
                    if (componentRef.afterGuiAttached) {
                        componentRef.afterGuiAttached();
                    }
                };
                ReactCellEditor.prototype.isPopup = function () {
                    var componentRef = this.getComponentRef();
                    if (componentRef.isPopup) {
                        return componentRef.isPopup();
                    } else {
                        return false;
                    }
                };
                ReactCellEditor.prototype.isCancelBeforeStart = function () {
                    var componentRef = this.getComponentRef();
                    if (componentRef.isCancelBeforeStart) {
                        return componentRef.isCancelBeforeStart();
                    } else {
                        return false;
                    }
                };
                ReactCellEditor.prototype.isCancelAfterEnd = function () {
                    var componentRef = this.getComponentRef();
                    if (componentRef.isCancelAfterEnd) {
                        return componentRef.isCancelAfterEnd();
                    } else {
                        return false;
                    }
                };
                return ReactCellEditor;
            }(agReactComponent_1.AgReactComponent);
            return ReactCellEditor;
        }
        exports.reactCellEditorFactory = reactCellEditorFactory;

        /***/ },
    /* 341 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        // ag-grid-react v5.5.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var agReactComponent_1 = __webpack_require__(339);
        var React = __webpack_require__(222);
        // wraps the provided React filter component
        function reactFilterFactory(reactComponent, parentComponent) {
            var ReactFilter = function (_super) {
                __extends(ReactFilter, _super);
                function ReactFilter() {
                    _super.call(this, reactComponent, parentComponent);
                }
                ReactFilter.prototype.init = function (params) {
                    _super.prototype.init.call(this, params);
                };
                ReactFilter.prototype.isFilterActive = function () {
                    var componentRef = this.getComponentRef();
                    if (componentRef.isFilterActive) {
                        return componentRef.isFilterActive();
                    } else {
                        console.error("ag-Grid: React filter is missing the mandatory method isFilterActive()");
                        return false;
                    }
                };
                ReactFilter.prototype.doesFilterPass = function (params) {
                    var componentRef = this.getComponentRef();
                    if (componentRef.doesFilterPass) {
                        return componentRef.doesFilterPass(params);
                    } else {
                        console.error("ag-Grid: React filter is missing the mandatory method doesFilterPass()");
                        return false;
                    }
                };
                ReactFilter.prototype.getModel = function () {
                    var componentRef = this.getComponentRef();
                    if (componentRef.getModel) {
                        return componentRef.getModel();
                    } else {
                        console.error("ag-Grid: React filter is missing the mandatory method getModel()");
                        return null;
                    }
                };
                /** Restores the filter state. */
                ReactFilter.prototype.setModel = function (model) {
                    var componentRef = this.getComponentRef();
                    if (componentRef.setModel) {
                        componentRef.setModel(model);
                    } else {
                        console.error("ag-Grid: React filter is missing the mandatory method setModel()");
                    }
                };
                ReactFilter.prototype.afterGuiAttached = function (params) {
                    var componentRef = this.getComponentRef();
                    if (componentRef.afterGuiAttached) {
                        componentRef.afterGuiAttached(params);
                    }
                };
                ReactFilter.prototype.onNewRowsLoaded = function () {
                    var componentRef = this.getComponentRef();
                    if (componentRef.onNewRowsLoaded) {
                        componentRef.onNewRowsLoaded();
                    }
                };
                return ReactFilter;
            }(agReactComponent_1.AgReactComponent);
            return ReactFilter;
        }
        exports.reactFilterFactory = reactFilterFactory;

        /***/ },
    /* 342 */
    /***/ function(module, exports) {

        "use strict";

        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        var RefData = function RefData() {
            _classCallCheck(this, RefData);
        };

        exports.default = RefData;


        RefData.FIRST_NAMES = ["Sophie", "Isabelle", "Emily", "Olivia", "Lily", "Chloe", "Isabella", "Amelia", "Jessica", "Sophia", "Ava", "Charlotte", "Mia", "Lucy", "Grace", "Ruby", "Ella", "Evie", "Freya", "Isla", "Poppy", "Daisy", "Layla"];

        RefData.LAST_NAMES = ["Beckham", "Black", "Braxton", "Brennan", "Brock", "Bryson", "Cadwell", "Cage", "Carson", "Chandler", "Cohen", "Cole", "Corbin", "Dallas", "Dalton", "Dane", "Donovan", "Easton", "Fisher", "Fletcher", "Grady", "Greyson", "Griffin", "Gunner", "Hayden", "Hudson", "Hunter", "Jacoby", "Jagger", "Jaxon", "Jett", "Kade", "Kane", "Keating", "Keegan", "Kingston", "Kobe"];

        RefData.COUNTRY_CODES = {
            Ireland: "ie",
            Spain: "es",
            "United Kingdom": "gb",
            France: "fr",
            Germany: "de",
            Sweden: "se",
            Italy: "it",
            Greece: "gr",
            Iceland: "is",
            Portugal: "pt",
            Malta: "mt",
            Norway: "no",
            Brazil: "br",
            Argentina: "ar",
            Colombia: "co",
            Peru: "pe",
            Venezuela: "ve",
            Uruguay: "uy"
        };

        RefData.COUNTRIES = [{ country: "Ireland", continent: "Europe", language: "English" }, { country: "Spain", continent: "Europe", language: "Spanish" }, { country: "United Kingdom", continent: "Europe", language: "English" }, { country: "France", continent: "Europe", language: "French" }, { country: "Germany", continent: "Europe", language: "(other)" }, { country: "Sweden", continent: "Europe", language: "(other)" }, { country: "Norway", continent: "Europe", language: "(other)" }, { country: "Italy", continent: "Europe", language: "(other)" }, { country: "Greece", continent: "Europe", language: "(other)" }, { country: "Iceland", continent: "Europe", language: "(other)" }, { country: "Portugal", continent: "Europe", language: "Portuguese" }, { country: "Malta", continent: "Europe", language: "(other)" }, { country: "Brazil", continent: "South America", language: "Portuguese" }, { country: "Argentina", continent: "South America", language: "Spanish" }, { country: "Colombia", continent: "South America", language: "Spanish" }, { country: "Peru", continent: "South America", language: "Spanish" }, { country: "Venezuela", continent: "South America", language: "Spanish" }, { country: "Uruguay", continent: "South America", language: "Spanish" }];

        RefData.ADDRESSES = ['1197 Thunder Wagon Common, Cataract, RI, 02987-1016, US, (401) 747-0763', '3685 Rocky Glade, Showtucket, NU, X1E-9I0, CA, (867) 371-4215', '3235 High Forest, Glen Campbell, MS, 39035-6845, US, (601) 638-8186', '2234 Sleepy Pony Mall , Drain, DC, 20078-4243, US, (202) 948-3634', '2722 Hazy Turnabout, Burnt Cabins, NY, 14120-5642, US, (917) 604-6597', '6686 Lazy Ledge, Two Rock, CA, 92639-3020, US, (619) 901-9911', '2000 Dewy Limits, Wacahoota, NF, A4L-2V9, CA, (709) 065-3959', '7710 Noble Pond Avenue, Bolivia, RI, 02931-1842, US, (401) 865-2160', '3452 Sunny Vale, Pyro, ON, M8V-4Z0, CA, (519) 072-8609', '4402 Dusty Cove, Many Farms, UT, 84853-8223, US, (435) 518-0673', '5198 Silent Parade, Round Bottom, MD, 21542-9798, US, (301) 060-7245', '8550 Shady Moor, Kitty Fork, CO, 80941-6207, US, (303) 502-3767', '2131 Old Dell, Merry Midnight, AK, 99906-8842, US, (907) 369-2206', '7390 Harvest Crest, Mosquito Crossing, RI, 02957-6116, US, (401) 463-6348', '874 Little Point, Hot Coffee, BC, V3U-2P6, CA, (250) 706-9207', '8834 Stony Pioneer Heights, Newlove, OR, 97419-8670, US, (541) 408-2213', '9829 Grand Beach, Flint, UT, 84965-9900, US, (435) 700-5161', '3799 Cozy Blossom Ramp, Ptarmigan, MS, 38715-0313, US, (769) 740-1526', '3254 Silver Island Loop, Maunaloa, DE, 19869-3169, US, (302) 667-7671', '1081 Middle Wood, Taylors Gut Landing, OR, 97266-2873, US, (541) 357-6310', '1137 Umber Trail, Shacktown, NW, X3U-5Y8, CA, (867) 702-6883', '9914 Hidden Bank, Wyoming, MO, 64635-9665, US, (636) 280-4192', '7080 Misty Nectar Townline, Coward, AB, T9U-3N4, CA, (403) 623-2838', '1184 Wishing Grounds, Vibank, NW, X7D-0V9, CA, (867) 531-2730', '126 Easy Pointe, Grandview Beach, KY, 40928-9539, US, (502) 548-0956', '6683 Colonial Street, Swan River, BC, V1A-9I8, CA, (778) 014-4257', '960 Gentle Oak Lane, Shakopee, ND, 58618-6277, US, (701) 327-1219', '6918 Cotton Pine Corner, Kenaston, IA, 52165-3975, US, (515) 906-7427', '2368 Burning Woods, Ernfold, NY, 11879-9186, US, (646) 819-0355', '5646 Quiet Shadow Chase, Tiger Tail, IA, 52283-5537, US, (712) 375-9225', '5466 Foggy Mountain Dale, Sweet Home, MT, 59738-0251, US, (406) 881-1706', '5313 Clear Willow Route, Amazon, BC, V0S-2S6, CA, (604) 340-7596', '7000 Pleasant Autoroute, Spaceport City, UT, 84749-2448, US, (435) 154-3360', '8359 Quaking Anchor Road, Gross, BC, V9O-0H5, CA, (250) 985-3859', '5143 Amber Deer Hollow, New Deal, ND, 58446-0853, US, (701) 927-0322', '6230 Jagged Bear Key, Young, AR, 72337-3811, US, (501) 805-7239', '7207 Heather Vista, Devon, WY, 82520-1771, US, (307) 358-7092', '9416 Red Rise Place, Spraytown, OK, 73809-4766, US, (580) 867-1973', '3770 Golden Horse Diversion, Yelland, IL, 60471-1487, US, (224) 717-9349', '4819 Honey Treasure Park, Alaska, NB, E1U-3I0, CA, (506) 656-9138', '6187 Round Front, Land O Lakes, AK, 99873-6403, US, (907) 853-9063', '9218 Crystal Highway, Pickelville, MT, 59847-9299, US, (406) 076-0024', '6737 Bright Quay, Lazy Mountain, KY, 42390-4772, US, (606) 256-7288', '237 Merry Campus, Twentysix, SC, 29330-4909, US, (864) 945-0157', '446 Fallen Gate Rise, Petrolia, SC, 29959-9527, US, (864) 826-0553', '2347 Indian Boulevard, Frisbee, VA, 23797-6458, US, (703) 656-8445', '365 Emerald Grove Line, Level, NC, 28381-1514, US, (919) 976-7958', '1207 Iron Extension, Klickitat, SC, 29197-8571, US, (803) 535-7888', '6770 Cinder Glen, Caronport, OH, 45053-5002, US, (440) 369-4018', '7619 Tawny Carrefour, Senlac, NV, 89529-9876, US, (775) 901-6433'];

        RefData.IT_SKILLS = ['android', 'css', 'html5', 'mac', 'windows'];

        RefData.IT_SKILLS_NAMES = ['Android', 'CSS', 'HTML 5', 'Mac', 'Windows'];

        /***/ },
    /* 343 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

        var _RefData = __webpack_require__(342);

        var _RefData2 = _interopRequireDefault(_RefData);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        var RowDataFactory = function () {
            function RowDataFactory() {
                _classCallCheck(this, RowDataFactory);
            }

            _createClass(RowDataFactory, [{
                key: 'createRowData',
                value: function createRowData() {
                    var rowData = [];

                    for (var i = 0; i < 1000; i++) {
                        var countryData = _RefData2.default.COUNTRIES[i % _RefData2.default.COUNTRIES.length];
                        rowData.push({
                            name: _RefData2.default.FIRST_NAMES[i % _RefData2.default.FIRST_NAMES.length] + ' ' + _RefData2.default.LAST_NAMES[i % _RefData2.default.LAST_NAMES.length],
                            skills: {
                                android: Math.random() < 0.4,
                                html5: Math.random() < 0.4,
                                mac: Math.random() < 0.4,
                                windows: Math.random() < 0.4,
                                css: Math.random() < 0.4
                            },
                            address: _RefData2.default.ADDRESSES[i % _RefData2.default.ADDRESSES.length],
                            years: Math.round(Math.random() * 100),
                            proficiency: Math.round(Math.random() * 100),
                            country: countryData.country,
                            continent: countryData.continent,
                            language: countryData.language,
                            mobile: this.createRandomPhoneNumber(),
                            landline: this.createRandomPhoneNumber()
                        });
                    }

                    return rowData;
                }
            }, {
                key: 'createRandomPhoneNumber',
                value: function createRandomPhoneNumber() {
                    var result = '+';
                    for (var i = 0; i < 12; i++) {
                        result += Math.round(Math.random() * 10);
                        if (i === 2 || i === 5 || i === 8) {
                            result += ' ';
                        }
                    }
                    return result;
                }
            }]);

            return RowDataFactory;
        }();

        exports.default = RowDataFactory;

        /***/ },
    /* 344 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

        var _SkillsCellRenderer = __webpack_require__(345);

        var _SkillsCellRenderer2 = _interopRequireDefault(_SkillsCellRenderer);

        var _NameCellEditor = __webpack_require__(346);

        var _NameCellEditor2 = _interopRequireDefault(_NameCellEditor);

        var _ProficiencyCellRenderer = __webpack_require__(347);

        var _ProficiencyCellRenderer2 = _interopRequireDefault(_ProficiencyCellRenderer);

        var _RefData = __webpack_require__(342);

        var _RefData2 = _interopRequireDefault(_RefData);

        var _SkillsFilter = __webpack_require__(348);

        var _SkillsFilter2 = _interopRequireDefault(_SkillsFilter);

        var _ProficiencyFilter = __webpack_require__(349);

        var _ProficiencyFilter2 = _interopRequireDefault(_ProficiencyFilter);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        var ColDefFactory = function () {
            function ColDefFactory() {
                _classCallCheck(this, ColDefFactory);
            }

            _createClass(ColDefFactory, [{
                key: 'createColDefs',
                value: function createColDefs() {

                    var columnDefs = [{ headerName: '#', width: 30, checkboxSelection: true, suppressSorting: true,
                        suppressMenu: true, pinned: true }, {
                        headerName: 'Employee',
                        children: [{ headerName: "Name", field: "name", enableRowGroup: true, enablePivot: true,
                            width: 150, pinned: true, editable: true,
                            // use a React cellEditor
                            cellEditorFramework: _NameCellEditor2.default
                        }, { headerName: "Country", field: "country", width: 150, enableRowGroup: true, enablePivot: true,
                            // an example of using a non-React cell renderer
                            cellRenderer: countryCellRenderer, pinned: true,
                            filterParams: { cellRenderer: countryCellRenderer, cellHeight: 20 } }]
                    }, {
                        headerName: 'IT Skills',
                        children: [{ headerName: "Skills", width: 125, suppressSorting: true, field: 'skills', enableRowGroup: true, enablePivot: true,
                            // supply a React component
                            cellRendererFramework: _SkillsCellRenderer2.default,
                            // supply a React component
                            filterFramework: _SkillsFilter2.default
                        }, { headerName: "Proficiency", field: "proficiency", width: 120, enableValue: true,
                            // supply a React component
                            cellRendererFramework: _ProficiencyCellRenderer2.default,
                            // supply a React component
                            filterFramework: _ProficiencyFilter2.default
                        }]
                    }, {
                        headerName: 'Contact',
                        children: [{ headerName: "Mobile", field: "mobile", width: 150, filter: 'text' }, { headerName: "Land-line", field: "landline", width: 150, filter: 'text' }, { headerName: "Address", field: "address", width: 500, filter: 'text' }]
                    }];
                    return columnDefs;
                }
            }]);

            return ColDefFactory;
        }();

        // this is a simple cell renderer, putting together static html, no
        // need to use React for it.


        exports.default = ColDefFactory;
        function countryCellRenderer(params) {
            if (params.value) {
                var flag = "<img border='0' width='15' height='10' " + "style='margin-bottom: 2px' src='http://flags.fmcdn.net/data/flags/mini/" + _RefData2.default.COUNTRY_CODES[params.value] + ".png'>";
                return flag + " " + params.value;
            } else {
                return null;
            }
        }

        /***/ },
    /* 345 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

        var _react = __webpack_require__(222);

        var _react2 = _interopRequireDefault(_react);

        var _RefData = __webpack_require__(342);

        var _RefData2 = _interopRequireDefault(_RefData);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

        var SkillsCellRenderer = function (_React$Component) {
            _inherits(SkillsCellRenderer, _React$Component);

            function SkillsCellRenderer() {
                _classCallCheck(this, SkillsCellRenderer);

                return _possibleConstructorReturn(this, Object.getPrototypeOf(SkillsCellRenderer).apply(this, arguments));
            }

            _createClass(SkillsCellRenderer, [{
                key: 'render',
                value: function render() {
                    var skills = [];
                    var rowData = this.props.data;
                    _RefData2.default.IT_SKILLS.forEach(function (skill) {
                        if (rowData && rowData.skills && rowData.skills[skill]) {
                            skills.push(_react2.default.createElement('img', { key: skill, src: 'images/skills/' + skill + '.png', width: 16, title: skill }));
                        }
                    });

                    return _react2.default.createElement(
                        'span',
                        null,
                        skills
                    );
                }
            }]);

            return SkillsCellRenderer;
        }(_react2.default.Component);

        // the grid will always pass in one props called 'params',
        // which is the grid passing you the params for the cellRenderer.
        // this piece is optional. the grid will always pass the 'params'
        // props, so little need for adding this validation meta-data.


        exports.default = SkillsCellRenderer;
        SkillsCellRenderer.propTypes = {
            params: _react2.default.PropTypes.object
        };

        /***/ },
    /* 346 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

        var _react = __webpack_require__(222);

        var _react2 = _interopRequireDefault(_react);

        var _RefData = __webpack_require__(342);

        var _RefData2 = _interopRequireDefault(_RefData);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

        var KEY_BACKSPACE = 8;
        var KEY_DELETE = 46;
        var KEY_F2 = 113;

        // cell renderer for the proficiency column. this is a very basic cell editor,

        var NameCellEditor = function (_React$Component) {
            _inherits(NameCellEditor, _React$Component);

            function NameCellEditor(props) {
                _classCallCheck(this, NameCellEditor);

                // the entire ag-Grid properties are passed as one single object inside the params

                var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NameCellEditor).call(this, props));

                _this.state = _this.createInitialState(props);
                return _this;
            }

            // work out how to present the data based on what the user hit. you don't need to do any of
            // this for your ag-Grid cellEditor to work, however it makes sense to do this so the user
            // experience is similar to Excel


            _createClass(NameCellEditor, [{
                key: 'createInitialState',
                value: function createInitialState(props) {

                    var startValue;
                    var putCursorAtEndOnFocus = false;
                    var highlightAllOnFocus = false;

                    if (props.keyPress === KEY_BACKSPACE || props.keyPress === KEY_DELETE) {
                        // if backspace or delete pressed, we clear the cell
                        startValue = '';
                    } else if (props.charPress) {
                        // if a letter was pressed, we start with the letter
                        startValue = props.charPress;
                    } else {
                        // otherwise we start with the current value
                        startValue = props.value;
                        if (props.keyPress === KEY_F2) {
                            this.putCursorAtEndOnFocus = true;
                        } else {
                            this.highlightAllOnFocus = true;
                        }
                    }

                    return {
                        value: startValue,
                        putCursorAtEndOnFocus: putCursorAtEndOnFocus,
                        highlightAllOnFocus: highlightAllOnFocus
                    };
                }
            }, {
                key: 'render',
                value: function render() {
                    return _react2.default.createElement('input', { ref: 'textField', value: this.state.value, onChange: this.onChangeListener.bind(this) });
                }
            }, {
                key: 'onChangeListener',
                value: function onChangeListener(event) {
                    // if doing React, you will probably be using a library for managing immutable
                    // objects better. to keep this example simple, we don't use one.
                    var newState = {
                        value: event.target.value,
                        putCursorAtEndOnFocus: this.state.putCursorAtEndOnFocus,
                        highlightAllOnFocus: this.state.highlightAllOnFocus
                    };
                    this.setState(newState);
                }

                // called by ag-Grid, to get the final value

            }, {
                key: 'getValue',
                value: function getValue() {
                    return this.state.value;
                }

                // cannot use componentDidMount because although the component might be ready from React's point of
                // view, it may not yet be in the browser (put in by ag-Grid) so focus will not work

            }, {
                key: 'afterGuiAttached',
                value: function afterGuiAttached() {
                    // get ref from React component
                    var eInput = this.refs.textField;
                    eInput.focus();
                    if (this.highlightAllOnFocus) {
                        eInput.select();
                    } else {
                        // when we started editing, we want the carot at the end, not the start.
                        // this comes into play in two scenarios: a) when user hits F2 and b)
                        // when user hits a printable character, then on IE (and only IE) the carot
                        // was placed after the first character, thus 'apply' would end up as 'pplea'
                        var length = eInput.value ? eInput.value.length : 0;
                        if (length > 0) {
                            eInput.setSelectionRange(length, length);
                        }
                    }
                }

                // if we want the editor to appear in a popup, then return true.

            }, {
                key: 'isPopup',
                value: function isPopup() {
                    return false;
                }

                // return true here if you don't want to allow editing on the cell.

            }, {
                key: 'isCancelBeforeStart',
                value: function isCancelBeforeStart() {
                    return false;
                }

                // just to demonstrate, if you type in 'cancel' then the edit will not take effect

            }, {
                key: 'isCancelAfterEnd',
                value: function isCancelAfterEnd() {
                    if (this.state.value && this.state.value.toUpperCase() === 'CANCEL') {
                        return true;
                    } else {
                        return false;
                    }
                }
            }]);

            return NameCellEditor;
        }(_react2.default.Component);

        // the grid will always pass in one props called 'params',
        // which is the grid passing you the params for the cellRenderer.
        // this piece is optional. the grid will always pass the 'params'
        // props, so little need for adding this validation meta-data.


        exports.default = NameCellEditor;
        NameCellEditor.propTypes = {
            params: _react2.default.PropTypes.object
        };

        /***/ },
    /* 347 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

        var _react = __webpack_require__(222);

        var _react2 = _interopRequireDefault(_react);

        var _RefData = __webpack_require__(342);

        var _RefData2 = _interopRequireDefault(_RefData);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

        // cell renderer for the proficiency column. this is a very basic cell renderer,
        // it is arguable that we should not of used React and just returned a string of
        // html as a normal ag-Grid cellRenderer.

        var ProficiencyCellRenderer = function (_React$Component) {
            _inherits(ProficiencyCellRenderer, _React$Component);

            function ProficiencyCellRenderer() {
                _classCallCheck(this, ProficiencyCellRenderer);

                return _possibleConstructorReturn(this, Object.getPrototypeOf(ProficiencyCellRenderer).apply(this, arguments));
            }

            _createClass(ProficiencyCellRenderer, [{
                key: 'render',
                value: function render() {
                    var backgroundColor;
                    if (this.props.value < 20) {
                        backgroundColor = 'red';
                    } else if (this.props.value < 60) {
                        backgroundColor = '#ff9900';
                    } else {
                        backgroundColor = '#00A000';
                    }

                    return _react2.default.createElement(
                        'div',
                        { className: 'div-percent-bar', style: { width: this.props.value + '%', backgroundColor: backgroundColor } },
                        _react2.default.createElement(
                            'div',
                            { className: 'div-percent-value' },
                            this.props.value,
                            '%'
                        )
                    );
                }
            }]);

            return ProficiencyCellRenderer;
        }(_react2.default.Component);

        exports.default = ProficiencyCellRenderer;

        /***/ },
    /* 348 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

        var _react = __webpack_require__(222);

        var _react2 = _interopRequireDefault(_react);

        var _RefData = __webpack_require__(342);

        var _RefData2 = _interopRequireDefault(_RefData);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

        // the skills filter component. this can be laid out much better in a 'React'
        // way. there are design patterns you can apply to layout out your React classes.
        // however, i'm not worried, as the intention here is to show you ag-Grid
        // working with React, and that's all. i'm not looking for any awards for my
        // React design skills.

        var SkillsFilter = function (_React$Component) {
            _inherits(SkillsFilter, _React$Component);

            function SkillsFilter(props) {
                _classCallCheck(this, SkillsFilter);

                var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SkillsFilter).call(this, props));

                _this.state = {
                    android: false,
                    css: false,
                    html5: false,
                    mac: false,
                    windows: false
                };
                return _this;
            }

            _createClass(SkillsFilter, [{
                key: 'getModel',
                value: function getModel() {
                    return {
                        android: this.state.android,
                        css: this.state.css,
                        html5: this.state.html5,
                        mac: this.state.mac,
                        windows: this.state.windows
                    };
                }
            }, {
                key: 'setModel',
                value: function setModel(model) {
                    this.setState({
                        android: model.android,
                        css: model.css,
                        html5: model.html5,
                        mac: model.mac,
                        windows: model.windows
                    });
                }

                // called by agGrid

            }, {
                key: 'doesFilterPass',
                value: function doesFilterPass(params) {
                    var _this2 = this;

                    var rowSkills = params.data.skills;
                    var passed = true;

                    _RefData2.default.IT_SKILLS.forEach(function (skill) {
                        if (_this2.state[skill]) {
                            if (!rowSkills[skill]) {
                                passed = false;
                            }
                        }
                    });

                    return passed;
                }
            }, {
                key: 'isFilterActive',


                // called by agGrid
                value: function isFilterActive() {
                    var somethingSelected = this.state.android || this.state.css || this.state.html5 || this.state.mac || this.state.windows;
                    return somethingSelected;
                }
            }, {
                key: 'onSkillChanged',
                value: function onSkillChanged(skill, event) {
                    var newValue = event.target.checked;
                    var newModel = {};
                    newModel[skill] = newValue;
                    // set the state, and once it is done, then call filterChangedCallback
                    this.setState(newModel, this.props.filterChangedCallback);
                }
            }, {
                key: 'render',
                value: function render() {
                    var _this3 = this;

                    var skillsTemplates = [];
                    _RefData2.default.IT_SKILLS.forEach(function (skill, index) {

                        var skillName = _RefData2.default.IT_SKILLS_NAMES[index];
                        var template = _react2.default.createElement(
                            'label',
                            { key: skill, style: { border: '1px solid lightgrey', margin: 4, padding: 4, display: 'inline-block' } },
                            _react2.default.createElement(
                                'span',
                                null,
                                _react2.default.createElement(
                                    'div',
                                    { style: { textAlign: 'center' } },
                                    skillName
                                ),
                                _react2.default.createElement(
                                    'div',
                                    null,
                                    _react2.default.createElement('input', { type: 'checkbox', onClick: _this3.onSkillChanged.bind(_this3, skill) }),
                                    _react2.default.createElement('img', { src: 'images/skills/' + skill + '.png', width: 30 })
                                )
                            )
                        );

                        skillsTemplates.push(template);
                    });

                    return _react2.default.createElement(
                        'div',
                        { style: { width: 380 } },
                        _react2.default.createElement(
                            'div',
                            { style: { textAlign: 'center', background: 'lightgray', width: '100%', display: 'block', borderBottom: '1px solid grey' } },
                            _react2.default.createElement(
                                'b',
                                null,
                                'Custom Skills Filter'
                            )
                        ),
                        skillsTemplates
                    );
                }

                // these are other method that agGrid calls that we
                // could of implemented, but they are optional and
                // we have no use for them in this particular filter.
                //afterGuiAttached(params) {}
                //onNewRowsLoaded() {}
                //onAnyFilterChanged() {}

            }]);

            return SkillsFilter;
        }(_react2.default.Component);

        exports.default = SkillsFilter;

        /***/ },
    /* 349 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

        var _react = __webpack_require__(222);

        var _react2 = _interopRequireDefault(_react);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

        var PROFICIENCY_NAMES = ['No Filter', 'Above 40%', 'Above 60%', 'Above 80%'];

        // the proficiency filter component. this demonstrates how to integrate
        // a React filter component with ag-Grid.

        var ProficiencyFilter = function (_React$Component) {
            _inherits(ProficiencyFilter, _React$Component);

            function ProficiencyFilter(props) {
                _classCallCheck(this, ProficiencyFilter);

                var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ProficiencyFilter).call(this));

                _this.state = {
                    selected: PROFICIENCY_NAMES[0]
                };
                return _this;
            }

            // called by agGrid


            _createClass(ProficiencyFilter, [{
                key: 'doesFilterPass',
                value: function doesFilterPass(params) {
                    var value = this.props.valueGetter(params);
                    var valueAsNumber = parseFloat(value);

                    switch (this.state.selected) {
                        case PROFICIENCY_NAMES[1]:
                            return valueAsNumber >= 40;
                        case PROFICIENCY_NAMES[2]:
                            return valueAsNumber >= 60;
                        case PROFICIENCY_NAMES[3]:
                            return valueAsNumber >= 80;
                        default:
                            return true;
                    }
                }
            }, {
                key: 'isFilterActive',


                // called by agGrid
                value: function isFilterActive() {
                    return this.state.selected !== PROFICIENCY_NAMES[0];
                }
            }, {
                key: 'onButtonPressed',
                value: function onButtonPressed(name) {
                    console.log(name);
                    var newState = { selected: name };
                    // set the state, and once it is done, then call filterChangedCallback
                    this.setState(newState, this.props.filterChangedCallback);
                    console.log(name);
                }
            }, {
                key: 'render',
                value: function render() {
                    var _this2 = this;

                    var rows = [];
                    PROFICIENCY_NAMES.forEach(function (name) {
                        var selected = _this2.state.selected === name;
                        rows.push(_react2.default.createElement(
                            'div',
                            { key: name },
                            _react2.default.createElement(
                                'label',
                                { style: { paddingLeft: 4 } },
                                _react2.default.createElement('input', { type: 'radio', checked: selected, name: Math.random(), onChange: _this2.onButtonPressed.bind(_this2, name) }),
                                name
                            )
                        ));
                    });

                    return _react2.default.createElement(
                        'div',
                        null,
                        _react2.default.createElement(
                            'div',
                            { style: { textAlign: 'center', background: 'lightgray', width: '100%', display: 'block', borderBottom: '1px solid grey' } },
                            _react2.default.createElement(
                                'b',
                                null,
                                'Custom Proficiency Filter'
                            )
                        ),
                        rows
                    );
                }

                // these are other method that agGrid calls that we
                // could of implemented, but they are optional and
                // we have no use for them in this particular filter.
                //getApi() {}
                //afterGuiAttached(params) {}
                //onNewRowsLoaded() {}
                //onAnyFilterChanged() {}

            }]);

            return ProficiencyFilter;
        }(_react2.default.Component);

        exports.default = ProficiencyFilter;

        /***/ },
    /* 350 */
    /***/ function(module, exports, __webpack_require__) {

        // style-loader: Adds some css to the DOM by adding a <style> tag

        // load the styles
        var content = __webpack_require__(351);
        if(typeof content === 'string') content = [[module.id, content, '']];
        // add the styles to the DOM
        var update = __webpack_require__(353)(content, {});
        if(content.locals) module.exports = content.locals;
        // Hot Module Replacement
        if(true) {
            // When the styles change, update the <style> tags
            if(!content.locals) {
                module.hot.accept(351, function() {
                    var newContent = __webpack_require__(351);
                    if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
                    update(newContent);
                });
            }
            // When the module is disposed, remove the <style> tags
            module.hot.dispose(function() { update(); });
        }

        /***/ },
    /* 351 */
    /***/ function(module, exports, __webpack_require__) {

        exports = module.exports = __webpack_require__(352)();
        // imports


        // module
        exports.push([module.id, "\r\n.ag-cell {\r\n    padding-top: 2px !important;\r\n    padding-bottom: 2px !important;\r\n}\r\n\r\nlabel {\r\n    font-weight: normal !important;\r\n}\r\n\r\n.div-percent-bar {\r\n    display: inline-block;\r\n    height: 20px;\r\n    position: relative;\r\n}\r\n\r\n.div-percent-value {\r\n    position: absolute;\r\n    padding-left: 4px;\r\n    font-weight: bold;\r\n    font-size: 13px;\r\n}\r\n\r\n.div-outer-div {\r\n    display: inline-block;\r\n    height: 100%;\r\n    width: 100%;\r\n}\r\n", ""]);

        // exports


        /***/ },
    /* 352 */
    /***/ function(module, exports) {

        "use strict";

        /*
         MIT License http://www.opensource.org/licenses/mit-license.php
         Author Tobias Koppers @sokra
         */
        // css base code, injected by the css-loader
        module.exports = function () {
            var list = [];

            // return the list of modules as css string
            list.toString = function toString() {
                var result = [];
                for (var i = 0; i < this.length; i++) {
                    var item = this[i];
                    if (item[2]) {
                        result.push("@media " + item[2] + "{" + item[1] + "}");
                    } else {
                        result.push(item[1]);
                    }
                }
                return result.join("");
            };

            // import a list of modules into the list
            list.i = function (modules, mediaQuery) {
                if (typeof modules === "string") modules = [[null, modules, ""]];
                var alreadyImportedModules = {};
                for (var i = 0; i < this.length; i++) {
                    var id = this[i][0];
                    if (typeof id === "number") alreadyImportedModules[id] = true;
                }
                for (i = 0; i < modules.length; i++) {
                    var item = modules[i];
                    // skip already imported module
                    // this implementation is not 100% perfect for weird media query combinations
                    //  when a module is imported multiple times with different media queries.
                    //  I hope this will never occur (Hey this way we have smaller bundles)
                    if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
                        if (mediaQuery && !item[2]) {
                            item[2] = mediaQuery;
                        } else if (mediaQuery) {
                            item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
                        }
                        list.push(item);
                    }
                }
            };
            return list;
        };

        /***/ },
    /* 353 */
    /***/ function(module, exports, __webpack_require__) {

        /*
         MIT License http://www.opensource.org/licenses/mit-license.php
         Author Tobias Koppers @sokra
         */
        var stylesInDom = {},
            memoize = function(fn) {
                var memo;
                return function () {
                    if (typeof memo === "undefined") memo = fn.apply(this, arguments);
                    return memo;
                };
            },
            isOldIE = memoize(function() {
                return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
            }),
            getHeadElement = memoize(function () {
                return document.head || document.getElementsByTagName("head")[0];
            }),
            singletonElement = null,
            singletonCounter = 0,
            styleElementsInsertedAtTop = [];

        module.exports = function(list, options) {
            if(false) {
                if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
            }

            options = options || {};
            // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
            // tags it will allow on a page
            if (typeof options.singleton === "undefined") options.singleton = isOldIE();

            // By default, add <style> tags to the bottom of <head>.
            if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

            var styles = listToStyles(list);
            addStylesToDom(styles, options);

            return function update(newList) {
                var mayRemove = [];
                for(var i = 0; i < styles.length; i++) {
                    var item = styles[i];
                    var domStyle = stylesInDom[item.id];
                    domStyle.refs--;
                    mayRemove.push(domStyle);
                }
                if(newList) {
                    var newStyles = listToStyles(newList);
                    addStylesToDom(newStyles, options);
                }
                for(var i = 0; i < mayRemove.length; i++) {
                    var domStyle = mayRemove[i];
                    if(domStyle.refs === 0) {
                        for(var j = 0; j < domStyle.parts.length; j++)
                            domStyle.parts[j]();
                        delete stylesInDom[domStyle.id];
                    }
                }
            };
        }

        function addStylesToDom(styles, options) {
            for(var i = 0; i < styles.length; i++) {
                var item = styles[i];
                var domStyle = stylesInDom[item.id];
                if(domStyle) {
                    domStyle.refs++;
                    for(var j = 0; j < domStyle.parts.length; j++) {
                        domStyle.parts[j](item.parts[j]);
                    }
                    for(; j < item.parts.length; j++) {
                        domStyle.parts.push(addStyle(item.parts[j], options));
                    }
                } else {
                    var parts = [];
                    for(var j = 0; j < item.parts.length; j++) {
                        parts.push(addStyle(item.parts[j], options));
                    }
                    stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
                }
            }
        }

        function listToStyles(list) {
            var styles = [];
            var newStyles = {};
            for(var i = 0; i < list.length; i++) {
                var item = list[i];
                var id = item[0];
                var css = item[1];
                var media = item[2];
                var sourceMap = item[3];
                var part = {css: css, media: media, sourceMap: sourceMap};
                if(!newStyles[id])
                    styles.push(newStyles[id] = {id: id, parts: [part]});
                else
                    newStyles[id].parts.push(part);
            }
            return styles;
        }

        function insertStyleElement(options, styleElement) {
            var head = getHeadElement();
            var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
            if (options.insertAt === "top") {
                if(!lastStyleElementInsertedAtTop) {
                    head.insertBefore(styleElement, head.firstChild);
                } else if(lastStyleElementInsertedAtTop.nextSibling) {
                    head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
                } else {
                    head.appendChild(styleElement);
                }
                styleElementsInsertedAtTop.push(styleElement);
            } else if (options.insertAt === "bottom") {
                head.appendChild(styleElement);
            } else {
                throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
            }
        }

        function removeStyleElement(styleElement) {
            styleElement.parentNode.removeChild(styleElement);
            var idx = styleElementsInsertedAtTop.indexOf(styleElement);
            if(idx >= 0) {
                styleElementsInsertedAtTop.splice(idx, 1);
            }
        }

        function createStyleElement(options) {
            var styleElement = document.createElement("style");
            styleElement.type = "text/css";
            insertStyleElement(options, styleElement);
            return styleElement;
        }

        function createLinkElement(options) {
            var linkElement = document.createElement("link");
            linkElement.rel = "stylesheet";
            insertStyleElement(options, linkElement);
            return linkElement;
        }

        function addStyle(obj, options) {
            var styleElement, update, remove;

            if (options.singleton) {
                var styleIndex = singletonCounter++;
                styleElement = singletonElement || (singletonElement = createStyleElement(options));
                update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
                remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
            } else if(obj.sourceMap &&
                typeof URL === "function" &&
                typeof URL.createObjectURL === "function" &&
                typeof URL.revokeObjectURL === "function" &&
                typeof Blob === "function" &&
                typeof btoa === "function") {
                styleElement = createLinkElement(options);
                update = updateLink.bind(null, styleElement);
                remove = function() {
                    removeStyleElement(styleElement);
                    if(styleElement.href)
                        URL.revokeObjectURL(styleElement.href);
                };
            } else {
                styleElement = createStyleElement(options);
                update = applyToTag.bind(null, styleElement);
                remove = function() {
                    removeStyleElement(styleElement);
                };
            }

            update(obj);

            return function updateStyle(newObj) {
                if(newObj) {
                    if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
                        return;
                    update(obj = newObj);
                } else {
                    remove();
                }
            };
        }

        var replaceText = (function () {
            var textStore = [];

            return function (index, replacement) {
                textStore[index] = replacement;
                return textStore.filter(Boolean).join('\n');
            };
        })();

        function applyToSingletonTag(styleElement, index, remove, obj) {
            var css = remove ? "" : obj.css;

            if (styleElement.styleSheet) {
                styleElement.styleSheet.cssText = replaceText(index, css);
            } else {
                var cssNode = document.createTextNode(css);
                var childNodes = styleElement.childNodes;
                if (childNodes[index]) styleElement.removeChild(childNodes[index]);
                if (childNodes.length) {
                    styleElement.insertBefore(cssNode, childNodes[index]);
                } else {
                    styleElement.appendChild(cssNode);
                }
            }
        }

        function applyToTag(styleElement, obj) {
            var css = obj.css;
            var media = obj.media;
            var sourceMap = obj.sourceMap;

            if(media) {
                styleElement.setAttribute("media", media)
            }

            if(styleElement.styleSheet) {
                styleElement.styleSheet.cssText = css;
            } else {
                while(styleElement.firstChild) {
                    styleElement.removeChild(styleElement.firstChild);
                }
                styleElement.appendChild(document.createTextNode(css));
            }
        }

        function updateLink(linkElement, obj) {
            var css = obj.css;
            var media = obj.media;
            var sourceMap = obj.sourceMap;

            if(sourceMap) {
                // http://stackoverflow.com/a/26603875
                css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
            }

            var blob = new Blob([css], { type: "text/css" });

            var oldSrc = linkElement.href;

            linkElement.href = URL.createObjectURL(blob);

            if(oldSrc)
                URL.revokeObjectURL(oldSrc);
        }


        /***/ },
    /* 354 */
    /***/ function(module, exports, __webpack_require__) {

        'use strict';

        __webpack_require__(355);

        var populateClientExports = __webpack_require__(389).populateClientExports;
        populateClientExports(exports);

        /***/ },
    /* 355 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        // ag-grid-enterprise v5.4.0
        var main_1 = __webpack_require__(238);
        var enterpriseMenu_1 = __webpack_require__(356);
        var rangeController_1 = __webpack_require__(361);
        var clipboardService_1 = __webpack_require__(362);
        var groupStage_1 = __webpack_require__(363);
        var aggregationStage_1 = __webpack_require__(364);
        var enterpriseBoot_1 = __webpack_require__(367);
        var statusBar_1 = __webpack_require__(376);
        var contextMenu_1 = __webpack_require__(378);
        var viewportRowModel_1 = __webpack_require__(379);
        var pivotColumnsPanel_1 = __webpack_require__(380);
        var toolPanelComp_1 = __webpack_require__(383);
        var rowGroupCompFactory_1 = __webpack_require__(387);
        var licenseManager_1 = __webpack_require__(374);
        var md5_1 = __webpack_require__(375);
        var pivotStage_1 = __webpack_require__(365);
        var pivotColDefService_1 = __webpack_require__(366);
        var aggFuncService_1 = __webpack_require__(360);
        var pivotCompFactory_1 = __webpack_require__(388);
        var rowModelTypes = { viewport: viewportRowModel_1.ViewportRowModel };
        main_1.Grid.setEnterpriseBeans([toolPanelComp_1.ToolPanelComp, enterpriseMenu_1.EnterpriseMenuFactory, rowGroupCompFactory_1.RowGroupCompFactory, pivotCompFactory_1.PivotCompFactory, pivotColumnsPanel_1.PivotColumnsPanel, rangeController_1.RangeController, clipboardService_1.ClipboardService, pivotStage_1.PivotStage, pivotColDefService_1.PivotColDefService, contextMenu_1.ContextMenuFactory, groupStage_1.GroupStage, aggregationStage_1.AggregationStage, enterpriseBoot_1.EnterpriseBoot, aggFuncService_1.AggFuncService, statusBar_1.StatusBar, licenseManager_1.LicenseManager, md5_1.MD5], rowModelTypes);

        /***/ },
    /* 356 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var columnSelectPanel_1 = __webpack_require__(357);
        var aggFuncService_1 = __webpack_require__(360);
        var svgFactory = main_1.SvgFactory.getInstance();
        var EnterpriseMenuFactory = function () {
            function EnterpriseMenuFactory() {}
            EnterpriseMenuFactory.prototype.showMenuAfterMouseEvent = function (column, mouseEvent) {
                var _this = this;
                this.showMenu(column, function (menu) {
                    _this.popupService.positionPopupUnderMouseEvent({
                        mouseEvent: mouseEvent,
                        ePopup: menu.getGui()
                    });
                });
            };
            EnterpriseMenuFactory.prototype.showMenuAfterButtonClick = function (column, eventSource) {
                var _this = this;
                this.showMenu(column, function (menu) {
                    _this.popupService.positionPopupUnderComponent({ eventSource: eventSource,
                        ePopup: menu.getGui(),
                        nudgeX: -9,
                        nudgeY: -26,
                        minWidth: menu.getMinWidth(),
                        keepWithinBounds: true
                    });
                });
            };
            EnterpriseMenuFactory.prototype.showMenu = function (column, positionCallback) {
                var _this = this;
                var menu = new EnterpriseMenu(column, this.lastSelectedTab);
                this.context.wireBean(menu);
                var eMenuGui = menu.getGui();
                // need to show filter before positioning, as only after filter
                // is visible can we find out what the width of it is
                var hidePopup = this.popupService.addAsModalPopup(eMenuGui, true, function () {
                    return menu.destroy();
                });
                positionCallback(menu);
                menu.afterGuiAttached({
                    hidePopup: hidePopup
                });
                menu.addEventListener(EnterpriseMenu.EVENT_TAB_SELECTED, function (event) {
                    _this.lastSelectedTab = event.key;
                });
            };
            EnterpriseMenuFactory.prototype.isMenuEnabled = function (column) {
                var showColumnPanel = !this.gridOptionsWrapper.isSuppressMenuColumnPanel();
                var showMainPanel = !this.gridOptionsWrapper.isSuppressMenuMainPanel();
                var showFilterPanel = !this.gridOptionsWrapper.isSuppressMenuFilterPanel() && column.isFilterAllowed();
                return showColumnPanel || showMainPanel || showFilterPanel;
            };
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], EnterpriseMenuFactory.prototype, "context", void 0);
            __decorate([main_1.Autowired('popupService'), __metadata('design:type', main_1.PopupService)], EnterpriseMenuFactory.prototype, "popupService", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], EnterpriseMenuFactory.prototype, "gridOptionsWrapper", void 0);
            EnterpriseMenuFactory = __decorate([main_1.Bean('menuFactory'), __metadata('design:paramtypes', [])], EnterpriseMenuFactory);
            return EnterpriseMenuFactory;
        }();
        exports.EnterpriseMenuFactory = EnterpriseMenuFactory;
        var EnterpriseMenu = function () {
            function EnterpriseMenu(column, initialSelection) {
                this.eventService = new main_1.EventService();
                this.column = column;
                this.initialSelection = initialSelection;
            }
            EnterpriseMenu.prototype.addEventListener = function (event, listener) {
                this.eventService.addEventListener(event, listener);
            };
            EnterpriseMenu.prototype.getMinWidth = function () {
                return this.tabbedLayout.getMinWidth();
            };
            EnterpriseMenu.prototype.init = function () {
                var tabItems = [];
                if (!this.gridOptionsWrapper.isSuppressMenuMainPanel()) {
                    this.createMainPanel();
                    tabItems.push(this.tabItemGeneral);
                }
                if (!this.gridOptionsWrapper.isSuppressMenuFilterPanel() && this.column.isFilterAllowed()) {
                    this.createFilterPanel();
                    tabItems.push(this.tabItemFilter);
                }
                if (!this.gridOptionsWrapper.isSuppressMenuColumnPanel()) {
                    this.createColumnsPanel();
                    tabItems.push(this.tabItemColumns);
                }
                this.tabbedLayout = new main_1.TabbedLayout({
                    items: tabItems,
                    cssClass: 'ag-menu',
                    onActiveItemClicked: this.onHidePopup.bind(this),
                    onItemClicked: this.onTabItemClicked.bind(this)
                });
            };
            EnterpriseMenu.prototype.showTabBasedOnPreviousSelection = function () {
                // show the tab the user was on last time they had a menu open
                if (this.tabItemColumns && this.initialSelection === EnterpriseMenu.TAB_COLUMNS) {
                    this.tabbedLayout.showItem(this.tabItemColumns);
                } else if (this.tabItemFilter && this.initialSelection === EnterpriseMenu.TAB_FILTER) {
                    this.tabbedLayout.showItem(this.tabItemFilter);
                } else if (this.tabItemGeneral && this.initialSelection === EnterpriseMenu.TAB_GENERAL) {
                    this.tabbedLayout.showItem(this.tabItemGeneral);
                } else {
                    this.tabbedLayout.showFirstItem();
                }
            };
            EnterpriseMenu.prototype.onTabItemClicked = function (event) {
                var key;
                switch (event.item) {
                    case this.tabItemColumns:
                        key = EnterpriseMenu.TAB_COLUMNS;
                        break;
                    case this.tabItemFilter:
                        key = EnterpriseMenu.TAB_FILTER;
                        break;
                    case this.tabItemGeneral:
                        key = EnterpriseMenu.TAB_GENERAL;
                        break;
                }
                if (key) {
                    this.eventService.dispatchEvent(EnterpriseMenu.EVENT_TAB_SELECTED, { key: key });
                }
            };
            EnterpriseMenu.prototype.destroy = function () {
                if (this.columnSelectPanel) {
                    this.columnSelectPanel.destroy();
                }
                if (this.mainMenuList) {
                    this.mainMenuList.destroy();
                }
            };
            EnterpriseMenu.prototype.createPinnedSubMenu = function () {
                var _this = this;
                var cMenuList = new main_1.MenuList();
                this.context.wireBean(cMenuList);
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                cMenuList.addItem({
                    name: localeTextFunc('pinLeft', 'Pin Left'),
                    action: function action() {
                        return _this.columnController.setColumnPinned(_this.column, main_1.Column.PINNED_LEFT);
                    },
                    checked: this.column.isPinnedLeft()
                });
                cMenuList.addItem({
                    name: localeTextFunc('pinRight', 'Pin Right'),
                    action: function action() {
                        return _this.columnController.setColumnPinned(_this.column, main_1.Column.PINNED_RIGHT);
                    },
                    checked: this.column.isPinnedRight()
                });
                cMenuList.addItem({
                    name: localeTextFunc('noPin', 'No Pin'),
                    action: function action() {
                        return _this.columnController.setColumnPinned(_this.column, null);
                    },
                    checked: !this.column.isPinned()
                });
                return cMenuList;
            };
            EnterpriseMenu.prototype.createAggregationSubMenu = function () {
                var _this = this;
                var cMenuList = new main_1.MenuList();
                this.context.wireBean(cMenuList);
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                var columnIsAlreadyAggValue = this.column.isValueActive();
                var funcNames = this.aggFuncService.getFuncNames();
                var columnToUse;
                if (this.column.isPrimary()) {
                    columnToUse = this.column;
                } else {
                    columnToUse = this.column.getColDef().pivotValueColumn;
                }
                funcNames.forEach(function (funcName) {
                    cMenuList.addItem({
                        name: localeTextFunc(funcName, funcName),
                        action: function action() {
                            _this.columnController.setColumnAggFunc(columnToUse, funcName);
                            _this.columnController.addValueColumn(columnToUse);
                        },
                        checked: columnIsAlreadyAggValue && columnToUse.getAggFunc() === funcName
                    });
                });
                return cMenuList;
            };
            EnterpriseMenu.prototype.createBuiltInMenuOptions = function () {
                var _this = this;
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                var builtInMenuOptions = {
                    pinSubMenu: {
                        name: localeTextFunc('pinColumn', 'Pin Column'),
                        icon: svgFactory.createPinIcon(),
                        childMenu: this.createPinnedSubMenu()
                    },
                    valueAggSubMenu: {
                        name: localeTextFunc('valueAggregation', 'Value Aggregation'),
                        icon: svgFactory.createAggregationIcon(),
                        childMenu: this.createAggregationSubMenu()
                    },
                    autoSizeThis: {
                        name: localeTextFunc('autosizeThiscolumn', 'Autosize This Column'),
                        action: function action() {
                            return _this.columnController.autoSizeColumn(_this.column);
                        }
                    },
                    autoSizeAll: {
                        name: localeTextFunc('autosizeAllColumns', 'Autosize All Columns'),
                        action: function action() {
                            return _this.columnController.autoSizeAllColumns();
                        }
                    },
                    rowGroup: {
                        name: localeTextFunc('groupBy', 'Group by') + ' ' + this.column.getColDef().headerName,
                        action: function action() {
                            return _this.columnController.addRowGroupColumn(_this.column);
                        },
                        icon: svgFactory.createGroupIcon12()
                    },
                    rowUnGroup: {
                        name: localeTextFunc('ungroupBy', 'Un-Group by') + ' ' + this.column.getColDef().headerName,
                        action: function action() {
                            return _this.columnController.removeRowGroupColumn(_this.column);
                        },
                        icon: svgFactory.createGroupIcon12()
                    },
                    resetColumns: {
                        name: localeTextFunc('resetColumns', 'Reset Columns'),
                        action: function action() {
                            return _this.columnController.resetColumnState();
                        }
                    },
                    expandAll: {
                        name: localeTextFunc('expandAll', 'Expand All'),
                        action: function action() {
                            return _this.gridApi.expandAll();
                        }
                    },
                    contractAll: {
                        name: localeTextFunc('collapseAll', 'Collapse All'),
                        action: function action() {
                            return _this.gridApi.collapseAll();
                        }
                    },
                    toolPanel: {
                        name: localeTextFunc('toolPanel', 'Tool Panel'),
                        checked: this.gridApi.isToolPanelShowing(),
                        action: function action() {
                            return _this.gridApi.showToolPanel(!_this.gridApi.isToolPanelShowing());
                        }
                    }
                };
                return builtInMenuOptions;
            };
            EnterpriseMenu.prototype.getMenuItems = function () {
                var defaultMenuOptions = this.getDefaultMenuOptions();
                var result;
                var userFunc = this.gridOptionsWrapper.getMainMenuItemsFunc();
                if (userFunc) {
                    var userOptions = userFunc({
                        column: this.column,
                        api: this.gridOptionsWrapper.getApi(),
                        columnApi: this.gridOptionsWrapper.getColumnApi(),
                        context: this.gridOptionsWrapper.getContext(),
                        defaultItems: defaultMenuOptions
                    });
                    result = userOptions;
                } else {
                    result = defaultMenuOptions;
                }
                // GUI looks weird when two separators are side by side. this can happen accidentally
                // if we remove items from the menu then two separators can edit up adjacent.
                main_1.Utils.removeRepeatsFromArray(result, EnterpriseMenu.MENU_ITEM_SEPARATOR);
                return result;
            };
            EnterpriseMenu.prototype.getDefaultMenuOptions = function () {
                var result = [];
                var rowGroupCount = this.columnController.getRowGroupColumns().length;
                var doingGrouping = rowGroupCount > 0;
                var groupedByThisColumn = this.columnController.getRowGroupColumns().indexOf(this.column) >= 0;
                var allowValue = this.column.isAllowValue();
                var allowRowGroup = this.column.isAllowRowGroup();
                var isPrimary = this.column.isPrimary();
                var pivotModeOn = this.columnController.isPivotMode();
                result.push('pinSubMenu');
                var allowValueAgg =
                    // if primary, then only allow aggValue if grouping and it's a value columns
                    isPrimary && doingGrouping && allowValue || !isPrimary;
                if (allowValueAgg) {
                    result.push('valueAggSubMenu');
                }
                result.push(EnterpriseMenu.MENU_ITEM_SEPARATOR);
                result.push('autoSizeThis');
                result.push('autoSizeAll');
                result.push(EnterpriseMenu.MENU_ITEM_SEPARATOR);
                if (allowRowGroup && this.column.isPrimary()) {
                    if (groupedByThisColumn) {
                        result.push('rowUnGroup');
                    } else {
                        result.push('rowGroup');
                    }
                }
                result.push(EnterpriseMenu.MENU_ITEM_SEPARATOR);
                result.push('resetColumns');
                result.push('toolPanel');
                // only add grouping expand/collapse if grouping
                // if pivoting, we only have expandable groups if grouping by 2 or more columns
                // as the lowest level group is not expandable while pivoting.
                // if not pivoting, then any active row group can be expanded.
                var allowExpandAndContract = pivotModeOn ? rowGroupCount > 1 : rowGroupCount > 0;
                if (allowExpandAndContract) {
                    result.push('expandAll');
                    result.push('contractAll');
                }
                return result;
            };
            EnterpriseMenu.prototype.createMainPanel = function () {
                this.mainMenuList = new main_1.MenuList();
                this.context.wireBean(this.mainMenuList);
                var menuItems = this.getMenuItems();
                var builtInOptions = this.createBuiltInMenuOptions();
                this.mainMenuList.addMenuItems(menuItems, builtInOptions);
                this.mainMenuList.addEventListener(main_1.MenuItemComponent.EVENT_ITEM_SELECTED, this.onHidePopup.bind(this));
                this.tabItemGeneral = {
                    title: svgFactory.createMenuSvg(),
                    body: this.mainMenuList.getGui()
                };
            };
            EnterpriseMenu.prototype.onHidePopup = function () {
                this.hidePopupFunc();
            };
            EnterpriseMenu.prototype.createFilterPanel = function () {
                var filterWrapper = this.filterManager.getOrCreateFilterWrapper(this.column);
                var afterFilterAttachedCallback;
                if (filterWrapper.filter.afterGuiAttached) {
                    afterFilterAttachedCallback = filterWrapper.filter.afterGuiAttached.bind(filterWrapper.filter);
                }
                this.tabItemFilter = {
                    title: svgFactory.createFilterSvg12(),
                    body: filterWrapper.gui,
                    afterAttachedCallback: afterFilterAttachedCallback
                };
            };
            EnterpriseMenu.prototype.createColumnsPanel = function () {
                var eWrapperDiv = document.createElement('div');
                main_1.Utils.addCssClass(eWrapperDiv, 'ag-menu-column-select-wrapper');
                this.columnSelectPanel = new columnSelectPanel_1.ColumnSelectPanel(false);
                this.context.wireBean(this.columnSelectPanel);
                eWrapperDiv.appendChild(this.columnSelectPanel.getGui());
                this.tabItemColumns = {
                    title: svgFactory.createColumnsSvg12(),
                    body: eWrapperDiv
                };
            };
            EnterpriseMenu.prototype.afterGuiAttached = function (params) {
                this.tabbedLayout.setAfterAttachedParams({ hidePopup: params.hidePopup });
                this.showTabBasedOnPreviousSelection();
                this.hidePopupFunc = params.hidePopup;
            };
            EnterpriseMenu.prototype.getGui = function () {
                return this.tabbedLayout.getGui();
            };
            EnterpriseMenu.EVENT_TAB_SELECTED = 'tabSelected';
            EnterpriseMenu.TAB_FILTER = 'filter';
            EnterpriseMenu.TAB_GENERAL = 'general';
            EnterpriseMenu.TAB_COLUMNS = 'columns';
            EnterpriseMenu.MENU_ITEM_SEPARATOR = 'separator';
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], EnterpriseMenu.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('filterManager'), __metadata('design:type', main_1.FilterManager)], EnterpriseMenu.prototype, "filterManager", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], EnterpriseMenu.prototype, "context", void 0);
            __decorate([main_1.Autowired('gridApi'), __metadata('design:type', main_1.GridApi)], EnterpriseMenu.prototype, "gridApi", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], EnterpriseMenu.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('aggFuncService'), __metadata('design:type', aggFuncService_1.AggFuncService)], EnterpriseMenu.prototype, "aggFuncService", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], EnterpriseMenu.prototype, "init", null);
            return EnterpriseMenu;
        }();
        exports.EnterpriseMenu = EnterpriseMenu;

        /***/ },
    /* 357 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var renderedGroup_1 = __webpack_require__(358);
        var renderedColumn_1 = __webpack_require__(359);
        var ColumnSelectPanel = function (_super) {
            __extends(ColumnSelectPanel, _super);
            // we allow dragging in the toolPanel, but not when this component appears in the column menu
            function ColumnSelectPanel(allowDragging) {
                _super.call(this, ColumnSelectPanel.TEMPLATE);
                this.allowDragging = allowDragging;
            }
            ColumnSelectPanel.prototype.init = function () {
                this.addDestroyableEventListener(this.globalEventService, main_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onColumnsChanged.bind(this));
                if (this.columnController.isReady()) {
                    this.onColumnsChanged();
                }
            };
            ColumnSelectPanel.prototype.onColumnsChanged = function () {
                this.destroyAllRenderedElements();
                this.columnTree = this.columnController.getPrimaryColumnTree();
                this.recursivelyRenderComponents(this.columnTree, 0);
            };
            ColumnSelectPanel.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                this.destroyAllRenderedElements();
            };
            ColumnSelectPanel.prototype.destroyAllRenderedElements = function () {
                main_1.Utils.removeAllChildren(this.getGui());
                if (this.renderedItems) {
                    main_1.Utils.iterateObject(this.renderedItems, function (key, renderedItem) {
                        return renderedItem.destroy();
                    });
                }
                this.renderedItems = {};
            };
            ColumnSelectPanel.prototype.recursivelyRenderGroupComponent = function (columnGroup, dept) {
                // only render group if user provided the definition
                var newDept;
                if (columnGroup.getColGroupDef()) {
                    var renderedGroup = new renderedGroup_1.RenderedGroup(columnGroup, dept, this.onGroupExpanded.bind(this), this.allowDragging);
                    this.context.wireBean(renderedGroup);
                    this.appendChild(renderedGroup.getGui());
                    // we want to indent on the gui for the children
                    newDept = dept + 1;
                    this.renderedItems[columnGroup.getId()] = renderedGroup;
                } else {
                    // no children, so no indent
                    newDept = dept;
                }
                this.recursivelyRenderComponents(columnGroup.getChildren(), newDept);
            };
            ColumnSelectPanel.prototype.recursivelyRenderColumnComponent = function (column, dept) {
                var renderedColumn = new renderedColumn_1.RenderedColumn(column, dept, this.allowDragging);
                this.context.wireBean(renderedColumn);
                this.appendChild(renderedColumn.getGui());
                this.renderedItems[column.getId()] = renderedColumn;
            };
            ColumnSelectPanel.prototype.recursivelyRenderComponents = function (tree, dept) {
                var _this = this;
                tree.forEach(function (child) {
                    if (child instanceof main_1.OriginalColumnGroup) {
                        _this.recursivelyRenderGroupComponent(child, dept);
                    } else {
                        _this.recursivelyRenderColumnComponent(child, dept);
                    }
                });
            };
            ColumnSelectPanel.prototype.recursivelySetVisibility = function (columnTree, visible) {
                var _this = this;
                columnTree.forEach(function (child) {
                    var component = _this.renderedItems[child.getId()];
                    if (component) {
                        component.setVisible(visible);
                    }
                    if (child instanceof main_1.OriginalColumnGroup) {
                        var columnGroup = child;
                        var newVisible;
                        if (component) {
                            var expanded = component.isExpanded();
                            newVisible = visible ? expanded : false;
                        } else {
                            newVisible = visible;
                        }
                        var newChildren = columnGroup.getChildren();
                        _this.recursivelySetVisibility(newChildren, newVisible);
                    }
                });
            };
            ColumnSelectPanel.prototype.onGroupExpanded = function () {
                this.recursivelySetVisibility(this.columnTree, true);
            };
            ColumnSelectPanel.TEMPLATE = '<div class="ag-column-select-panel"></div>';
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], ColumnSelectPanel.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], ColumnSelectPanel.prototype, "globalEventService", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], ColumnSelectPanel.prototype, "context", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ColumnSelectPanel.prototype, "init", null);
            return ColumnSelectPanel;
        }(main_1.Component);
        exports.ColumnSelectPanel = ColumnSelectPanel;

        /***/ },
    /* 358 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var svgFactory = main_1.SvgFactory.getInstance();
        var RenderedGroup = function (_super) {
            __extends(RenderedGroup, _super);
            function RenderedGroup(columnGroup, columnDept, expandedCallback, allowDragging) {
                _super.call(this, RenderedGroup.TEMPLATE);
                this.expanded = true;
                this.processingColumnStateChange = false;
                this.columnGroup = columnGroup;
                this.columnDept = columnDept;
                this.expandedCallback = expandedCallback;
                this.allowDragging = allowDragging;
            }
            RenderedGroup.prototype.init = function () {
                var _this = this;
                this.instantiate(this.context);
                var eText = this.queryForHtmlElement('#eText');
                this.displayName = this.columnGroup.getColGroupDef() ? this.columnGroup.getColGroupDef().headerName : null;
                if (main_1.Utils.missing(this.displayName)) {
                    this.displayName = '>>';
                }
                eText.innerHTML = this.displayName;
                this.setupExpandContract();
                var eIndent = this.queryForHtmlElement('#eIndent');
                eIndent.style.width = this.columnDept * 10 + 'px';
                this.addDestroyableEventListener(eText, 'click', function () {
                    return _this.cbSelect.setSelected(!_this.cbSelect.isSelected());
                });
                this.addDestroyableEventListener(this.eventService, main_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this));
                this.addDestroyableEventListener(this.cbSelect, main_1.AgCheckbox.EVENT_CHANGED, this.onCheckboxChanged.bind(this));
                this.setOpenClosedIcons();
                if (this.allowDragging) {
                    this.addDragSource();
                }
                this.onColumnStateChanged();
                this.addVisibilityListenersToAllChildren();
            };
            RenderedGroup.prototype.addVisibilityListenersToAllChildren = function () {
                var _this = this;
                this.columnGroup.getLeafColumns().forEach(function (column) {
                    _this.addDestroyableEventListener(column, main_1.Column.EVENT_VISIBLE_CHANGED, _this.onColumnStateChanged.bind(_this));
                    _this.addDestroyableEventListener(column, main_1.Column.EVENT_VALUE_CHANGED, _this.onColumnStateChanged.bind(_this));
                    _this.addDestroyableEventListener(column, main_1.Column.EVENT_PIVOT_CHANGED, _this.onColumnStateChanged.bind(_this));
                    _this.addDestroyableEventListener(column, main_1.Column.EVENT_ROW_GROUP_CHANGED, _this.onColumnStateChanged.bind(_this));
                });
            };
            RenderedGroup.prototype.addDragSource = function () {
                var dragSource = {
                    type: main_1.DragSourceType.ToolPanel,
                    eElement: this.getGui(),
                    dragItemName: this.displayName,
                    dragItem: this.columnGroup.getLeafColumns()
                };
                this.dragAndDropService.addDragSource(dragSource);
            };
            RenderedGroup.prototype.setupExpandContract = function () {
                this.eGroupClosedIcon = this.queryForHtmlElement('#eGroupClosedIcon');
                this.eGroupOpenedIcon = this.queryForHtmlElement('#eGroupOpenedIcon');
                this.eGroupClosedIcon.appendChild(main_1.Utils.createIcon('columnSelectClosed', this.gridOptionsWrapper, null, svgFactory.createFolderClosed));
                this.eGroupOpenedIcon.appendChild(main_1.Utils.createIcon('columnSelectOpen', this.gridOptionsWrapper, null, svgFactory.createFolderOpen));
                this.addDestroyableEventListener(this.eGroupClosedIcon, 'click', this.onExpandOrContractClicked.bind(this));
                this.addDestroyableEventListener(this.eGroupOpenedIcon, 'click', this.onExpandOrContractClicked.bind(this));
            };
            RenderedGroup.prototype.onCheckboxChanged = function () {
                if (this.processingColumnStateChange) {
                    return;
                }
                var childColumns = this.columnGroup.getLeafColumns();
                var selected = this.cbSelect.isSelected();
                if (this.columnController.isPivotMode()) {
                    if (selected) {
                        this.actionCheckedReduce(childColumns);
                    } else {
                        this.actionUnCheckedReduce(childColumns);
                    }
                } else {
                    this.columnController.setColumnsVisible(childColumns, selected);
                }
            };
            RenderedGroup.prototype.actionUnCheckedReduce = function (columns) {
                var columnsToUnPivot = [];
                var columnsToUnValue = [];
                var columnsToUnGroup = [];
                columns.forEach(function (column) {
                    if (column.isPivotActive()) {
                        columnsToUnPivot.push(column);
                    }
                    if (column.isRowGroupActive()) {
                        columnsToUnGroup.push(column);
                    }
                    if (column.isValueActive()) {
                        columnsToUnValue.push(column);
                    }
                });
                if (columnsToUnPivot.length > 0) {
                    this.columnController.removePivotColumns(columnsToUnPivot);
                }
                if (columnsToUnGroup.length > 0) {
                    this.columnController.removeRowGroupColumns(columnsToUnGroup);
                }
                if (columnsToUnValue.length > 0) {
                    this.columnController.removeValueColumns(columnsToUnValue);
                }
            };
            RenderedGroup.prototype.actionCheckedReduce = function (columns) {
                var columnsToAggregate = [];
                var columnsToGroup = [];
                var columnsToPivot = [];
                columns.forEach(function (column) {
                    // don't change any column that's already got a function active
                    if (column.isAnyFunctionActive()) {
                        return;
                    }
                    if (column.isAllowValue()) {
                        columnsToAggregate.push(column);
                    } else if (column.isAllowRowGroup()) {
                        columnsToGroup.push(column);
                    } else if (column.isAllowRowGroup()) {
                        columnsToPivot.push(column);
                    }
                });
                if (columnsToAggregate.length > 0) {
                    this.columnController.addValueColumns(columnsToAggregate);
                }
                if (columnsToGroup.length > 0) {
                    this.columnController.addRowGroupColumns(columnsToGroup);
                }
                if (columnsToPivot.length > 0) {
                    this.columnController.addPivotColumns(columnsToPivot);
                }
            };
            RenderedGroup.prototype.onColumnStateChanged = function () {
                var _this = this;
                var columnsReduced = this.columnController.isPivotMode();
                var visibleChildCount = 0;
                var hiddenChildCount = 0;
                this.columnGroup.getLeafColumns().forEach(function (column) {
                    if (_this.isColumnVisible(column, columnsReduced)) {
                        visibleChildCount++;
                    } else {
                        hiddenChildCount++;
                    }
                });
                var selectedValue;
                if (visibleChildCount > 0 && hiddenChildCount > 0) {
                    selectedValue = null;
                } else if (visibleChildCount > 0) {
                    selectedValue = true;
                } else {
                    selectedValue = false;
                }
                this.processingColumnStateChange = true;
                this.cbSelect.setSelected(selectedValue);
                this.processingColumnStateChange = false;
            };
            RenderedGroup.prototype.isColumnVisible = function (column, columnsReduced) {
                if (columnsReduced) {
                    var pivoted = column.isPivotActive();
                    var grouped = column.isRowGroupActive();
                    var aggregated = column.isValueActive();
                    return pivoted || grouped || aggregated;
                } else {
                    return column.isVisible();
                }
            };
            RenderedGroup.prototype.onExpandOrContractClicked = function () {
                this.expanded = !this.expanded;
                this.setOpenClosedIcons();
                this.expandedCallback();
            };
            RenderedGroup.prototype.setOpenClosedIcons = function () {
                var folderOpen = this.expanded;
                main_1.Utils.setVisible(this.eGroupClosedIcon, !folderOpen);
                main_1.Utils.setVisible(this.eGroupOpenedIcon, folderOpen);
            };
            RenderedGroup.prototype.isExpanded = function () {
                return this.expanded;
            };
            RenderedGroup.TEMPLATE = '<div class="ag-column-select-column-group">' + '  <span id="eIndent" class="ag-column-select-indent"></span>' + '  <span class="ag-column-group-icons">' + '    <span id="eGroupOpenedIcon" class="ag-column-group-closed-icon"></span>' + '    <span id="eGroupClosedIcon" class="ag-column-group-opened-icon"></span>' + '  </span>' + '  <ag-checkbox class="ag-column-select-checkbox"></ag-checkbox>' + '  <span id="eText" class="ag-column-select-column-group-label"></span>' + '</div>';
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], RenderedGroup.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], RenderedGroup.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('gridPanel'), __metadata('design:type', main_1.GridPanel)], RenderedGroup.prototype, "gridPanel", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], RenderedGroup.prototype, "context", void 0);
            __decorate([main_1.Autowired('dragAndDropService'), __metadata('design:type', main_1.DragAndDropService)], RenderedGroup.prototype, "dragAndDropService", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], RenderedGroup.prototype, "eventService", void 0);
            __decorate([main_1.QuerySelector('.ag-column-select-checkbox'), __metadata('design:type', main_1.AgCheckbox)], RenderedGroup.prototype, "cbSelect", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RenderedGroup.prototype, "init", null);
            return RenderedGroup;
        }(main_1.Component);
        exports.RenderedGroup = RenderedGroup;

        /***/ },
    /* 359 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var svgFactory = main_1.SvgFactory.getInstance();
        var RenderedColumn = function (_super) {
            __extends(RenderedColumn, _super);
            function RenderedColumn(column, columnDept, allowDragging) {
                _super.call(this, RenderedColumn.TEMPLATE);
                this.processingColumnStateChange = false;
                this.column = column;
                this.columnDept = columnDept;
                this.allowDragging = allowDragging;
            }
            RenderedColumn.prototype.init = function () {
                this.displayName = this.columnController.getDisplayNameForCol(this.column);
                this.eText.innerHTML = this.displayName;
                this.eIndent.style.width = this.columnDept * 10 + 'px';
                if (this.allowDragging) {
                    this.addDragSource();
                }
                this.addDestroyableEventListener(this.eventService, main_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this));
                this.addDestroyableEventListener(this.column, main_1.Column.EVENT_VALUE_CHANGED, this.onColumnStateChanged.bind(this));
                this.addDestroyableEventListener(this.column, main_1.Column.EVENT_PIVOT_CHANGED, this.onColumnStateChanged.bind(this));
                this.addDestroyableEventListener(this.column, main_1.Column.EVENT_ROW_GROUP_CHANGED, this.onColumnStateChanged.bind(this));
                this.addDestroyableEventListener(this.column, main_1.Column.EVENT_VISIBLE_CHANGED, this.onColumnStateChanged.bind(this));
                this.addDestroyableEventListener(this.gridOptionsWrapper, 'functionsReadOnly', this.onColumnStateChanged.bind(this));
                this.instantiate(this.context);
                this.onColumnStateChanged();
                this.addDestroyableEventListener(this.cbSelect, main_1.AgCheckbox.EVENT_CHANGED, this.onChange.bind(this));
                this.addDestroyableEventListener(this.eText, 'click', this.onClick.bind(this));
            };
            RenderedColumn.prototype.onClick = function () {
                if (this.cbSelect.isReadOnly()) {
                    return;
                }
                this.cbSelect.toggle();
            };
            RenderedColumn.prototype.onChange = function (event) {
                // only want to action if the user clicked the checkbox, not is we are setting the checkbox because
                // of a change in the model
                if (this.processingColumnStateChange) {
                    return;
                }
                // action in a timeout, as the action takes some time, we want to update the icons first
                // so the user gets nice feedback when they click. otherwise there would be a lag and the
                // user would think the checkboxes were clunky
                if (this.columnController.isPivotMode()) {
                    if (event.selected) {
                        this.actionCheckedPivotMode();
                    } else {
                        this.actionUnCheckedPivotMode();
                    }
                } else {
                    this.columnController.setColumnVisible(this.column, event.selected);
                }
            };
            RenderedColumn.prototype.actionUnCheckedPivotMode = function () {
                var functionPassive = this.gridOptionsWrapper.isFunctionsPassive();
                var column = this.column;
                var columnController = this.columnController;
                // remove pivot if column is pivoted
                if (column.isPivotActive()) {
                    if (functionPassive) {
                        this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_PIVOT_REMOVE_REQUEST, { columns: [column] });
                    } else {
                        columnController.removePivotColumn(column);
                    }
                }
                // remove value if column is value
                if (column.isValueActive()) {
                    if (functionPassive) {
                        this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_VALUE_REMOVE_REQUEST, { columns: [column] });
                    } else {
                        columnController.removeValueColumn(column);
                    }
                }
                // remove group if column is grouped
                if (column.isRowGroupActive()) {
                    if (functionPassive) {
                        this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_ROW_GROUP_REMOVE_REQUEST, { columns: [column] });
                    } else {
                        columnController.removeRowGroupColumn(column);
                    }
                }
            };
            RenderedColumn.prototype.actionCheckedPivotMode = function () {
                var column = this.column;
                var columnController = this.columnController;
                // function already active, so do nothing
                if (column.isValueActive() || column.isPivotActive() || column.isRowGroupActive()) {
                    return;
                }
                var functionPassive = this.gridOptionsWrapper.isFunctionsPassive();
                if (column.isAllowValue()) {
                    if (functionPassive) {
                        this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_VALUE_ADD_REQUEST, { columns: [column] });
                    } else {
                        columnController.addValueColumn(column);
                    }
                } else if (column.isAllowRowGroup()) {
                    if (functionPassive) {
                        this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_ROW_GROUP_ADD_REQUEST, { columns: [column] });
                    } else {
                        columnController.addRowGroupColumn(column);
                    }
                } else if (column.isAllowPivot()) {
                    if (functionPassive) {
                        this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_PIVOT_ADD_REQUEST, { columns: [column] });
                    } else {
                        columnController.addPivotColumn(column);
                    }
                }
            };
            RenderedColumn.prototype.addDragSource = function () {
                var dragSource = {
                    type: main_1.DragSourceType.ToolPanel,
                    eElement: this.getGui(),
                    dragItemName: this.displayName,
                    dragItem: [this.column]
                };
                this.dragAndDropService.addDragSource(dragSource);
            };
            RenderedColumn.prototype.onColumnStateChanged = function () {
                this.processingColumnStateChange = true;
                var isPivotMode = this.columnController.isPivotMode();
                if (isPivotMode) {
                    // if reducing, checkbox means column is one of pivot, value or group
                    var anyFunctionActive = this.column.isAnyFunctionActive();
                    this.cbSelect.setSelected(anyFunctionActive);
                } else {
                    // if not reducing, the checkbox tells us if column is visible or not
                    this.cbSelect.setSelected(this.column.isVisible());
                }
                // read only in pivot mode if:
                var checkboxReadOnly = isPivotMode && (this.gridOptionsWrapper.isFunctionsReadOnly() || !this.column.isAnyFunctionAllowed());
                this.cbSelect.setReadOnly(checkboxReadOnly);
                var checkboxPassive = isPivotMode && this.gridOptionsWrapper.isFunctionsPassive();
                this.cbSelect.setPassive(checkboxPassive);
                this.processingColumnStateChange = false;
            };
            RenderedColumn.TEMPLATE = '<div class="ag-column-select-column">' + '  <span class="ag-column-select-indent"></span>' + '  <ag-checkbox class="ag-column-select-checkbox"></ag-checkbox>' + '  <span class="ag-column-select-label"></span>' + '</div>';
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], RenderedColumn.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], RenderedColumn.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], RenderedColumn.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('dragAndDropService'), __metadata('design:type', main_1.DragAndDropService)], RenderedColumn.prototype, "dragAndDropService", void 0);
            __decorate([main_1.Autowired('gridPanel'), __metadata('design:type', main_1.GridPanel)], RenderedColumn.prototype, "gridPanel", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], RenderedColumn.prototype, "context", void 0);
            __decorate([main_1.QuerySelector('.ag-column-select-label'), __metadata('design:type', HTMLElement)], RenderedColumn.prototype, "eText", void 0);
            __decorate([main_1.QuerySelector('.ag-column-select-indent'), __metadata('design:type', HTMLElement)], RenderedColumn.prototype, "eIndent", void 0);
            __decorate([main_1.QuerySelector('.ag-column-select-checkbox'), __metadata('design:type', main_1.AgCheckbox)], RenderedColumn.prototype, "cbSelect", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RenderedColumn.prototype, "init", null);
            return RenderedColumn;
        }(main_1.Component);
        exports.RenderedColumn = RenderedColumn;

        /***/ },
    /* 360 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var AggFuncService = function () {
            function AggFuncService() {
                this.aggFuncsMap = {};
                this.initialised = false;
            }
            AggFuncService.prototype.init = function () {
                if (this.initialised) {
                    return;
                }
                this.initialised = true;
                this.initialiseWithDefaultAggregations();
                this.addAggFuncs(this.gridOptionsWrapper.getAggFuncs());
            };
            AggFuncService.prototype.initialiseWithDefaultAggregations = function () {
                this.aggFuncsMap[AggFuncService.AGG_SUM] = aggSum;
                this.aggFuncsMap[AggFuncService.AGG_FIRST] = aggFirst;
                this.aggFuncsMap[AggFuncService.AGG_LAST] = aggLast;
                this.aggFuncsMap[AggFuncService.AGG_MIN] = aggMin;
                this.aggFuncsMap[AggFuncService.AGG_MAX] = aggMax;
                this.aggFuncsMap[AggFuncService.AGG_COUNT] = aggCount;
                this.aggFuncsMap[AggFuncService.AGG_AVG] = aggAvg;
            };
            AggFuncService.prototype.getDefaultAggFunc = function () {
                if (this.aggFuncsMap[AggFuncService.AGG_SUM]) {
                    // use 'sum' if it's still there (ie user has not removed it)
                    return AggFuncService.AGG_SUM;
                } else {
                    var allKeys = this.getFuncNames();
                    if (main_1.Utils.existsAndNotEmpty(allKeys)) {
                        return allKeys[0];
                    } else {
                        return null;
                    }
                }
            };
            AggFuncService.prototype.addAggFuncs = function (aggFuncs) {
                main_1.Utils.iterateObject(aggFuncs, this.addAggFunc.bind(this));
            };
            AggFuncService.prototype.addAggFunc = function (key, aggFunc) {
                this.init();
                this.aggFuncsMap[key] = aggFunc;
            };
            AggFuncService.prototype.getAggFunc = function (name) {
                this.init();
                return this.aggFuncsMap[name];
            };
            AggFuncService.prototype.getFuncNames = function () {
                return Object.keys(this.aggFuncsMap).sort();
            };
            AggFuncService.prototype.clear = function () {
                this.aggFuncsMap = {};
            };
            AggFuncService.AGG_SUM = 'sum';
            AggFuncService.AGG_FIRST = 'first';
            AggFuncService.AGG_LAST = 'last';
            AggFuncService.AGG_MIN = 'min';
            AggFuncService.AGG_MAX = 'max';
            AggFuncService.AGG_COUNT = 'count';
            AggFuncService.AGG_AVG = 'avg';
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], AggFuncService.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], AggFuncService.prototype, "init", null);
            AggFuncService = __decorate([main_1.Bean('aggFuncService'), __metadata('design:paramtypes', [])], AggFuncService);
            return AggFuncService;
        }();
        exports.AggFuncService = AggFuncService;
        function aggSum(input) {
            var result = null;
            var length = input.length;
            for (var i = 0; i < length; i++) {
                if (typeof input[i] === 'number') {
                    if (result === null) {
                        result = input[i];
                    } else {
                        result += input[i];
                    }
                }
            }
            return result;
        }
        function aggFirst(input) {
            if (input.length >= 0) {
                return input[0];
            } else {
                return null;
            }
        }
        function aggLast(input) {
            if (input.length >= 0) {
                return input[input.length - 1];
            } else {
                return null;
            }
        }
        function aggMin(input) {
            var result = null;
            var length = input.length;
            for (var i = 0; i < length; i++) {
                if (typeof input[i] === 'number') {
                    if (result === null) {
                        result = input[i];
                    } else if (result > input[i]) {
                        result = input[i];
                    }
                }
            }
            return result;
        }
        function aggMax(input) {
            var result = null;
            var length = input.length;
            for (var i = 0; i < length; i++) {
                if (typeof input[i] === 'number') {
                    if (result === null) {
                        result = input[i];
                    } else if (result < input[i]) {
                        result = input[i];
                    }
                }
            }
            return result;
        }
        function aggCount(input) {
            var result = {
                value: 0,
                toString: function toString() {
                    return this.value;
                }
            };
            var length = input.length;
            for (var i = 0; i < length; i++) {
                var isGroupAgg = main_1.Utils.exists(input[i]) && typeof input[i].value === 'number';
                if (isGroupAgg) {
                    result += input[i].value;
                } else {
                    result.value++;
                }
            }
            return result;
        }
        // the average function is tricky as the multiple levels require weighted averages
        // for the non-leaf node aggregations.
        function aggAvg(input) {
            // the average will be the sum / count
            var sum = 0;
            var count = 0;
            var length = input.length;
            for (var i = 0; i < length; i++) {
                var currentItem = input[i];
                // skip values that are not numbers (ie skip empty values)
                if (typeof currentItem === 'number') {
                    sum += currentItem;
                    count++;
                } else if (typeof currentItem.value === 'number' && typeof currentItem.count === 'number') {
                    // we are aggregating groups, so we take the
                    // aggregated values to calculated a weighted average
                    sum += currentItem.value * currentItem.count;
                    count += currentItem.count;
                }
            }
            // avoid divide by zero error
            var value = null;
            if (count !== 0) {
                value = sum / count;
            }
            // the result will be an object. when this cell is rendered, only the avg is shown.
            // however when this cell is part of another aggregation, the count is also needed
            // to create a weighted average for the next level.
            var result = {
                count: count,
                value: value,
                // the grid by default uses toString to render values for an object, so this
                // is a trick to get the default cellRenderer to display the avg value
                toString: function toString() {
                    return this.value;
                }
            };
            return result;
        }

        /***/ },
    /* 361 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var RangeController = function () {
            function RangeController() {
                this.bodyScrollListener = this.onBodyScroll.bind(this);
                this.dragging = false;
            }
            RangeController.prototype.init = function () {
                this.logger = this.loggerFactory.create('RangeController');
                this.eventService.addEventListener(main_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.clearSelection.bind(this));
                this.eventService.addEventListener(main_1.Events.EVENT_COLUMN_GROUP_OPENED, this.clearSelection.bind(this));
                this.eventService.addEventListener(main_1.Events.EVENT_COLUMN_MOVED, this.clearSelection.bind(this));
                this.eventService.addEventListener(main_1.Events.EVENT_COLUMN_PINNED, this.clearSelection.bind(this));
                this.eventService.addEventListener(main_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearSelection.bind(this));
                this.eventService.addEventListener(main_1.Events.EVENT_COLUMN_VISIBLE, this.clearSelection.bind(this));
                this.eventService.addEventListener(main_1.Events.EVENT_SORT_CHANGED, this.clearSelection.bind(this));
            };
            RangeController.prototype.setRangeToCell = function (cell) {
                if (!this.gridOptionsWrapper.isEnableRangeSelection()) {
                    return;
                }
                var columns = this.updateSelectedColumns(cell.column, cell.column);
                if (!columns) {
                    return;
                }
                var newRange = {
                    start: new main_1.GridCell(cell.rowIndex, cell.floating, cell.column),
                    end: new main_1.GridCell(cell.rowIndex, cell.floating, cell.column),
                    columns: columns
                };
                this.cellRanges = [];
                this.cellRanges.push(newRange);
                this.activeRange = null;
                this.dispatchChangedEvent(true, false);
            };
            RangeController.prototype.setRange = function (rangeSelection) {
                if (!this.gridOptionsWrapper.isEnableRangeSelection()) {
                    return;
                }
                this.cellRanges = [];
                this.addRange(rangeSelection);
            };
            RangeController.prototype.addRange = function (rangeSelection) {
                if (!this.gridOptionsWrapper.isEnableRangeSelection()) {
                    return;
                }
                var columnStart = this.columnController.getColumnWithValidation(rangeSelection.columnStart);
                var columnEnd = this.columnController.getPrimaryColumn(rangeSelection.columnEnd);
                if (!columnStart || !columnEnd) {
                    return;
                }
                var columns = this.updateSelectedColumns(columnStart, columnEnd);
                if (!columns) {
                    return;
                }
                var newRange = {
                    start: new main_1.GridCell(rangeSelection.rowStart, rangeSelection.floatingStart, columnStart),
                    end: new main_1.GridCell(rangeSelection.rowEnd, rangeSelection.floatingEnd, columnEnd),
                    columns: columns
                };
                if (!this.cellRanges) {
                    this.cellRanges = [];
                }
                this.cellRanges.push(newRange);
                this.dispatchChangedEvent(true, false);
            };
            RangeController.prototype.getCellRanges = function () {
                return this.cellRanges;
            };
            RangeController.prototype.isEmpty = function () {
                return main_1.Utils.missingOrEmpty(this.cellRanges);
            };
            RangeController.prototype.isMoreThanOneCell = function () {
                if (main_1.Utils.missingOrEmpty(this.cellRanges)) {
                    return false;
                } else {
                    if (this.cellRanges.length > 1) {
                        return true;
                    } else {
                        var onlyRange = this.cellRanges[0];
                        var onlyOneCellInRange = onlyRange.start.column === onlyRange.end.column && onlyRange.start.rowIndex === onlyRange.end.rowIndex;
                        return !onlyOneCellInRange;
                    }
                }
            };
            RangeController.prototype.clearSelection = function () {
                if (main_1.Utils.missing(this.cellRanges)) {
                    return;
                }
                this.activeRange = null;
                this.cellRanges = null;
                this.dispatchChangedEvent(true, false);
            };
            // as the user is dragging outside of the panel, the div starts to scroll, which in turn
            // means we are selection more (or less) cells, but the mouse isn't moving, so we recalculate
            // the selection my mimicking a new mouse event
            RangeController.prototype.onBodyScroll = function () {
                this.onDragging(this.lastMouseEvent);
            };
            RangeController.prototype.isCellInAnyRange = function (cell) {
                return this.getCellRangeCount(cell) > 0;
            };
            RangeController.prototype.isCellInSpecificRange = function (cell, range) {
                var columnInRange = range.columns.indexOf(cell.column) >= 0;
                var rowInRange = this.isRowInRange(cell.rowIndex, cell.floating, range);
                return columnInRange && rowInRange;
            };
            // returns the number of ranges this cell is in
            RangeController.prototype.getCellRangeCount = function (cell) {
                var _this = this;
                if (main_1.Utils.missingOrEmpty(this.cellRanges)) {
                    return 0;
                }
                var matchingCount = 0;
                this.cellRanges.forEach(function (cellRange) {
                    if (_this.isCellInSpecificRange(cell, cellRange)) {
                        matchingCount++;
                    }
                });
                return matchingCount;
            };
            RangeController.prototype.isRowInRange = function (rowIndex, floating, cellRange) {
                var row1 = new main_1.GridRow(cellRange.start.rowIndex, cellRange.start.floating);
                var row2 = new main_1.GridRow(cellRange.end.rowIndex, cellRange.end.floating);
                var firstRow = row1.before(row2) ? row1 : row2;
                var lastRow = row1.before(row2) ? row2 : row1;
                var thisRow = new main_1.GridRow(rowIndex, floating);
                if (thisRow.equals(firstRow) || thisRow.equals(lastRow)) {
                    return true;
                } else {
                    var afterFirstRow = !thisRow.before(firstRow);
                    var beforeLastRow = thisRow.before(lastRow);
                    return afterFirstRow && beforeLastRow;
                }
            };
            RangeController.prototype.onDragStart = function (mouseEvent) {
                if (!this.gridOptionsWrapper.isEnableRangeSelection()) {
                    return;
                }
                // ctrlKey for windows, metaKey for Apple
                var multiSelectKeyPressed = mouseEvent.ctrlKey || mouseEvent.metaKey;
                if (main_1.Utils.missing(this.cellRanges) || !multiSelectKeyPressed) {
                    this.cellRanges = [];
                }
                var cell = this.mouseEventService.getCellForMouseEvent(mouseEvent);
                if (main_1.Utils.missing(cell)) {
                    // if drag wasn't on cell, then do nothing, including do not set dragging=true,
                    // (which them means onDragging and onDragStop do nothing)
                    return;
                }
                this.createNewActiveRange(cell);
                this.gridPanel.addScrollEventListener(this.bodyScrollListener);
                this.dragging = true;
                this.lastMouseEvent = mouseEvent;
                this.selectionChanged(false, true);
            };
            RangeController.prototype.createNewActiveRange = function (cell) {
                this.activeRange = {
                    start: new main_1.GridCell(cell.rowIndex, cell.floating, cell.column),
                    end: new main_1.GridCell(cell.rowIndex, cell.floating, cell.column),
                    columns: [cell.column]
                };
                this.cellRanges.push(this.activeRange);
            };
            RangeController.prototype.selectionChanged = function (finished, started) {
                this.activeRange.columns = this.updateSelectedColumns(this.activeRange.start.column, this.activeRange.end.column);
                this.dispatchChangedEvent(finished, started);
            };
            RangeController.prototype.dispatchChangedEvent = function (finished, started) {
                this.eventService.dispatchEvent(main_1.Events.EVENT_RANGE_SELECTION_CHANGED, { finished: finished, started: started });
            };
            RangeController.prototype.onDragStop = function () {
                if (!this.dragging) {
                    return;
                }
                this.gridPanel.removeScrollEventListener(this.bodyScrollListener);
                this.lastMouseEvent = null;
                this.dragging = false;
                this.dispatchChangedEvent(true, false);
            };
            RangeController.prototype.onDragging = function (mouseEvent) {
                if (!this.dragging) {
                    return;
                }
                this.lastMouseEvent = mouseEvent;
                var cell = this.mouseEventService.getCellForMouseEvent(mouseEvent);
                if (main_1.Utils.missing(cell)) {
                    return;
                }
                var columnChanged = false;
                if (cell.column !== this.activeRange.end.column) {
                    this.activeRange.end.column = cell.column;
                    columnChanged = true;
                }
                var rowChanged = false;
                if (cell.rowIndex !== this.activeRange.end.rowIndex || cell.floating !== this.activeRange.end.floating) {
                    this.activeRange.end.rowIndex = cell.rowIndex;
                    this.activeRange.end.floating = cell.floating;
                    rowChanged = true;
                }
                if (columnChanged || rowChanged) {
                    this.selectionChanged(false, false);
                }
            };
            RangeController.prototype.updateSelectedColumns = function (columnFrom, columnTo) {
                var allDisplayedColumns = this.columnController.getAllDisplayedColumns();
                var fromIndex = allDisplayedColumns.indexOf(columnFrom);
                var toIndex = allDisplayedColumns.indexOf(columnTo);
                if (fromIndex < 0) {
                    console.log('ag-Grid: column ' + columnFrom.getId() + ' is not visible');
                    return null;
                }
                if (toIndex < 0) {
                    console.log('ag-Grid: column ' + columnTo.getId() + ' is not visible');
                    return null;
                }
                var firstIndex = Math.min(fromIndex, toIndex);
                var lastIndex = Math.max(fromIndex, toIndex);
                var columns = [];
                for (var i = firstIndex; i <= lastIndex; i++) {
                    columns.push(allDisplayedColumns[i]);
                }
                return columns;
            };
            __decorate([main_1.Autowired('loggerFactory'), __metadata('design:type', main_1.LoggerFactory)], RangeController.prototype, "loggerFactory", void 0);
            __decorate([main_1.Autowired('gridPanel'), __metadata('design:type', main_1.GridPanel)], RangeController.prototype, "gridPanel", void 0);
            __decorate([main_1.Autowired('rowModel'), __metadata('design:type', Object)], RangeController.prototype, "rowModel", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], RangeController.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], RangeController.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('rowRenderer'), __metadata('design:type', main_1.RowRenderer)], RangeController.prototype, "rowRenderer", void 0);
            __decorate([main_1.Autowired('focusedCellController'), __metadata('design:type', main_1.FocusedCellController)], RangeController.prototype, "focusedCellController", void 0);
            __decorate([main_1.Autowired('mouseEventService'), __metadata('design:type', main_1.MouseEventService)], RangeController.prototype, "mouseEventService", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], RangeController.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RangeController.prototype, "init", null);
            RangeController = __decorate([main_1.Bean('rangeController'), __metadata('design:paramtypes', [])], RangeController);
            return RangeController;
        }();
        exports.RangeController = RangeController;

        /***/ },
    /* 362 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var rangeController_1 = __webpack_require__(361);
        var ClipboardService = function () {
            function ClipboardService() {}
            ClipboardService.prototype.init = function () {
                this.logger = this.loggerFactory.create('ClipboardService');
            };
            ClipboardService.prototype.pasteFromClipboard = function () {
                var _this = this;
                this.logger.log('pasteFromClipboard');
                this.executeOnTempElement(function (textArea) {
                    textArea.focus();
                }, function (element) {
                    var text = element.value;
                    _this.finishPasteFromClipboard(text);
                });
            };
            ClipboardService.prototype.copyRangeDown = function () {
                var _this = this;
                if (this.rangeController.isEmpty()) {
                    return;
                }
                var cellsToFlash = {};
                var firstRowValues = null;
                var updatedRowNodes = [];
                var updatedColumnIds = [];
                this.iterateFirstActiveRange(function (currentRow, rowNode, columns) {
                    // take reference of first row, this is the one we will be using to copy from
                    if (!firstRowValues) {
                        firstRowValues = [];
                        // two reasons for looping through columns
                        columns.forEach(function (column) {
                            // reason 1 - to get the initial values to copy down
                            var value = _this.valueService.getValue(column, rowNode);
                            firstRowValues.push(value);
                            // reason 2 - to record the columnId for refreshing
                            updatedColumnIds.push(column.getId());
                        });
                    } else {
                        // otherwise we are not the first row, so copy
                        updatedRowNodes.push(rowNode);
                        columns.forEach(function (column, index) {
                            if (!column.isCellEditable(rowNode)) {
                                return;
                            }
                            var firstRowValue = firstRowValues[index];
                            _this.valueService.setValue(rowNode, column, firstRowValue);
                            var cellId = new main_1.GridCell(currentRow.rowIndex, currentRow.floating, column).createId();
                            cellsToFlash[cellId] = true;
                        });
                    }
                });
                // this is very heavy, should possibly just refresh the specific cells?
                this.rowRenderer.refreshView();
                this.rowRenderer.refreshCells(updatedRowNodes, updatedColumnIds);
                this.eventService.dispatchEvent(main_1.Events.EVENT_FLASH_CELLS, { cells: cellsToFlash });
            };
            ClipboardService.prototype.finishPasteFromClipboard = function (data) {
                var _this = this;
                if (main_1.Utils.missingOrEmpty(data)) {
                    return;
                }
                var focusedCell = this.focusedCellController.getFocusedCell();
                if (!focusedCell) {
                    return;
                }
                var parsedData = this.dataToArray(data);
                if (!parsedData) {
                    return;
                }
                // remove last row if empty, excel puts empty last row in
                var lastLine = parsedData[parsedData.length - 1];
                if (lastLine.length === 1 && lastLine[0] === '') {
                    main_1.Utils.removeFromArray(parsedData, lastLine);
                }
                var currentRow = new main_1.GridRow(focusedCell.rowIndex, focusedCell.floating);
                var cellsToFlash = {};
                var updatedRowNodes = [];
                var updatedColumnIds = [];
                parsedData.forEach(function (values, index) {
                    // if we have come to end of rows in grid, then skip
                    if (!currentRow) {
                        return;
                    }
                    var rowNode = _this.getRowNode(currentRow);
                    updatedRowNodes.push(rowNode);
                    var column = focusedCell.column;
                    values.forEach(function (value) {
                        if (main_1.Utils.missing(column)) {
                            return;
                        }
                        if (!column.isCellEditable(rowNode)) {
                            return;
                        }
                        _this.valueService.setValue(rowNode, column, value);
                        var cellId = new main_1.GridCell(currentRow.rowIndex, currentRow.floating, column).createId();
                        cellsToFlash[cellId] = true;
                        if (index === 0) {
                            updatedColumnIds.push(column.getId());
                        }
                        column = _this.columnController.getDisplayedColAfter(column);
                    });
                    // move to next row down for next set of values
                    currentRow = _this.cellNavigationService.getRowBelow(currentRow);
                });
                // this is very heavy, should possibly just refresh the specific cells?
                this.rowRenderer.refreshCells(updatedRowNodes, updatedColumnIds);
                this.eventService.dispatchEvent(main_1.Events.EVENT_FLASH_CELLS, { cells: cellsToFlash });
                this.focusedCellController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.floating, true);
            };
            ClipboardService.prototype.copyToClipboard = function (includeHeaders) {
                if (includeHeaders === void 0) {
                    includeHeaders = false;
                }
                this.logger.log("copyToClipboard: includeHeaders = " + includeHeaders);
                var selectedRowsToCopy = !this.selectionController.isEmpty() && !this.gridOptionsWrapper.isSuppressCopyRowsToClipboard();
                // default is copy range if exists, otherwise rows
                if (this.rangeController.isMoreThanOneCell()) {
                    this.copySelectedRangeToClipboard(includeHeaders);
                } else if (selectedRowsToCopy) {
                    this.copySelectedRowsToClipboard(includeHeaders);
                } else if (!this.rangeController.isEmpty()) {
                    this.copySelectedRangeToClipboard(includeHeaders);
                }
            };
            ClipboardService.prototype.iterateFirstActiveRange = function (rowCallback, columnCallback) {
                if (this.rangeController.isEmpty()) {
                    return;
                }
                var rangeSelections = this.rangeController.getCellRanges();
                // if more than one range selected, we take the first one only, we ignore the others,
                // in Excel, it doesn't allow multiple blocks to be copied to clipboard at same time
                var range = rangeSelections[0];
                // get starting and ending row, remember rowEnd could be before rowStart
                var startRow = range.start.getGridRow();
                var endRow = range.end.getGridRow();
                var startRowIsFirst = startRow.before(endRow);
                var currentRow = startRowIsFirst ? startRow : endRow;
                var lastRow = startRowIsFirst ? endRow : startRow;
                if (main_1.Utils.exists(columnCallback)) {
                    columnCallback(range.columns);
                }
                while (true) {
                    var rowNode = this.getRowNode(currentRow);
                    rowCallback(currentRow, rowNode, range.columns);
                    if (currentRow.equals(lastRow)) {
                        break;
                    }
                    currentRow = this.cellNavigationService.getRowBelow(currentRow);
                }
            };
            ClipboardService.prototype.copySelectedRangeToClipboard = function (includeHeaders) {
                var _this = this;
                if (includeHeaders === void 0) {
                    includeHeaders = false;
                }
                if (this.rangeController.isEmpty()) {
                    return;
                }
                var data = '';
                var cellsToFlash = {};
                // adds columns to the data
                var columnCallback = function columnCallback(columns) {
                    if (!includeHeaders) {
                        return;
                    }
                    columns.forEach(function (column, index) {
                        var value = _this.columnController.getDisplayNameForCol(column, true);
                        if (index != 0) {
                            data += '\t';
                        }
                        if (main_1.Utils.exists(value)) {
                            data += value;
                        }
                    });
                    data += '\r\n';
                };
                // adds cell values to the data
                var rowCallback = function rowCallback(currentRow, rowNode, columns) {
                    columns.forEach(function (column, index) {
                        var value = _this.valueService.getValue(column, rowNode);
                        value = _this.processRangeCell(rowNode, column, value);
                        if (index != 0) {
                            data += '\t';
                        }
                        if (main_1.Utils.exists(value)) {
                            data += value;
                        }
                        var cellId = new main_1.GridCell(currentRow.rowIndex, currentRow.floating, column).createId();
                        cellsToFlash[cellId] = true;
                    });
                    data += '\r\n';
                };
                this.iterateFirstActiveRange(rowCallback, columnCallback);
                this.copyDataToClipboard(data);
                this.eventService.dispatchEvent(main_1.Events.EVENT_FLASH_CELLS, { cells: cellsToFlash });
            };
            ClipboardService.prototype.processRangeCell = function (rowNode, column, value) {
                var func = this.gridOptionsWrapper.getProcessCellForClipboardFunc();
                if (func) {
                    return func({
                        column: column,
                        node: rowNode,
                        value: value,
                        api: this.gridOptionsWrapper.getApi(),
                        columnApi: this.gridOptionsWrapper.getColumnApi(),
                        context: this.gridOptionsWrapper.getContext()
                    });
                } else {
                    return value;
                }
            };
            ClipboardService.prototype.getRowNode = function (gridRow) {
                switch (gridRow.floating) {
                    case main_1.Constants.FLOATING_TOP:
                        return this.floatingRowModel.getFloatingTopRowData()[gridRow.rowIndex];
                    case main_1.Constants.FLOATING_BOTTOM:
                        return this.floatingRowModel.getFloatingBottomRowData()[gridRow.rowIndex];
                    default:
                        return this.rowModel.getRow(gridRow.rowIndex);
                }
            };
            ClipboardService.prototype.copySelectedRowsToClipboard = function (includeHeaders, columnKeys) {
                if (includeHeaders === void 0) {
                    includeHeaders = false;
                }
                var skipHeader = !includeHeaders;
                var params = {
                    columnKeys: columnKeys,
                    skipHeader: skipHeader,
                    skipFooters: true,
                    columnSeparator: '\t',
                    onlySelected: true,
                    processCellCallback: this.gridOptionsWrapper.getProcessCellForClipboardFunc()
                };
                var data = this.csvCreator.getDataAsCsv(params);
                this.copyDataToClipboard(data);
            };
            ClipboardService.prototype.copyDataToClipboard = function (data) {
                this.executeOnTempElement(function (element) {
                    element.value = data;
                    element.select();
                    element.focus();
                    return document.execCommand('copy');
                });
            };
            ClipboardService.prototype.executeOnTempElement = function (callbackNow, callbackAfter) {
                var eTempInput = document.createElement('textarea');
                eTempInput.style.width = '1px';
                eTempInput.style.height = '1px';
                eTempInput.style.top = '0px';
                eTempInput.style.left = '0px';
                eTempInput.style.position = 'absolute';
                eTempInput.style.opacity = '0.0';
                var guiRoot = this.gridCore.getRootGui();
                guiRoot.appendChild(eTempInput);
                try {
                    var result = callbackNow(eTempInput);
                    this.logger.log('Clipboard operation result: ' + result);
                } catch (err) {
                    this.logger.log('Browser doesn\t support document.execComment(\'copy\') for clipboard operations');
                }
                if (callbackAfter) {
                    setTimeout(function () {
                        callbackAfter(eTempInput);
                        guiRoot.removeChild(eTempInput);
                    }, 0);
                } else {
                    guiRoot.removeChild(eTempInput);
                }
            };
            // From http://stackoverflow.com/questions/1293147/javascript-code-to-parse-csv-data
            // This will parse a delimited string into an array of
            // arrays. The default delimiter is the comma, but this
            // can be overriden in the second argument.
            ClipboardService.prototype.dataToArray = function (strData) {
                var strDelimiter = '\t';
                // Create a regular expression to parse the CSV values.
                var objPattern = new RegExp(
                    // Delimiters.
                    "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +
                    // Quoted fields.
                    "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
                    // Standard fields.
                    "([^\"\\" + strDelimiter + "\\r\\n]*))", "gi");
                // Create an array to hold our data. Give the array
                // a default empty first row.
                var arrData = [[]];
                // Create an array to hold our individual pattern
                // matching groups.
                var arrMatches = null;
                // Keep looping over the regular expression matches
                // until we can no longer find a match.
                while (arrMatches = objPattern.exec(strData)) {
                    // Get the delimiter that was found.
                    var strMatchedDelimiter = arrMatches[1];
                    // Check to see if the given delimiter has a length
                    // (is not the start of string) and if it matches
                    // field delimiter. If id does not, then we know
                    // that this delimiter is a row delimiter.
                    if (strMatchedDelimiter.length && strMatchedDelimiter !== strDelimiter) {
                        // Since we have reached a new row of data,
                        // add an empty row to our data array.
                        arrData.push([]);
                    }
                    var strMatchedValue;
                    // Now that we have our delimiter out of the way,
                    // let's check to see which kind of value we
                    // captured (quoted or unquoted).
                    if (arrMatches[2]) {
                        // We found a quoted value. When we capture
                        // this value, unescape any double quotes.
                        strMatchedValue = arrMatches[2].replace(new RegExp("\"\"", "g"), "\"");
                    } else {
                        // We found a non-quoted value.
                        strMatchedValue = arrMatches[3];
                    }
                    // Now that we have our value string, let's add
                    // it to the data array.
                    arrData[arrData.length - 1].push(strMatchedValue);
                }
                // Return the parsed data.
                return arrData;
            };
            __decorate([main_1.Autowired('csvCreator'), __metadata('design:type', main_1.CsvCreator)], ClipboardService.prototype, "csvCreator", void 0);
            __decorate([main_1.Autowired('loggerFactory'), __metadata('design:type', main_1.LoggerFactory)], ClipboardService.prototype, "loggerFactory", void 0);
            __decorate([main_1.Autowired('selectionController'), __metadata('design:type', main_1.SelectionController)], ClipboardService.prototype, "selectionController", void 0);
            __decorate([main_1.Autowired('rangeController'), __metadata('design:type', rangeController_1.RangeController)], ClipboardService.prototype, "rangeController", void 0);
            __decorate([main_1.Autowired('rowModel'), __metadata('design:type', Object)], ClipboardService.prototype, "rowModel", void 0);
            __decorate([main_1.Autowired('floatingRowModel'), __metadata('design:type', main_1.FloatingRowModel)], ClipboardService.prototype, "floatingRowModel", void 0);
            __decorate([main_1.Autowired('valueService'), __metadata('design:type', main_1.ValueService)], ClipboardService.prototype, "valueService", void 0);
            __decorate([main_1.Autowired('focusedCellController'), __metadata('design:type', main_1.FocusedCellController)], ClipboardService.prototype, "focusedCellController", void 0);
            __decorate([main_1.Autowired('rowRenderer'), __metadata('design:type', main_1.RowRenderer)], ClipboardService.prototype, "rowRenderer", void 0);
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], ClipboardService.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], ClipboardService.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('cellNavigationService'), __metadata('design:type', main_1.CellNavigationService)], ClipboardService.prototype, "cellNavigationService", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], ClipboardService.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('gridCore'), __metadata('design:type', main_1.GridCore)], ClipboardService.prototype, "gridCore", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ClipboardService.prototype, "init", null);
            ClipboardService = __decorate([main_1.Bean('clipboardService'), __metadata('design:paramtypes', [])], ClipboardService);
            return ClipboardService;
        }();
        exports.ClipboardService = ClipboardService;

        /***/ },
    /* 363 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var GroupStage = function () {
            function GroupStage() {}
            GroupStage.prototype.execute = function (rowNode) {
                var groupedCols = this.columnController.getRowGroupColumns();
                var expandByDefault;
                if (this.gridOptionsWrapper.isGroupSuppressRow()) {
                    expandByDefault = -1;
                } else {
                    expandByDefault = this.gridOptionsWrapper.getGroupDefaultExpanded();
                }
                // putting this in a wrapper, so it's pass by reference
                var groupId = { value: -1 };
                this.recursivelyGroup(rowNode, groupedCols, 0, expandByDefault, groupId);
            };
            GroupStage.prototype.recursivelyGroup = function (rowNode, groupColumns, level, expandByDefault, groupId) {
                var _this = this;
                var groupingThisLevel = level < groupColumns.length;
                rowNode.leafGroup = level === groupColumns.length;
                if (groupingThisLevel) {
                    var groupColumn = groupColumns[level];
                    this.setChildrenAfterGroup(rowNode, groupColumn, groupId, expandByDefault, level);
                    rowNode.childrenAfterGroup.forEach(function (child) {
                        _this.recursivelyGroup(child, groupColumns, level + 1, expandByDefault, groupId);
                    });
                } else {
                    rowNode.childrenAfterGroup = rowNode.allLeafChildren;
                    rowNode.childrenAfterGroup.forEach(function (child) {
                        child.level = level;
                        child.parent = rowNode;
                    });
                }
            };
            GroupStage.prototype.setChildrenAfterGroup = function (rowNode, groupColumn, groupId, expandByDefault, level) {
                var _this = this;
                rowNode.childrenAfterGroup = [];
                rowNode.childrenMapped = {};
                rowNode.allLeafChildren.forEach(function (child) {
                    var groupKey = _this.getKeyForNode(groupColumn, child);
                    var groupForChild = rowNode.childrenMapped[groupKey];
                    if (!groupForChild) {
                        groupForChild = _this.createGroup(groupColumn, groupKey, rowNode, groupId, expandByDefault, level);
                        rowNode.childrenMapped[groupKey] = groupForChild;
                        rowNode.childrenAfterGroup.push(groupForChild);
                    }
                    groupForChild.allLeafChildren.push(child);
                });
            };
            GroupStage.prototype.getKeyForNode = function (groupColumn, rowNode) {
                var value = this.valueService.getValue(groupColumn, rowNode);
                var result;
                var keyCreator = groupColumn.getColDef().keyCreator;
                if (keyCreator) {
                    result = keyCreator({ value: value });
                } else {
                    result = value;
                }
                return result;
            };
            GroupStage.prototype.createGroup = function (groupColumn, groupKey, parent, groupId, expandByDefault, level) {
                var nextGroup = new main_1.RowNode();
                this.context.wireBean(nextGroup);
                nextGroup.group = true;
                nextGroup.field = groupColumn.getColDef().field;
                nextGroup.id = groupId.value.toString();
                nextGroup.key = groupKey;
                nextGroup.expanded = this.isExpanded(expandByDefault, level);
                nextGroup.allLeafChildren = [];
                nextGroup.allChildrenCount = 0;
                nextGroup.level = level;
                groupId.value--;
                var includeParents = !this.gridOptionsWrapper.isSuppressParentsInRowNodes();
                nextGroup.parent = includeParents ? parent : null;
                return nextGroup;
            };
            GroupStage.prototype.isExpanded = function (expandByDefault, level) {
                if (expandByDefault === -1) {
                    return true;
                } else {
                    return level < expandByDefault;
                }
            };
            __decorate([main_1.Autowired('selectionController'), __metadata('design:type', main_1.SelectionController)], GroupStage.prototype, "selectionController", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], GroupStage.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], GroupStage.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('valueService'), __metadata('design:type', main_1.ValueService)], GroupStage.prototype, "valueService", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], GroupStage.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], GroupStage.prototype, "context", void 0);
            GroupStage = __decorate([main_1.Bean('groupStage'), __metadata('design:paramtypes', [])], GroupStage);
            return GroupStage;
        }();
        exports.GroupStage = GroupStage;

        /***/ },
    /* 364 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var pivotStage_1 = __webpack_require__(365);
        var aggFuncService_1 = __webpack_require__(360);
        var AggregationStage = function () {
            function AggregationStage() {}
            // it's possible to recompute the aggregate without doing the other parts
            // + gridApi.recomputeAggregates()
            AggregationStage.prototype.execute = function (rootNode) {
                // we don't do aggregation if user provided the groups
                var rowsAlreadyGrouped = main_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
                if (rowsAlreadyGrouped) {
                    return;
                }
                var pivotActive = this.columnController.isPivotActive();
                var measureColumns = this.columnController.getValueColumns();
                var pivotColumns = pivotActive ? this.columnController.getPivotColumns() : [];
                this.recursivelyCreateAggData(rootNode, measureColumns, pivotColumns);
            };
            AggregationStage.prototype.recursivelyCreateAggData = function (rowNode, measureColumns, pivotColumns) {
                var _this = this;
                // aggregate all children first, as we use the result in this nodes calculations
                rowNode.childrenAfterFilter.forEach(function (child) {
                    if (child.group) {
                        _this.recursivelyCreateAggData(child, measureColumns, pivotColumns);
                    }
                });
                this.aggregateRowNode(rowNode, measureColumns, pivotColumns);
            };
            AggregationStage.prototype.aggregateRowNode = function (rowNode, measureColumns, pivotColumns) {
                var measureColumnsMissing = measureColumns.length === 0;
                var pivotColumnsMissing = pivotColumns.length === 0;
                var userProvidedGroupRowAggNodes = this.gridOptionsWrapper.getGroupRowAggNodesFunc();
                var aggResult;
                if (userProvidedGroupRowAggNodes) {
                    aggResult = userProvidedGroupRowAggNodes(rowNode.childrenAfterFilter);
                } else if (measureColumnsMissing) {
                    aggResult = null;
                } else if (pivotColumnsMissing) {
                    aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, measureColumns);
                } else {
                    aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);
                }
                rowNode.data = aggResult;
                // if we are grouping, then it's possible there is a sibling footer
                // to the group, so update the data here also if there is one
                if (rowNode.sibling) {
                    rowNode.sibling.data = aggResult;
                }
            };
            AggregationStage.prototype.aggregateRowNodeUsingValuesAndPivot = function (rowNode) {
                var _this = this;
                var result = {};
                var pivotColumnDefs = this.pivotStage.getPivotColumnDefs();
                pivotColumnDefs.forEach(function (pivotColumnDef) {
                    var values;
                    var valueColumn = pivotColumnDef.pivotValueColumn;
                    if (rowNode.leafGroup) {
                        // lowest level group, get the values from the mapped set
                        var keys = pivotColumnDef.pivotKeys;
                        values = _this.getValuesFromMappedSet(rowNode.childrenMapped, keys, valueColumn);
                    } else {
                        // value columns and pivot columns, non-leaf group
                        values = _this.getValuesPivotNonLeaf(rowNode, pivotColumnDef.colId);
                    }
                    result[pivotColumnDef.colId] = _this.aggregateValues(values, valueColumn.getAggFunc());
                });
                this.putInValueForGroupNode(result, rowNode);
                return result;
            };
            AggregationStage.prototype.aggregateRowNodeUsingValuesOnly = function (rowNode, valueColumns) {
                var _this = this;
                var result = {};
                var values2d = this.getValuesNormal(rowNode, valueColumns);
                valueColumns.forEach(function (valueColumn, index) {
                    result[valueColumn.getId()] = _this.aggregateValues(values2d[index], valueColumn.getAggFunc());
                });
                this.putInValueForGroupNode(result, rowNode);
                return result;
            };
            // when doing copy to clipboard, the valueService is used to get the value for the cell.
            // the problem is that the valueService is wired to get the values directly from the data
            // using column ID's (rather than, eg, valueGetters), so we need to have the value of the
            // group key in the data, so when copy to clipboard is executed, the value is picked up correctly.
            AggregationStage.prototype.putInValueForGroupNode = function (result, rowNode) {
                result[main_1.ColumnController.GROUP_AUTO_COLUMN_ID] = rowNode.key;
            };
            AggregationStage.prototype.getValuesPivotNonLeaf = function (rowNode, colId) {
                var values = [];
                rowNode.childrenAfterFilter.forEach(function (rowNode) {
                    var value = rowNode.data[colId];
                    values.push(value);
                });
                return values;
            };
            AggregationStage.prototype.getValuesFromMappedSet = function (mappedSet, keys, valueColumn) {
                var _this = this;
                var mapPointer = mappedSet;
                keys.forEach(function (key) {
                    return mapPointer = mapPointer ? mapPointer[key] : null;
                });
                if (!mapPointer) {
                    return [];
                }
                var values = [];
                mapPointer.forEach(function (rowNode) {
                    var value = _this.valueService.getValue(valueColumn, rowNode);
                    values.push(value);
                });
                return values;
            };
            AggregationStage.prototype.getValuesNormal = function (rowNode, valueColumns) {
                // create 2d array, of all values for all valueColumns
                var values = [];
                valueColumns.forEach(function () {
                    return values.push([]);
                });
                var valueColumnCount = valueColumns.length;
                var rowCount = rowNode.childrenAfterFilter.length;
                for (var i = 0; i < rowCount; i++) {
                    var childNode = rowNode.childrenAfterFilter[i];
                    for (var j = 0; j < valueColumnCount; j++) {
                        var valueColumn = valueColumns[j];
                        var value;
                        // if the row is a group, then it will only have an agg result value,
                        // which means valueGetter is never used.
                        if (childNode.group) {
                            value = childNode.data[valueColumn.getId()];
                        } else {
                            value = this.valueService.getValueUsingSpecificData(valueColumn, childNode.data, childNode);
                        }
                        values[j].push(value);
                    }
                }
                return values;
            };
            AggregationStage.prototype.aggregateValues = function (values, aggFuncOrString) {
                var aggFunction;
                if (typeof aggFuncOrString === 'string') {
                    aggFunction = this.aggFuncService.getAggFunc(aggFuncOrString);
                } else {
                    aggFunction = aggFuncOrString;
                }
                if (typeof aggFunction !== 'function') {
                    console.error("ag-Grid: unrecognised aggregation function " + aggFuncOrString);
                    return null;
                }
                var result = aggFunction(values);
                return result;
            };
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], AggregationStage.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], AggregationStage.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('valueService'), __metadata('design:type', main_1.ValueService)], AggregationStage.prototype, "valueService", void 0);
            __decorate([main_1.Autowired('pivotStage'), __metadata('design:type', pivotStage_1.PivotStage)], AggregationStage.prototype, "pivotStage", void 0);
            __decorate([main_1.Autowired('aggFuncService'), __metadata('design:type', aggFuncService_1.AggFuncService)], AggregationStage.prototype, "aggFuncService", void 0);
            AggregationStage = __decorate([main_1.Bean('aggregationStage'), __metadata('design:paramtypes', [])], AggregationStage);
            return AggregationStage;
        }();
        exports.AggregationStage = AggregationStage;

        /***/ },
    /* 365 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var pivotColDefService_1 = __webpack_require__(366);
        var PivotStage = function () {
            function PivotStage() {
                this.uniqueValues = {};
            }
            PivotStage.prototype.execute = function (rootNode) {
                if (this.columnController.isPivotActive()) {
                    this.executePivotOn(rootNode);
                } else {
                    this.executePivotOff();
                }
            };
            PivotStage.prototype.executePivotOff = function () {
                this.aggregationColumnsHashLastTime = null;
                this.uniqueValues = {};
                this.columnController.setSecondaryColumns(null);
            };
            PivotStage.prototype.executePivotOn = function (rootNode) {
                var uniqueValues = this.bucketUpRowNodes(rootNode);
                var uniqueValuesChanged = this.setUniqueValues(uniqueValues);
                var aggregationColumns = this.columnController.getValueColumns();
                var aggregationColumnsHash = aggregationColumns.map(function (column) {
                    return column.getId();
                }).join('#');
                var aggregationColumnsChanged = this.aggregationColumnsHashLastTime !== aggregationColumnsHash;
                this.aggregationColumnsHashLastTime = aggregationColumnsHash;
                if (uniqueValuesChanged || aggregationColumnsChanged) {
                    var result = this.pivotColDefService.createPivotColumnDefs(this.uniqueValues);
                    this.pivotColumnGroupDefs = result.pivotColumnGroupDefs;
                    this.pivotColumnDefs = result.pivotColumnDefs;
                    this.columnController.setSecondaryColumns(this.pivotColumnGroupDefs);
                }
            };
            PivotStage.prototype.setUniqueValues = function (newValues) {
                var json1 = JSON.stringify(newValues);
                var json2 = JSON.stringify(this.uniqueValues);
                var uniqueValuesChanged = json1 !== json2;
                // we only continue the below if the unique values are different, as otherwise
                // the result will be the same as the last time we did it
                if (uniqueValuesChanged) {
                    this.uniqueValues = newValues;
                    return true;
                } else {
                    return false;
                }
            };
            // returns true if values were different
            PivotStage.prototype.bucketUpRowNodes = function (rootNode) {
                // accessed from inside inner function
                var uniqueValues = {};
                var that = this;
                recursivelySearchForLeafNodes(rootNode);
                return uniqueValues;
                // finds all leaf groups and calls mapRowNode with it
                function recursivelySearchForLeafNodes(rowNode) {
                    if (rowNode.leafGroup) {
                        that.bucketRowNode(rowNode, uniqueValues);
                    } else {
                        rowNode.childrenAfterFilter.forEach(function (child) {
                            recursivelySearchForLeafNodes(child);
                        });
                    }
                }
            };
            PivotStage.prototype.bucketRowNode = function (rowNode, uniqueValues) {
                var pivotColumns = this.columnController.getPivotColumns();
                if (pivotColumns.length === 0) {
                    rowNode.childrenMapped = null;
                    return;
                }
                rowNode.childrenMapped = this.bucketChildren(rowNode.childrenAfterFilter, pivotColumns, 0, uniqueValues);
            };
            PivotStage.prototype.bucketChildren = function (children, pivotColumns, pivotIndex, uniqueValues) {
                var _this = this;
                var mappedChildren = {};
                var pivotColumn = pivotColumns[pivotIndex];
                // map the children out based on the pivot column
                children.forEach(function (child) {
                    var key = _this.valueService.getValue(pivotColumn, child);
                    if (main_1.Utils.missing(key)) {
                        key = '';
                    }
                    if (!uniqueValues[key]) {
                        uniqueValues[key] = {};
                    }
                    if (!mappedChildren[key]) {
                        mappedChildren[key] = [];
                    }
                    mappedChildren[key].push(child);
                });
                // if it's the last pivot column, return as is, otherwise go one level further in the map
                if (pivotIndex === pivotColumns.length - 1) {
                    return mappedChildren;
                } else {
                    var result = {};
                    main_1.Utils.iterateObject(mappedChildren, function (key, value) {
                        result[key] = _this.bucketChildren(value, pivotColumns, pivotIndex + 1, uniqueValues[key]);
                    });
                    return result;
                }
            };
            PivotStage.prototype.getPivotColumnDefs = function () {
                return this.pivotColumnDefs;
            };
            __decorate([main_1.Autowired('rowModel'), __metadata('design:type', Object)], PivotStage.prototype, "rowModel", void 0);
            __decorate([main_1.Autowired('valueService'), __metadata('design:type', main_1.ValueService)], PivotStage.prototype, "valueService", void 0);
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], PivotStage.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], PivotStage.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('pivotColDefService'), __metadata('design:type', pivotColDefService_1.PivotColDefService)], PivotStage.prototype, "pivotColDefService", void 0);
            PivotStage = __decorate([main_1.Bean('pivotStage'), __metadata('design:paramtypes', [])], PivotStage);
            return PivotStage;
        }();
        exports.PivotStage = PivotStage;

        /***/ },
    /* 366 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var PivotColDefService = function () {
            function PivotColDefService() {}
            PivotColDefService.prototype.createPivotColumnDefs = function (uniqueValues) {
                var pivotColumnGroupDefs = [];
                var pivotColumnDefs = [];
                var pivotColumns = this.columnController.getPivotColumns();
                var levelsDeep = pivotColumns.length;
                var columnIdSequence = new main_1.NumberSequence();
                this.recursivelyAddGroup(pivotColumnGroupDefs, pivotColumnDefs, 1, uniqueValues, [], columnIdSequence, levelsDeep);
                return {
                    pivotColumnGroupDefs: pivotColumnGroupDefs,
                    pivotColumnDefs: pivotColumnDefs
                };
            };
            // parentChildren - the list of colDefs we are adding to
            // @index - how far the column is from the top (also same as pivotKeys.length)
            // @uniqueValues - the values for which we should create a col for
            // @pivotKeys - the keys for the pivot, eg if pivoting on {Language,Country} then could be {English,Ireland}
            PivotColDefService.prototype.recursivelyAddGroup = function (parentChildren, pivotColumnDefs, index, uniqueValues, pivotKeys, columnIdSequence, levelsDeep) {
                var _this = this;
                main_1.Utils.iterateObject(uniqueValues, function (key, value) {
                    var newPivotKeys = pivotKeys.slice(0);
                    newPivotKeys.push(key);
                    var createGroup = index !== levelsDeep;
                    if (createGroup) {
                        var groupDef = {
                            children: [],
                            headerName: key
                        };
                        parentChildren.push(groupDef);
                        _this.recursivelyAddGroup(groupDef.children, pivotColumnDefs, index + 1, value, newPivotKeys, columnIdSequence, levelsDeep);
                    } else {
                        var measureColumns = _this.columnController.getValueColumns();
                        var valueGroup = {
                            children: [],
                            headerName: key
                        };
                        parentChildren.push(valueGroup);
                        // if no value columns selected, then we insert one blank column, so the user at least sees columns
                        // rendered. otherwise the grid would render with no columns (just empty groups) which would give the
                        // impression that the grid is broken
                        if (measureColumns.length === 0) {
                            // this is the blank column, for when no value columns enabled.
                            var colDef = _this.createColDef(null, '-', newPivotKeys, columnIdSequence, "'n/a'");
                            valueGroup.children.push(colDef);
                            pivotColumnDefs.push(colDef);
                        } else {
                            measureColumns.forEach(function (measureColumn) {
                                var colDef = _this.createColDef(measureColumn, measureColumn.getColDef().headerName, newPivotKeys, columnIdSequence, null);
                                valueGroup.children.push(colDef);
                                pivotColumnDefs.push(colDef);
                            });
                        }
                        valueGroup.children.sort(_this.headerNameComparator.bind(_this));
                    }
                    parentChildren.sort(_this.headerNameComparator.bind(_this));
                });
            };
            PivotColDefService.prototype.createColDef = function (valueColumn, headerName, pivotKeys, columnIdSequence, valueGetter) {
                var colDef = {};
                if (valueColumn) {
                    var colDefToCopy = valueColumn.getColDef();
                    main_1.Utils.assign(colDef, colDefToCopy);
                    // even if original column was hidden, we always show the pivot value column, otherwise it would be
                    // very confusing for people thinking the pivot is broken
                    colDef.hide = false;
                }
                colDef.valueGetter = valueGetter;
                colDef.headerName = headerName;
                colDef.colId = 'pivot_' + columnIdSequence.next();
                colDef.pivotKeys = pivotKeys;
                colDef.pivotValueColumn = valueColumn;
                return colDef;
            };
            PivotColDefService.prototype.headerNameComparator = function (a, b) {
                if (a.headerName < b.headerName) {
                    return -1;
                } else if (a.headerName > b.headerName) {
                    return 1;
                } else {
                    return 0;
                }
            };
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], PivotColDefService.prototype, "columnController", void 0);
            PivotColDefService = __decorate([main_1.Bean('pivotColDefService'), __metadata('design:paramtypes', [])], PivotColDefService);
            return PivotColDefService;
        }();
        exports.PivotColDefService = PivotColDefService;

        /***/ },
    /* 367 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var setFilter_1 = __webpack_require__(368);
        var richSelectCellEditor_1 = __webpack_require__(372);
        var licenseManager_1 = __webpack_require__(374);
        var EnterpriseBoot = function () {
            function EnterpriseBoot() {}
            EnterpriseBoot.prototype.init = function () {
                this.filterManager.registerFilter('set', setFilter_1.SetFilter);
                this.cellEditorFactory.addCellEditor(EnterpriseBoot.RICH_SELECT, richSelectCellEditor_1.RichSelectCellEditor);
                this.licenseManager.validateLicense();
            };
            EnterpriseBoot.RICH_SELECT = 'richSelect';
            __decorate([main_1.Autowired('filterManager'), __metadata('design:type', main_1.FilterManager)], EnterpriseBoot.prototype, "filterManager", void 0);
            __decorate([main_1.Autowired('cellEditorFactory'), __metadata('design:type', main_1.CellEditorFactory)], EnterpriseBoot.prototype, "cellEditorFactory", void 0);
            __decorate([main_1.Autowired('licenseManager'), __metadata('design:type', licenseManager_1.LicenseManager)], EnterpriseBoot.prototype, "licenseManager", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], EnterpriseBoot.prototype, "init", null);
            EnterpriseBoot = __decorate([main_1.Bean('enterpriseBoot'), __metadata('design:paramtypes', [])], EnterpriseBoot);
            return EnterpriseBoot;
        }();
        exports.EnterpriseBoot = EnterpriseBoot;

        /***/ },
    /* 368 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var setFilterModel_1 = __webpack_require__(369);
        var setFilterListItem_1 = __webpack_require__(370);
        var virtualList_1 = __webpack_require__(371);
        var SetFilter = function (_super) {
            __extends(SetFilter, _super);
            function SetFilter() {
                _super.call(this);
            }
            SetFilter.prototype.postConstruct = function () {
                this.setTemplate(this.createTemplate());
                this.virtualList = new virtualList_1.VirtualList();
                this.context.wireBean(this.virtualList);
                this.getGui().querySelector('#richList').appendChild(this.virtualList.getGui());
            };
            SetFilter.prototype.init = function (params) {
                this.params = params;
                this.applyActive = this.params.apply === true;
                this.suppressSorting = this.params.suppressSorting;
                this.newRowsActionKeep = this.params.newRowsAction === 'keep';
                if (main_1.Utils.exists(this.params.cellHeight)) {
                    this.virtualList.setRowHeight(this.params.cellHeight);
                }
                this.virtualList.setComponentCreator(this.createSetListItem.bind(this));
                this.model = new setFilterModel_1.SetFilterModel(params.colDef, params.rowModel, params.valueGetter, params.doesRowPassOtherFilter, this.suppressSorting);
                this.virtualList.setModel(new ModelWrapper(this.model));
                this.createGui();
            };
            SetFilter.prototype.createSetListItem = function (value) {
                var _this = this;
                var cellRenderer = this.params.cellRenderer;
                var listItem = new setFilterListItem_1.SetFilterListItem(value, cellRenderer);
                this.context.wireBean(listItem);
                listItem.setSelected(this.model.isValueSelected(value));
                listItem.addEventListener(setFilterListItem_1.SetFilterListItem.EVENT_SELECTED, function () {
                    _this.onItemSelected(value, listItem.isSelected());
                });
                return listItem;
            };
            // we need to have the gui attached before we can draw the virtual rows, as the
            // virtual row logic needs info about the gui state
            SetFilter.prototype.afterGuiAttached = function (params) {
                this.virtualList.refresh();
                this.eMiniFilter.focus();
            };
            SetFilter.prototype.isFilterActive = function () {
                return this.model.isFilterActive();
            };
            SetFilter.prototype.doesFilterPass = function (params) {
                // if no filter, always pass
                if (this.model.isEverythingSelected()) {
                    return true;
                }
                // if nothing selected in filter, always fail
                if (this.model.isNothingSelected()) {
                    return false;
                }
                var value = this.params.valueGetter(params.node);
                if (this.params.colDef.keyCreator) {
                    value = this.params.colDef.keyCreator({ value: value });
                }
                value = main_1.Utils.makeNull(value);
                if (Array.isArray(value)) {
                    for (var i = 0; i < value.length; i++) {
                        if (this.model.isValueSelected(value[i])) {
                            return true;
                        }
                    }
                    return false;
                } else {
                    return this.model.isValueSelected(value);
                }
            };
            SetFilter.prototype.onNewRowsLoaded = function () {
                var keepSelection = this.params && this.params.newRowsAction === 'keep';
                var isSelectAll = this.eSelectAll && this.eSelectAll.checked && !this.eSelectAll.indeterminate;
                // default is reset
                this.model.refreshAfterNewRowsLoaded(keepSelection, isSelectAll);
                this.virtualList.refresh();
            };
            SetFilter.prototype.onAnyFilterChanged = function () {
                this.model.refreshAfterAnyFilterChanged();
                this.virtualList.refresh();
            };
            SetFilter.prototype.createTemplate = function () {
                var translate = this.gridOptionsWrapper.getLocaleTextFunc();
                return "<div>\n                    <div class=\"ag-filter-header-container\">\n                        <input class=\"ag-filter-filter\" type=\"text\" placeholder=\"" + translate('searchOoo', 'Search...') + "\"/>\n                    </div>\n                    <div class=\"ag-filter-header-container\">\n                        <label>\n                            <input id=\"selectAll\" type=\"checkbox\" class=\"ag-filter-checkbox\"/>\n                            <span class=\"ag-filter-value\">(" + translate('selectAll', 'Select All') + ")</span>\n                        </label>\n                    </div>\n                    <div id=\"richList\" class=\"ag-set-filter-list\"></div>\n                    <div class=\"ag-filter-apply-panel\" id=\"applyPanel\">\n                        <button type=\"button\" id=\"applyButton\">" + translate('applyFilter', 'Apply Filter') + "</button>\n                    </div>\n                </div>";
            };
            SetFilter.prototype.createGui = function () {
                var _this = this;
                this.eSelectAll = this.queryForHtmlElement("#selectAll");
                this.eMiniFilter = this.queryForHtmlElement(".ag-filter-filter");
                this.eMiniFilter.value = this.model.getMiniFilter();
                this.addDestroyableEventListener(this.eMiniFilter, 'input', function () {
                    _this.onMiniFilterChanged();
                });
                this.eSelectAll.onclick = this.onSelectAll.bind(this);
                if (this.model.isEverythingSelected()) {
                    this.eSelectAll.indeterminate = false;
                    this.eSelectAll.checked = true;
                } else if (this.model.isNothingSelected()) {
                    this.eSelectAll.indeterminate = false;
                    this.eSelectAll.checked = false;
                } else {
                    this.eSelectAll.indeterminate = true;
                }
                this.setupApply();
                this.virtualList.refresh();
            };
            SetFilter.prototype.setupApply = function () {
                var _this = this;
                if (this.applyActive) {
                    this.eApplyButton = this.queryForHtmlElement('#applyButton');
                    this.eApplyButton.addEventListener('click', function () {
                        _this.params.filterChangedCallback();
                    });
                } else {
                    main_1.Utils.removeElement(this.getGui(), '#applyPanel');
                }
            };
            SetFilter.prototype.filterChanged = function () {
                this.params.filterModifiedCallback();
                if (!this.applyActive) {
                    this.params.filterChangedCallback();
                }
            };
            SetFilter.prototype.onMiniFilterChanged = function () {
                var miniFilterChanged = this.model.setMiniFilter(this.eMiniFilter.value);
                if (miniFilterChanged) {
                    this.virtualList.refresh();
                }
            };
            SetFilter.prototype.onSelectAll = function () {
                var checked = this.eSelectAll.checked;
                if (checked) {
                    this.model.selectEverything();
                } else {
                    this.model.selectNothing();
                }
                this.virtualList.refresh();
                this.filterChanged();
            };
            SetFilter.prototype.onItemSelected = function (value, selected) {
                if (selected) {
                    this.model.selectValue(value);
                    if (this.model.isEverythingSelected()) {
                        this.eSelectAll.indeterminate = false;
                        this.eSelectAll.checked = true;
                    } else {
                        this.eSelectAll.indeterminate = true;
                    }
                } else {
                    this.model.unselectValue(value);
                    //if set is empty, nothing is selected
                    if (this.model.isNothingSelected()) {
                        this.eSelectAll.indeterminate = false;
                        this.eSelectAll.checked = false;
                    } else {
                        this.eSelectAll.indeterminate = true;
                    }
                }
                this.filterChanged();
            };
            SetFilter.prototype.setMiniFilter = function (newMiniFilter) {
                this.model.setMiniFilter(newMiniFilter);
            };
            SetFilter.prototype.getMiniFilter = function () {
                return this.model.getMiniFilter();
            };
            SetFilter.prototype.selectEverything = function () {
                this.eSelectAll.indeterminate = false;
                this.eSelectAll.checked = true;
                // not sure if we need to call this, as checking the checkout above might
                // fire events.
                this.model.selectEverything();
            };
            SetFilter.prototype.selectNothing = function () {
                this.eSelectAll.indeterminate = false;
                this.eSelectAll.checked = false;
                // not sure if we need to call this, as checking the checkout above might
                // fire events.
                this.model.selectNothing();
            };
            SetFilter.prototype.unselectValue = function (value) {
                this.model.unselectValue(value);
                this.virtualList.refresh();
            };
            SetFilter.prototype.selectValue = function (value) {
                this.model.selectValue(value);
                this.virtualList.refresh();
            };
            SetFilter.prototype.isValueSelected = function (value) {
                return this.model.isValueSelected(value);
            };
            SetFilter.prototype.isEverythingSelected = function () {
                return this.model.isEverythingSelected();
            };
            SetFilter.prototype.isNothingSelected = function () {
                return this.model.isNothingSelected();
            };
            SetFilter.prototype.getUniqueValueCount = function () {
                return this.model.getUniqueValueCount();
            };
            SetFilter.prototype.getUniqueValue = function (index) {
                return this.model.getUniqueValue(index);
            };
            SetFilter.prototype.getModel = function () {
                return this.model.getModel();
            };
            SetFilter.prototype.setModel = function (dataModel) {
                this.model.setModel(dataModel);
                this.virtualList.refresh();
            };
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], SetFilter.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], SetFilter.prototype, "context", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], SetFilter.prototype, "postConstruct", null);
            return SetFilter;
        }(main_1.Component);
        exports.SetFilter = SetFilter;
        var ModelWrapper = function () {
            function ModelWrapper(model) {
                this.model = model;
            }
            ModelWrapper.prototype.getRowCount = function () {
                return this.model.getDisplayedValueCount();
            };
            ModelWrapper.prototype.getRow = function (index) {
                return this.model.getDisplayedValue(index);
            };
            return ModelWrapper;
        }();

        /***/ },
    /* 369 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        // ag-grid-enterprise v5.4.0
        var main_1 = __webpack_require__(238);
        var SetFilterModel = function () {
            function SetFilterModel(colDef, rowModel, valueGetter, doesRowPassOtherFilters, suppressSorting) {
                this.suppressSorting = suppressSorting;
                this.colDef = colDef;
                this.rowModel = rowModel;
                this.valueGetter = valueGetter;
                this.doesRowPassOtherFilters = doesRowPassOtherFilters;
                this.filterParams = this.colDef.filterParams;
                if (main_1.Utils.exists(this.filterParams)) {
                    this.usingProvidedSet = main_1.Utils.exists(this.filterParams.values);
                    this.showingAvailableOnly = this.filterParams.suppressRemoveEntries !== true;
                } else {
                    this.usingProvidedSet = false;
                    this.showingAvailableOnly = true;
                }
                this.createAllUniqueValues();
                this.createAvailableUniqueValues();
                // by default, no filter, so we display everything
                this.displayedValues = this.availableUniqueValues;
                this.miniFilter = null;
                // we use a map rather than an array for the selected values as the lookup
                // for a map is much faster than the lookup for an array, especially when
                // the length of the array is thousands of records long
                this.selectedValuesMap = {};
                this.selectEverything();
            }
            // if keepSelection not set will always select all filters
            // if keepSelection set will keep current state of selected filters
            //    unless selectAll chosen in which case will select all
            SetFilterModel.prototype.refreshAfterNewRowsLoaded = function (keepSelection, isSelectAll) {
                this.createAllUniqueValues();
                this.createAvailableUniqueValues();
                var oldModel = Object.keys(this.selectedValuesMap);
                this.selectedValuesMap = {};
                this.processMiniFilter();
                if (keepSelection) {
                    this.setModel(oldModel, isSelectAll);
                } else {
                    this.selectEverything();
                }
            };
            SetFilterModel.prototype.refreshAfterAnyFilterChanged = function () {
                if (this.showingAvailableOnly) {
                    this.createAvailableUniqueValues();
                    this.processMiniFilter();
                }
            };
            SetFilterModel.prototype.createAllUniqueValues = function () {
                if (this.usingProvidedSet) {
                    this.allUniqueValues = main_1.Utils.toStrings(this.filterParams.values);
                } else {
                    var uniqueValuesAsAnyObjects = this.getUniqueValues(false);
                    this.allUniqueValues = main_1.Utils.toStrings(uniqueValuesAsAnyObjects);
                }
                this.sortValues(this.allUniqueValues);
            };
            SetFilterModel.prototype.createAvailableUniqueValues = function () {
                var dontCheckAvailableValues = !this.showingAvailableOnly || this.usingProvidedSet;
                if (dontCheckAvailableValues) {
                    this.availableUniqueValues = this.allUniqueValues;
                    return;
                }
                var uniqueValuesAsAnyObjects = this.getUniqueValues(true);
                this.availableUniqueValues = main_1.Utils.toStrings(uniqueValuesAsAnyObjects);
                this.sortValues(this.availableUniqueValues);
            };
            SetFilterModel.prototype.sortValues = function (values) {
                if (this.filterParams && this.filterParams.comparator) {
                    values.sort(this.filterParams.comparator);
                } else if (this.colDef.comparator) {
                    values.sort(this.colDef.comparator);
                } else {
                    values.sort(main_1.Utils.defaultComparator);
                }
            };
            SetFilterModel.prototype.getUniqueValues = function (filterOutNotAvailable) {
                var _this = this;
                var uniqueCheck = {};
                var result = [];
                if (!this.rowModel.forEachLeafNode) {
                    console.error('ag-Grid: Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values');
                    return [];
                }
                this.rowModel.forEachLeafNode(function (node) {
                    if (!node.group) {
                        var value = _this.valueGetter(node);
                        if (_this.colDef.keyCreator) {
                            value = _this.colDef.keyCreator({ value: value });
                        }
                        if (value === "" || value === undefined) {
                            value = null;
                        }
                        if (filterOutNotAvailable) {
                            if (!_this.doesRowPassOtherFilters(node)) {
                                return;
                            }
                        }
                        if (value != null && Array.isArray(value)) {
                            for (var j = 0; j < value.length; j++) {
                                addUniqueValueIfMissing(value[j]);
                            }
                        } else {
                            addUniqueValueIfMissing(value);
                        }
                    }
                });
                function addUniqueValueIfMissing(value) {
                    if (!uniqueCheck.hasOwnProperty(value)) {
                        result.push(value);
                        uniqueCheck[value] = 1;
                    }
                }
                return result;
            };
            //sets mini filter. returns true if it changed from last value, otherwise false
            SetFilterModel.prototype.setMiniFilter = function (newMiniFilter) {
                newMiniFilter = main_1.Utils.makeNull(newMiniFilter);
                if (this.miniFilter === newMiniFilter) {
                    //do nothing if filter has not changed
                    return false;
                }
                this.miniFilter = newMiniFilter;
                this.processMiniFilter();
                return true;
            };
            SetFilterModel.prototype.getMiniFilter = function () {
                return this.miniFilter;
            };
            SetFilterModel.prototype.processMiniFilter = function () {
                // if no filter, just use the unique values
                if (this.miniFilter === null) {
                    this.displayedValues = this.availableUniqueValues;
                    return;
                }
                // if filter present, we filter down the list
                this.displayedValues = [];
                var miniFilterUpperCase = this.miniFilter.toUpperCase();
                for (var i = 0, l = this.availableUniqueValues.length; i < l; i++) {
                    var filteredValue = this.availableUniqueValues[i];
                    if (filteredValue !== null && filteredValue.toString().toUpperCase().indexOf(miniFilterUpperCase) >= 0) {
                        this.displayedValues.push(filteredValue);
                    }
                }
            };
            SetFilterModel.prototype.getDisplayedValueCount = function () {
                return this.displayedValues.length;
            };
            SetFilterModel.prototype.getDisplayedValue = function (index) {
                return this.displayedValues[index];
            };
            SetFilterModel.prototype.selectEverything = function () {
                var count = this.allUniqueValues.length;
                for (var i = 0; i < count; i++) {
                    var value = this.allUniqueValues[i];
                    this.selectedValuesMap[value] = null;
                }
                this.selectedValuesCount = count;
            };
            SetFilterModel.prototype.isFilterActive = function () {
                return this.allUniqueValues.length !== this.selectedValuesCount;
            };
            SetFilterModel.prototype.selectNothing = function () {
                this.selectedValuesMap = {};
                this.selectedValuesCount = 0;
            };
            SetFilterModel.prototype.getUniqueValueCount = function () {
                return this.allUniqueValues.length;
            };
            SetFilterModel.prototype.getUniqueValue = function (index) {
                return this.allUniqueValues[index];
            };
            SetFilterModel.prototype.unselectValue = function (value) {
                if (this.selectedValuesMap[value] !== undefined) {
                    delete this.selectedValuesMap[value];
                    this.selectedValuesCount--;
                }
            };
            SetFilterModel.prototype.selectValue = function (value) {
                if (this.selectedValuesMap[value] === undefined) {
                    this.selectedValuesMap[value] = null;
                    this.selectedValuesCount++;
                }
            };
            SetFilterModel.prototype.isValueSelected = function (value) {
                return this.selectedValuesMap[value] !== undefined;
            };
            SetFilterModel.prototype.isEverythingSelected = function () {
                return this.allUniqueValues.length === this.selectedValuesCount;
            };
            SetFilterModel.prototype.isNothingSelected = function () {
                return this.allUniqueValues.length === 0;
            };
            SetFilterModel.prototype.getModel = function () {
                if (!this.isFilterActive()) {
                    return null;
                }
                var selectedValues = [];
                main_1.Utils.iterateObject(this.selectedValuesMap, function (key) {
                    selectedValues.push(key);
                });
                return selectedValues;
            };
            SetFilterModel.prototype.setModel = function (model, isSelectAll) {
                if (isSelectAll === void 0) {
                    isSelectAll = false;
                }
                if (model && !isSelectAll) {
                    this.selectNothing();
                    for (var i = 0; i < model.length; i++) {
                        var newValue = model[i];
                        if (this.allUniqueValues.indexOf(newValue) >= 0) {
                            this.selectValue(model[i]);
                        }
                    }
                } else {
                    this.selectEverything();
                }
            };
            return SetFilterModel;
        }();
        exports.SetFilterModel = SetFilterModel;

        /***/ },
    /* 370 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var SetFilterListItem = function (_super) {
            __extends(SetFilterListItem, _super);
            function SetFilterListItem(value, cellRenderer) {
                _super.call(this, SetFilterListItem.TEMPLATE);
                this.value = value;
                this.cellRenderer = cellRenderer;
            }
            SetFilterListItem.prototype.init = function () {
                var _this = this;
                this.render();
                this.eCheckbox = this.queryForHtmlInputElement("input");
                this.addDestroyableEventListener(this.eCheckbox, 'click', function () {
                    return _this.dispatchEvent(SetFilterListItem.EVENT_SELECTED);
                });
            };
            SetFilterListItem.prototype.isSelected = function () {
                return this.eCheckbox.checked;
            };
            SetFilterListItem.prototype.setSelected = function (selected) {
                this.eCheckbox.checked = selected;
            };
            SetFilterListItem.prototype.render = function () {
                var valueElement = this.queryForHtmlElement(".ag-filter-value");
                // var valueElement = eFilterValue.querySelector(".ag-filter-value");
                if (this.cellRenderer) {
                    var component = this.cellRendererService.useCellRenderer(this.cellRenderer, valueElement, { value: this.value });
                    if (component && component.destroy) {
                        this.addDestroyFunc(component.destroy.bind(component));
                    }
                } else {
                    // otherwise display as a string
                    var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                    var blanksText = '(' + localeTextFunc('blanks', 'Blanks') + ')';
                    var displayNameOfValue = this.value === null ? blanksText : this.value;
                    valueElement.innerHTML = displayNameOfValue;
                }
            };
            SetFilterListItem.EVENT_SELECTED = 'selected';
            SetFilterListItem.TEMPLATE = '<label class="ag-set-filter-item">' + '<input type="checkbox" class="ag-filter-checkbox"/>' + '<span class="ag-filter-value"></span>' + '</label>';
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], SetFilterListItem.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('cellRendererService'), __metadata('design:type', main_1.CellRendererService)], SetFilterListItem.prototype, "cellRendererService", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], SetFilterListItem.prototype, "init", null);
            return SetFilterListItem;
        }(main_1.Component);
        exports.SetFilterListItem = SetFilterListItem;

        /***/ },
    /* 371 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var VirtualList = function (_super) {
            __extends(VirtualList, _super);
            function VirtualList() {
                _super.call(this, null);
                this.rowsInBodyContainer = {};
                this.rowHeight = 20;
            }
            VirtualList.prototype.init = function () {
                this.setTemplate(VirtualList.TEMPLATE);
                this.eListContainer = this.queryForHtmlElement(".ag-virtual-list-container");
                this.addScrollListener();
            };
            VirtualList.prototype.ensureIndexVisible = function (index) {
                var lastRow = this.model.getRowCount();
                if (typeof index !== 'number' || index < 0 || index >= lastRow) {
                    console.warn('invalid row index for ensureIndexVisible: ' + index);
                    return;
                }
                // var nodeAtIndex = this.rowModel.getRow(index);
                var rowTopPixel = index * this.rowHeight;
                var rowBottomPixel = rowTopPixel + this.rowHeight;
                var viewportTopPixel = this.getGui().scrollTop;
                var viewportHeight = this.getGui().offsetHeight;
                var viewportBottomPixel = viewportTopPixel + viewportHeight;
                var viewportScrolledPastRow = viewportTopPixel > rowTopPixel;
                var viewportScrolledBeforeRow = viewportBottomPixel < rowBottomPixel;
                if (viewportScrolledPastRow) {
                    // if row is before, scroll up with row at top
                    this.getGui().scrollTop = rowTopPixel;
                } else if (viewportScrolledBeforeRow) {
                    // if row is below, scroll down with row at bottom
                    var newScrollPosition = rowBottomPixel - viewportHeight;
                    this.getGui().scrollTop = newScrollPosition;
                }
            };
            VirtualList.prototype.setComponentCreator = function (componentCreator) {
                this.componentCreator = componentCreator;
            };
            VirtualList.prototype.getRowHeight = function () {
                return this.rowHeight;
            };
            VirtualList.prototype.getScrollTop = function () {
                return this.getGui().scrollTop;
            };
            VirtualList.prototype.setRowHeight = function (rowHeight) {
                this.rowHeight = rowHeight;
                this.refresh();
            };
            VirtualList.prototype.refresh = function () {
                if (main_1.Utils.missing(this.model)) {
                    return;
                }
                this.eListContainer.style.height = this.model.getRowCount() * this.rowHeight + "px";
                this.clearVirtualRows();
                this.drawVirtualRows();
            };
            VirtualList.prototype.clearVirtualRows = function () {
                var rowsToRemove = Object.keys(this.rowsInBodyContainer);
                this.removeVirtualRows(rowsToRemove);
            };
            VirtualList.prototype.drawVirtualRows = function () {
                var topPixel = this.getGui().scrollTop;
                var bottomPixel = topPixel + this.getGui().offsetHeight;
                var firstRow = Math.floor(topPixel / this.rowHeight);
                var lastRow = Math.floor(bottomPixel / this.rowHeight);
                this.ensureRowsRendered(firstRow, lastRow);
            };
            VirtualList.prototype.ensureRowsRendered = function (start, finish) {
                // at the end, this array will contain the items we need to remove
                var rowsToRemove = Object.keys(this.rowsInBodyContainer);
                // add in new rows
                for (var rowIndex = start; rowIndex <= finish; rowIndex++) {
                    // see if item already there, and if yes, take it out of the 'to remove' array
                    if (rowsToRemove.indexOf(rowIndex.toString()) >= 0) {
                        rowsToRemove.splice(rowsToRemove.indexOf(rowIndex.toString()), 1);
                        continue;
                    }
                    // check this row actually exists (in case overflow buffer window exceeds real data)
                    if (this.model.getRowCount() > rowIndex) {
                        var value = this.model.getRow(rowIndex);
                        this.insertRow(value, rowIndex);
                    }
                }
                // at this point, everything in our 'rowsToRemove' . . .
                this.removeVirtualRows(rowsToRemove);
            };
            // takes array of row id's
            VirtualList.prototype.removeVirtualRows = function (rowsToRemove) {
                var _this = this;
                rowsToRemove.forEach(function (index) {
                    var component = _this.rowsInBodyContainer[index];
                    _this.eListContainer.removeChild(component.eDiv);
                    if (component.rowComponent.destroy) {
                        component.rowComponent.destroy();
                    }
                    delete _this.rowsInBodyContainer[index];
                });
            };
            VirtualList.prototype.insertRow = function (value, rowIndex) {
                var eDiv = document.createElement('div');
                main_1.Utils.addCssClass(eDiv, 'ag-virtual-list-item');
                eDiv.style.top = this.rowHeight * rowIndex + "px";
                var rowComponent = this.componentCreator(value);
                eDiv.appendChild(rowComponent.getGui());
                this.eListContainer.appendChild(eDiv);
                this.rowsInBodyContainer[rowIndex] = {
                    rowComponent: rowComponent,
                    eDiv: eDiv
                };
            };
            VirtualList.prototype.addScrollListener = function () {
                var _this = this;
                this.addGuiEventListener('scroll', function () {
                    _this.drawVirtualRows();
                });
            };
            VirtualList.prototype.setModel = function (model) {
                this.model = model;
            };
            VirtualList.TEMPLATE = '<div class="ag-virtual-list-viewport">' + '<div class="ag-virtual-list-container">' + '</div>' + '</div>';
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], VirtualList.prototype, "init", null);
            return VirtualList;
        }(main_1.Component);
        exports.VirtualList = VirtualList;

        /***/ },
    /* 372 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var richSelectRow_1 = __webpack_require__(373);
        var virtualList_1 = __webpack_require__(371);
        var RichSelectCellEditor = function (_super) {
            __extends(RichSelectCellEditor, _super);
            function RichSelectCellEditor() {
                _super.call(this, RichSelectCellEditor.TEMPLATE);
            }
            RichSelectCellEditor.prototype.init = function (params) {
                this.params = params;
                this.selectedValue = params.value;
                this.cellRenderer = this.params.cellRenderer;
                this.virtualList = new virtualList_1.VirtualList();
                this.context.wireBean(this.virtualList);
                this.virtualList.setComponentCreator(this.createRowComponent.bind(this));
                this.getGui().querySelector('.ag-rich-select-list').appendChild(this.virtualList.getGui());
                this.renderSelectedValue();
                if (main_1.Utils.missing(params.values)) {
                    console.log('ag-Grid: richSelectCellEditor requires values for it to work');
                    return;
                }
                var values = params.values;
                this.virtualList.setModel({
                    getRowCount: function getRowCount() {
                        return values.length;
                    },
                    getRow: function getRow(index) {
                        return values[index];
                    }
                });
                this.addGuiEventListener('keydown', this.onKeyDown.bind(this));
                this.addDestroyableEventListener(this.virtualList.getGui(), 'click', this.onClick.bind(this));
                this.addDestroyableEventListener(this.virtualList.getGui(), 'mousemove', this.onMouseMove.bind(this));
            };
            RichSelectCellEditor.prototype.onKeyDown = function (event) {
                var key = event.which || event.keyCode;
                switch (key) {
                    case main_1.Constants.KEY_ENTER:
                        this.onEnterKeyDown();
                        break;
                    case main_1.Constants.KEY_DOWN:
                    case main_1.Constants.KEY_UP:
                        this.onNavigationKeyPressed(event, key);
                        break;
                }
            };
            RichSelectCellEditor.prototype.onEnterKeyDown = function () {
                this.params.stopEditing();
            };
            RichSelectCellEditor.prototype.onNavigationKeyPressed = function (event, key) {
                // if we don't stop propagation, then the grids navigation kicks in
                event.stopPropagation();
                var oldIndex = this.params.values.indexOf(this.selectedValue);
                var newIndex = key === main_1.Constants.KEY_UP ? oldIndex - 1 : oldIndex + 1;
                if (newIndex >= 0 && newIndex < this.params.values.length) {
                    var valueToSelect = this.params.values[newIndex];
                    this.setSelectedValue(valueToSelect);
                }
            };
            RichSelectCellEditor.prototype.renderSelectedValue = function () {
                var eValue = this.getGui().querySelector('.ag-rich-select-value');
                if (this.cellRenderer) {
                    var result = this.cellRendererService.useCellRenderer(this.cellRenderer, eValue, { value: this.selectedValue });
                    if (result && result.destroy) {
                        this.addDestroyFunc(function () {
                            return result.destroy();
                        });
                    }
                } else {
                    if (main_1.Utils.exists(this.selectedValue)) {
                        eValue.innerHTML = this.selectedValue.toString();
                    } else {
                        eValue.innerHTML = '';
                    }
                }
            };
            RichSelectCellEditor.prototype.setSelectedValue = function (value) {
                if (this.selectedValue === value) {
                    return;
                }
                var index = this.params.values.indexOf(value);
                if (index >= 0) {
                    this.selectedValue = value;
                    this.virtualList.ensureIndexVisible(index);
                    this.virtualList.refresh();
                }
            };
            RichSelectCellEditor.prototype.createRowComponent = function (value) {
                var row = new richSelectRow_1.RichSelectRow(this.cellRenderer);
                this.context.wireBean(row);
                row.setState(value, value === this.selectedValue);
                return row;
            };
            RichSelectCellEditor.prototype.onMouseMove = function (mouseEvent) {
                var rect = this.virtualList.getGui().getBoundingClientRect();
                var scrollTop = this.virtualList.getScrollTop();
                var mouseY = mouseEvent.clientY - rect.top + scrollTop;
                var row = Math.floor(mouseY / this.virtualList.getRowHeight());
                var value = this.params.values[row];
                if (main_1.Utils.exists(value)) {
                    this.setSelectedValue(value);
                }
            };
            RichSelectCellEditor.prototype.onClick = function () {
                this.params.stopEditing();
            };
            // we need to have the gui attached before we can draw the virtual rows, as the
            // virtual row logic needs info about the gui state
            RichSelectCellEditor.prototype.afterGuiAttached = function () {
                var selectedIndex = this.params.values.indexOf(this.selectedValue);
                // we have to call this here to get the list to have the right height, ie
                // otherwise it would not have scrolls yet and ensureIndeVisible would do nothing
                this.virtualList.refresh();
                if (selectedIndex >= 0) {
                    this.virtualList.ensureIndexVisible(selectedIndex);
                }
                // we call refresh again, as the list could of moved, and we need to render the new rows
                this.virtualList.refresh();
                this.getGui().focus();
            };
            RichSelectCellEditor.prototype.getValue = function () {
                return this.selectedValue;
            };
            RichSelectCellEditor.prototype.isPopup = function () {
                return true;
            };
            RichSelectCellEditor.TEMPLATE =
                // tab index is needed so we can focus, which is needed for keyboard events
                '<div class="ag-rich-select" tabindex="0">' + '<div class="ag-rich-select-value"></div>' + '<div class="ag-rich-select-list"></div>' + '</div>';
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], RichSelectCellEditor.prototype, "context", void 0);
            __decorate([main_1.Autowired('cellRendererService'), __metadata('design:type', main_1.CellRendererService)], RichSelectCellEditor.prototype, "cellRendererService", void 0);
            return RichSelectCellEditor;
        }(main_1.Component);
        exports.RichSelectCellEditor = RichSelectCellEditor;

        /***/ },
    /* 373 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var RichSelectRow = function (_super) {
            __extends(RichSelectRow, _super);
            function RichSelectRow(cellRenderer) {
                _super.call(this, '<div class="ag-rich-select-row"></div>');
                this.cellRenderer = cellRenderer;
            }
            RichSelectRow.prototype.setState = function (value, selected) {
                if (main_1.Utils.exists(this.cellRenderer)) {
                    this.populateWithRenderer(value);
                } else {
                    this.populateWithoutRenderer(value);
                }
                main_1.Utils.addOrRemoveCssClass(this.getGui(), 'ag-rich-select-row-selected', selected);
            };
            RichSelectRow.prototype.populateWithoutRenderer = function (value) {
                if (main_1.Utils.exists(value) && value !== '') {
                    // not using innerHTML to prevent injection of HTML
                    // https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#Security_considerations
                    this.getGui().textContent = value.toString();
                }
            };
            RichSelectRow.prototype.populateWithRenderer = function (value) {
                var childComponent = this.cellRendererService.useCellRenderer(this.cellRenderer, this.getGui(), { value: value });
                if (childComponent && childComponent.destroy) {
                    this.addDestroyFunc(childComponent.destroy.bind(childComponent));
                }
            };
            __decorate([main_1.Autowired('cellRendererService'), __metadata('design:type', main_1.CellRendererService)], RichSelectRow.prototype, "cellRendererService", void 0);
            return RichSelectRow;
        }(main_1.Component);
        exports.RichSelectRow = RichSelectRow;

        /***/ },
    /* 374 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var main_2 = __webpack_require__(238);
        var md5_1 = __webpack_require__(375);
        var LicenseManager = function () {
            function LicenseManager() {}
            LicenseManager.prototype.validateLicense = function () {
                var gridReleaseDate = LicenseManager.getGridReleaseDate();
                var valid = false;
                var current = false;
                if (!main_2.Utils.missingOrEmpty(LicenseManager.licenseKey) && LicenseManager.licenseKey.length > 32) {
                    var hashStart = LicenseManager.licenseKey.length - 32;
                    var md5 = LicenseManager.licenseKey.substring(hashStart);
                    var license = LicenseManager.licenseKey.substring(0, hashStart);
                    if (md5 === this.md5.md5(license)) {
                        var restrictionHashed = license.substring(license.lastIndexOf('_') + 1, license.length);
                        var expiry = new Date(parseInt(LicenseManager.decode(restrictionHashed)));
                        if (!isNaN(expiry.getTime())) {
                            valid = true;
                            current = gridReleaseDate < expiry;
                        }
                    }
                }
                if (!valid) {
                    LicenseManager.outputMessage('********************************************* Invalid License **************************************************', '* Your license for ag-Grid Enterprise is not valid - please contact ag-Grid support to obtain a valid license. *');
                } else if (!current) {
                    var formattedExpiryDate = LicenseManager.formatDate(expiry);
                    var formattedReleaseDate = LicenseManager.formatDate(gridReleaseDate);
                    LicenseManager.outputMessage('********************* License not compatible with installed version of ag-Grid Enterprise. *********************', "Your license for ag-Grid Enterprise expired on " + formattedExpiryDate + " but the version installed was released on " + formattedReleaseDate + ". Please " + 'contact ag-Grid Support to renew your license');
                }
            };
            LicenseManager.outputMessage = function (header, message) {
                console.error('****************************************************************************************************************');
                console.error('*************************************** ag-Grid Enterprise License *********************************************');
                console.error(header);
                console.error(message);
                console.error('****************************************************************************************************************');
                console.error('****************************************************************************************************************');
            };
            LicenseManager.formatDate = function (date) {
                var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                var day = date.getDate();
                var monthIndex = date.getMonth();
                var year = date.getFullYear();
                return day + ' ' + monthNames[monthIndex] + ' ' + year;
            };
            LicenseManager.getGridReleaseDate = function () {
                return new Date(parseInt(LicenseManager.decode(LicenseManager.RELEASE_INFORMATION)));
            };
            ;
            LicenseManager.decode = function (input) {
                var keystr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
                var t = '';
                var n, r, i;
                var s, o, u, a;
                var f = 0;
                var e = input.replace(/[^A-Za-z0-9+/=]/g, '');
                while (f < e.length) {
                    s = keystr.indexOf(e.charAt(f++));
                    o = keystr.indexOf(e.charAt(f++));
                    u = keystr.indexOf(e.charAt(f++));
                    a = keystr.indexOf(e.charAt(f++));
                    n = s << 2 | o >> 4;
                    r = (o & 15) << 4 | u >> 2;
                    i = (u & 3) << 6 | a;
                    t = t + String.fromCharCode(n);
                    if (u != 64) {
                        t = t + String.fromCharCode(r);
                    }
                    if (a != 64) {
                        t = t + String.fromCharCode(i);
                    }
                }
                t = LicenseManager.utf8_decode(t);
                return t;
            };
            LicenseManager.utf8_decode = function (input) {
                input = input.replace(/rn/g, 'n');
                var t = '';
                for (var n = 0; n < input.length; n++) {
                    var r = input.charCodeAt(n);
                    if (r < 128) {
                        t += String.fromCharCode(r);
                    } else if (r > 127 && r < 2048) {
                        t += String.fromCharCode(r >> 6 | 192);
                        t += String.fromCharCode(r & 63 | 128);
                    } else {
                        t += String.fromCharCode(r >> 12 | 224);
                        t += String.fromCharCode(r >> 6 & 63 | 128);
                        t += String.fromCharCode(r & 63 | 128);
                    }
                }
                return t;
            };
            LicenseManager.setLicenseKey = function (licenseKey) {
                LicenseManager.licenseKey = licenseKey;
            };
            LicenseManager.RELEASE_INFORMATION = 'MTQ2ODM5ODkxNjg4MA==';
            __decorate([main_1.Autowired('md5'), __metadata('design:type', md5_1.MD5)], LicenseManager.prototype, "md5", void 0);
            LicenseManager = __decorate([main_1.Bean('licenseManager'), __metadata('design:paramtypes', [])], LicenseManager);
            return LicenseManager;
        }();
        exports.LicenseManager = LicenseManager;

        /***/ },
    /* 375 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var MD5 = function () {
            function MD5() {
                this.ieCompatibility = false;
            }
            MD5.prototype.init = function () {
                this.ieCompatibility = this.md5('hello') != '5d41402abc4b2a76b9719d911017c592';
            };
            MD5.prototype.md5cycle = function (x, k) {
                var a = x[0],
                    b = x[1],
                    c = x[2],
                    d = x[3];
                a = this.ff(a, b, c, d, k[0], 7, -680876936);
                d = this.ff(d, a, b, c, k[1], 12, -389564586);
                c = this.ff(c, d, a, b, k[2], 17, 606105819);
                b = this.ff(b, c, d, a, k[3], 22, -1044525330);
                a = this.ff(a, b, c, d, k[4], 7, -176418897);
                d = this.ff(d, a, b, c, k[5], 12, 1200080426);
                c = this.ff(c, d, a, b, k[6], 17, -1473231341);
                b = this.ff(b, c, d, a, k[7], 22, -45705983);
                a = this.ff(a, b, c, d, k[8], 7, 1770035416);
                d = this.ff(d, a, b, c, k[9], 12, -1958414417);
                c = this.ff(c, d, a, b, k[10], 17, -42063);
                b = this.ff(b, c, d, a, k[11], 22, -1990404162);
                a = this.ff(a, b, c, d, k[12], 7, 1804603682);
                d = this.ff(d, a, b, c, k[13], 12, -40341101);
                c = this.ff(c, d, a, b, k[14], 17, -1502002290);
                b = this.ff(b, c, d, a, k[15], 22, 1236535329);
                a = this.gg(a, b, c, d, k[1], 5, -165796510);
                d = this.gg(d, a, b, c, k[6], 9, -1069501632);
                c = this.gg(c, d, a, b, k[11], 14, 643717713);
                b = this.gg(b, c, d, a, k[0], 20, -373897302);
                a = this.gg(a, b, c, d, k[5], 5, -701558691);
                d = this.gg(d, a, b, c, k[10], 9, 38016083);
                c = this.gg(c, d, a, b, k[15], 14, -660478335);
                b = this.gg(b, c, d, a, k[4], 20, -405537848);
                a = this.gg(a, b, c, d, k[9], 5, 568446438);
                d = this.gg(d, a, b, c, k[14], 9, -1019803690);
                c = this.gg(c, d, a, b, k[3], 14, -187363961);
                b = this.gg(b, c, d, a, k[8], 20, 1163531501);
                a = this.gg(a, b, c, d, k[13], 5, -1444681467);
                d = this.gg(d, a, b, c, k[2], 9, -51403784);
                c = this.gg(c, d, a, b, k[7], 14, 1735328473);
                b = this.gg(b, c, d, a, k[12], 20, -1926607734);
                a = this.hh(a, b, c, d, k[5], 4, -378558);
                d = this.hh(d, a, b, c, k[8], 11, -2022574463);
                c = this.hh(c, d, a, b, k[11], 16, 1839030562);
                b = this.hh(b, c, d, a, k[14], 23, -35309556);
                a = this.hh(a, b, c, d, k[1], 4, -1530992060);
                d = this.hh(d, a, b, c, k[4], 11, 1272893353);
                c = this.hh(c, d, a, b, k[7], 16, -155497632);
                b = this.hh(b, c, d, a, k[10], 23, -1094730640);
                a = this.hh(a, b, c, d, k[13], 4, 681279174);
                d = this.hh(d, a, b, c, k[0], 11, -358537222);
                c = this.hh(c, d, a, b, k[3], 16, -722521979);
                b = this.hh(b, c, d, a, k[6], 23, 76029189);
                a = this.hh(a, b, c, d, k[9], 4, -640364487);
                d = this.hh(d, a, b, c, k[12], 11, -421815835);
                c = this.hh(c, d, a, b, k[15], 16, 530742520);
                b = this.hh(b, c, d, a, k[2], 23, -995338651);
                a = this.ii(a, b, c, d, k[0], 6, -198630844);
                d = this.ii(d, a, b, c, k[7], 10, 1126891415);
                c = this.ii(c, d, a, b, k[14], 15, -1416354905);
                b = this.ii(b, c, d, a, k[5], 21, -57434055);
                a = this.ii(a, b, c, d, k[12], 6, 1700485571);
                d = this.ii(d, a, b, c, k[3], 10, -1894986606);
                c = this.ii(c, d, a, b, k[10], 15, -1051523);
                b = this.ii(b, c, d, a, k[1], 21, -2054922799);
                a = this.ii(a, b, c, d, k[8], 6, 1873313359);
                d = this.ii(d, a, b, c, k[15], 10, -30611744);
                c = this.ii(c, d, a, b, k[6], 15, -1560198380);
                b = this.ii(b, c, d, a, k[13], 21, 1309151649);
                a = this.ii(a, b, c, d, k[4], 6, -145523070);
                d = this.ii(d, a, b, c, k[11], 10, -1120210379);
                c = this.ii(c, d, a, b, k[2], 15, 718787259);
                b = this.ii(b, c, d, a, k[9], 21, -343485551);
                x[0] = this.add32(a, x[0]);
                x[1] = this.add32(b, x[1]);
                x[2] = this.add32(c, x[2]);
                x[3] = this.add32(d, x[3]);
            };
            MD5.prototype.cmn = function (q, a, b, x, s, t) {
                a = this.add32(this.add32(a, q), this.add32(x, t));
                return this.add32(a << s | a >>> 32 - s, b);
            };
            MD5.prototype.ff = function (a, b, c, d, x, s, t) {
                return this.cmn(b & c | ~b & d, a, b, x, s, t);
            };
            MD5.prototype.gg = function (a, b, c, d, x, s, t) {
                return this.cmn(b & d | c & ~d, a, b, x, s, t);
            };
            MD5.prototype.hh = function (a, b, c, d, x, s, t) {
                return this.cmn(b ^ c ^ d, a, b, x, s, t);
            };
            MD5.prototype.ii = function (a, b, c, d, x, s, t) {
                return this.cmn(c ^ (b | ~d), a, b, x, s, t);
            };
            MD5.prototype.md51 = function (s) {
                var n = s.length,
                    state = [1732584193, -271733879, -1732584194, 271733878],
                    i;
                for (i = 64; i <= s.length; i += 64) {
                    this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));
                }
                s = s.substring(i - 64);
                var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                for (i = 0; i < s.length; i++) {
                    tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
                }tail[i >> 2] |= 0x80 << (i % 4 << 3);
                if (i > 55) {
                    this.md5cycle(state, tail);
                    for (i = 0; i < 16; i++) {
                        tail[i] = 0;
                    }
                }
                tail[14] = n * 8;
                this.md5cycle(state, tail);
                return state;
            };
            /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
             * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
             * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
             * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
             * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
             * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
             * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
             */
            MD5.prototype.md5blk = function (s) {
                var md5blks = [],
                    i;
                /* Andy King said do it this way. */
                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                }
                return md5blks;
            };
            MD5.prototype.rhex = function (n) {
                var hex_chr = '0123456789abcdef'.split('');
                var s = '',
                    j = 0;
                for (; j < 4; j++) {
                    s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];
                }return s;
            };
            MD5.prototype.hex = function (x) {
                for (var i = 0; i < x.length; i++) {
                    x[i] = this.rhex(x[i]);
                }return x.join('');
            };
            MD5.prototype.md5 = function (s) {
                return this.hex(this.md51(s));
            };
            MD5.prototype.add32 = function (a, b) {
                return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);
            };
            /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
             need the idiotic second function, generated by an if clause.  */
            MD5.prototype.add32Std = function (a, b) {
                return a + b & 0xFFFFFFFF;
            };
            MD5.prototype.add32Compat = function (x, y) {
                var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                    msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                return msw << 16 | lsw & 0xFFFF;
            };
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], MD5.prototype, "init", null);
            MD5 = __decorate([main_1.Bean('md5'), __metadata('design:paramtypes', [])], MD5);
            return MD5;
        }();
        exports.MD5 = MD5;

        /***/ },
    /* 376 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var statusItem_1 = __webpack_require__(377);
        var rangeController_1 = __webpack_require__(361);
        var StatusBar = function (_super) {
            __extends(StatusBar, _super);
            function StatusBar() {
                _super.call(this, StatusBar.TEMPLATE);
                this.aggregationsComponent = new main_1.Component('<div class="ag-status-bar-aggregations"></div>');
            }
            StatusBar.prototype.init = function () {
                this.createStatusItems();
                this.eventService.addEventListener(main_1.Events.EVENT_RANGE_SELECTION_CHANGED, this.onRangeSelectionChanged.bind(this));
            };
            StatusBar.prototype.createStatusItems = function () {
                var _this = this;
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                this.statusItemSum = new statusItem_1.StatusItem(localeTextFunc('sum', 'Sum'));
                this.statusItemCount = new statusItem_1.StatusItem(localeTextFunc('count', 'Count'));
                this.statusItemMin = new statusItem_1.StatusItem(localeTextFunc('min', 'Min'));
                this.statusItemMax = new statusItem_1.StatusItem(localeTextFunc('max', 'Max'));
                this.statusItemAvg = new statusItem_1.StatusItem(localeTextFunc('average', 'Average'));
                this.forEachStatusItem(function (statusItem) {
                    _this.context.wireBean(statusItem);
                    _this.aggregationsComponent.appendChild(statusItem);
                    statusItem.setVisible(false);
                });
                this.appendChild(this.aggregationsComponent);
            };
            StatusBar.prototype.forEachStatusItem = function (callback) {
                [this.statusItemAvg, this.statusItemCount, this.statusItemMin, this.statusItemMax, this.statusItemSum].forEach(callback);
            };
            StatusBar.prototype.onRangeSelectionChanged = function () {
                var _this = this;
                var cellRanges = this.rangeController.getCellRanges();
                var sum = 0;
                var count = 0;
                var numberCount = 0;
                var min = null;
                var max = null;
                var cellsSoFar = {};
                if (!main_1.Utils.missingOrEmpty(cellRanges)) {
                    cellRanges.forEach(function (cellRange) {
                        // get starting and ending row, remember rowEnd could be before rowStart
                        var startRow = cellRange.start.getGridRow();
                        var endRow = cellRange.end.getGridRow();
                        var startRowIsFirst = startRow.before(endRow);
                        var currentRow = startRowIsFirst ? startRow : endRow;
                        var lastRow = startRowIsFirst ? endRow : startRow;
                        while (true) {
                            cellRange.columns.forEach(function (column) {
                                // we only want to include each cell once, in case a cell is in multiple ranges
                                var cellId = currentRow.getGridCell(column).createId();
                                if (cellsSoFar[cellId]) {
                                    return;
                                }
                                cellsSoFar[cellId] = true;
                                var rowNode = _this.getRowNode(currentRow);
                                var value = _this.valueService.getValue(column, rowNode);
                                // if empty cell, skip it, doesn't impact count or anything
                                if (main_1.Utils.missing(value) || value === '') {
                                    return;
                                }
                                // see if value is wrapped, can happen when doing count() or avg() functions
                                if (value.value) {
                                    value = value.value;
                                }
                                if (typeof value === 'string') {
                                    value = Number(value);
                                }
                                if (typeof value === 'number' && !isNaN(value)) {
                                    sum += value;
                                    if (max === null || value > max) {
                                        max = value;
                                    }
                                    if (min === null || value < min) {
                                        min = value;
                                    }
                                    numberCount++;
                                }
                                count++;
                            });
                            if (currentRow.equals(lastRow)) {
                                break;
                            }
                            currentRow = _this.cellNavigationService.getRowBelow(currentRow);
                        }
                    });
                }
                var gotResult = count > 1;
                var gotNumberResult = numberCount > 0;
                // we should count even if no numbers
                if (gotResult) {
                    this.statusItemCount.setValue(count);
                }
                this.statusItemCount.setVisible(gotResult);
                // if numbers, then show the number items
                if (gotNumberResult) {
                    this.statusItemSum.setValue(sum);
                    this.statusItemMin.setValue(min);
                    this.statusItemMax.setValue(max);
                    this.statusItemAvg.setValue(sum / numberCount);
                }
                this.statusItemSum.setVisible(gotNumberResult);
                this.statusItemMin.setVisible(gotNumberResult);
                this.statusItemMax.setVisible(gotNumberResult);
                this.statusItemAvg.setVisible(gotNumberResult);
            };
            StatusBar.prototype.getRowNode = function (gridRow) {
                switch (gridRow.floating) {
                    case main_1.Constants.FLOATING_TOP:
                        return this.floatingRowModel.getFloatingTopRowData()[gridRow.rowIndex];
                    case main_1.Constants.FLOATING_BOTTOM:
                        return this.floatingRowModel.getFloatingBottomRowData()[gridRow.rowIndex];
                    default:
                        return this.rowModel.getRow(gridRow.rowIndex);
                }
            };
            StatusBar.TEMPLATE = '<div class="ag-status-bar">' + '</div>';
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], StatusBar.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('rangeController'), __metadata('design:type', rangeController_1.RangeController)], StatusBar.prototype, "rangeController", void 0);
            __decorate([main_1.Autowired('valueService'), __metadata('design:type', main_1.ValueService)], StatusBar.prototype, "valueService", void 0);
            __decorate([main_1.Autowired('cellNavigationService'), __metadata('design:type', main_1.CellNavigationService)], StatusBar.prototype, "cellNavigationService", void 0);
            __decorate([main_1.Autowired('floatingRowModel'), __metadata('design:type', main_1.FloatingRowModel)], StatusBar.prototype, "floatingRowModel", void 0);
            __decorate([main_1.Autowired('rowModel'), __metadata('design:type', Object)], StatusBar.prototype, "rowModel", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], StatusBar.prototype, "context", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], StatusBar.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], StatusBar.prototype, "init", null);
            StatusBar = __decorate([main_1.Bean('statusBar'), __metadata('design:paramtypes', [])], StatusBar);
            return StatusBar;
        }(main_1.Component);
        exports.StatusBar = StatusBar;

        /***/ },
    /* 377 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var StatusItem = function (_super) {
            __extends(StatusItem, _super);
            function StatusItem(label) {
                _super.call(this, StatusItem.TEMPLATE);
                this.queryForHtmlElement('#_label').innerHTML = label;
            }
            StatusItem.prototype.init = function () {
                this.lbValue = this.queryForHtmlElement('#_value');
            };
            StatusItem.prototype.setValue = function (value) {
                this.lbValue.innerHTML = main_1.Utils.formatNumberTwoDecimalPlacesAndCommas(value);
            };
            StatusItem.TEMPLATE = '<span class="ag-status-bar-item">' + '  <span id="_label"></span>' + '  <span id="_value"></span>' + '</span>';
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], StatusItem.prototype, "init", null);
            return StatusItem;
        }(main_1.Component);
        exports.StatusItem = StatusItem;

        /***/ },
    /* 378 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var clipboardService_1 = __webpack_require__(362);
        var svgFactory = main_1.SvgFactory.getInstance();
        var ContextMenuFactory = function () {
            function ContextMenuFactory() {}
            ContextMenuFactory.prototype.init = function () {};
            ContextMenuFactory.prototype.getMenuItems = function (node, column, value) {
                var defaultMenuOptions;
                if (main_1.Utils.exists(node)) {
                    // if user clicks a cell
                    defaultMenuOptions = ['copy', 'copyWithHeaders', 'paste', 'separator', 'toolPanel'];
                } else {
                    // if user clicks outside of a cell (eg below the rows, or not rows present)
                    defaultMenuOptions = ['toolPanel'];
                }
                if (this.gridOptionsWrapper.getContextMenuItemsFunc()) {
                    var userFunc = this.gridOptionsWrapper.getContextMenuItemsFunc();
                    var params = {
                        node: node,
                        column: column,
                        value: value,
                        defaultItems: defaultMenuOptions,
                        api: this.gridOptionsWrapper.getApi(),
                        columnApi: this.gridOptionsWrapper.getColumnApi(),
                        context: this.gridOptionsWrapper.getContext()
                    };
                    var menuItemsFromUser = userFunc(params);
                    return menuItemsFromUser;
                } else {
                    return defaultMenuOptions;
                }
            };
            ContextMenuFactory.prototype.showMenu = function (node, column, value, mouseEvent) {
                var menuItems = this.getMenuItems(node, column, value);
                var menu = new ContextMenu(menuItems);
                this.context.wireBean(menu);
                var eMenuGui = menu.getGui();
                // need to show filter before positioning, as only after filter
                // is visible can we find out what the width of it is
                var hidePopup = this.popupService.addAsModalPopup(eMenuGui, true, function () {
                    return menu.destroy();
                });
                this.popupService.positionPopupUnderMouseEvent({
                    mouseEvent: mouseEvent,
                    ePopup: eMenuGui
                });
                menu.afterGuiAttached(hidePopup);
            };
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], ContextMenuFactory.prototype, "context", void 0);
            __decorate([main_1.Autowired('popupService'), __metadata('design:type', main_1.PopupService)], ContextMenuFactory.prototype, "popupService", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], ContextMenuFactory.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ContextMenuFactory.prototype, "init", null);
            ContextMenuFactory = __decorate([main_1.Bean('contextMenuFactory'), __metadata('design:paramtypes', [])], ContextMenuFactory);
            return ContextMenuFactory;
        }();
        exports.ContextMenuFactory = ContextMenuFactory;
        var ContextMenu = function (_super) {
            __extends(ContextMenu, _super);
            function ContextMenu(menuItems) {
                _super.call(this, '<div class="ag-menu"></div>');
                this.menuItems = menuItems;
            }
            ContextMenu.prototype.createDefaultMenuItems = function () {
                var _this = this;
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                var result = {
                    copy: {
                        name: localeTextFunc('copy', 'Copy'),
                        shortcut: localeTextFunc('ctrlC', 'Ctrl+C'),
                        icon: svgFactory.createCopyIcon(),
                        action: function action() {
                            return _this.clipboardService.copyToClipboard(false);
                        }
                    },
                    copyWithHeaders: {
                        name: localeTextFunc('copyWithHeaders', 'Copy with Headers'),
                        // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
                        icon: svgFactory.createCopyIcon(),
                        action: function action() {
                            return _this.clipboardService.copyToClipboard(true);
                        }
                    },
                    paste: {
                        name: localeTextFunc('paste', 'Paste'),
                        shortcut: localeTextFunc('ctrlV', 'Ctrl+V'),
                        disabled: true,
                        icon: svgFactory.createPasteIcon(),
                        action: function action() {
                            return _this.clipboardService.pasteFromClipboard();
                        }
                    },
                    toolPanel: {
                        name: localeTextFunc('toolPanel', 'Tool Panel'),
                        checked: this.gridApi.isToolPanelShowing(),
                        action: function action() {
                            return _this.gridApi.showToolPanel(!_this.gridApi.isToolPanelShowing());
                        }
                    }
                };
                return result;
            };
            ContextMenu.prototype.addMenuItems = function () {
                this.menuList = new main_1.MenuList();
                this.context.wireBean(this.menuList);
                var defaultMenuItems = this.createDefaultMenuItems();
                this.menuList.addMenuItems(this.menuItems, defaultMenuItems);
                this.getGui().appendChild(this.menuList.getGui());
                this.menuList.addEventListener(main_1.MenuItemComponent.EVENT_ITEM_SELECTED, this.onHidePopup.bind(this));
            };
            ContextMenu.prototype.onHidePopup = function () {
                this.hidePopupFunc();
            };
            ContextMenu.prototype.afterGuiAttached = function (hidePopup) {
                this.hidePopupFunc = hidePopup;
            };
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], ContextMenu.prototype, "context", void 0);
            __decorate([main_1.Autowired('clipboardService'), __metadata('design:type', clipboardService_1.ClipboardService)], ContextMenu.prototype, "clipboardService", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], ContextMenu.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('gridApi'), __metadata('design:type', main_1.GridApi)], ContextMenu.prototype, "gridApi", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ContextMenu.prototype, "addMenuItems", null);
            return ContextMenu;
        }(main_1.Component);

        /***/ },
    /* 379 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var ViewportRowModel = function () {
            function ViewportRowModel() {
                // rowRenderer tells us these
                this.firstRow = -1;
                this.lastRow = -1;
                // datasource tells us this
                this.rowCount = -1;
                this.rowNodesByIndex = {};
            }
            ViewportRowModel.prototype.init = function () {
                this.rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();
                this.eventService.addEventListener(main_1.Events.EVENT_VIEWPORT_CHANGED, this.onViewportChanged.bind(this));
                var viewportEnabled = this.gridOptionsWrapper.isRowModelViewport();
                if (viewportEnabled && this.gridOptionsWrapper.getViewportDatasource()) {
                    this.setViewportDatasource(this.gridOptionsWrapper.getViewportDatasource());
                }
            };
            ViewportRowModel.prototype.destroy = function () {
                this.destroyCurrentDatasource();
            };
            ViewportRowModel.prototype.destroyCurrentDatasource = function () {
                if (this.viewportDatasource && this.viewportDatasource.destroy) {
                    this.viewportDatasource.destroy();
                }
            };
            ViewportRowModel.prototype.calculateFirstRow = function (firstRenderedRow) {
                var bufferSize = this.gridOptionsWrapper.getViewportRowModelBufferSize();
                var pageSize = this.gridOptionsWrapper.getViewportRowModelPageSize();
                var afterBuffer = firstRenderedRow - bufferSize;
                if (afterBuffer < 0) {
                    return 0;
                } else {
                    return Math.floor(afterBuffer / pageSize) * pageSize;
                }
            };
            ViewportRowModel.prototype.calculateLastRow = function (lastRenderedRow) {
                var bufferSize = this.gridOptionsWrapper.getViewportRowModelBufferSize();
                var pageSize = this.gridOptionsWrapper.getViewportRowModelPageSize();
                var afterBuffer = lastRenderedRow + bufferSize;
                var result = Math.ceil(afterBuffer / pageSize) * pageSize;
                if (result <= this.rowCount) {
                    return result;
                } else {
                    return this.rowCount;
                }
            };
            ViewportRowModel.prototype.onViewportChanged = function (event) {
                var newFirst = this.calculateFirstRow(event.firstRow);
                var newLast = this.calculateLastRow(event.lastRow);
                if (this.firstRow !== newFirst || this.lastRow !== newLast) {
                    this.firstRow = newFirst;
                    this.lastRow = newLast;
                    this.purgeRowsNotInViewport();
                    if (this.viewportDatasource) {
                        this.viewportDatasource.setViewportRange(this.firstRow, this.lastRow);
                    }
                }
            };
            ViewportRowModel.prototype.purgeRowsNotInViewport = function () {
                var _this = this;
                Object.keys(this.rowNodesByIndex).forEach(function (indexStr) {
                    var index = parseInt(indexStr);
                    if (index < _this.firstRow || index > _this.lastRow) {
                        delete _this.rowNodesByIndex[index];
                    }
                });
            };
            ViewportRowModel.prototype.setViewportDatasource = function (viewportDatasource) {
                this.destroyCurrentDatasource();
                this.viewportDatasource = viewportDatasource;
                this.rowCount = 0;
                if (!viewportDatasource.init) {
                    console.warn('ag-Grid: viewport is missing init method.');
                } else {
                    viewportDatasource.init({
                        setRowCount: this.setRowCount.bind(this),
                        setRowData: this.setRowData.bind(this),
                        getRow: this.getRow.bind(this)
                    });
                }
            };
            ViewportRowModel.prototype.getType = function () {
                return main_1.Constants.ROW_MODEL_TYPE_VIEWPORT;
            };
            ViewportRowModel.prototype.getRow = function (rowIndex) {
                if (!this.rowNodesByIndex[rowIndex]) {
                    this.rowNodesByIndex[rowIndex] = this.createNode(null, rowIndex);
                }
                return this.rowNodesByIndex[rowIndex];
            };
            ViewportRowModel.prototype.getRowCount = function () {
                return this.rowCount;
            };
            ViewportRowModel.prototype.getRowIndexAtPixel = function (pixel) {
                if (this.rowHeight !== 0) {
                    return Math.floor(pixel / this.rowHeight);
                } else {
                    return 0;
                }
            };
            ViewportRowModel.prototype.getRowCombinedHeight = function () {
                return this.rowCount * this.rowHeight;
            };
            ViewportRowModel.prototype.isEmpty = function () {
                return this.rowCount > 0;
            };
            ViewportRowModel.prototype.isRowsToRender = function () {
                return this.rowCount > 0;
            };
            ViewportRowModel.prototype.forEachNode = function (callback) {
                var _this = this;
                var callbackCount = 0;
                Object.keys(this.rowNodesByIndex).forEach(function (indexStr) {
                    var index = parseInt(indexStr);
                    var rowNode = _this.rowNodesByIndex[index];
                    callback(rowNode, callbackCount);
                    callbackCount++;
                });
            };
            ViewportRowModel.prototype.setRowData = function (rowData) {
                var _this = this;
                main_1.Utils.iterateObject(rowData, function (indexStr, dataItem) {
                    var index = parseInt(indexStr);
                    // we should never keep rows that we didn't specifically ask for, this
                    // guarantees the contract we have with the server.
                    if (index >= _this.firstRow && index <= _this.lastRow) {
                        var nodeAlreadyExists = !!_this.rowNodesByIndex[index];
                        if (nodeAlreadyExists) {
                            // if the grid already asked for this row (the normal case), then we would
                            // of put a placeholder node in place.
                            _this.rowNodesByIndex[index].setData(dataItem);
                        } else {
                            // the abnormal case is we requested a row even though the grid didn't need it
                            // as a result of the paging and buffer (ie the row is off screen), in which
                            // case we need to create a new node now
                            _this.rowNodesByIndex[index] = _this.createNode(dataItem, index);
                        }
                    }
                });
            };
            // this is duplicated in virtualPageRowModel, need to refactor
            ViewportRowModel.prototype.createNode = function (data, rowIndex) {
                var rowHeight = this.rowHeight;
                var top = rowHeight * rowIndex;
                // need to refactor this, get it in sync with VirtualPageRowController, which was not
                // written with the rowNode.rowUpdated in mind
                var rowNode = new main_1.RowNode();
                this.context.wireBean(rowNode);
                rowNode.id = rowIndex.toString();
                rowNode.data = data;
                rowNode.rowTop = top;
                rowNode.rowHeight = rowHeight;
                return rowNode;
            };
            ViewportRowModel.prototype.setRowCount = function (rowCount) {
                if (rowCount !== this.rowCount) {
                    this.rowCount = rowCount;
                    this.eventService.dispatchEvent(main_1.Events.EVENT_MODEL_UPDATED);
                }
            };
            ViewportRowModel.prototype.insertItemsAtIndex = function (index, items) {
                console.log('not yet supported');
            };
            ViewportRowModel.prototype.removeItems = function (rowNodes) {
                console.log('not yet supported');
            };
            ViewportRowModel.prototype.addItems = function (item) {
                console.log('not yet supported');
            };
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], ViewportRowModel.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], ViewportRowModel.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('selectionController'), __metadata('design:type', main_1.SelectionController)], ViewportRowModel.prototype, "selectionController", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], ViewportRowModel.prototype, "context", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ViewportRowModel.prototype, "init", null);
            __decorate([main_1.PreDestroy, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ViewportRowModel.prototype, "destroy", null);
            ViewportRowModel = __decorate([main_1.Bean('rowModel'), __metadata('design:paramtypes', [])], ViewportRowModel);
            return ViewportRowModel;
        }();
        exports.ViewportRowModel = ViewportRowModel;

        /***/ },
    /* 380 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var abstractColumnDropPanel_1 = __webpack_require__(381);
        var svgFactory = main_1.SvgFactory.getInstance();
        var PivotColumnsPanel = function (_super) {
            __extends(PivotColumnsPanel, _super);
            function PivotColumnsPanel(horizontal) {
                _super.call(this, horizontal, false);
            }
            PivotColumnsPanel.prototype.passBeansUp = function () {
                _super.prototype.setBeans.call(this, {
                    gridOptionsWrapper: this.gridOptionsWrapper,
                    eventService: this.eventService,
                    context: this.context,
                    loggerFactory: this.loggerFactory,
                    dragAndDropService: this.dragAndDropService
                });
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                var emptyMessage = localeTextFunc('pivotColumnsEmptyMessage', 'Drag here to pivot');
                var title = localeTextFunc('pivots', 'Pivots');
                _super.prototype.init.call(this, {
                    dragAndDropIcon: main_1.DragAndDropService.ICON_GROUP,
                    iconFactory: svgFactory.createPivotIcon,
                    emptyMessage: emptyMessage,
                    title: title
                });
                this.addDestroyableEventListener(this.eventService, main_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.refresh.bind(this));
                this.addDestroyableEventListener(this.eventService, main_1.Events.EVENT_COLUMN_PIVOT_CHANGED, this.refresh.bind(this));
                this.addDestroyableEventListener(this.eventService, main_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.checkVisibility.bind(this));
                this.refresh();
            };
            PivotColumnsPanel.prototype.refresh = function () {
                this.checkVisibility();
                this.refreshGui();
            };
            PivotColumnsPanel.prototype.checkVisibility = function () {
                var pivotMode = this.columnController.isPivotMode();
                if (this.isHorizontal()) {
                    // what we do for horizontal (ie the pivot panel at the top) depends
                    // on the user property as well as pivotMode.
                    switch (this.gridOptionsWrapper.getPivotPanelShow()) {
                        case 'always':
                            this.setVisible(pivotMode);
                            break;
                        case 'onlyWhenPivoting':
                            var pivotActive = this.columnController.isPivotActive();
                            this.setVisible(pivotMode && pivotActive);
                            break;
                        default:
                            // never show it
                            this.setVisible(false);
                            break;
                    }
                } else {
                    // in toolPanel, the pivot panel is always shown when pivot mode is on
                    this.setVisible(pivotMode);
                }
            };
            PivotColumnsPanel.prototype.isColumnDroppable = function (column) {
                if (this.gridOptionsWrapper.isFunctionsReadOnly()) {
                    return false;
                }
                // we never allow grouping of secondary columns
                if (!column.isPrimary()) {
                    return false;
                }
                var allowPivot = column.isAllowPivot();
                var columnNotAlreadyPivoted = !column.isPivotActive();
                return allowPivot && columnNotAlreadyPivoted;
            };
            PivotColumnsPanel.prototype.removeColumns = function (columns) {
                if (this.gridOptionsWrapper.isFunctionsPassive()) {
                    this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_PIVOT_REMOVE_REQUEST, { columns: columns });
                } else {
                    var columnsPivoted = main_1.Utils.filter(columns, function (column) {
                        return column.isPivotActive();
                    });
                    this.columnController.removePivotColumns(columnsPivoted);
                }
            };
            PivotColumnsPanel.prototype.getIconName = function () {
                return this.isPotentialDndColumns() ? main_1.DragAndDropService.ICON_PIVOT : main_1.DragAndDropService.ICON_NOT_ALLOWED;
            };
            PivotColumnsPanel.prototype.addColumns = function (columns) {
                if (this.gridOptionsWrapper.isFunctionsPassive()) {
                    this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_PIVOT_ADD_REQUEST, { columns: columns });
                } else {
                    this.columnController.addPivotColumns(columns);
                }
            };
            PivotColumnsPanel.prototype.getExistingColumns = function () {
                return this.columnController.getPivotColumns();
            };
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], PivotColumnsPanel.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], PivotColumnsPanel.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], PivotColumnsPanel.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], PivotColumnsPanel.prototype, "context", void 0);
            __decorate([main_1.Autowired('loggerFactory'), __metadata('design:type', main_1.LoggerFactory)], PivotColumnsPanel.prototype, "loggerFactory", void 0);
            __decorate([main_1.Autowired('dragAndDropService'), __metadata('design:type', main_1.DragAndDropService)], PivotColumnsPanel.prototype, "dragAndDropService", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], PivotColumnsPanel.prototype, "passBeansUp", null);
            return PivotColumnsPanel;
        }(abstractColumnDropPanel_1.AbstractColumnDropPanel);
        exports.PivotColumnsPanel = PivotColumnsPanel;

        /***/ },
    /* 381 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var main_1 = __webpack_require__(238);
        var columnComponent_1 = __webpack_require__(382);
        var AbstractColumnDropPanel = function (_super) {
            __extends(AbstractColumnDropPanel, _super);
            function AbstractColumnDropPanel(horizontal, valueColumn) {
                _super.call(this, "<div class=\"ag-column-drop ag-font-style ag-column-drop-" + (horizontal ? 'horizontal' : 'vertical') + "\"></div>");
                this.guiDestroyFunctions = [];
                this.horizontal = horizontal;
                this.valueColumn = valueColumn;
            }
            AbstractColumnDropPanel.prototype.isHorizontal = function () {
                return this.horizontal;
            };
            AbstractColumnDropPanel.prototype.setBeans = function (beans) {
                this.beans = beans;
            };
            AbstractColumnDropPanel.prototype.destroy = function () {
                this.destroyGui();
                _super.prototype.destroy.call(this);
            };
            AbstractColumnDropPanel.prototype.destroyGui = function () {
                this.guiDestroyFunctions.forEach(function (func) {
                    return func();
                });
                this.guiDestroyFunctions.length = 0;
                main_1.Utils.removeAllChildren(this.getGui());
            };
            AbstractColumnDropPanel.prototype.init = function (params) {
                this.params = params;
                this.logger = this.beans.loggerFactory.create('AbstractColumnDropPanel');
                this.beans.eventService.addEventListener(main_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.refreshGui.bind(this));
                this.addDestroyableEventListener(this.beans.gridOptionsWrapper, 'functionsReadOnly', this.refreshGui.bind(this));
                this.setupDropTarget();
                // we don't know if this bean will be initialised before columnController.
                // if columnController first, then below will work
                // if columnController second, then below will put blank in, and then above event gets first when columnController is set up
                this.refreshGui();
            };
            AbstractColumnDropPanel.prototype.setupDropTarget = function () {
                this.dropTarget = {
                    getContainer: this.getGui.bind(this),
                    getIconName: this.getIconName.bind(this),
                    onDragging: this.onDragging.bind(this),
                    onDragEnter: this.onDragEnter.bind(this),
                    onDragLeave: this.onDragLeave.bind(this),
                    onDragStop: this.onDragStop.bind(this)
                };
                this.beans.dragAndDropService.addDropTarget(this.dropTarget);
            };
            AbstractColumnDropPanel.prototype.onDragging = function () {};
            AbstractColumnDropPanel.prototype.onDragEnter = function (draggingEvent) {
                // this will contain all columns that are potential drops
                var dragColumns = draggingEvent.dragSource.dragItem;
                // take out columns that are not groupable
                var goodDragColumns = main_1.Utils.filter(dragColumns, this.isColumnDroppable.bind(this));
                var weHaveColumnsToDrag = goodDragColumns.length > 0;
                if (weHaveColumnsToDrag) {
                    this.potentialDndColumns = goodDragColumns;
                    this.refreshGui();
                }
            };
            AbstractColumnDropPanel.prototype.isPotentialDndColumns = function () {
                return main_1.Utils.existsAndNotEmpty(this.potentialDndColumns);
            };
            AbstractColumnDropPanel.prototype.onDragLeave = function (draggingEvent) {
                // if the dragging started from us, we remove the group, however if it started
                // someplace else, then we don't, as it was only 'asking'
                var thisPanelStartedTheDrag = draggingEvent.dragSource.dragSourceDropTarget === this.dropTarget;
                if (thisPanelStartedTheDrag) {
                    var columns = draggingEvent.dragSource.dragItem;
                    this.removeColumns(columns);
                }
                if (this.potentialDndColumns) {
                    this.potentialDndColumns = null;
                    this.refreshGui();
                }
            };
            AbstractColumnDropPanel.prototype.onDragStop = function () {
                if (this.potentialDndColumns) {
                    this.addColumns(this.potentialDndColumns);
                    this.potentialDndColumns = null;
                    this.refreshGui();
                }
            };
            AbstractColumnDropPanel.prototype.refreshGui = function () {
                this.destroyGui();
                this.addIconAndTitleToGui();
                this.addEmptyMessageToGui();
                this.addExistingColumnsToGui();
                this.addPotentialDragItemsToGui();
            };
            AbstractColumnDropPanel.prototype.addPotentialDragItemsToGui = function () {
                var _this = this;
                var first = this.isExistingColumnsEmpty();
                if (this.potentialDndColumns) {
                    this.potentialDndColumns.forEach(function (column) {
                        if (!first) {
                            _this.addArrowToGui();
                        }
                        first = false;
                        var ghostCell = new columnComponent_1.ColumnComponent(column, _this.dropTarget, true, _this.valueColumn);
                        ghostCell.addEventListener(columnComponent_1.ColumnComponent.EVENT_COLUMN_REMOVE, _this.removeColumns.bind(_this, [column]));
                        _this.beans.context.wireBean(ghostCell);
                        _this.getGui().appendChild(ghostCell.getGui());
                        _this.guiDestroyFunctions.push(function () {
                            return ghostCell.destroy();
                        });
                    });
                }
            };
            AbstractColumnDropPanel.prototype.addExistingColumnsToGui = function () {
                var _this = this;
                var existingColumns = this.getExistingColumns();
                existingColumns.forEach(function (column, index) {
                    if (index > 0) {
                        _this.addArrowToGui();
                    }
                    var cell = new columnComponent_1.ColumnComponent(column, _this.dropTarget, false, _this.valueColumn);
                    cell.addEventListener(columnComponent_1.ColumnComponent.EVENT_COLUMN_REMOVE, _this.removeColumns.bind(_this, [column]));
                    _this.beans.context.wireBean(cell);
                    _this.getGui().appendChild(cell.getGui());
                    _this.guiDestroyFunctions.push(function () {
                        return cell.destroy();
                    });
                });
            };
            AbstractColumnDropPanel.prototype.addIconAndTitleToGui = function () {
                var iconFaded = this.horizontal && this.isExistingColumnsEmpty();
                var eGroupIcon = this.params.iconFactory();
                main_1.Utils.addCssClass(eGroupIcon, 'ag-column-drop-icon');
                main_1.Utils.addOrRemoveCssClass(eGroupIcon, 'ag-faded', iconFaded);
                this.getGui().appendChild(eGroupIcon);
                if (!this.horizontal) {
                    var eTitle = document.createElement('span');
                    eTitle.innerHTML = this.params.title;
                    main_1.Utils.addCssClass(eTitle, 'ag-column-drop-title');
                    main_1.Utils.addOrRemoveCssClass(eTitle, 'ag-faded', iconFaded);
                    this.getGui().appendChild(eTitle);
                }
            };
            AbstractColumnDropPanel.prototype.isExistingColumnsEmpty = function () {
                return this.getExistingColumns().length === 0;
            };
            AbstractColumnDropPanel.prototype.addEmptyMessageToGui = function () {
                var showEmptyMessage = this.isExistingColumnsEmpty() && !this.potentialDndColumns;
                if (!showEmptyMessage) {
                    return;
                }
                var eMessage = document.createElement('span');
                eMessage.innerHTML = this.params.emptyMessage;
                main_1.Utils.addCssClass(eMessage, 'ag-column-drop-empty-message');
                this.getGui().appendChild(eMessage);
            };
            AbstractColumnDropPanel.prototype.addArrowToGui = function () {
                // only add the arrows if the layout is horizontal
                if (this.horizontal) {
                    var eArrow = document.createElement('span');
                    eArrow.innerHTML = '&#8594;';
                    this.getGui().appendChild(eArrow);
                }
            };
            return AbstractColumnDropPanel;
        }(main_1.Component);
        exports.AbstractColumnDropPanel = AbstractColumnDropPanel;

        /***/ },
    /* 382 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var virtualList_1 = __webpack_require__(371);
        var aggFuncService_1 = __webpack_require__(360);
        var ColumnComponent = function (_super) {
            __extends(ColumnComponent, _super);
            function ColumnComponent(column, dragSourceDropTarget, ghost, valueColumn) {
                _super.call(this, ColumnComponent.TEMPLATE);
                this.popupShowing = false;
                this.valueColumn = valueColumn;
                this.column = column;
                this.dragSourceDropTarget = dragSourceDropTarget;
                this.ghost = ghost;
            }
            ColumnComponent.prototype.init = function () {
                this.displayName = this.columnController.getDisplayNameForCol(this.column);
                this.setupComponents();
                if (!this.ghost && !this.gridOptionsWrapper.isFunctionsReadOnly()) {
                    this.addDragSource();
                }
            };
            ColumnComponent.prototype.addDragSource = function () {
                var dragSource = {
                    type: main_1.DragSourceType.ToolPanel,
                    eElement: this.getGui(),
                    dragItem: [this.column],
                    dragItemName: this.displayName,
                    dragSourceDropTarget: this.dragSourceDropTarget
                };
                this.dragAndDropService.addDragSource(dragSource);
            };
            ColumnComponent.prototype.setupComponents = function () {
                var _this = this;
                this.setTextValue();
                this.addDestroyableEventListener(this.btRemove, 'click', function (event) {
                    _this.dispatchEvent(ColumnComponent.EVENT_COLUMN_REMOVE);
                    event.stopPropagation();
                });
                main_1.Utils.setVisible(this.btRemove, !this.gridOptionsWrapper.isFunctionsReadOnly());
                if (this.ghost) {
                    main_1.Utils.addCssClass(this.getGui(), 'ag-column-drop-cell-ghost');
                }
                if (this.valueColumn && !this.gridOptionsWrapper.isFunctionsReadOnly()) {
                    this.addGuiEventListener('click', this.onShowAggFuncSelection.bind(this));
                }
            };
            ColumnComponent.prototype.setTextValue = function () {
                var displayValue;
                if (this.valueColumn) {
                    var aggFunc = this.column.getAggFunc();
                    // if aggFunc is a string, we can use it, but if it's a function, then we swap with 'func'
                    var aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'agg';
                    displayValue = aggFuncString + "(" + this.displayName + ")";
                } else {
                    displayValue = this.displayName;
                }
                this.eText.innerHTML = displayValue;
            };
            ColumnComponent.prototype.onShowAggFuncSelection = function () {
                var _this = this;
                if (this.popupShowing) {
                    return;
                }
                this.popupShowing = true;
                var virtualList = new virtualList_1.VirtualList();
                var rows = this.aggFuncService.getFuncNames();
                virtualList.setModel({
                    getRow: function getRow(index) {
                        return rows[index];
                    },
                    getRowCount: function getRowCount() {
                        return rows.length;
                    }
                });
                this.context.wireBean(virtualList);
                var ePopup = main_1.Utils.loadTemplate('<div class="ag-select-agg-func-popup"></div>');
                ePopup.style.top = '0px';
                ePopup.style.left = '0px';
                ePopup.appendChild(virtualList.getGui());
                ePopup.style.height = '100px';
                ePopup.style.width = this.getGui().clientWidth + 'px';
                var popupHiddenFunc = function popupHiddenFunc() {
                    virtualList.destroy();
                    _this.popupShowing = false;
                };
                var hidePopup = this.popupService.addAsModalPopup(ePopup, true, popupHiddenFunc);
                virtualList.setComponentCreator(this.createAggSelect.bind(this, hidePopup));
                this.popupService.positionPopupUnderComponent({
                    eventSource: this.getGui(),
                    ePopup: ePopup,
                    keepWithinBounds: true
                });
                virtualList.refresh();
            };
            ColumnComponent.prototype.createAggSelect = function (hidePopup, value) {
                var _this = this;
                var itemSelected = function itemSelected() {
                    hidePopup();
                    if (_this.gridOptionsWrapper.isFunctionsPassive()) {
                        var event = {
                            columns: [_this.column],
                            aggFunc: value
                        };
                        _this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST, event);
                    } else {
                        _this.columnController.setColumnAggFunc(_this.column, value);
                    }
                };
                var comp = new AggItemComp(itemSelected, value.toString());
                return comp;
            };
            ColumnComponent.EVENT_COLUMN_REMOVE = 'columnRemove';
            ColumnComponent.TEMPLATE = "<span class=\"ag-column-drop-cell\">\n          <span class=\"ag-column-drop-cell-text\"></span>\n          <span class=\"ag-column-drop-cell-button\">&#10006;</span>\n        </span>";
            __decorate([main_1.Autowired('dragAndDropService'), __metadata('design:type', main_1.DragAndDropService)], ColumnComponent.prototype, "dragAndDropService", void 0);
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], ColumnComponent.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('gridPanel'), __metadata('design:type', main_1.GridPanel)], ColumnComponent.prototype, "gridPanel", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], ColumnComponent.prototype, "context", void 0);
            __decorate([main_1.Autowired('popupService'), __metadata('design:type', main_1.PopupService)], ColumnComponent.prototype, "popupService", void 0);
            __decorate([main_1.Autowired('aggFuncService'), __metadata('design:type', aggFuncService_1.AggFuncService)], ColumnComponent.prototype, "aggFuncService", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], ColumnComponent.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], ColumnComponent.prototype, "eventService", void 0);
            __decorate([main_1.QuerySelector('.ag-column-drop-cell-text'), __metadata('design:type', HTMLElement)], ColumnComponent.prototype, "eText", void 0);
            __decorate([main_1.QuerySelector('.ag-column-drop-cell-button'), __metadata('design:type', HTMLElement)], ColumnComponent.prototype, "btRemove", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ColumnComponent.prototype, "init", null);
            return ColumnComponent;
        }(main_1.Component);
        exports.ColumnComponent = ColumnComponent;
        var AggItemComp = function (_super) {
            __extends(AggItemComp, _super);
            function AggItemComp(itemSelected, value) {
                _super.call(this, '<div class="ag-select-agg-func-item"/>');
                this.getGui().innerText = value;
                this.value = value;
                this.addGuiEventListener('click', itemSelected);
            }
            return AggItemComp;
        }(main_1.Component);

        /***/ },
    /* 383 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var columnSelectPanel_1 = __webpack_require__(357);
        var rowGroupColumnsPanel_1 = __webpack_require__(384);
        var pivotColumnsPanel_1 = __webpack_require__(380);
        var pivotModePanel_1 = __webpack_require__(385);
        var valueColumnsPanel_1 = __webpack_require__(386);
        var ToolPanelComp = function (_super) {
            __extends(ToolPanelComp, _super);
            function ToolPanelComp() {
                _super.call(this, ToolPanelComp.TEMPLATE);
                this.initialised = false;
            }
            // lazy initialise the toolPanel
            ToolPanelComp.prototype.setVisible = function (visible) {
                _super.prototype.setVisible.call(this, visible);
                if (visible && !this.initialised) {
                    this.init();
                }
            };
            ToolPanelComp.prototype.init = function () {
                if (!this.gridOptionsWrapper.isToolPanelSuppressPivotMode()) {
                    this.addComponent(new pivotModePanel_1.PivotModePanel());
                }
                this.addComponent(new columnSelectPanel_1.ColumnSelectPanel(true));
                if (!this.gridOptionsWrapper.isToolPanelSuppressRowGroups()) {
                    this.addComponent(new rowGroupColumnsPanel_1.RowGroupColumnsPanel(false));
                }
                if (!this.gridOptionsWrapper.isToolPanelSuppressValues()) {
                    this.addComponent(new valueColumnsPanel_1.ValuesColumnPanel(false));
                }
                if (!this.gridOptionsWrapper.isToolPanelSuppressPivots()) {
                    this.addComponent(new pivotColumnsPanel_1.PivotColumnsPanel(false));
                }
                this.initialised = true;
            };
            ToolPanelComp.prototype.addComponent = function (component) {
                this.context.wireBean(component);
                this.getGui().appendChild(component.getGui());
                this.addDestroyFunc(function () {
                    component.destroy();
                });
            };
            ToolPanelComp.TEMPLATE = '<div class="ag-tool-panel"></div>';
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], ToolPanelComp.prototype, "context", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], ToolPanelComp.prototype, "gridOptionsWrapper", void 0);
            ToolPanelComp = __decorate([main_1.Bean('toolPanel'), __metadata('design:paramtypes', [])], ToolPanelComp);
            return ToolPanelComp;
        }(main_1.Component);
        exports.ToolPanelComp = ToolPanelComp;

        /***/ },
    /* 384 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var abstractColumnDropPanel_1 = __webpack_require__(381);
        var svgFactory = main_1.SvgFactory.getInstance();
        var RowGroupColumnsPanel = function (_super) {
            __extends(RowGroupColumnsPanel, _super);
            function RowGroupColumnsPanel(horizontal) {
                _super.call(this, horizontal, false);
            }
            RowGroupColumnsPanel.prototype.passBeansUp = function () {
                _super.prototype.setBeans.call(this, {
                    gridOptionsWrapper: this.gridOptionsWrapper,
                    eventService: this.eventService,
                    context: this.context,
                    loggerFactory: this.loggerFactory,
                    dragAndDropService: this.dragAndDropService
                });
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                var emptyMessage = localeTextFunc('rowGroupColumnsEmptyMessage', 'Drag here to group');
                var title = localeTextFunc('groups', 'Groups');
                _super.prototype.init.call(this, {
                    dragAndDropIcon: main_1.DragAndDropService.ICON_GROUP,
                    iconFactory: svgFactory.createGroupIcon,
                    emptyMessage: emptyMessage,
                    title: title
                });
                this.addDestroyableEventListener(this.eventService, main_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshGui.bind(this));
            };
            RowGroupColumnsPanel.prototype.isColumnDroppable = function (column) {
                if (this.gridOptionsWrapper.isFunctionsReadOnly()) {
                    return false;
                }
                // we never allow grouping of secondary columns
                if (!column.isPrimary()) {
                    return false;
                }
                var columnGroupable = column.isAllowRowGroup();
                var columnNotAlreadyGrouped = !column.isRowGroupActive();
                return columnGroupable && columnNotAlreadyGrouped;
            };
            RowGroupColumnsPanel.prototype.removeColumns = function (columns) {
                var _this = this;
                if (this.gridOptionsWrapper.isFunctionsPassive()) {
                    this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_ROW_GROUP_REMOVE_REQUEST, { columns: columns });
                } else {
                    // this panel only allows dragging columns (not column groups) so we are guaranteed
                    // the dragItem is a column
                    var rowGroupColumns = this.columnController.getRowGroupColumns();
                    columns.forEach(function (column) {
                        var columnIsGrouped = rowGroupColumns.indexOf(column) >= 0;
                        if (columnIsGrouped) {
                            _this.columnController.removeRowGroupColumn(column);
                            _this.columnController.setColumnVisible(column, true);
                        }
                    });
                }
            };
            RowGroupColumnsPanel.prototype.getIconName = function () {
                return this.isPotentialDndColumns() ? main_1.DragAndDropService.ICON_GROUP : main_1.DragAndDropService.ICON_NOT_ALLOWED;
            };
            RowGroupColumnsPanel.prototype.addColumns = function (columns) {
                if (this.gridOptionsWrapper.isFunctionsPassive()) {
                    this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_ROW_GROUP_ADD_REQUEST, { columns: columns });
                } else {
                    this.columnController.addRowGroupColumns(columns);
                }
            };
            RowGroupColumnsPanel.prototype.getExistingColumns = function () {
                return this.columnController.getRowGroupColumns();
            };
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], RowGroupColumnsPanel.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], RowGroupColumnsPanel.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], RowGroupColumnsPanel.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], RowGroupColumnsPanel.prototype, "context", void 0);
            __decorate([main_1.Autowired('loggerFactory'), __metadata('design:type', main_1.LoggerFactory)], RowGroupColumnsPanel.prototype, "loggerFactory", void 0);
            __decorate([main_1.Autowired('dragAndDropService'), __metadata('design:type', main_1.DragAndDropService)], RowGroupColumnsPanel.prototype, "dragAndDropService", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RowGroupColumnsPanel.prototype, "passBeansUp", null);
            return RowGroupColumnsPanel;
        }(abstractColumnDropPanel_1.AbstractColumnDropPanel);
        exports.RowGroupColumnsPanel = RowGroupColumnsPanel;

        /***/ },
    /* 385 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var PivotModePanel = function (_super) {
            __extends(PivotModePanel, _super);
            function PivotModePanel() {
                _super.call(this);
            }
            PivotModePanel.prototype.createTemplate = function () {
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                return "<div class=\"ag-pivot-mode\">\n                <ag-checkbox class=\"ag-pivot-mode-select\" label=\"" + localeTextFunc('pivotMode', 'Pivot Mode') + "\"></ag-checkbox>\n            </div>";
            };
            PivotModePanel.prototype.init = function () {
                this.setTemplate(this.createTemplate());
                this.instantiate(this.context);
                this.cbPivotMode.setSelected(this.columnController.isPivotMode());
                this.addDestroyableEventListener(this.cbPivotMode, main_1.AgCheckbox.EVENT_CHANGED, this.onBtPivotMode.bind(this));
                this.addDestroyableEventListener(this.eventService, main_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onPivotModeChanged.bind(this));
                this.addDestroyableEventListener(this.eventService, main_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this));
            };
            PivotModePanel.prototype.onBtPivotMode = function () {
                var newValue = this.cbPivotMode.isSelected();
                if (newValue !== this.columnController.isPivotMode()) {
                    this.columnController.setPivotMode(newValue);
                }
            };
            PivotModePanel.prototype.onPivotModeChanged = function () {
                var pivotModeActive = this.columnController.isPivotMode();
                this.cbPivotMode.setSelected(pivotModeActive);
            };
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], PivotModePanel.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], PivotModePanel.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], PivotModePanel.prototype, "context", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], PivotModePanel.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.QuerySelector('.ag-pivot-mode-select'), __metadata('design:type', main_1.AgCheckbox)], PivotModePanel.prototype, "cbPivotMode", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], PivotModePanel.prototype, "init", null);
            return PivotModePanel;
        }(main_1.Component);
        exports.PivotModePanel = PivotModePanel;

        /***/ },
    /* 386 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __extends = undefined && undefined.__extends || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var abstractColumnDropPanel_1 = __webpack_require__(381);
        var svgFactory = main_1.SvgFactory.getInstance();
        var ValuesColumnPanel = function (_super) {
            __extends(ValuesColumnPanel, _super);
            function ValuesColumnPanel(horizontal) {
                _super.call(this, horizontal, true);
            }
            ValuesColumnPanel.prototype.passBeansUp = function () {
                _super.prototype.setBeans.call(this, {
                    gridOptionsWrapper: this.gridOptionsWrapper,
                    eventService: this.eventService,
                    context: this.context,
                    loggerFactory: this.loggerFactory,
                    dragAndDropService: this.dragAndDropService
                });
                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
                var emptyMessage = localeTextFunc('pivotColumnsEmptyMessage', 'Drag here to aggregate');
                var title = localeTextFunc('values', 'Values');
                _super.prototype.init.call(this, {
                    dragAndDropIcon: main_1.DragAndDropService.ICON_AGGREGATE,
                    iconFactory: svgFactory.createAggregationIcon,
                    emptyMessage: emptyMessage,
                    title: title
                });
                this.addDestroyableEventListener(this.eventService, main_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.refreshGui.bind(this));
            };
            ValuesColumnPanel.prototype.getIconName = function () {
                return this.isPotentialDndColumns() ? main_1.DragAndDropService.ICON_AGGREGATE : main_1.DragAndDropService.ICON_NOT_ALLOWED;
            };
            ValuesColumnPanel.prototype.isColumnDroppable = function (column) {
                if (this.gridOptionsWrapper.isFunctionsReadOnly()) {
                    return false;
                }
                // we never allow grouping of secondary columns
                if (!column.isPrimary()) {
                    return false;
                }
                var columnValue = column.isAllowValue();
                var columnNotValue = !column.isValueActive();
                return columnValue && columnNotValue;
            };
            ValuesColumnPanel.prototype.removeColumns = function (columns) {
                if (this.gridOptionsWrapper.isFunctionsPassive()) {
                    this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_VALUE_REMOVE_REQUEST, { columns: columns });
                } else {
                    var columnsCurrentlyValueColumns = main_1.Utils.filter(columns, function (column) {
                        return column.isValueActive();
                    });
                    this.columnController.removeValueColumns(columnsCurrentlyValueColumns);
                }
            };
            ValuesColumnPanel.prototype.addColumns = function (columns) {
                if (this.gridOptionsWrapper.isFunctionsPassive()) {
                    this.eventService.dispatchEvent(main_1.Events.EVENT_COLUMN_VALUE_ADD_REQUEST, { columns: columns });
                } else {
                    this.columnController.addValueColumns(columns);
                }
            };
            ValuesColumnPanel.prototype.getExistingColumns = function () {
                return this.columnController.getValueColumns();
            };
            __decorate([main_1.Autowired('columnController'), __metadata('design:type', main_1.ColumnController)], ValuesColumnPanel.prototype, "columnController", void 0);
            __decorate([main_1.Autowired('eventService'), __metadata('design:type', main_1.EventService)], ValuesColumnPanel.prototype, "eventService", void 0);
            __decorate([main_1.Autowired('gridOptionsWrapper'), __metadata('design:type', main_1.GridOptionsWrapper)], ValuesColumnPanel.prototype, "gridOptionsWrapper", void 0);
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], ValuesColumnPanel.prototype, "context", void 0);
            __decorate([main_1.Autowired('loggerFactory'), __metadata('design:type', main_1.LoggerFactory)], ValuesColumnPanel.prototype, "loggerFactory", void 0);
            __decorate([main_1.Autowired('dragAndDropService'), __metadata('design:type', main_1.DragAndDropService)], ValuesColumnPanel.prototype, "dragAndDropService", void 0);
            __decorate([main_1.PostConstruct, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], ValuesColumnPanel.prototype, "passBeansUp", null);
            return ValuesColumnPanel;
        }(abstractColumnDropPanel_1.AbstractColumnDropPanel);
        exports.ValuesColumnPanel = ValuesColumnPanel;

        /***/ },
    /* 387 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var rowGroupColumnsPanel_1 = __webpack_require__(384);
        var RowGroupCompFactory = function () {
            function RowGroupCompFactory() {}
            RowGroupCompFactory.prototype.create = function () {
                var rowGroupComp = new rowGroupColumnsPanel_1.RowGroupColumnsPanel(true);
                this.context.wireBean(rowGroupComp);
                return rowGroupComp;
            };
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], RowGroupCompFactory.prototype, "context", void 0);
            RowGroupCompFactory = __decorate([main_1.Bean('rowGroupCompFactory'), __metadata('design:paramtypes', [])], RowGroupCompFactory);
            return RowGroupCompFactory;
        }();
        exports.RowGroupCompFactory = RowGroupCompFactory;

        /***/ },
    /* 388 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        // ag-grid-enterprise v5.4.0
        var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                }return c > 3 && r && Object.defineProperty(target, key, r), r;
            };
        var __metadata = undefined && undefined.__metadata || function (k, v) {
                if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };
        var main_1 = __webpack_require__(238);
        var pivotColumnsPanel_1 = __webpack_require__(380);
        var PivotCompFactory = function () {
            function PivotCompFactory() {}
            PivotCompFactory.prototype.create = function () {
                var pivotComp = new pivotColumnsPanel_1.PivotColumnsPanel(true);
                this.context.wireBean(pivotComp);
                return pivotComp;
            };
            __decorate([main_1.Autowired('context'), __metadata('design:type', main_1.Context)], PivotCompFactory.prototype, "context", void 0);
            PivotCompFactory = __decorate([main_1.Bean('pivotCompFactory'), __metadata('design:paramtypes', [])], PivotCompFactory);
            return PivotCompFactory;
        }();
        exports.PivotCompFactory = PivotCompFactory;

        /***/ },
    /* 389 */
    /***/ function(module, exports, __webpack_require__) {

        "use strict";

        // ag-grid-enterprise v5.4.0
        var columnSelectPanel_1 = __webpack_require__(357);
        var renderedColumn_1 = __webpack_require__(359);
        var renderedGroup_1 = __webpack_require__(358);
        var aggregationStage_1 = __webpack_require__(364);
        var groupStage_1 = __webpack_require__(363);
        var setFilter_1 = __webpack_require__(368);
        var setFilterModel_1 = __webpack_require__(369);
        var statusBar_1 = __webpack_require__(376);
        var statusItem_1 = __webpack_require__(377);
        var clipboardService_1 = __webpack_require__(362);
        var enterpriseBoot_1 = __webpack_require__(367);
        var enterpriseMenu_1 = __webpack_require__(356);
        var rangeController_1 = __webpack_require__(361);
        var rowGroupColumnsPanel_1 = __webpack_require__(384);
        var contextMenu_1 = __webpack_require__(378);
        var viewportRowModel_1 = __webpack_require__(379);
        var richSelectCellEditor_1 = __webpack_require__(372);
        var richSelectRow_1 = __webpack_require__(373);
        var virtualList_1 = __webpack_require__(371);
        var abstractColumnDropPanel_1 = __webpack_require__(381);
        var pivotColumnsPanel_1 = __webpack_require__(380);
        var toolPanelComp_1 = __webpack_require__(383);
        var licenseManager_1 = __webpack_require__(374);
        var pivotStage_1 = __webpack_require__(365);
        var pivotColDefService_1 = __webpack_require__(366);
        var pivotModePanel_1 = __webpack_require__(385);
        var aggFuncService_1 = __webpack_require__(360);
        var md5_1 = __webpack_require__(375);
        var setFilterListItem_1 = __webpack_require__(370);
        var columnComponent_1 = __webpack_require__(382);
        var valueColumnsPanel_1 = __webpack_require__(386);
        var pivotCompFactory_1 = __webpack_require__(388);
        var rowGroupCompFactory_1 = __webpack_require__(387);
        function populateClientExports(exports) {
            exports.AggFuncService = aggFuncService_1.AggFuncService;
            exports.MD5 = md5_1.MD5;
            exports.RichSelectCellEditor = richSelectCellEditor_1.RichSelectCellEditor;
            exports.RichSelectRow = richSelectRow_1.RichSelectRow;
            exports.VirtualList = virtualList_1.VirtualList;
            exports.AggregationStage = aggregationStage_1.AggregationStage;
            exports.GroupStage = groupStage_1.GroupStage;
            exports.PivotColDefService = pivotColDefService_1.PivotColDefService;
            exports.PivotStage = pivotStage_1.PivotStage;
            exports.SetFilter = setFilter_1.SetFilter;
            exports.SetFilter = setFilterListItem_1.SetFilterListItem;
            exports.SetFilterModel = setFilterModel_1.SetFilterModel;
            exports.StatusBar = statusBar_1.StatusBar;
            exports.StatusItem = statusItem_1.StatusItem;
            exports.AbstractColumnDropPanel = abstractColumnDropPanel_1.AbstractColumnDropPanel;
            exports.ColumnComponent = columnComponent_1.ColumnComponent;
            exports.PivotColumnsPanel = pivotColumnsPanel_1.PivotColumnsPanel;
            exports.PivotModePanel = pivotModePanel_1.PivotModePanel;
            exports.RowGroupColumnsPanel = rowGroupColumnsPanel_1.RowGroupColumnsPanel;
            exports.ValuesColumnPanel = valueColumnsPanel_1.ValuesColumnPanel;
            exports.ToolPanelComp = toolPanelComp_1.ToolPanelComp;
            exports.ColumnSelectPanel = columnSelectPanel_1.ColumnSelectPanel;
            exports.RenderedColumn = renderedColumn_1.RenderedColumn;
            exports.RenderedGroup = renderedGroup_1.RenderedGroup;
            exports.ViewportRowModel = viewportRowModel_1.ViewportRowModel;
            exports.ClipboardService = clipboardService_1.ClipboardService;
            exports.ContextMenuFactory = contextMenu_1.ContextMenuFactory;
            exports.EnterpriseBoot = enterpriseBoot_1.EnterpriseBoot;
            exports.EnterpriseMenu = enterpriseMenu_1.EnterpriseMenu;
            exports.LicenseManager = licenseManager_1.LicenseManager;
            exports.PivotCompFactory = pivotCompFactory_1.PivotCompFactory;
            exports.RangeController = rangeController_1.RangeController;
            exports.RowGroupCompFactory = rowGroupCompFactory_1.RowGroupCompFactory;
        }
        exports.populateClientExports = populateClientExports;

        /***/ },
    /* 390 */
    /***/ function(module, exports, __webpack_require__) {

        // style-loader: Adds some css to the DOM by adding a <style> tag

        // load the styles
        var content = __webpack_require__(391);
        if(typeof content === 'string') content = [[module.id, content, '']];
        // add the styles to the DOM
        var update = __webpack_require__(353)(content, {});
        if(content.locals) module.exports = content.locals;
        // Hot Module Replacement
        if(true) {
            // When the styles change, update the <style> tags
            if(!content.locals) {
                module.hot.accept(391, function() {
                    var newContent = __webpack_require__(391);
                    if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
                    update(newContent);
                });
            }
            // When the module is disposed, remove the <style> tags
            module.hot.dispose(function() { update(); });
        }

        /***/ },
    /* 391 */
    /***/ function(module, exports, __webpack_require__) {

        exports = module.exports = __webpack_require__(352)();
        // imports


        // module
        exports.push([module.id, "ag-grid-ng2 {\n  display: inline-block;\n}\n.ag-select-agg-func-popup {\n  position: absolute;\n}\n.ag-body-no-select {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.ag-root {\n/* set to relative, so absolute popups appear relative to this */\n  position: relative;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n/* was getting some 'should be there' scrolls, this sorts it out */\n  overflow: hidden;\n}\n.ag-font-style {\n  cursor: default;\n/* disable user mouse selection */\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.ag-no-scrolls {\n  white-space: nowrap;\n  display: inline-block;\n}\n.ag-scrolls {\n  height: 100%;\n}\n.ag-popup-backdrop {\n  position: fixed;\n  left: 0px;\n  top: 0px;\n  width: 100%;\n  height: 100%;\n}\n.ag-header {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  white-space: nowrap;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n  width: 100%;\n}\n.ag-pinned-left-header {\n  float: left;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  display: inline-block;\n  overflow: hidden;\n  height: 100%;\n}\n.ag-pinned-right-header {\n  float: right;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  display: inline-block;\n  overflow: hidden;\n  height: 100%;\n}\n.ag-header-viewport {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n  height: 100%;\n}\n.ag-scrolls .ag-header-row {\n  position: absolute;\n}\n.ag-scrolls .ag-header-container {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  position: relative;\n  white-space: nowrap;\n  height: 100%;\n}\n.ag-no-scrolls .ag-header-container {\n  white-space: nowrap;\n}\n.ag-header-overlay {\n  display: block;\n  position: absolute;\n}\n.ag-header-cell {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  vertical-align: bottom;\n  text-align: center;\n  display: inline-block;\n  height: 100%;\n  position: absolute;\n}\n.ag-dnd-ghost {\n  font-size: 14px;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  position: absolute;\n  background: #e5e5e5;\n  border: 1px solid #000;\n  cursor: move;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n  -o-text-overflow: ellipsis;\n  text-overflow: ellipsis;\n  padding: 3px;\n  line-height: 1.4;\n}\n.ag-dnd-ghost-icon {\n  display: inline-block;\n  float: left;\n  padding-left: 2px;\n  padding-right: 2px;\n}\n.ag-dnd-ghost-label {\n  display: inline-block;\n}\n.ag-header-group-cell {\n  height: 100%;\n  display: inline-block;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  -o-text-overflow: ellipsis;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  position: absolute;\n}\n.ag-header-group-cell-label {\n  -o-text-overflow: ellipsis;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n.ag-header-cell-label {\n  -o-text-overflow: ellipsis;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n.ag-header-cell-resize {\n  height: 100%;\n  width: 4px;\n  float: right;\n  cursor: col-resize;\n}\n.ag-header-expand-icon {\n  padding-left: 4px;\n}\n.ag-header-cell-menu-button {\n  float: right;\n}\n.ag-overlay-panel {\n  display: table;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n}\n.ag-overlay-wrapper {\n  display: table-cell;\n  vertical-align: middle;\n  text-align: center;\n}\n.ag-bl-overlay {\n  pointer-events: none;\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  top: 0px;\n  left: 0px;\n}\n.ag-bl-full-height {\n  height: 100%;\n  overflow: auto;\n  position: relative;\n}\n.ag-bl-full-height-west {\n  height: 100%;\n  float: left;\n}\n.ag-bl-full-height-east {\n  height: 100%;\n  float: right;\n}\n.ag-bl-full-height-center {\n  height: 100%;\n}\n.ag-bl-normal {\n  height: 100%;\n  position: relative;\n}\n.ag-bl-normal-center-row {\n  height: 100%;\n  overflow: hidden;\n}\n.ag-bl-normal-west {\n  height: 100%;\n  float: left;\n}\n.ag-bl-normal-east {\n  height: 100%;\n  float: right;\n}\n.ag-bl-normal-center {\n  height: 100%;\n}\n.ag-bl-dont-fill {\n  position: relative;\n}\n.ag-body {\n  height: 100%;\n  width: 100%;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  position: absolute;\n}\n.ag-floating-top {\n  position: absolute;\n  left: 0px;\n  width: 100%;\n  white-space: nowrap;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n}\n.ag-pinned-left-floating-top {\n  float: left;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  display: inline-block;\n  overflow: hidden;\n  height: 100%;\n}\n.ag-pinned-right-floating-top {\n  float: right;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  display: inline-block;\n  overflow: hidden;\n  height: 100%;\n}\n.ag-floating-top-viewport {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n  height: 100%;\n}\n.ag-floating-top-container {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  position: relative;\n  white-space: nowrap;\n}\n.ag-floating-bottom {\n  position: absolute;\n  left: 0px;\n  width: 100%;\n  white-space: nowrap;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n}\n.ag-pinned-left-floating-bottom {\n  float: left;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  display: inline-block;\n  overflow: hidden;\n  height: 100%;\n}\n.ag-pinned-right-floating-bottom {\n  float: right;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  display: inline-block;\n  overflow: hidden;\n  height: 100%;\n}\n.ag-floating-bottom-viewport {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n  height: 100%;\n}\n.ag-floating-bottom-container {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  position: relative;\n  white-space: nowrap;\n}\n.ag-pinned-left-cols-viewport {\n  float: left;\n  overflow: hidden;\n}\n.ag-pinned-left-cols-container {\n  display: inline-block;\n  position: relative;\n}\n.ag-pinned-right-cols-viewport {\n  float: right;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.ag-pinned-right-cols-container {\n  display: inline-block;\n  position: relative;\n}\n.ag-body-viewport-wrapper {\n  height: 100%;\n}\n.ag-body-viewport {\n  overflow-x: auto;\n  overflow-y: auto;\n  height: 100%;\n}\n.ag-full-width-viewport {\n  height: 100%;\n  width: 100%;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  display: inline;\n  pointer-events: none;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n}\n.ag-full-width-container {\n  overflow: hidden;\n  position: relative;\n  width: 100%;\n}\n.ag-floating-bottom-full-width-container {\n  height: 100%;\n  width: 100%;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  pointer-events: none;\n  overflow: hidden;\n  display: inline;\n}\n.ag-floating-top-full-width-container {\n  height: 100%;\n  width: 100%;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  pointer-events: none;\n  overflow: hidden;\n  display: inline;\n}\n.ag-full-width-row {\n  pointer-events: all;\n  overflow: hidden;\n}\n.ag-scrolls .ag-body-container {\n  position: relative;\n  display: inline-block;\n}\n.ag-scrolls .ag-row {\n  white-space: nowrap;\n  position: absolute;\n  width: 100%;\n}\n.ag-no-scrolls .ag-row {\n  position: relative;\n}\n.ag-column-drop {\n  width: 100%;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.ag-column-drop-vertical .ag-column-drop-cell {\n  display: block;\n}\n.ag-column-drop-vertical .ag-column-drop-empty-message {\n  display: block;\n}\n.ag-column-drop-vertical .ag-column-drop-cell-button {\n  float: right;\n  line-height: 16px;\n}\n.ag-column-drop-horizontal {\n  white-space: nowrap;\n}\n.ag-cell {\n  display: inline-block;\n  white-space: nowrap;\n  height: 100%;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  -o-text-overflow: ellipsis;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  position: absolute;\n}\n.ag-fade-out {\n  opacity: 1;\n  -ms-filter: none;\n  filter: none;\n  margin-right: 5px;\n  -webkit-transition: opacity 3s, margin-right 3s;\n  -moz-transition: opacity 3s, margin-right 3s;\n  -o-transition: opacity 3s, margin-right 3s;\n  -ms-transition: opacity 3s, margin-right 3s;\n  transition: opacity 3s, margin-right 3s;\n  -webkit-transition-timing-function: linear;\n  -moz-transition-timing-function: linear;\n  -o-transition-timing-function: linear;\n  -ms-transition-timing-function: linear;\n  transition-timing-function: linear;\n}\n.ag-fade-out-end {\n  opacity: 0;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";\n  filter: alpha(opacity=0);\n  margin-right: 10px;\n}\n.ag-cell-edit-input {\n  width: 100%;\n  height: 100%;\n}\n.ag-group-cell-entire-row {\n  width: 100%;\n  display: inline-block;\n  white-space: nowrap;\n  height: 100%;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  -o-text-overflow: ellipsis;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n.ag-footer-cell-entire-row {\n  width: 100%;\n  display: inline-block;\n  white-space: nowrap;\n  height: 100%;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  -o-text-overflow: ellipsis;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n.ag-large .ag-root {\n  font-size: 20px;\n}\n.ag-popup-editor {\n  position: absolute;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.ag-menu {\n  position: absolute;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.ag-menu-column-select-wrapper {\n  width: 200px;\n  height: 300px;\n  overflow: auto;\n}\n.ag-menu-list {\n  display: table;\n  border-collapse: collapse;\n}\n.ag-menu-option {\n  display: table-row;\n}\n.ag-menu-option-text {\n  display: table-cell;\n}\n.ag-menu-option-shortcut {\n  display: table-cell;\n}\n.ag-menu-option-icon {\n  display: table-cell;\n}\n.ag-menu-option-popup-pointer {\n  display: table-cell;\n}\n.ag-menu-separator {\n  display: table-row;\n}\n.ag-menu-separator-cell {\n  display: table-cell;\n}\n.ag-virtual-list-viewport {\n  overflow-x: auto;\n  height: 100%;\n  width: 100%;\n}\n.ag-virtual-list-container {\n  position: relative;\n  overflow: hidden;\n}\n.ag-rich-select {\n  outline: none;\n}\n.ag-rich-select-list {\n  width: 200px;\n  height: 200px;\n}\n.ag-set-filter-list {\n  width: 200px;\n  height: 200px;\n}\n.ag-set-filter-item {\n  -o-text-overflow: ellipsis;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n}\n.ag-virtual-list-item {\n  position: absolute;\n  width: 100%;\n}\n.ag-filter-filter {\n  width: 170px;\n  margin: 4px;\n}\n.ag-filter-select {\n  width: 110px;\n  margin: 4px 4px 0px 4px;\n}\n.ag-no-vertical-scroll .ag-scrolls {\n  height: unset;\n}\n.ag-no-vertical-scroll .ag-body {\n  height: unset;\n}\n.ag-no-vertical-scroll .ag-body-viewport-wrapper {\n  height: unset;\n}\n.ag-no-vertical-scroll .ag-body-viewport {\n  height: unset;\n}\n.ag-list-selection {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  cursor: default;\n}\n.ag-tool-panel {\n  width: 200px;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  cursor: default;\n  height: 100%;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: auto;\n}\n.ag-column-select-indent {\n  display: inline-block;\n}\n.ag-column-select-column {\n  margin-left: 14px;\n  white-space: nowrap;\n}\n.ag-column-select-column-group {\n  white-space: nowrap;\n}\n.ag-hidden {\n  display: none;\n}\n.ag-faded {\n  opacity: 0.3;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=30)\";\n  filter: alpha(opacity=30);\n}\n.ag-width-half {\n  width: 50%;\n  display: inline-block;\n}\n.ag-shake-left-to-right {\n  -webkit-animation-name: ag-shake-left-to-right;\n  -moz-animation-name: ag-shake-left-to-right;\n  -o-animation-name: ag-shake-left-to-right;\n  -ms-animation-name: ag-shake-left-to-right;\n  animation-name: ag-shake-left-to-right;\n  -webkit-animation-duration: 0.2s;\n  -moz-animation-duration: 0.2s;\n  -o-animation-duration: 0.2s;\n  -ms-animation-duration: 0.2s;\n  animation-duration: 0.2s;\n  -webkit-animation-iteration-count: infinite;\n  -moz-animation-iteration-count: infinite;\n  -o-animation-iteration-count: infinite;\n  -ms-animation-iteration-count: infinite;\n  animation-iteration-count: infinite;\n  -webkit-animation-direction: alternate;\n  -moz-animation-direction: alternate;\n  -o-animation-direction: alternate;\n  -ms-animation-direction: alternate;\n  animation-direction: alternate;\n}\n@-moz-keyframes ag-shake-left-to-right {\n  from {\n    padding-left: 6px;\n    padding-right: 2px;\n  }\n  to {\n    padding-left: 2px;\n    padding-right: 6px;\n  }\n}\n@-webkit-keyframes ag-shake-left-to-right {\n  from {\n    padding-left: 6px;\n    padding-right: 2px;\n  }\n  to {\n    padding-left: 2px;\n    padding-right: 6px;\n  }\n}\n@-o-keyframes ag-shake-left-to-right {\n  from {\n    padding-left: 6px;\n    padding-right: 2px;\n  }\n  to {\n    padding-left: 2px;\n    padding-right: 6px;\n  }\n}\n@keyframes ag-shake-left-to-right {\n  from {\n    padding-left: 6px;\n    padding-right: 2px;\n  }\n  to {\n    padding-left: 2px;\n    padding-right: 6px;\n  }\n}\n", ""]);

        // exports


        /***/ },
    /* 392 */
    /***/ function(module, exports, __webpack_require__) {

        // style-loader: Adds some css to the DOM by adding a <style> tag

        // load the styles
        var content = __webpack_require__(393);
        if(typeof content === 'string') content = [[module.id, content, '']];
        // add the styles to the DOM
        var update = __webpack_require__(353)(content, {});
        if(content.locals) module.exports = content.locals;
        // Hot Module Replacement
        if(true) {
            // When the styles change, update the <style> tags
            if(!content.locals) {
                module.hot.accept(393, function() {
                    var newContent = __webpack_require__(393);
                    if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
                    update(newContent);
                });
            }
            // When the module is disposed, remove the <style> tags
            module.hot.dispose(function() { update(); });
        }

        /***/ },
    /* 393 */
    /***/ function(module, exports, __webpack_require__) {

        exports = module.exports = __webpack_require__(352)();
        // imports


        // module
        exports.push([module.id, ".ag-fresh {\n  line-height: 1.4;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  color: #222;\n/* this is for the rowGroupPanel, that appears along the top of the grid */\n/* this is for the column drops that appear in the toolPanel */\n}\n.ag-fresh img {\n  vertical-align: middle;\n  border: 0;\n}\n.ag-fresh .ag-root {\n  border: 1px solid #808080;\n}\n.ag-fresh .ag-cell-not-inline-editing {\n  padding: 2px;\n}\n.ag-fresh .ag-cell-range-selected-1:not(.ag-cell-focus) {\n  background-color: rgba(120,120,120,0.4);\n}\n.ag-fresh .ag-cell-range-selected-2:not(.ag-cell-focus) {\n  background-color: rgba(80,80,80,0.4);\n}\n.ag-fresh .ag-cell-range-selected-3:not(.ag-cell-focus) {\n  background-color: rgba(40,40,40,0.4);\n}\n.ag-fresh .ag-cell-range-selected-4:not(.ag-cell-focus) {\n  background-color: rgba(0,0,0,0.4);\n}\n.ag-fresh .ag-column-moving .ag-cell {\n  -webkit-transition: left 0.2s;\n  -moz-transition: left 0.2s;\n  -o-transition: left 0.2s;\n  -ms-transition: left 0.2s;\n  transition: left 0.2s;\n}\n.ag-fresh .ag-column-moving .ag-header-cell {\n  -webkit-transition: left 0.2s;\n  -moz-transition: left 0.2s;\n  -o-transition: left 0.2s;\n  -ms-transition: left 0.2s;\n  transition: left 0.2s;\n}\n.ag-fresh .ag-column-moving .ag-header-group-cell {\n  -webkit-transition: left 0.2s;\n  -moz-transition: left 0.2s;\n  -o-transition: left 0.2s;\n  -ms-transition: left 0.2s;\n  transition: left 0.2s;\n}\n.ag-fresh .ag-cell-focus {\n  border: 1px solid #a9a9a9;\n}\n.ag-fresh .ag-cell-no-focus {\n  border-right: 1px dotted #808080;\n  border-top: 1px solid transparent;\n  border-left: 1px solid transparent;\n  border-bottom: 1px solid transparent;\n}\n.ag-fresh .ag-cell-first-right-pinned {\n  border-left: 1px solid #808080;\n}\n.ag-fresh .ag-cell-last-left-pinned {\n  border-right: 1px solid #808080;\n}\n.ag-fresh .ag-cell-highlight {\n  border: 1px solid #006400;\n}\n.ag-fresh .ag-cell-highlight-animation {\n  -webkit-transition: border 1s;\n  -moz-transition: border 1s;\n  -o-transition: border 1s;\n  -ms-transition: border 1s;\n  transition: border 1s;\n}\n.ag-fresh .ag-value-change-delta {\n  padding-right: 2px;\n}\n.ag-fresh .ag-value-change-delta-up {\n  color: #006400;\n}\n.ag-fresh .ag-value-change-delta-down {\n  color: #8b0000;\n}\n.ag-fresh .ag-value-change-value {\n  background-color: transparent;\n  -webkit-border-radius: 1px;\n  border-radius: 1px;\n  padding-left: 1px;\n  padding-right: 1px;\n  -webkit-transition: background-color 1s;\n  -moz-transition: background-color 1s;\n  -o-transition: background-color 1s;\n  -ms-transition: background-color 1s;\n  transition: background-color 1s;\n}\n.ag-fresh .ag-value-change-value-highlight {\n  background-color: #cec;\n  -webkit-transition: background-color 0.1s;\n  -moz-transition: background-color 0.1s;\n  -o-transition: background-color 0.1s;\n  -ms-transition: background-color 0.1s;\n  transition: background-color 0.1s;\n}\n.ag-fresh .ag-rich-select {\n  font-size: 14px;\n  border: 1px solid #808080;\n  background-color: #fff;\n}\n.ag-fresh .ag-rich-select-value {\n  padding: 2px;\n}\n.ag-fresh .ag-rich-select-list {\n  border-top: 1px solid #d3d3d3;\n}\n.ag-fresh .ag-rich-select-row {\n  padding: 2px;\n}\n.ag-fresh .ag-rich-select-row-selected {\n  background-color: #bde2e5;\n}\n.ag-fresh .ag-large-text {\n  border: 1px solid #808080;\n}\n.ag-fresh .ag-header {\n  color: #000;\n  background: -webkit-linear-gradient(#fff, #d3d3d3);\n  background: -moz-linear-gradient(#fff, #d3d3d3);\n  background: -o-linear-gradient(#fff, #d3d3d3);\n  background: -ms-linear-gradient(#fff, #d3d3d3);\n  background: linear-gradient(#fff, #d3d3d3);\n  border-bottom: 1px solid #808080;\n  font-weight: normal;\n}\n.ag-fresh .ag-header-icon {\n  color: #000;\n  stroke: none;\n  fill: #000;\n}\n.ag-fresh .ag-no-scrolls .ag-header-container {\n  background: -webkit-linear-gradient(#fff, #d3d3d3);\n  background: -moz-linear-gradient(#fff, #d3d3d3);\n  background: -o-linear-gradient(#fff, #d3d3d3);\n  background: -ms-linear-gradient(#fff, #d3d3d3);\n  background: linear-gradient(#fff, #d3d3d3);\n  border-bottom: 1px solid #808080;\n}\n.ag-fresh .ag-header-cell {\n  border-right: 1px solid #808080;\n}\n.ag-fresh .ag-header-cell-moving .ag-header-cell-label {\n  opacity: 0.5;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)\";\n  filter: alpha(opacity=50);\n}\n.ag-fresh .ag-header-cell-moving {\n  background-color: #bebebe;\n}\n.ag-fresh .ag-header-group-cell {\n  border-right: 1px solid #808080;\n}\n.ag-fresh .ag-header-group-cell-with-group {\n  border-bottom: 1px solid #808080;\n}\n.ag-fresh .ag-header-cell-label {\n  padding: 4px 2px 4px 2px;\n}\n.ag-fresh .ag-header-cell-text {\n  padding-left: 2px;\n}\n.ag-fresh .ag-header-group-cell-label {\n  padding: 4px;\n  padding-left: 10px;\n}\n.ag-fresh .ag-header-group-text {\n  margin-right: 2px;\n}\n.ag-fresh .ag-header-cell-menu-button {\n  padding: 2px;\n  margin-top: 4px;\n  border: 1px solid transparent;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n  -webkit-box-sizing: content-box /* When using bootstrap, box-sizing was set to 'border-box' */;\n  -moz-box-sizing: content-box /* When using bootstrap, box-sizing was set to 'border-box' */;\n  box-sizing: content-box /* When using bootstrap, box-sizing was set to 'border-box' */;\n  line-height: 0px /* normal line height, a space was appearing below the menu button */;\n}\n.ag-fresh .ag-pinned-right-header {\n  border-left: 1px solid #808080;\n}\n.ag-fresh .ag-header-cell-menu-button:hover {\n  border: 1px solid #808080;\n}\n.ag-fresh .ag-body {\n  background-color: #f6f6f6;\n}\n.ag-fresh .ag-row {\n  -webkit-transition: background-color 0.1s;\n  -moz-transition: background-color 0.1s;\n  -o-transition: background-color 0.1s;\n  -ms-transition: background-color 0.1s;\n  transition: background-color 0.1s;\n}\n.ag-fresh .ag-row-odd {\n  background-color: #f6f6f6;\n}\n.ag-fresh .ag-row-even {\n  background-color: #fff;\n}\n.ag-fresh .ag-row-selected {\n  background-color: #b0e0e6;\n}\n.ag-fresh .ag-floating-top .ag-row {\n  background-color: #f0f0f0;\n}\n.ag-fresh .ag-floating-bottom .ag-row {\n  background-color: #f0f0f0;\n}\n.ag-fresh .ag-overlay-loading-wrapper {\n  background-color: rgba(255,255,255,0.5);\n}\n.ag-fresh .ag-overlay-loading-center {\n  background-color: #fff;\n  border: 1px solid #808080;\n  -webkit-border-radius: 10px;\n  border-radius: 10px;\n  padding: 10px;\n  color: #000;\n}\n.ag-fresh .ag-overlay-no-rows-center {\n  background-color: #fff;\n  border: 1px solid #808080;\n  -webkit-border-radius: 10px;\n  border-radius: 10px;\n  padding: 10px;\n}\n.ag-fresh .ag-group-cell-entire-row {\n  background-color: #f6f6f6;\n  padding: 2px;\n}\n.ag-fresh .ag-footer-cell-entire-row {\n  background-color: #f6f6f6;\n  padding: 2px;\n}\n.ag-fresh .ag-group-cell {\n  font-style: italic;\n}\n.ag-fresh .ag-group-expanded {\n  padding-right: 4px;\n}\n.ag-fresh .ag-group-contracted {\n  padding-right: 4px;\n}\n.ag-fresh .ag-group-value {\n  padding-right: 2px;\n}\n.ag-fresh .ag-group-checkbox {\n  padding-right: 2px;\n}\n.ag-fresh .ag-footer-cell {\n  font-style: italic;\n}\n.ag-fresh .ag-menu {\n  border: 1px solid #808080;\n  background-color: #f6f6f6;\n  cursor: default;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  font-size: 14px;\n}\n.ag-fresh .ag-menu .ag-tab-header {\n  background-color: #e6e6e6;\n}\n.ag-fresh .ag-menu .ag-tab {\n  padding: 6px 8px 6px 8px;\n  margin: 2px 2px 0px 2px;\n  display: inline-block;\n  border-right: 1px solid transparent;\n  border-left: 1px solid transparent;\n  border-top: 1px solid transparent;\n  border-top-right-radius: 2px;\n  border-top-left-radius: 2px;\n}\n.ag-fresh .ag-menu .ag-tab-selected {\n  background-color: #f6f6f6;\n  border-right: 1px solid #d3d3d3;\n  border-left: 1px solid #d3d3d3;\n  border-top: 1px solid #d3d3d3;\n}\n.ag-fresh .ag-menu-separator {\n  border-top: 1px solid #d3d3d3;\n}\n.ag-fresh .ag-menu-option-active {\n  background-color: #bde2e5;\n}\n.ag-fresh .ag-menu-option-icon {\n  padding: 2px 4px 2px 4px;\n  vertical-align: middle;\n}\n.ag-fresh .ag-menu-option-text {\n  padding: 2px 4px 2px 4px;\n  vertical-align: middle;\n}\n.ag-fresh .ag-menu-option-shortcut {\n  padding: 2px 2px 2px 20px;\n  vertical-align: middle;\n}\n.ag-fresh .ag-menu-option-popup-pointer {\n  padding: 2px 4px 2px 4px;\n  vertical-align: middle;\n}\n.ag-fresh .ag-menu-option-disabled {\n  opacity: 0.5;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)\";\n  filter: alpha(opacity=50);\n}\n.ag-fresh .ag-menu-column-select-wrapper {\n  margin: 2px;\n}\n.ag-fresh .ag-filter-checkbox {\n  position: relative;\n  top: 2px;\n  left: 2px;\n}\n.ag-fresh .ag-filter-header-container {\n  border-bottom: 1px solid #d3d3d3;\n}\n.ag-fresh .ag-filter-apply-panel {\n  border-top: 1px solid #d3d3d3;\n  padding: 2px;\n}\n.ag-fresh .ag-filter-value {\n  margin-left: 4px;\n}\n.ag-fresh .ag-selection-checkbox {\n  padding-right: 4px;\n}\n.ag-fresh .ag-paging-panel {\n  padding: 4px;\n}\n.ag-fresh .ag-paging-button {\n  margin-left: 4px;\n  margin-right: 4px;\n}\n.ag-fresh .ag-paging-row-summary-panel {\n  display: inline-block;\n  width: 300px;\n}\n.ag-fresh .ag-tool-panel {\n  background-color: #f6f6f6;\n  border-right: 1px solid #808080;\n  border-bottom: 1px solid #808080;\n  border-top: 1px solid #808080;\n  color: #222;\n}\n.ag-fresh .ag-status-bar {\n  color: #222;\n  background-color: #f6f6f6;\n  font-size: 14px;\n  height: 22px;\n  border-bottom: 1px solid #808080;\n  border-left: 1px solid #808080;\n  border-right: 1px solid #808080;\n  padding: 2px;\n}\n.ag-fresh .ag-status-bar-aggregations {\n  float: right;\n}\n.ag-fresh .ag-status-bar-item {\n  padding-left: 10px;\n}\n.ag-fresh .ag-column-drop-cell {\n  background: -webkit-linear-gradient(#fff, #d3d3d3);\n  background: -moz-linear-gradient(#fff, #d3d3d3);\n  background: -o-linear-gradient(#fff, #d3d3d3);\n  background: -ms-linear-gradient(#fff, #d3d3d3);\n  background: linear-gradient(#fff, #d3d3d3);\n  color: #000;\n  border: 1px solid #808080;\n}\n.ag-fresh .ag-column-drop-cell-ghost {\n  opacity: 0.5;\n  -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)\";\n  filter: alpha(opacity=50);\n}\n.ag-fresh .ag-column-drop-cell-text {\n  padding-left: 2px;\n  padding-right: 2px;\n}\n.ag-fresh .ag-column-drop-cell-button {\n  border: 1px solid transparent;\n  padding-left: 2px;\n  padding-right: 2px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n}\n.ag-fresh .ag-column-drop-cell-button:hover {\n  border: 1px solid #808080;\n}\n.ag-fresh .ag-column-drop-empty-message {\n  padding-left: 2px;\n  padding-right: 2px;\n  color: #808080;\n}\n.ag-fresh .ag-column-drop-icon {\n  padding-right: 4px;\n}\n.ag-fresh .ag-column-drop {\n  background-color: #f6f6f6;\n}\n.ag-fresh .ag-column-drop-horizontal {\n  padding: 4px 4px 4px 4px;\n  border-top: 1px solid #808080;\n  border-left: 1px solid #808080;\n  border-right: 1px solid #808080;\n}\n.ag-fresh .ag-column-drop-horizontal .ag-column-drop-cell {\n  padding: 2px;\n}\n.ag-fresh .ag-column-drop-vertical {\n  padding: 4px 4px 10px 4px;\n  border-bottom: 1px solid #808080;\n}\n.ag-fresh .ag-column-drop-vertical .ag-column-drop-cell {\n  margin-top: 2px;\n}\n.ag-fresh .ag-column-drop-vertical .ag-column-drop-empty-message {\n  text-align: center;\n  padding: 5px;\n}\n.ag-fresh .ag-pivot-mode {\n  border-bottom: 1px solid #808080;\n  padding: 4px;\n  background-color: #f6f6f6;\n}\n.ag-fresh .ag-tool-panel .ag-column-select-panel {\n  border-bottom: 1px solid #808080;\n}\n.ag-fresh .ag-select-agg-func-popup {\n  cursor: default;\n  position: absolute;\n  font-size: 14px;\n  background-color: #fff;\n  border: 1px solid #808080;\n}\n.ag-fresh .ag-select-agg-func-item {\n  padding-left: 2px;\n  padding-right: 2px;\n}\n.ag-fresh .ag-select-agg-func-item:hover {\n  background-color: #bde2e5;\n}\n", ""]);

        // exports


        /***/ }
    /******/ ]);