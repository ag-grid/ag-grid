{"isEnterprise":true,"isLocale":false,"isIntegratedCharts":false,"entryFileName":"main.js","mainFileName":"main.js","scriptFiles":["data.js","main.js"],"styleFiles":["styles.css"],"files":{"styles.css":".example-wrapper {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n#myGrid {\n    flex: 1 1 0px;\n    width: 100%;\n}\n\n.number {\n    text-align: right;\n}\n","data.js":"// a list of the data, that we modify as we go. if you are using an immutable\n// data store (such as Redux) then this would be similar to your store of data.\nvar globalRowData;\n\nvar MIN_BOOK_COUNT = 10;\nvar MAX_BOOK_COUNT = 20;\n\nvar MIN_TRADE_COUNT = 1;\nvar MAX_TRADE_COUNT = 10;\n\nvar products = [\n    'Palm Oil',\n    'Rubber',\n    'Wool',\n    'Amber',\n    'Copper',\n    'Lead',\n    'Zinc',\n    'Tin',\n    'Aluminium',\n    'Aluminium Alloy',\n    'Nickel',\n    'Cobalt',\n    'Molybdenum',\n    'Recycled Steel',\n    'Corn',\n    'Oats',\n    'Rough Rice',\n    'Soybeans',\n    'Rapeseed',\n    'Soybean Meal',\n    'Soybean Oil',\n    'Wheat',\n    'Milk',\n    'Coca',\n    'Coffee C',\n    'Cotton No.2',\n    'Sugar No.11',\n    'Sugar No.14',\n];\n\nvar portfolios = ['Aggressive', 'Defensive', 'Income', 'Speculative', 'Hybrid'];\n\n// start the book id's and trade id's at some future random number,\n// looks more realistic than starting them at 0\nvar nextBookId = 62472;\nvar nextTradeId = 24287;\n\n// build up the test data\nfunction getData() {\n    globalRowData = [];\n    for (var i = 0; i < products.length; i++) {\n        var product = products[i];\n        for (var j = 0; j < portfolios.length; j++) {\n            var portfolio = portfolios[j];\n\n            var bookCount = randomBetween(MAX_BOOK_COUNT, MIN_BOOK_COUNT);\n\n            for (var k = 0; k < bookCount; k++) {\n                var book = createBookName();\n                var tradeCount = randomBetween(MAX_TRADE_COUNT, MIN_TRADE_COUNT);\n                for (var l = 0; l < tradeCount; l++) {\n                    var trade = createTradeRecord(product, portfolio, book);\n                    globalRowData.push(trade);\n                }\n            }\n        }\n    }\n}\n\nfunction randomBetween(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction createTradeRecord(product, portfolio, book) {\n    var current = Math.floor(Math.random() * 100000) + 100;\n    var previous = current + Math.floor(Math.random() * 10000) - 2000;\n    var trade = {\n        product: product,\n        portfolio: portfolio,\n        book: book,\n        trade: createTradeId(),\n        submitterID: randomBetween(10, 1000),\n        submitterDealID: randomBetween(10, 1000),\n        dealType: Math.random() < 0.2 ? 'Physical' : 'Financial',\n        bidFlag: Math.random() < 0.5 ? 'Buy' : 'Sell',\n        current: current,\n        previous: previous,\n        pl1: randomBetween(100, 1000),\n        pl2: randomBetween(100, 1000),\n        gainDx: randomBetween(100, 1000),\n        sxPx: randomBetween(100, 1000),\n        _99Out: randomBetween(100, 1000),\n    };\n    return trade;\n}\n\nfunction createBookName() {\n    nextBookId++;\n    return 'GL-' + nextBookId;\n}\n\nfunction createTradeId() {\n    nextTradeId++;\n    return nextTradeId;\n}\n","main.js":"const UPDATE_COUNT = 500;\n\nconst columnDefs = [\n    // these are the row groups, so they are all hidden (they are show in the group column)\n    {\n        headerName: 'Product',\n        field: 'product',\n        enableRowGroup: true,\n        enablePivot: true,\n        rowGroupIndex: 0,\n        hide: true,\n    },\n    {\n        headerName: 'Portfolio',\n        field: 'portfolio',\n        enableRowGroup: true,\n        enablePivot: true,\n        rowGroupIndex: 1,\n        hide: true,\n    },\n    {\n        headerName: 'Book',\n        field: 'book',\n        enableRowGroup: true,\n        enablePivot: true,\n        rowGroupIndex: 2,\n        hide: true,\n    },\n    { headerName: 'Trade', field: 'trade', width: 100 },\n\n    // all the other columns (visible and not grouped)\n    {\n        field: 'current',\n        width: 200,\n        aggFunc: 'sum',\n        enableValue: true,\n        cellClass: 'number',\n        valueFormatter: numberCellFormatter,\n        cellRenderer: 'agAnimateShowChangeCellRenderer',\n    },\n    {\n        field: 'previous',\n        width: 200,\n        aggFunc: 'sum',\n        enableValue: true,\n        cellClass: 'number',\n        valueFormatter: numberCellFormatter,\n        cellRenderer: 'agAnimateShowChangeCellRenderer',\n    },\n    {\n        field: 'dealType',\n        enableRowGroup: true,\n        enablePivot: true,\n    },\n    {\n        headerName: 'Bid',\n        field: 'bidFlag',\n        enableRowGroup: true,\n        enablePivot: true,\n        width: 100,\n    },\n    {\n        headerName: 'PL 1',\n        field: 'pl1',\n        width: 200,\n        aggFunc: 'sum',\n        enableValue: true,\n        cellClass: 'number',\n        valueFormatter: numberCellFormatter,\n        cellRenderer: 'agAnimateShowChangeCellRenderer',\n    },\n    {\n        headerName: 'PL 2',\n        field: 'pl2',\n        width: 200,\n        aggFunc: 'sum',\n        enableValue: true,\n        cellClass: 'number',\n        valueFormatter: numberCellFormatter,\n        cellRenderer: 'agAnimateShowChangeCellRenderer',\n    },\n    {\n        headerName: 'Gain-DX',\n        field: 'gainDx',\n        width: 200,\n        aggFunc: 'sum',\n        enableValue: true,\n        cellClass: 'number',\n        valueFormatter: numberCellFormatter,\n        cellRenderer: 'agAnimateShowChangeCellRenderer',\n    },\n    {\n        headerName: 'SX / PX',\n        field: 'sxPx',\n        width: 200,\n        aggFunc: 'sum',\n        enableValue: true,\n        cellClass: 'number',\n        valueFormatter: numberCellFormatter,\n        cellRenderer: 'agAnimateShowChangeCellRenderer',\n    },\n    {\n        headerName: '99 Out',\n        field: '_99Out',\n        width: 200,\n        aggFunc: 'sum',\n        enableValue: true,\n        cellClass: 'number',\n        valueFormatter: numberCellFormatter,\n        cellRenderer: 'agAnimateShowChangeCellRenderer',\n    },\n    {\n        field: 'submitterID',\n        width: 200,\n        aggFunc: 'sum',\n        enableValue: true,\n        cellClass: 'number',\n        valueFormatter: numberCellFormatter,\n        cellRenderer: 'agAnimateShowChangeCellRenderer',\n    },\n    {\n        field: 'submitterDealID',\n        width: 200,\n        aggFunc: 'sum',\n        enableValue: true,\n        cellClass: 'number',\n        valueFormatter: numberCellFormatter,\n        cellRenderer: 'agAnimateShowChangeCellRenderer',\n    },\n];\n\nfunction numberCellFormatter(params) {\n    return Math.floor(params.value)\n        .toString()\n        .replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1,');\n}\n\nlet gridApi;\nconst gridOptions = {\n    columnDefs: columnDefs,\n    suppressAggFuncInHeader: true,\n    rowGroupPanelShow: 'always',\n    pivotPanelShow: 'always',\n    getRowId: (params) => String(params.data.trade),\n    defaultColDef: {\n        width: 120,\n    },\n    autoGroupColumnDef: {\n        width: 250,\n    },\n    onGridReady: (params) => {\n        getData();\n        params.api.setGridOption('rowData', globalRowData);\n    },\n};\n\nfunction onNormalUpdate() {\n    const startMillis = new Date().getTime();\n\n    setMessage('Running Transaction');\n\n    for (let i = 0; i < UPDATE_COUNT; i++) {\n        setTimeout(() => {\n            // pick one index at random\n            const index = Math.floor(Math.random() * globalRowData.length);\n            const itemToUpdate = globalRowData[index];\n            const newItem = copyObject(itemToUpdate);\n            // copy previous to current value\n            newItem.previous = newItem.current;\n            // then create new current value\n            newItem.current = Math.floor(Math.random() * 100000) + 100;\n            // do normal update. update is done before method returns\n            gridApi.applyTransaction({ update: [newItem] });\n        }, 0);\n    }\n\n    // print message in next VM turn to allow browser to refresh first.\n    // we assume the browser executes the timeouts in order they are created,\n    // so this timeout executes after all the update timeouts created above.\n    setTimeout(() => {\n        const endMillis = new Date().getTime();\n        const duration = endMillis - startMillis;\n        setMessage('Transaction took ' + duration.toLocaleString() + 'ms');\n    }, 0);\n\n    function setMessage(msg) {\n        const eMessage = document.querySelector('#eMessage') ;\n        eMessage.textContent = msg;\n    }\n}\n\nfunction onAsyncUpdate() {\n    const startMillis = new Date().getTime();\n\n    setMessage('Running Async');\n\n    let updatedCount = 0;\n    for (let i = 0; i < UPDATE_COUNT; i++) {\n        setTimeout(() => {\n            // pick one index at random\n            const index = Math.floor(Math.random() * globalRowData.length);\n            const itemToUpdate = globalRowData[index];\n            const newItem = copyObject(itemToUpdate);\n            // copy previous to current value\n            newItem.previous = newItem.current;\n            // then create new current value\n            newItem.current = Math.floor(Math.random() * 100000) + 100;\n\n            // update using async method. passing the callback is\n            // optional, we are doing it here so we know when the update\n            // was processed by the grid.\n            gridApi.applyTransactionAsync({ update: [newItem] }, resultCallback);\n        }, 0);\n    }\n\n    function resultCallback() {\n        updatedCount++;\n        if (updatedCount === UPDATE_COUNT) {\n            // print message in next VM turn to allow browser to refresh\n            setTimeout(() => {\n                const endMillis = new Date().getTime();\n                const duration = endMillis - startMillis;\n                setMessage('Async took ' + duration.toLocaleString() + 'ms');\n            }, 0);\n        }\n    }\n\n    function setMessage(msg) {\n        const eMessage = document.querySelector('#eMessage') ;\n        eMessage.textContent = msg;\n    }\n}\n\n// makes a copy of the original and merges in the new values\nfunction copyObject(object) {\n    // start with new object\n    const newObject = {};\n\n    // copy in the old values\n    Object.keys(object).forEach((key) => {\n        newObject[key] = object[key];\n    });\n\n    return newObject;\n}\n\n// after page is loaded, create the grid.\ndocument.addEventListener('DOMContentLoaded', function () {\n    const eGridDiv = document.querySelector('#myGrid');\n    gridApi = agGrid.createGrid(eGridDiv, gridOptions); \n});\n","index.html":"<div class=\"example-wrapper\">\n    <div style=\"margin-bottom: 5px\">\n        <button onclick=\"onNormalUpdate()\">Normal Update</button>\n        <button onclick=\"onAsyncUpdate()\">Async Update</button>\n        <span id=\"eMessage\"></span>\n    </div>\n    <div id=\"myGrid\" class=\"ag-theme-quartz\"></div>\n</div>\n"},"boilerPlateFiles":{},"packageJson":{"name":"ag-grid-packages","dependencies":{"ag-grid-community":"^31.3.1","ag-grid-charts-enterprise":"^31.3.1"}}}