{
  "version": 3,
  "sources": ["../../src/sparklinesModule.ts", "../../src/sparklineCellRenderer.ts", "../../src/sparkline/agSparkline.ts", "../../src/sparkline/area/areaSparkline.ts", "../../src/util/lineDash.ts", "../../src/sparkline/marker/markerFactory.ts", "../../src/sparkline/sparkline.ts", "../../src/sparkline/tooltip/defaultTooltipCss.ts", "../../src/sparkline/tooltip/sparklineTooltip.ts", "../../src/sparkline/bar-column/barSparkline.ts", "../../src/sparkline/bar-column/barColumnSparkline.ts", "../../src/sparkline/label/label.ts", "../../src/sparkline/bar-column/columnSparkline.ts", "../../src/sparkline/line/lineSparkline.ts", "../../src/tooltip/sparklineTooltipSingleton.ts", "../../src/version.ts"],
  "sourcesContent": ["import type { Module } from '@ag-grid-community/core';\nimport { ModuleNames } from '@ag-grid-community/core';\nimport { EnterpriseCoreModule } from '@ag-grid-enterprise/core';\n\nimport { SparklineCellRenderer } from './sparklineCellRenderer';\nimport { SparklineTooltipSingleton } from './tooltip/sparklineTooltipSingleton';\nimport { VERSION } from './version';\n\nexport const SparklinesModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.SparklinesModule,\n    beans: [SparklineTooltipSingleton],\n    userComponents: [{ name: 'agSparklineCellRenderer', classImp: SparklineCellRenderer }],\n    dependantModules: [EnterpriseCoreModule],\n};\n", "import type {\n    BeanCollection,\n    ICellRenderer,\n    ISparklineCellRendererParams,\n    ResizeObserverService,\n} from '@ag-grid-community/core';\nimport { Component, RefPlaceholder } from '@ag-grid-community/core';\n\nimport type { SparklineFactoryOptions } from './sparkline/agSparkline';\nimport { AgSparkline } from './sparkline/agSparkline';\nimport type { SparklineTooltipSingleton } from './tooltip/sparklineTooltipSingleton';\n\nexport class SparklineCellRenderer extends Component implements ICellRenderer {\n    private resizeObserverService!: ResizeObserverService;\n    private sparklineTooltipSingleton!: SparklineTooltipSingleton;\n\n    public wireBeans(beans: BeanCollection) {\n        this.resizeObserverService = beans.resizeObserverService;\n        this.sparklineTooltipSingleton = beans.sparklineTooltipSingleton as SparklineTooltipSingleton;\n    }\n\n    private readonly eSparkline: HTMLElement = RefPlaceholder;\n\n    private sparkline?: any;\n\n    constructor() {\n        super(/* html */ `<div class=\"ag-sparkline-wrapper\">\n            <span data-ref=\"eSparkline\"></span>\n        </div>`);\n    }\n\n    public init(params: ISparklineCellRendererParams): void {\n        let firstTimeIn = true;\n        const updateSparkline = () => {\n            const { clientWidth, clientHeight } = this.getGui();\n            if (clientWidth === 0 || clientHeight === 0) {\n                return;\n            }\n\n            if (firstTimeIn) {\n                const options: SparklineFactoryOptions = {\n                    data: params.value,\n                    width: clientWidth,\n                    height: clientHeight,\n                    context: {\n                        data: params.data,\n                    },\n                    ...params.sparklineOptions,\n                };\n\n                // create new instance of sparkline\n                this.sparkline = AgSparkline.create(options, this.sparklineTooltipSingleton.getSparklineTooltip());\n\n                // append sparkline canvas to cell renderer element\n                this.eSparkline!.appendChild(this.sparkline.canvasElement);\n\n                firstTimeIn = false;\n            } else {\n                this.sparkline.width = clientWidth;\n                this.sparkline.height = clientHeight;\n            }\n        };\n\n        const unsubscribeFromResize = this.resizeObserverService.observeResize(this.getGui(), updateSparkline);\n        this.addDestroyFunc(() => unsubscribeFromResize());\n    }\n\n    public refresh(params: ISparklineCellRendererParams): boolean {\n        if (this.sparkline) {\n            this.sparkline.data = params.value;\n            return true;\n        }\n        return false;\n    }\n\n    public override destroy() {\n        if (this.sparkline) {\n            this.sparkline.destroy();\n        }\n        super.destroy();\n    }\n}\n", "import type {\n    CrosshairLineOptions,\n    HighlightStyleOptions,\n    PaddingOptions,\n    SparklineCrosshairsOptions,\n    SparklineLineOptions,\n    SparklineMarkerOptions,\n    SparklineOptions,\n} from '@ag-grid-community/core';\nimport { _warnOnce } from '@ag-grid-community/core';\nimport { _Util } from 'ag-charts-community';\n\nimport { AreaSparkline } from './area/areaSparkline';\nimport type { BarColumnLabel } from './bar-column/barColumnSparkline';\nimport { BarSparkline } from './bar-column/barSparkline';\nimport { ColumnSparkline } from './bar-column/columnSparkline';\nimport { LineSparkline } from './line/lineSparkline';\nimport type { SparklineAxis } from './sparkline';\nimport type { SparklineTooltip } from './tooltip/sparklineTooltip';\n\nconst { isNumber } = _Util;\n\nexport type SparklineFactoryOptions = SparklineOptions & {\n    data: any[];\n    width: number;\n    height: number;\n    context?: any;\n    container?: HTMLElement;\n};\n\ntype SparklineType = LineSparkline | AreaSparkline | ColumnSparkline | BarSparkline;\n\ntype Validators = {\n    [property: string]: ValidatorFunc;\n};\n\ntype ValidatorFunc = (property: string, value: any, defaultValue?: any) => boolean;\n\nexport abstract class AgSparkline {\n    static create(options: SparklineFactoryOptions, tooltip: SparklineTooltip) {\n        // avoid mutating user provided options\n        options = _Util.deepClone(options);\n\n        const sparkline = getSparklineInstance(options.type);\n\n        if (tooltip) {\n            sparkline.tooltip = tooltip;\n        }\n\n        initSparkline(sparkline, options);\n        initSparklineByType(sparkline, options);\n\n        if (options.data) {\n            sparkline.data = options.data;\n        }\n\n        sparkline.processedOptions = options;\n\n        return sparkline;\n    }\n}\n\nfunction getSparklineInstance(type: string = 'line'): any {\n    switch (type) {\n        case 'column':\n            return new ColumnSparkline();\n        case 'bar':\n            return new BarSparkline();\n        case 'area':\n            return new AreaSparkline();\n        case 'line':\n        default:\n            return new LineSparkline();\n    }\n}\n\nfunction initSparklineByType(sparkline: SparklineType, options: any): void {\n    switch (options.type) {\n        case 'bar':\n            initBarColumnSparkline(sparkline as BarSparkline, options);\n            break;\n        case 'column':\n            initBarColumnSparkline(sparkline as ColumnSparkline, options);\n            break;\n        case 'area':\n            initAreaSparkline(sparkline as AreaSparkline, options);\n            break;\n        case 'line':\n        default:\n            initLineSparkline(sparkline as LineSparkline, options);\n            break;\n    }\n}\n\nfunction initSparkline(sparkline: SparklineType, options: any) {\n    setValueIfPropertyExists(sparkline, 'context', options.context, options);\n    setValueIfPropertyExists(sparkline, 'width', options.width, options);\n    setValueIfPropertyExists(sparkline, 'height', options.height, options);\n    setValueIfPropertyExists(sparkline, 'container', options.container, options);\n    setValueIfPropertyExists(sparkline, 'xKey', options.xKey, options);\n    setValueIfPropertyExists(sparkline, 'yKey', options.yKey, options);\n\n    if (options.padding) {\n        initPaddingOptions(sparkline.padding, options.padding);\n    }\n\n    if (options.axis) {\n        initAxisOptions(sparkline.axis, options.axis);\n    }\n\n    if (options.highlightStyle) {\n        initHighlightStyleOptions(sparkline.highlightStyle, options.highlightStyle);\n    }\n}\n\nfunction initLineSparkline(sparkline: LineSparkline, options: any) {\n    if (options.marker) {\n        initMarkerOptions(sparkline.marker, options.marker);\n    }\n\n    if (options.line) {\n        initLineOptions(sparkline.line, options.line);\n    }\n\n    if (options.crosshairs) {\n        initCrosshairsOptions(sparkline.crosshairs, options.crosshairs);\n    }\n}\n\nfunction initAreaSparkline(sparkline: AreaSparkline, options: any) {\n    setValueIfPropertyExists(sparkline, 'fill', options.fill, options);\n\n    if (options.marker) {\n        initMarkerOptions(sparkline.marker, options.marker);\n    }\n\n    if (options.line) {\n        initLineOptions(sparkline.line, options.line);\n    }\n\n    if (options.crosshairs) {\n        initCrosshairsOptions(sparkline.crosshairs, options.crosshairs);\n    }\n}\n\nfunction initBarColumnSparkline(sparkline: ColumnSparkline | BarSparkline, options: any) {\n    setValueIfPropertyExists(sparkline, 'valueAxisDomain', options.valueAxisDomain, options);\n    setValueIfPropertyExists(sparkline, 'fill', options.fill, options);\n    setValueIfPropertyExists(sparkline, 'stroke', options.stroke, options);\n    setValueIfPropertyExists(sparkline, 'strokeWidth', options.strokeWidth, options);\n    setValueIfPropertyExists(sparkline, 'paddingInner', options.paddingInner, options);\n    setValueIfPropertyExists(sparkline, 'paddingOuter', options.paddingOuter, options);\n    setValueIfPropertyExists(sparkline, 'formatter', options.formatter, options);\n\n    if (options.label) {\n        initLabelOptions(sparkline.label, options.label);\n    }\n}\n\nfunction initPaddingOptions(target: PaddingOptions, options: any) {\n    setValueIfPropertyExists(target, 'top', options.top, options);\n    setValueIfPropertyExists(target, 'right', options.right, options);\n    setValueIfPropertyExists(target, 'bottom', options.bottom, options);\n    setValueIfPropertyExists(target, 'left', options.left, options);\n}\n\nfunction initMarkerOptions(target: SparklineMarkerOptions, options: any) {\n    setValueIfPropertyExists(target, 'enabled', options.enabled, options);\n    setValueIfPropertyExists(target, 'size', options.size, options);\n    setValueIfPropertyExists(target, 'shape', options.shape, options);\n    setValueIfPropertyExists(target, 'fill', options.fill, options);\n    setValueIfPropertyExists(target, 'stroke', options.stroke, options);\n    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);\n    setValueIfPropertyExists(target, 'formatter', options.formatter, options);\n}\n\nfunction initLabelOptions(target: BarColumnLabel, options: any) {\n    setValueIfPropertyExists(target, 'enabled', options.enabled, options);\n    setValueIfPropertyExists(target, 'fontStyle', options.fontStyle, options);\n    setValueIfPropertyExists(target, 'fontWeight', options.fontWeight, options);\n    setValueIfPropertyExists(target, 'fontSize', options.fontSize, options);\n    setValueIfPropertyExists(target, 'fontFamily', options.fontFamily, options);\n    setValueIfPropertyExists(target, 'textAlign', options.textAlign, options);\n    setValueIfPropertyExists(target, 'textBaseline', options.textBaseline, options);\n    setValueIfPropertyExists(target, 'color', options.color, options);\n    setValueIfPropertyExists(target, 'formatter', options.formatter, options);\n    setValueIfPropertyExists(target, 'placement', options.placement, options);\n}\n\nfunction initLineOptions(target: SparklineLineOptions, options: any) {\n    setValueIfPropertyExists(target, 'stroke', options.stroke, options);\n    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);\n}\n\nfunction initAxisOptions(target: SparklineAxis, options: any) {\n    setValueIfPropertyExists(target, 'type', options.type, options);\n    setValueIfPropertyExists(target, 'stroke', options.stroke, options);\n    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);\n}\n\nfunction initHighlightStyleOptions(target: HighlightStyleOptions, options: any) {\n    setValueIfPropertyExists(target, 'fill', options.fill, options);\n    setValueIfPropertyExists(target, 'size', options.size, options);\n    setValueIfPropertyExists(target, 'stroke', options.stroke, options);\n    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);\n}\n\nfunction initCrosshairsOptions(target: SparklineCrosshairsOptions, options: any) {\n    if (target.xLine && options.xLine) {\n        initCrosshairLineOptions(target.xLine, options.xLine);\n    }\n\n    if (target.yLine && options.yLine) {\n        initCrosshairLineOptions(target.yLine, options.yLine);\n    }\n}\n\nfunction initCrosshairLineOptions(target: CrosshairLineOptions, options: any) {\n    setValueIfPropertyExists(target, 'enabled', options.enabled, options);\n    setValueIfPropertyExists(target, 'stroke', options.stroke, options);\n    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);\n    setValueIfPropertyExists(target, 'lineDash', options.lineDash, options);\n    setValueIfPropertyExists(target, 'lineCap', options.lineCap, options);\n}\n\nconst offsetValidator = (property: string, value: number, defaultOffset?: number): boolean => {\n    if (isNumber(value)) {\n        return true;\n    }\n\n    _warnOnce(\n        `${property} must be a number, the value you provided is not a valid number. Using the default of ${defaultOffset}px.`\n    );\n    return false;\n};\n\nconst validators: Validators = {\n    xOffset: offsetValidator,\n    yOffset: offsetValidator,\n};\n\nfunction setValueIfPropertyExists(target: any, property: string, value: any, options: any): void {\n    if (property in options) {\n        if (property in target) {\n            const validator = validators[property];\n            const isValid = validator ? validator(property, value, target[property]) : true;\n\n            if (isValid && target[property] !== value) {\n                // only set property if the value is different to new value\n                target[property] = value;\n            }\n        } else {\n            _warnOnce(`Property ${property} does not exist on the target object.`);\n        }\n    }\n}\n", "import type { CrosshairLineOptions, MarkerFormat, MarkerFormatterParams } from '@ag-grid-community/core';\nimport { _Scale, _Scene, _Util } from 'ag-charts-community';\n\nimport { getLineDash } from '../../util/lineDash';\nimport { getMarker } from '../marker/markerFactory';\nimport type { Point, SeriesNodeDatum } from '../sparkline';\nimport { Sparkline, ZINDICIES } from '../sparkline';\nimport { toTooltipHtml } from '../tooltip/sparklineTooltip';\n\nconst { extent } = _Util;\nconst { BandScale } = _Scale;\n\ninterface AreaNodeDatum extends SeriesNodeDatum {}\n\ninterface PathDatum extends SeriesNodeDatum {\n    point: Point;\n}\n\nclass SparklineMarker {\n    enabled: boolean = true;\n    shape: string = 'circle';\n    size: number = 0;\n    fill?: string = 'rgb(124, 181, 236)';\n    stroke?: string = 'rgb(124, 181, 236)';\n    strokeWidth: number = 1;\n    formatter?: (params: MarkerFormatterParams) => MarkerFormat = undefined;\n}\n\nclass SparklineLine {\n    stroke: string = 'rgb(124, 181, 236)';\n    strokeWidth: number = 1;\n}\n\nclass SparklineCrosshairs {\n    xLine: CrosshairLineOptions = {\n        enabled: true,\n        stroke: 'rgba(0,0,0, 0.54)',\n        strokeWidth: 1,\n        lineDash: 'solid',\n        lineCap: undefined,\n    };\n    yLine: CrosshairLineOptions = {\n        enabled: false,\n        stroke: 'rgba(0,0,0, 0.54)',\n        strokeWidth: 1,\n        lineDash: 'solid',\n        lineCap: undefined,\n    };\n}\nexport class AreaSparkline extends Sparkline {\n    fill: string = 'rgba(124, 181, 236, 0.25)';\n\n    protected strokePath: _Scene.Path = new _Scene.Path();\n    protected fillPath: _Scene.Path = new _Scene.Path();\n    protected xCrosshairLine: _Scene.Line = new _Scene.Line();\n    protected yCrosshairLine: _Scene.Line = new _Scene.Line();\n\n    private areaSparklineGroup: _Scene.Group = new _Scene.Group();\n    private xAxisLine: _Scene.Line = new _Scene.Line();\n    private markers: _Scene.Group = new _Scene.Group();\n    private markerSelection: _Scene.Selection<_Scene.Marker, AreaNodeDatum> = _Scene.Selection.select(\n        this.markers,\n        () => this.markerFactory()\n    );\n    private markerSelectionData: AreaNodeDatum[] = [];\n\n    readonly marker = new SparklineMarker();\n    readonly line = new SparklineLine();\n    readonly crosshairs = new SparklineCrosshairs();\n\n    constructor() {\n        super();\n        this.rootGroup.append(this.areaSparklineGroup);\n\n        this.xAxisLine.zIndex = ZINDICIES.AXIS_LINE_ZINDEX;\n        this.fillPath.zIndex = ZINDICIES.SERIES_FILL_ZINDEX;\n        this.strokePath.zIndex = ZINDICIES.SERIES_STROKE_ZINDEX;\n        this.xCrosshairLine.zIndex = ZINDICIES.CROSSHAIR_ZINDEX;\n        this.yCrosshairLine.zIndex = ZINDICIES.CROSSHAIR_ZINDEX;\n        this.markers.zIndex = ZINDICIES.SERIES_MARKERS_ZINDEX;\n\n        this.areaSparklineGroup.append([\n            this.fillPath,\n            this.xAxisLine,\n            this.strokePath,\n            this.xCrosshairLine,\n            this.yCrosshairLine,\n            this.markers,\n        ]);\n    }\n\n    protected markerFactory(): _Scene.Marker {\n        const { shape } = this.marker;\n        const MarkerShape = getMarker(shape);\n        return new MarkerShape();\n    }\n\n    protected override getNodeData(): AreaNodeDatum[] {\n        return this.markerSelectionData;\n    }\n\n    protected override update(): void {\n        const data = this.generateNodeData();\n\n        if (!data) {\n            return;\n        }\n\n        const { nodeData, fillData, strokeData } = data;\n\n        this.markerSelectionData = nodeData;\n\n        this.updateSelection(nodeData);\n        this.updateNodes();\n\n        this.updateStroke(strokeData);\n        this.updateFill(fillData);\n    }\n\n    protected override updateYScaleDomain(): void {\n        const { yData, yScale } = this;\n        const yMinMax = extent(yData as number[]);\n\n        let yMin = 0;\n        let yMax = 1;\n\n        if (yMinMax !== undefined) {\n            yMin = this.min = yMinMax[0] as number;\n            yMax = this.max = yMinMax[1] as number;\n        }\n\n        // if yMin is positive, set yMin to 0\n        yMin = yMin < 0 ? yMin : 0;\n\n        // if yMax is negative, set yMax to 0\n        yMax = yMax < 0 ? 0 : yMax;\n\n        yScale.domain = [yMin, yMax];\n    }\n\n    protected override generateNodeData():\n        | { nodeData: AreaNodeDatum[]; fillData: PathDatum[]; strokeData: PathDatum[] }\n        | undefined {\n        const { data, yData, xData, xScale, yScale } = this;\n\n        if (!data) {\n            return;\n        }\n\n        const continuous = !(xScale instanceof BandScale);\n\n        const offsetX = !continuous ? xScale.bandwidth / 2 : 0;\n        const n = yData.length;\n\n        const nodeData: AreaNodeDatum[] = [];\n        const fillData: PathDatum[] = [];\n        const strokeData: PathDatum[] = [];\n\n        let firstValidX;\n        let lastValidX;\n\n        let previousX;\n        let nextX;\n\n        const yZero = yScale.convert(0);\n\n        for (let i = 0; i < n; i++) {\n            const yDatum = yData[i];\n            const xDatum = xData[i];\n\n            const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;\n            const y = yDatum === undefined ? NaN : yScale.convert(yDatum);\n\n            // if this iteration is not the last, set nextX using the next value in the data array\n            if (i + 1 < n) {\n                nextX = xScale.convert(continuous ? xScale.toDomain(xData[i + 1]) : xData[i + 1]) + offsetX;\n            }\n\n            // set stroke data regardless of missing/ undefined values. Undefined values will be handled in the updateStroke() method\n            strokeData.push({\n                seriesDatum: { x: xDatum, y: yDatum },\n                point: { x, y },\n            });\n\n            if (yDatum === undefined && previousX !== undefined) {\n                // if yDatum is undefined and there is a valid previous data point, add a phantom point at yZero\n                // if a next data point exists, add a phantom point at yZero at the next X\n                fillData.push({ seriesDatum: undefined, point: { x: previousX, y: yZero } });\n                if (nextX !== undefined) {\n                    fillData.push({ seriesDatum: undefined, point: { x: nextX, y: yZero } });\n                }\n            } else if (yDatum !== undefined) {\n                fillData.push({\n                    seriesDatum: { x: xDatum, y: yDatum },\n                    point: { x, y },\n                });\n\n                // set node data only if yDatum is not undefined. These values are used in the updateSelection() method to update markers\n                nodeData.push({\n                    seriesDatum: { x: xDatum, y: yDatum },\n                    point: { x, y },\n                });\n\n                firstValidX = firstValidX !== undefined ? firstValidX : x;\n                lastValidX = x;\n            }\n            previousX = x;\n        }\n\n        // phantom points for creating closed area\n        fillData.push(\n            { seriesDatum: undefined, point: { x: lastValidX, y: yZero } },\n            { seriesDatum: undefined, point: { x: firstValidX, y: yZero } }\n        );\n\n        return { nodeData, fillData, strokeData };\n    }\n\n    protected override updateAxisLine() {\n        const { xScale, yScale, axis, xAxisLine } = this;\n\n        xAxisLine.x1 = xScale.range[0];\n        xAxisLine.x2 = xScale.range[1];\n        xAxisLine.y1 = xAxisLine.y2 = 0;\n        xAxisLine.stroke = axis.stroke;\n        xAxisLine.strokeWidth = axis.strokeWidth;\n\n        const yZero: number = yScale.convert(0);\n        xAxisLine.translationY = yZero;\n    }\n\n    private updateSelection(selectionData: AreaNodeDatum[]): void {\n        this.markerSelection.update(selectionData);\n    }\n\n    protected override updateNodes(): void {\n        const { highlightedDatum, highlightStyle, marker } = this;\n        const {\n            size: highlightSize,\n            fill: highlightFill,\n            stroke: highlightStroke,\n            strokeWidth: highlightStrokeWidth,\n        } = highlightStyle;\n        const markerFormatter = marker.formatter;\n\n        this.markerSelection.each((node, datum, index) => {\n            const { point, seriesDatum } = datum;\n\n            if (!point) {\n                return;\n            }\n\n            const highlighted = datum === highlightedDatum;\n            const markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill;\n            const markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke;\n            const markerStrokeWidth =\n                highlighted && highlightStrokeWidth !== undefined ? highlightStrokeWidth : marker.strokeWidth;\n            const markerSize = highlighted && highlightSize !== undefined ? highlightSize : marker.size;\n\n            let markerFormat: MarkerFormat | undefined;\n\n            if (markerFormatter) {\n                const first = index === 0;\n                const last = index === this.markerSelectionData.length - 1;\n                const min = seriesDatum.y === this.min;\n                const max = seriesDatum.y === this.max;\n\n                markerFormat = markerFormatter({\n                    datum,\n                    xValue: seriesDatum.x,\n                    yValue: seriesDatum.y,\n                    min,\n                    max,\n                    first,\n                    last,\n                    fill: markerFill,\n                    stroke: markerStroke,\n                    strokeWidth: markerStrokeWidth,\n                    size: markerSize,\n                    highlighted,\n                });\n            }\n\n            node.size = markerFormat && markerFormat.size != undefined ? markerFormat.size : markerSize;\n            node.fill = markerFormat && markerFormat.fill != undefined ? markerFormat.fill : markerFill;\n            node.stroke = markerFormat && markerFormat.stroke != undefined ? markerFormat.stroke : markerStroke;\n            node.strokeWidth =\n                markerFormat && markerFormat.strokeWidth != undefined ? markerFormat.strokeWidth : markerStrokeWidth;\n\n            node.translationX = point.x;\n            node.translationY = point.y;\n            node.visible =\n                markerFormat && markerFormat.enabled != undefined\n                    ? markerFormat.enabled\n                    : marker.enabled && node.size > 0;\n        });\n    }\n\n    updateStroke(strokeData: PathDatum[]) {\n        const { strokePath, yData, line } = this;\n\n        const path = strokePath.path;\n        path.clear();\n\n        if (yData.length < 2) {\n            return;\n        }\n\n        const n = strokeData.length;\n        let moveTo = true;\n\n        for (let i = 0; i < n; i++) {\n            const { point, seriesDatum } = strokeData[i];\n\n            const x = point.x;\n            const y = point.y;\n\n            if (seriesDatum.y == undefined) {\n                moveTo = true;\n            } else {\n                if (moveTo) {\n                    path.moveTo(x, y);\n                    moveTo = false;\n                } else {\n                    path.lineTo(x, y);\n                }\n            }\n        }\n\n        strokePath.lineJoin = strokePath.lineCap = 'round';\n        strokePath.fill = undefined;\n        strokePath.stroke = line.stroke;\n        strokePath.strokeWidth = line.strokeWidth;\n    }\n\n    updateFill(areaData: PathDatum[]) {\n        const { fillPath, yData, fill } = this;\n\n        const path = fillPath.path;\n        const n = areaData.length;\n\n        path.clear();\n\n        if (yData.length < 2) {\n            return;\n        }\n\n        for (let i = 0; i < n; i++) {\n            const { point } = areaData[i];\n\n            const x = point.x;\n            const y = point.y;\n\n            if (i > 0) {\n                path.lineTo(x, y);\n            } else {\n                path.moveTo(x, y);\n            }\n        }\n\n        path.closePath();\n\n        fillPath.lineJoin = 'round';\n        fillPath.stroke = undefined;\n        fillPath.fill = fill;\n    }\n\n    protected override updateXCrosshairLine(): void {\n        const {\n            yScale,\n            xCrosshairLine,\n            highlightedDatum,\n            crosshairs: { xLine },\n        } = this;\n\n        if (!xLine.enabled || highlightedDatum == undefined) {\n            xCrosshairLine.strokeWidth = 0;\n            return;\n        }\n\n        xCrosshairLine.y1 = yScale.range[0];\n        xCrosshairLine.y2 = yScale.range[1];\n        xCrosshairLine.x1 = xCrosshairLine.x2 = 0;\n        xCrosshairLine.stroke = xLine.stroke;\n        xCrosshairLine.strokeWidth = xLine.strokeWidth ?? 1;\n\n        xCrosshairLine.lineCap = xLine.lineCap === 'round' || xLine.lineCap === 'square' ? xLine.lineCap : undefined;\n\n        const { lineDash } = xLine;\n        xCrosshairLine.lineDash = Array.isArray(lineDash)\n            ? lineDash\n            : getLineDash(xCrosshairLine.lineCap, xLine.lineDash as string);\n\n        xCrosshairLine.translationX = highlightedDatum.point!.x;\n    }\n\n    protected override updateYCrosshairLine() {\n        const {\n            xScale,\n            yCrosshairLine,\n            highlightedDatum,\n            crosshairs: { yLine },\n        } = this;\n\n        if (!yLine.enabled || highlightedDatum == undefined) {\n            yCrosshairLine.strokeWidth = 0;\n            return;\n        }\n\n        yCrosshairLine.x1 = xScale.range[0];\n        yCrosshairLine.x2 = xScale.range[1];\n        yCrosshairLine.y1 = yCrosshairLine.y2 = 0;\n        yCrosshairLine.stroke = yLine.stroke;\n        yCrosshairLine.strokeWidth = yLine.strokeWidth ?? 1;\n\n        yCrosshairLine.lineCap = yLine.lineCap === 'round' || yLine.lineCap === 'square' ? yLine.lineCap : undefined;\n\n        const { lineDash } = yLine;\n        yCrosshairLine.lineDash = Array.isArray(lineDash)\n            ? lineDash\n            : getLineDash(yCrosshairLine.lineCap, yLine.lineDash as string);\n\n        yCrosshairLine.translationY = highlightedDatum.point!.y;\n    }\n\n    getTooltipHtml(datum: SeriesNodeDatum): string | undefined {\n        const { dataType } = this;\n        const { seriesDatum } = datum;\n        const yValue = seriesDatum.y;\n        const xValue = seriesDatum.x;\n        const content = this.formatNumericDatum(yValue);\n        const title = dataType === 'array' || dataType === 'object' ? this.formatDatum(xValue) : undefined;\n\n        const defaults = {\n            content,\n            title,\n        };\n\n        const tooltipRenderer = this.processedOptions?.tooltip?.renderer;\n        if (tooltipRenderer) {\n            return toTooltipHtml(\n                tooltipRenderer({\n                    context: this.context,\n                    datum: seriesDatum,\n                    yValue,\n                    xValue,\n                }),\n                defaults\n            );\n        }\n\n        return toTooltipHtml(defaults);\n    }\n}\n", "import { _warnOnce } from '@ag-grid-community/core';\n\nexport function getLineDash(lineCap: 'butt' | 'square' | 'round' | undefined, lineDash: string = 'solid'): number[] {\n    const buttOrNull: { [key: string]: number[] } = {\n        solid: [],\n        dash: [4, 3],\n        dot: [1, 3],\n        dashDot: [4, 3, 1, 3],\n        dashDotDot: [4, 3, 1, 3, 1, 3],\n        shortDot: [1, 1],\n        shortDash: [3, 1],\n        shortDashDot: [3, 1, 1, 1],\n        shortDashDotDot: [3, 1, 1, 1, 1, 1],\n        longDash: [8, 3],\n        longDashDot: [8, 3, 1, 3],\n        longDashDotDot: [8, 3, 1, 3, 1, 3],\n    };\n\n    const roundOrSquare: { [key: string]: number[] } = {\n        solid: [],\n        dash: [3, 3],\n        dot: [0, 3],\n        dashDot: [3, 3, 0, 3],\n        dashDotDot: [3, 3, 0, 3, 0, 3],\n        shortDot: [0, 2],\n        shortDash: [2, 2],\n        shortDashDot: [2, 2, 0, 2],\n        shortDashDotDot: [2, 2, 0, 2, 0, 2],\n        longDash: [7, 3],\n        longDashDot: [7, 3, 0, 3],\n        longDashDotDot: [7, 3, 0, 3, 0, 3],\n    };\n\n    if (lineCap === 'round' || lineCap === 'square') {\n        if (roundOrSquare[lineDash] == undefined) {\n            warnInvalid(lineDash);\n            return roundOrSquare.solid;\n        }\n\n        return roundOrSquare[lineDash];\n    }\n\n    if (buttOrNull[lineDash] == undefined) {\n        warnInvalid(lineDash);\n        return buttOrNull.solid;\n    }\n\n    return buttOrNull[lineDash];\n}\n\nfunction warnInvalid(lineDash: string) {\n    _warnOnce(`'${lineDash}' is not a valid 'lineDash' option.`);\n}\n", "import { _Scene } from 'ag-charts-community';\n\nexport function getMarker(shape: string) {\n    switch (shape) {\n        case 'circle':\n            return _Scene.Circle;\n        case 'square':\n            return _Scene.Square;\n        case 'diamond':\n            return _Scene.Diamond;\n        default:\n            return _Scene.Circle;\n    }\n}\n", "import { _errorOnce } from '@ag-grid-community/core';\nimport type { HighlightStyleOptions } from '@ag-grid-community/core';\nimport { _Scale, _Scene, _Util } from 'ag-charts-community';\n\nimport type { SparklineFactoryOptions } from './agSparkline';\nimport { defaultTooltipCss } from './tooltip/defaultTooltipCss';\nimport type { SparklineTooltip, SparklineTooltipMeta } from './tooltip/sparklineTooltip';\n\nconst { extent, isNumber, isString, isStringObject, isDate, createId, Padding } = _Util;\nconst { LinearScale, BandScale, TimeScale } = _Scale;\n\n/**\n * Constants to declare the expected nominal zIndex for nodes in a sparkline rendering.\n */\nexport enum ZINDICIES {\n    SERIES_FILL_ZINDEX = 50,\n    AXIS_LINE_ZINDEX = 500,\n    SERIES_STROKE_ZINDEX = 1000,\n    SERIES_LABEL_ZINDEX = 1500,\n    CROSSHAIR_ZINDEX = 2000,\n    SERIES_MARKERS_ZINDEX = 2500,\n}\n\nexport interface SeriesNodeDatum {\n    readonly seriesDatum: any;\n    readonly point?: Point;\n}\n\nexport interface Point {\n    readonly x: number;\n    readonly y: number;\n}\n\ninterface SeriesRect {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\ntype Container = HTMLElement | undefined | null;\ntype Data = any[] | undefined | null;\ntype DataType = 'number' | 'array' | 'object' | undefined;\ntype AxisType = 'number' | 'category' | 'time';\ntype ScaleType = _Scale.LinearScale | _Scale.TimeScale | _Scale.BandScale<string>;\n\nexport class SparklineAxis {\n    type?: AxisType = 'category';\n    stroke: string = 'rgb(204, 214, 235)';\n    strokeWidth: number = 1;\n}\nexport abstract class Sparkline {\n    readonly id: string = createId(this);\n\n    processedOptions?: SparklineFactoryOptions;\n\n    readonly scene: _Scene.Scene;\n    readonly canvasElement: HTMLCanvasElement;\n    readonly rootGroup: _Scene.Group;\n\n    // Only one tooltip instance for all sparkline instances.\n    tooltip!: SparklineTooltip;\n    private static tooltipDocuments: Document[] = [];\n\n    private mouseMoveEvent: MouseEvent;\n\n    protected seriesRect: SeriesRect = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n    };\n\n    private _context: { data: any } | undefined = undefined;\n    set context(value: { data: any } | undefined) {\n        if (this._context !== value) {\n            this._context = value;\n        }\n    }\n    get context(): { data: any } | undefined {\n        return this._context;\n    }\n\n    private _container: Container = undefined;\n    set container(value: Container) {\n        if (this._container !== value) {\n            const { parentNode } = this.canvasElement;\n\n            if (parentNode != null) {\n                parentNode.removeChild(this.canvasElement);\n            }\n\n            if (value) {\n                value.appendChild(this.canvasElement);\n            }\n\n            this._container = value;\n        }\n    }\n    get container(): Container {\n        return this._container;\n    }\n\n    private _data: Data = undefined;\n    set data(value: Data) {\n        if (this._data !== value) {\n            this._data = value;\n            this.processData();\n            if (this.mouseMoveEvent && this.highlightedDatum) {\n                this.updateHitPoint(this.mouseMoveEvent);\n            }\n        }\n    }\n    get data() {\n        return this._data;\n    }\n\n    padding: _Util.Padding = new Padding(3);\n\n    xKey: string = 'x';\n    yKey: string = 'y';\n\n    protected dataType: DataType = undefined;\n    protected xData: any[] = [];\n    protected yData: (number | undefined)[] = [];\n\n    // Minimum y value in provided data.\n    protected min: number | undefined = undefined;\n    // Maximum y value in provided data.\n    protected max: number | undefined = undefined;\n\n    protected xScale!: any;\n    protected yScale: _Scale.LinearScale = new LinearScale();\n\n    readonly axis = new SparklineAxis();\n    readonly highlightStyle: HighlightStyleOptions = {\n        size: 6,\n        fill: 'yellow',\n        stroke: 'silver',\n        strokeWidth: 1,\n    };\n\n    protected constructor() {\n        const root = new _Scene.Group();\n        this.rootGroup = root;\n\n        const element = document.createElement('div');\n        element.setAttribute('class', 'ag-sparkline-wrapper');\n\n        // initialise scene\n        const scene = new _Scene.Scene({});\n        this.scene = scene;\n        this.canvasElement = scene.canvas.element;\n\n        // set scene properties\n        scene.setRoot(root);\n        scene.setContainer(element);\n\n        this.resizeAndSetDimensions(this.width, this.height);\n\n        // one style element for tooltip styles per document\n        if (!Sparkline.tooltipDocuments.includes(document)) {\n            this.initialiseTooltipStyles();\n        }\n\n        this.setupDomEventListeners(this.canvasElement);\n    }\n\n    private resizeAndSetDimensions(width: number, height: number): void {\n        this.scene.resize(width, height);\n        this.seriesRect.width = width;\n        this.seriesRect.height = height;\n    }\n\n    private initialiseTooltipStyles(): void {\n        const styleElement = document.createElement('style');\n        styleElement.innerHTML = defaultTooltipCss;\n        document.head.insertBefore(styleElement, document.head.querySelector('style'));\n        Sparkline.tooltipDocuments.push(document);\n    }\n\n    private _width: number = 100;\n    set width(value: number) {\n        if (this._width !== value) {\n            this._width = value;\n            this.scene.resize(value, this.height);\n            this.scheduleLayout();\n        }\n    }\n    get width(): number {\n        return this._width;\n    }\n\n    private _height: number = 100;\n    set height(value: number) {\n        if (this._height !== value) {\n            this._height = value;\n            this.scene.resize(this.width, value);\n            this.scheduleLayout();\n        }\n    }\n    get height(): number {\n        return this._height;\n    }\n\n    /**\n     * Generate node data from processed data.\n     * Produce data joins.\n     * Update selection's nodes using node data.\n     */\n    protected update() {}\n\n    // Update y scale based on processed data.\n    protected updateYScale(): void {\n        this.updateYScaleRange();\n        this.updateYScaleDomain();\n    }\n\n    // Update y scale domain based on processed data.\n    protected updateYScaleDomain() {}\n\n    // Update y scale range based on height and padding (seriesRect).\n    protected updateYScaleRange(): void {\n        const { yScale, seriesRect } = this;\n        yScale.range = [seriesRect.height, 0];\n    }\n\n    // Update x scale based on processed data.\n    protected updateXScale(): void {\n        const { type } = this.axis;\n\n        this.xScale = this.getXScale(type);\n\n        this.updateXScaleRange();\n        this.updateXScaleDomain();\n    }\n\n    // Update x scale range based on width and padding (seriesRect).\n    protected updateXScaleRange(): void {\n        this.xScale.range = [0, this.seriesRect.width];\n    }\n\n    // Update x scale domain based on processed data and type of scale.\n    protected updateXScaleDomain(): void {\n        const { xData, xScale } = this;\n\n        let xMinMax;\n        if (xScale instanceof LinearScale || xScale instanceof TimeScale) {\n            xMinMax = extent(xData);\n        }\n\n        this.xScale.domain = xMinMax ? xMinMax.slice() : xData;\n    }\n\n    /**\n     * Return xScale instance based on the provided type or return a `BandScale` by default.\n     * The default type is `category`.\n     * @param type\n     */\n    protected getXScale(type: AxisType = 'category'): ScaleType {\n        switch (type) {\n            case 'number':\n                return new LinearScale();\n            case 'time':\n                return new TimeScale();\n            case 'category':\n            default:\n                return new BandScale();\n        }\n    }\n\n    // Update axis line.\n    protected updateAxisLine(): void {}\n\n    // Update X and Y scales and the axis line.\n    protected updateAxes(): void {\n        this.updateYScale();\n        this.updateXScale();\n        this.updateAxisLine();\n    }\n\n    // Update horizontal and vertical crosshair lines.\n    protected updateCrosshairs(): void {\n        this.updateXCrosshairLine();\n        this.updateYCrosshairLine();\n    }\n\n    // Using processed data, generate data that backs visible nodes.\n    protected generateNodeData():\n        | { nodeData: SeriesNodeDatum[]; fillData: SeriesNodeDatum[]; strokeData: SeriesNodeDatum[] }\n        | SeriesNodeDatum[]\n        | undefined {\n        return [];\n    }\n\n    // Returns persisted node data associated with the sparkline's data.\n    protected getNodeData(): readonly SeriesNodeDatum[] {\n        return [];\n    }\n\n    // Update the selection's nodes.\n    protected updateNodes(): void {}\n\n    // Update the vertical crosshair line.\n    protected updateXCrosshairLine(): void {}\n\n    // Update the horizontal crosshair line.\n    protected updateYCrosshairLine(): void {}\n\n    // Efficiently update sparkline nodes on hightlight changes.\n    protected highlightedDatum?: SeriesNodeDatum;\n    protected highlightDatum(closestDatum: SeriesNodeDatum): void {\n        this.updateNodes();\n    }\n\n    protected dehighlightDatum(): void {\n        this.highlightedDatum = undefined;\n        this.updateNodes();\n        this.updateCrosshairs();\n    }\n\n    abstract getTooltipHtml(datum: SeriesNodeDatum): string | undefined;\n\n    /**\n     * Highlight closest datum and display tooltip if enabled.\n     * Only update if necessary, i.e. only update if the highlighted datum is different from previously highlighted datum,\n     * or if there is no previously highlighted datum.\n     * @param event\n     */\n    private onMouseMove(event: MouseEvent) {\n        this.mouseMoveEvent = event;\n        this.updateHitPoint(event);\n    }\n\n    private renderScene() {\n        this.scene.render().catch((e) => _errorOnce(`chart rendering failed`, e));\n    }\n\n    private updateHitPoint(event: MouseEvent) {\n        const closestDatum: SeriesNodeDatum | undefined = this.pickClosestSeriesNodeDatum(event.offsetX, event.offsetY);\n\n        if (!closestDatum) {\n            return;\n        }\n\n        const oldHighlightedDatum = this.highlightedDatum;\n        this.highlightedDatum = closestDatum;\n\n        if (\n            (this.highlightedDatum && !oldHighlightedDatum) ||\n            (this.highlightedDatum && oldHighlightedDatum && this.highlightedDatum !== oldHighlightedDatum)\n        ) {\n            this.highlightDatum(closestDatum);\n            this.updateCrosshairs();\n            this.renderScene();\n        }\n\n        const tooltipEnabled = this.processedOptions?.tooltip?.enabled ?? true;\n        if (tooltipEnabled) {\n            this.handleTooltip(event, closestDatum);\n        }\n    }\n\n    /**\n     * Dehighlight all nodes and remove tooltip.\n     * @param event\n     */\n    private onMouseOut(event: MouseEvent) {\n        this.dehighlightDatum();\n        this.tooltip.toggle(false);\n        this.renderScene();\n    }\n\n    protected smallestInterval?: { x: number; y: number } = undefined;\n    // Fetch required values from the data object and process them.\n    private processData() {\n        const { data, yData, xData } = this;\n\n        if (!data || this.invalidData(this.data)) {\n            return;\n        }\n\n        yData.length = 0;\n        xData.length = 0;\n\n        const n = data.length;\n\n        const dataType = this.getDataType(data);\n        this.dataType = dataType;\n\n        const { type: xValueType } = this.axis;\n        const xType = xValueType !== 'number' && xValueType !== 'time' ? 'category' : xValueType;\n\n        const isContinuousX = xType === 'number' || xType === 'time';\n\n        const setSmallestXInterval = (curr: number, prev: number) => {\n            if (this.smallestInterval == undefined) {\n                this.smallestInterval = { x: Infinity, y: Infinity };\n            }\n            const { x } = this.smallestInterval;\n\n            const interval = Math.abs(curr - prev);\n            if (interval > 0 && interval < x) {\n                this.smallestInterval.x = interval;\n            }\n        };\n\n        let prevX;\n\n        if (dataType === 'number') {\n            for (let i = 0; i < n; i++) {\n                const xDatum = i;\n                const yDatum = data[i];\n\n                const x = this.getDatum(xDatum, xType);\n                const y = this.getDatum(yDatum, 'number');\n\n                if (isContinuousX) {\n                    setSmallestXInterval(x, prevX);\n                }\n\n                xData.push(x);\n                yData.push(y);\n\n                prevX = x;\n            }\n        } else if (dataType === 'array') {\n            for (let i = 0; i < n; i++) {\n                const datum = data[i];\n                if (Array.isArray(datum)) {\n                    const xDatum = datum[0];\n                    const yDatum = datum[1];\n\n                    const x = this.getDatum(xDatum, xType);\n                    const y = this.getDatum(yDatum, 'number');\n\n                    if (x == undefined) {\n                        continue;\n                    }\n\n                    if (isContinuousX) {\n                        setSmallestXInterval(x, prevX);\n                    }\n\n                    xData.push(x);\n                    yData.push(y);\n\n                    prevX = x;\n                }\n            }\n        } else if (dataType === 'object') {\n            const { yKey, xKey } = this;\n\n            for (let i = 0; i < n; i++) {\n                const datum = data[i];\n\n                if (typeof datum === 'object' && !Array.isArray(datum)) {\n                    const xDatum = datum[xKey];\n                    const yDatum = datum[yKey];\n\n                    const x = this.getDatum(xDatum, xType);\n                    const y = this.getDatum(yDatum, 'number');\n\n                    if (x == undefined) {\n                        continue;\n                    }\n\n                    if (isContinuousX) {\n                        setSmallestXInterval(x, prevX);\n                    }\n\n                    xData.push(x);\n                    yData.push(y);\n\n                    prevX = x;\n                }\n            }\n        }\n\n        this.updateAxes();\n        this.immediateLayout();\n    }\n\n    /**\n     * Return the type of data provided to the sparkline based on the first truthy value in the data array.\n     * If the value is not a number, array or object, return `undefined`.\n     * @param data\n     */\n    private getDataType(data: any): DataType {\n        for (const datum of data) {\n            if (datum != undefined) {\n                if (isNumber(datum)) {\n                    return 'number';\n                } else if (Array.isArray(datum)) {\n                    return 'array';\n                } else if (typeof datum === 'object') {\n                    return 'object';\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the given value depending on the type of axis.\n     * Return `undefined` if the value is invalid for the given axis type.\n     * @param value\n     */\n    private getDatum(value: any, type: AxisType): any {\n        if ((type === 'number' && isNumber(value)) || (type === 'time' && (isNumber(value) || isDate(value)))) {\n            return value;\n        } else if (type === 'category') {\n            if (isString(value) || isDate(value) || isNumber(value)) {\n                return { toString: () => String(value) };\n            } else if (isStringObject(value)) {\n                return value;\n            }\n        }\n    }\n\n    private layoutId: number = 0;\n\n    /**\n     * Only `true` while we are waiting for the layout to start.\n     * This will be `false` if the layout has already started and is ongoing.\n     */\n    get layoutScheduled(): boolean {\n        return !!this.layoutId;\n    }\n\n    /**\n     * Execute update method on the next available screen repaint to make changes to the canvas.\n     * If we are waiting for a layout to start and a new layout is requested,\n     * cancel the previous layout using the non 0 integer (this.layoutId) returned from requestAnimationFrame.\n     */\n    protected scheduleLayout() {\n        if (this.layoutId) {\n            cancelAnimationFrame(this.layoutId);\n        }\n        this.layoutId = requestAnimationFrame(() => {\n            this.immediateLayout();\n\n            this.layoutId = 0;\n        });\n    }\n\n    private immediateLayout() {\n        this.setSparklineDimensions();\n\n        if (this.invalidData(this.data)) {\n            return;\n        }\n\n        // update axes ranges\n        this.updateXScaleRange();\n        this.updateYScaleRange();\n\n        // update axis line\n        this.updateAxisLine();\n\n        // produce data joins and update selection's nodes\n        this.update();\n\n        this.renderScene();\n    }\n\n    private setSparklineDimensions() {\n        const { width, height, padding, seriesRect, rootGroup } = this;\n        const shrunkWidth = width - padding.left - padding.right;\n        const shrunkHeight = height - padding.top - padding.bottom;\n\n        seriesRect.width = shrunkWidth;\n        seriesRect.height = shrunkHeight;\n        seriesRect.x = padding.left;\n        seriesRect.y = padding.top;\n\n        rootGroup.translationX = seriesRect.x;\n        rootGroup.translationY = seriesRect.y;\n    }\n\n    /**\n     * Return the closest data point to x/y canvas coordinates.\n     * @param x\n     * @param y\n     */\n    private pickClosestSeriesNodeDatum(x: number, y: number): SeriesNodeDatum | undefined {\n        let minDistance = Infinity;\n        let closestDatum: SeriesNodeDatum | undefined;\n        const hitPoint = this.rootGroup.transformPoint(x, y);\n        const nodeData = this.getNodeData();\n\n        for (let i = 0; i < nodeData.length; i++) {\n            const datum = nodeData[i];\n\n            if (!datum.point) {\n                return;\n            }\n            const distance = this.getDistance(hitPoint, datum.point);\n            if (distance <= minDistance) {\n                minDistance = distance;\n                closestDatum = datum;\n            }\n        }\n\n        return closestDatum;\n    }\n\n    /**\n     * Return the relevant distance between two points.\n     * The distance will be calculated based on the x value of the points for all sparklines except bar sparkline, where the distance is based on the y values.\n     * @param x\n     * @param y\n     */\n    protected getDistance(p1: Point, p2: Point): number {\n        return Math.abs(p1.x - p2.x);\n    }\n\n    /**\n     * calculate x/y coordinates for tooltip based on coordinates of highlighted datum, position of canvas and page offset.\n     * @param datum\n     */\n    private handleTooltip(event: MouseEvent, datum: SeriesNodeDatum): void {\n        const { seriesDatum } = datum;\n        const { canvasElement } = this;\n        const { clientX, clientY } = event;\n\n        const tooltipOptions = this.processedOptions?.tooltip;\n        const meta: SparklineTooltipMeta = {\n            pageX: clientX,\n            pageY: clientY,\n            position: {\n                xOffset: tooltipOptions?.xOffset,\n                yOffset: tooltipOptions?.yOffset,\n            },\n            container: tooltipOptions?.container,\n        };\n\n        // confine tooltip to sparkline width if tooltip container not provided.\n        if (meta.container == undefined) {\n            meta.container = canvasElement;\n        }\n\n        const yValue = seriesDatum.y;\n        const xValue = seriesDatum.x;\n\n        // check if tooltip is enabled for this specific data point\n        let enabled = tooltipOptions?.enabled ?? true;\n\n        const tooltipRenderer = tooltipOptions?.renderer;\n        if (tooltipRenderer) {\n            const tooltipRendererResult = tooltipRenderer({\n                context: this.context,\n                datum: seriesDatum,\n                yValue,\n                xValue,\n            });\n            enabled =\n                typeof tooltipRendererResult !== 'string' && tooltipRendererResult.enabled !== undefined\n                    ? tooltipRendererResult.enabled\n                    : enabled;\n        }\n\n        const html = enabled && seriesDatum.y !== undefined && this.getTooltipHtml(datum);\n\n        if (html) {\n            this.tooltip.show(meta, html);\n        }\n    }\n\n    protected formatNumericDatum(datum: number): string {\n        return String(Math.round(datum * 10) / 10);\n    }\n\n    private defaultDateFormatter = new Intl.DateTimeFormat('en-US', {\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false,\n    } as any);\n\n    // locale.format('%m/%d/%y, %H:%M:%S');\n\n    protected formatDatum(datum: any): string {\n        const type = this.axis.type || 'category';\n\n        if (type === 'number' && typeof datum === 'number') {\n            return this.formatNumericDatum(datum);\n        } else if (type === 'time' && (datum instanceof Date || isNumber(datum))) {\n            return this.defaultDateFormatter.format(datum);\n        } else {\n            return String(datum);\n        }\n    }\n\n    private _onMouseMove = this.onMouseMove.bind(this);\n    private _onMouseOut = this.onMouseOut.bind(this);\n\n    private setupDomEventListeners(chartElement: HTMLCanvasElement): void {\n        chartElement.addEventListener('mousemove', this._onMouseMove);\n        chartElement.addEventListener('mouseout', this._onMouseOut);\n    }\n\n    private cleanupDomEventListeners(chartElement: HTMLCanvasElement): void {\n        chartElement.removeEventListener('mousemove', this._onMouseMove);\n        chartElement.removeEventListener('mouseout', this._onMouseOut);\n    }\n\n    private invalidData(data: any) {\n        return !data || !Array.isArray(data);\n    }\n\n    /**\n     * Cleanup and remove canvas element from the DOM.\n     */\n    public destroy(): void {\n        this.cleanupDomEventListeners(this.canvasElement);\n        this.scene.destroy();\n        // remove canvas element from the DOM\n        this.container = undefined;\n    }\n}\n", "export const defaultTooltipCss = `\n.ag-sparkline-tooltip-wrapper {\n    position: absolute;\n    user-select: none;\n    pointer-events: none;\n}\n\n.ag-sparkline-tooltip {\n    position: relative;\n    font: 12px arial,sans-serif;\n    border-radius: 2px;\n    box-shadow: 0 1px 3px rgb(0 0 0 / 20%), 0 1px 1px rgb(0 0 0 / 14%);\n    line-height: 1.7em;\n    overflow: hidden;\n    white-space: nowrap;\n    z-index: 99999;\n    background-color: rgb(255, 255, 255);\n    color: rgba(0,0,0, 0.67);\n}\n\n.ag-sparkline-tooltip-content {\n    padding: 0 7px;\n    opacity: 1;\n}\n\n.ag-sparkline-tooltip-title {\n    padding-left: 7px;\n    opacity: 1;\n}\n\n.ag-sparkline-tooltip-wrapper-hidden {\n    top: -10000px !important;\n}\n\n.ag-sparkline-wrapper {\n    box-sizing: border-box;\n    overflow: hidden;\n}\n`;\n", "import type { TooltipRendererResult } from '@ag-grid-community/core';\n\nexport interface SparklineTooltipMeta {\n    pageX: number;\n    pageY: number;\n    position?: {\n        xOffset?: number;\n        yOffset?: number;\n    };\n    container?: HTMLElement;\n}\n\nexport function toTooltipHtml(input: string | TooltipRendererResult, defaults?: TooltipRendererResult): string {\n    if (typeof input === 'string') {\n        return input;\n    }\n\n    defaults = defaults ?? {};\n\n    const {\n        content = defaults.content ?? '',\n        title = defaults.title ?? undefined,\n        color = defaults.color,\n        backgroundColor = defaults.backgroundColor,\n        opacity = defaults.opacity ?? 1,\n    } = input;\n\n    let titleHtml;\n    let contentHtml;\n\n    if (color) {\n        titleHtml = title ? `<span class=\"${TooltipClass}-title\"; style=\"color: ${color}\">${title}</span>` : '';\n        contentHtml = `<span class=\"${TooltipClass}-content\" style=\"color: ${color}\">${content}</span>`;\n    } else {\n        titleHtml = title ? `<span class=\"${TooltipClass}-title\">${title}</span>` : '';\n        contentHtml = `<span class=\"${TooltipClass}-content\">${content}</span>`;\n    }\n\n    let style = `opacity: ${opacity}`;\n    if (backgroundColor) {\n        style += `; background-color: ${backgroundColor.toLowerCase()}`;\n    }\n\n    return `<div class=\"${TooltipClass}\" style=\"${style}\">\n                ${titleHtml}\n                ${contentHtml}\n            </div>`;\n}\n\nconst TooltipClass = 'ag-sparkline-tooltip';\nexport class SparklineTooltip {\n    element: HTMLElement = document.createElement('div');\n\n    constructor() {\n        const tooltipRoot = document.body;\n        tooltipRoot.appendChild(this.element);\n    }\n\n    isVisible(): boolean {\n        const { element } = this;\n        if (element.classList) {\n            return !element.classList.contains(`${TooltipClass}-wrapper-hidden`);\n        }\n\n        // IE11\n        const classes = element.getAttribute('class');\n        if (classes) {\n            return classes.split(' ').indexOf(`${TooltipClass}-wrapper-hidden`) < 0;\n        }\n\n        return false;\n    }\n\n    updateClass(visible?: boolean) {\n        const classList = [`${TooltipClass}-wrapper`];\n\n        if (visible !== true) {\n            classList.push(`${TooltipClass}-wrapper-hidden`);\n        }\n\n        this.element.setAttribute('class', classList.join(' '));\n    }\n\n    show(meta: SparklineTooltipMeta, html?: string) {\n        this.toggle(false);\n\n        const { element } = this;\n\n        if (html !== undefined) {\n            element.innerHTML = html;\n        } else if (!element.innerHTML) {\n            return;\n        }\n\n        const xOffset = meta.position?.xOffset ?? 10;\n        const yOffset = meta.position?.yOffset ?? 0;\n\n        let left = meta.pageX + xOffset;\n        let top = meta.pageY + yOffset;\n\n        const tooltipRect = element.getBoundingClientRect();\n\n        let maxLeft = window.innerWidth - tooltipRect.width;\n\n        if (meta.container) {\n            const containerRect = meta.container.getBoundingClientRect();\n\n            maxLeft = containerRect.left + (containerRect.width - tooltipRect.width);\n        }\n\n        if (left > maxLeft) {\n            left = meta.pageX - element.clientWidth - xOffset;\n        }\n\n        if (typeof scrollX !== 'undefined') {\n            left += scrollX;\n        }\n        if (typeof scrollY !== 'undefined') {\n            top += scrollY;\n        }\n\n        element.style.left = `${Math.round(left)}px`;\n        element.style.top = `${Math.round(top)}px`;\n\n        this.toggle(true);\n    }\n\n    toggle(visible?: boolean) {\n        this.updateClass(visible);\n    }\n\n    destroy() {\n        const { parentNode } = this.element;\n\n        if (parentNode) {\n            parentNode.removeChild(this.element);\n        }\n    }\n}\n", "import { _Scale, _Scene, _Util } from 'ag-charts-community';\n\nimport type { Point } from '../sparkline';\nimport type { RectNodeDatum } from './barColumnSparkline';\nimport { BarColumnLabelPlacement, BarColumnSparkline } from './barColumnSparkline';\n\nconst { isNumber } = _Util;\nconst { BandScale } = _Scale;\n\ninterface BarNodeDatum extends RectNodeDatum {}\nexport class BarSparkline extends BarColumnSparkline {\n    protected updateYScaleRange() {\n        const { seriesRect, yScale } = this;\n        yScale.range = [0, seriesRect.width];\n    }\n\n    protected updateXScaleRange() {\n        const { xScale, seriesRect, paddingOuter, paddingInner } = this;\n        if (xScale instanceof BandScale) {\n            xScale.range = [0, seriesRect.height];\n            xScale.paddingInner = paddingInner;\n            xScale.paddingOuter = paddingOuter;\n        } else {\n            // last node will be clipped if the scale is not a band scale\n            // subtract last band width from the range so that the last band is not clipped\n\n            const step = this.calculateStep(seriesRect.height);\n\n            // PaddingOuter and paddingInner are fractions of the step with values between 0 and 1\n            const padding = step * paddingOuter; // left and right outer padding\n            this.bandWidth = step * (1 - paddingInner);\n\n            xScale.range = [padding, seriesRect.height - padding - this.bandWidth];\n        }\n    }\n\n    protected override updateAxisLine() {\n        const { yScale, axis, axisLine, seriesRect } = this;\n        const { strokeWidth } = axis;\n\n        axisLine.x1 = 0;\n        axisLine.x2 = 0;\n        axisLine.y1 = 0;\n        axisLine.y2 = seriesRect.height;\n        axisLine.stroke = axis.stroke;\n        axisLine.strokeWidth = strokeWidth + (strokeWidth % 2 === 1 ? 1 : 0);\n\n        const yZero: number = yScale.convert(0);\n        axisLine.translationX = yZero;\n    }\n\n    protected generateNodeData(): BarNodeDatum[] | undefined {\n        const { data, yData, xData, xScale, yScale, fill, stroke, strokeWidth, label } = this;\n\n        if (!data) {\n            return;\n        }\n\n        const {\n            fontStyle: labelFontStyle,\n            fontWeight: labelFontWeight,\n            fontSize: labelFontSize,\n            fontFamily: labelFontFamily,\n            color: labelColor,\n            formatter: labelFormatter,\n            placement: labelPlacement,\n        } = label;\n\n        const nodeData: BarNodeDatum[] = [];\n\n        const yZero = yScale.convert(0);\n        const continuous = !(xScale instanceof BandScale);\n\n        for (let i = 0, n = yData.length; i < n; i++) {\n            let yDatum = yData[i];\n            const xDatum = xData[i];\n            const invalidDatum = yDatum === undefined;\n\n            if (invalidDatum) {\n                yDatum = 0;\n            }\n\n            const y = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum);\n            const x = Math.min(yDatum === undefined ? NaN : yScale.convert(yDatum), yZero);\n\n            const bottom: number = Math.max(yDatum === undefined ? NaN : yScale.convert(yDatum), yZero);\n\n            // if the scale is a band scale, the width of the rects will be the bandwidth, otherwise the width of the rects will be the range / number of items in the data\n            const height = !continuous ? xScale.bandwidth : this.bandWidth;\n\n            const width = bottom - x;\n\n            const midPoint = {\n                x: yZero,\n                y: y,\n            };\n\n            let labelText: string;\n            if (labelFormatter) {\n                labelText = labelFormatter({ value: yDatum });\n            } else {\n                labelText = yDatum !== undefined && isNumber(yDatum) ? this.formatLabelValue(yDatum) : '';\n            }\n\n            const labelY: number = y + height / 2;\n            let labelX: number;\n\n            const labelTextBaseline: CanvasTextBaseline = 'middle';\n            let labelTextAlign: CanvasTextAlign;\n\n            const isPositiveY = yDatum !== undefined && yDatum >= 0;\n            const labelPadding = 4;\n\n            if (labelPlacement === BarColumnLabelPlacement.Center) {\n                labelX = x + width / 2;\n                labelTextAlign = 'center';\n            } else if (labelPlacement === BarColumnLabelPlacement.OutsideEnd) {\n                labelX = x + (isPositiveY ? width + labelPadding : -labelPadding);\n                labelTextAlign = isPositiveY ? 'start' : 'end';\n            } else if (labelPlacement === BarColumnLabelPlacement.InsideEnd) {\n                labelX = x + (isPositiveY ? width - labelPadding : labelPadding);\n                labelTextAlign = isPositiveY ? 'end' : 'start';\n\n                const textSize = _Scene.Text.getTextSize(labelText, labelFontFamily);\n                const textWidth = textSize.width || 20;\n                const positiveBoundary = yZero + textWidth;\n                const negativeBoundary = yZero - textWidth;\n                const exceedsBoundaries =\n                    (isPositiveY && labelX < positiveBoundary) || (!isPositiveY && labelX > negativeBoundary);\n\n                if (exceedsBoundaries) {\n                    // if labelX exceeds the boundary, labels should be positioned at `insideBase`.\n                    labelX = yZero + labelPadding * (isPositiveY ? 1 : -1);\n                    labelTextAlign = isPositiveY ? 'start' : 'end';\n                }\n            } else {\n                // if labelPlacement === BarColumnLabelPlacement.InsideBase\n                labelX = yZero + labelPadding * (isPositiveY ? 1 : -1);\n                labelTextAlign = isPositiveY ? 'start' : 'end';\n            }\n\n            nodeData.push({\n                x,\n                y,\n                width,\n                height,\n                fill,\n                stroke,\n                strokeWidth,\n                seriesDatum: { x: xDatum, y: invalidDatum ? undefined : yDatum },\n                point: midPoint,\n                label: {\n                    x: labelX,\n                    y: labelY,\n                    text: labelText,\n                    fontStyle: labelFontStyle,\n                    fontWeight: labelFontWeight,\n                    fontSize: labelFontSize,\n                    fontFamily: labelFontFamily,\n                    textAlign: labelTextAlign,\n                    textBaseline: labelTextBaseline,\n                    fill: labelColor,\n                },\n            });\n        }\n        return nodeData;\n    }\n\n    protected override getDistance(p1: Point, p2: Point): number {\n        return Math.abs(p1.y - p2.y);\n    }\n}\n", "import type { ColumnFormat, ColumnFormatterParams } from '@ag-grid-community/core';\nimport type { FontStyle, FontWeight } from 'ag-charts-community';\nimport { _Scene, _Util } from 'ag-charts-community';\n\nimport { Label } from '../label/label';\nimport type { SeriesNodeDatum } from '../sparkline';\nimport { Sparkline, ZINDICIES } from '../sparkline';\nimport { toTooltipHtml } from '../tooltip/sparklineTooltip';\n\nconst { extent } = _Util;\n\nexport interface RectNodeDatum extends SeriesNodeDatum {\n    readonly x: number;\n    readonly y: number;\n    readonly width: number;\n    readonly height: number;\n    readonly fill?: string;\n    readonly stroke?: string;\n    readonly strokeWidth: number;\n    readonly label?: {\n        readonly x: number;\n        readonly y: number;\n        readonly text: string;\n        readonly fontStyle?: FontStyle;\n        readonly fontWeight?: FontWeight;\n        readonly fontSize: number;\n        readonly fontFamily: string;\n        readonly textAlign: CanvasTextAlign;\n        readonly textBaseline: CanvasTextBaseline;\n        readonly fill: string;\n    };\n}\n\nenum BarColumnNodeTag {\n    Rect,\n    Label,\n}\n\nexport enum BarColumnLabelPlacement {\n    InsideBase = 'insideBase',\n    InsideEnd = 'insideEnd',\n    Center = 'center',\n    OutsideEnd = 'outsideEnd',\n}\n\nexport class BarColumnLabel extends Label {\n    formatter?: (params: { value: number | undefined }) => string = undefined;\n    placement = BarColumnLabelPlacement.InsideEnd;\n}\n\nexport abstract class BarColumnSparkline extends Sparkline {\n    fill: string = 'rgb(124, 181, 236)';\n    stroke: string = 'silver';\n    strokeWidth: number = 0;\n    paddingInner: number = 0.1;\n    paddingOuter: number = 0.2;\n    valueAxisDomain: [number, number] | undefined = undefined;\n    formatter?: (params: ColumnFormatterParams) => ColumnFormat = undefined;\n\n    protected axisLine: _Scene.Line = new _Scene.Line();\n    protected bandWidth: number = 0;\n\n    private sparklineGroup: _Scene.Group = new _Scene.Group();\n    private rectGroup: _Scene.Group = new _Scene.Group();\n    private labelGroup: _Scene.Group = new _Scene.Group();\n\n    private rectSelection: _Scene.Selection<_Scene.Rect, RectNodeDatum> = _Scene.Selection.select(\n        this.rectGroup,\n        _Scene.Rect\n    );\n    private labelSelection: _Scene.Selection<_Scene.Text, RectNodeDatum> = _Scene.Selection.select(\n        this.labelGroup,\n        _Scene.Text\n    );\n\n    private nodeSelectionData: RectNodeDatum[] = [];\n\n    readonly label = new BarColumnLabel();\n\n    constructor() {\n        super();\n\n        this.rootGroup.append(this.sparklineGroup);\n\n        this.rectGroup.zIndex = ZINDICIES.SERIES_FILL_ZINDEX;\n        this.axisLine.zIndex = ZINDICIES.AXIS_LINE_ZINDEX;\n        this.labelGroup.zIndex = ZINDICIES.SERIES_LABEL_ZINDEX;\n\n        this.sparklineGroup.append([this.rectGroup, this.axisLine, this.labelGroup]);\n\n        this.axisLine.lineCap = 'round';\n\n        this.label.enabled = false;\n    }\n\n    protected abstract override generateNodeData(): RectNodeDatum[] | undefined;\n    protected abstract override updateYScaleRange(): void;\n    protected abstract override updateXScaleRange(): void;\n\n    protected override getNodeData(): RectNodeDatum[] {\n        return this.nodeSelectionData;\n    }\n\n    protected override update(): void {\n        this.updateSelections();\n        this.updateNodes();\n    }\n\n    protected updateSelections(): void {\n        const nodeData = this.generateNodeData();\n\n        if (!nodeData) {\n            return;\n        }\n\n        this.nodeSelectionData = nodeData;\n        this.updateRectSelection(nodeData);\n        this.updateLabelSelection(nodeData);\n    }\n\n    protected override updateNodes(): void {\n        this.updateRectNodes();\n        this.updateLabelNodes();\n    }\n\n    protected calculateStep(range: number): number {\n        const { xScale, paddingInner, paddingOuter, smallestInterval } = this;\n\n        // calculate step\n        const domainLength = xScale.domain[1] - xScale.domain[0];\n        const intervals = domainLength / (smallestInterval?.x ?? 1) + 1;\n\n        // The number of intervals/bands is used to determine the width of individual bands by dividing the available range.\n        // Allow a maximum of 50 bands to ensure the step (width of individual bands + padding) does not fall below a certain number of pixels.\n        // If the number of intervals exceeds 50, calculate the step for 50 bands within the given range.\n        // This means there could be some overlap of the bands in the sparkline.\n        const maxBands = 50;\n        const bands = Math.min(intervals, maxBands);\n        const gaps = bands - 1; // number of gaps (padding between bands)\n\n        const step = range / Math.max(1, 2 * paddingOuter + gaps * paddingInner + bands); // step width is a combination of band width and gap width\n\n        return step;\n    }\n\n    protected override updateYScaleDomain(): void {\n        const { yScale, yData, valueAxisDomain } = this;\n\n        const yMinMax = extent(yData as number[]);\n\n        let yMin = 0;\n        let yMax = 1;\n\n        if (yMinMax !== undefined) {\n            yMin = this.min = yMinMax[0] as number;\n            yMax = this.max = yMinMax[1] as number;\n        }\n\n        // if yMin is positive, set yMin to 0\n        yMin = yMin < 0 ? yMin : 0;\n\n        // if yMax is negative, set yMax to 0\n        yMax = yMax < 0 ? 0 : yMax;\n\n        if (valueAxisDomain) {\n            if (valueAxisDomain[1] < yMax) {\n                valueAxisDomain[1] = yMax;\n            }\n            if (valueAxisDomain[0] > yMin) {\n                valueAxisDomain[0] = yMin;\n            }\n        }\n\n        yScale.domain = valueAxisDomain ? valueAxisDomain : [yMin, yMax];\n    }\n\n    private updateRectSelection(selectionData: RectNodeDatum[]): void {\n        this.rectSelection.update(selectionData);\n    }\n\n    protected updateRectNodes(): void {\n        const { highlightedDatum, formatter: nodeFormatter, fill, stroke, strokeWidth } = this;\n        const { fill: highlightFill, stroke: highlightStroke, strokeWidth: highlightStrokeWidth } = this.highlightStyle;\n\n        this.rectSelection.each((node, datum, index) => {\n            const highlighted = datum === highlightedDatum;\n            const nodeFill = highlighted && highlightFill !== undefined ? highlightFill : fill;\n            const nodeStroke = highlighted && highlightStroke !== undefined ? highlightStroke : stroke;\n            const nodeStrokeWidth =\n                highlighted && highlightStrokeWidth !== undefined ? highlightStrokeWidth : strokeWidth;\n\n            let nodeFormat: ColumnFormat | undefined;\n\n            const { x, y, width, height, seriesDatum } = datum;\n\n            if (nodeFormatter) {\n                const first = index === 0;\n                const last = index === this.nodeSelectionData.length - 1;\n                const min = seriesDatum.y === this.min;\n                const max = seriesDatum.y === this.max;\n\n                nodeFormat = nodeFormatter({\n                    datum,\n                    xValue: seriesDatum.x,\n                    yValue: seriesDatum.y,\n                    width: width,\n                    height: height,\n                    min,\n                    max,\n                    first,\n                    last,\n                    fill: nodeFill,\n                    stroke: nodeStroke,\n                    strokeWidth: nodeStrokeWidth,\n                    highlighted,\n                });\n            }\n\n            node.fill = (nodeFormat && nodeFormat.fill) || nodeFill;\n            node.stroke = (nodeFormat && nodeFormat.stroke) || nodeStroke;\n            node.strokeWidth = (nodeFormat && nodeFormat.strokeWidth) || nodeStrokeWidth;\n\n            node.x = node.y = 0;\n            node.width = width;\n            node.height = height;\n            node.visible = node.height > 0;\n\n            node.translationX = x;\n            node.translationY = y;\n\n            // shifts bars upwards?\n            // node.crisp = true;\n        });\n    }\n\n    private updateLabelSelection(selectionData: RectNodeDatum[]): void {\n        this.labelSelection.update(selectionData, (text) => {\n            text.tag = BarColumnNodeTag.Label;\n            text.pointerEvents = _Scene.PointerEvents.None;\n        });\n    }\n\n    private updateLabelNodes(): void {\n        const {\n            label: { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color },\n        } = this;\n        this.labelSelection.each((text, datum) => {\n            const label = datum.label;\n\n            if (label && labelEnabled) {\n                text.fontStyle = fontStyle;\n                text.fontWeight = fontWeight;\n                text.fontSize = fontSize;\n                text.fontFamily = fontFamily;\n                text.textAlign = label.textAlign;\n                text.textBaseline = label.textBaseline;\n                text.text = label.text;\n                text.x = label.x;\n                text.y = label.y;\n                text.fill = color;\n                text.visible = true;\n            } else {\n                text.visible = false;\n            }\n        });\n    }\n\n    getTooltipHtml(datum: SeriesNodeDatum): string | undefined {\n        const { dataType } = this;\n        const { seriesDatum } = datum;\n        const yValue = seriesDatum.y;\n        const xValue = seriesDatum.x;\n        const content = this.formatNumericDatum(yValue);\n        const title = dataType === 'array' || dataType === 'object' ? this.formatDatum(xValue) : undefined;\n\n        const defaults = {\n            content,\n            title,\n        };\n\n        const tooltipRenderer = this.processedOptions?.tooltip?.renderer;\n        if (tooltipRenderer) {\n            return toTooltipHtml(\n                tooltipRenderer({\n                    context: this.context,\n                    datum: seriesDatum,\n                    yValue,\n                    xValue,\n                }),\n                defaults\n            );\n        }\n\n        return toTooltipHtml(defaults);\n    }\n\n    protected formatLabelValue(value: number): string {\n        return value % 1 !== 0 ? value.toFixed(1) : value.toFixed(0);\n    }\n}\n", "import type { FontStyle, FontWeight } from 'ag-charts-community';\n\nexport class Label {\n    enabled = true;\n    fontSize = 8;\n    fontFamily = 'Verdana, sans-serif';\n    fontStyle?: FontStyle = undefined;\n    fontWeight?: FontWeight = undefined;\n    color = 'rgba(70, 70, 70, 1)';\n}\n", "import { _Scale, _Scene, _Util } from 'ag-charts-community';\n\nimport type { RectNodeDatum } from './barColumnSparkline';\nimport { BarColumnLabelPlacement, BarColumnSparkline } from './barColumnSparkline';\n\nconst { isNumber } = _Util;\nconst { BandScale } = _Scale;\n\ninterface ColumnNodeDatum extends RectNodeDatum {}\nexport class ColumnSparkline extends BarColumnSparkline {\n    protected updateYScaleRange() {\n        const { seriesRect, yScale } = this;\n        yScale.range = [seriesRect.height, 0];\n    }\n\n    protected updateXScaleRange() {\n        const { xScale, seriesRect, paddingOuter, paddingInner } = this;\n        if (xScale instanceof BandScale) {\n            xScale.range = [0, seriesRect.width];\n            xScale.paddingInner = paddingInner;\n            xScale.paddingOuter = paddingOuter;\n        } else {\n            // last node will be clipped if the scale is not a band scale\n            // subtract last band width from the range so that the last band is not clipped\n\n            const step = this.calculateStep(seriesRect.width);\n\n            // PaddingOuter and paddingInner are fractions of the step with values between 0 and 1\n            const padding = step * paddingOuter; // left and right outer padding\n            this.bandWidth = step * (1 - paddingInner);\n\n            xScale.range = [padding, seriesRect.width - padding - this.bandWidth];\n        }\n    }\n\n    protected override updateAxisLine() {\n        const { yScale, axis, axisLine, seriesRect } = this;\n        const { strokeWidth } = axis;\n\n        axisLine.x1 = 0;\n        axisLine.x2 = seriesRect.width;\n        axisLine.y1 = 0;\n        axisLine.y2 = 0;\n        axisLine.stroke = axis.stroke;\n        axisLine.strokeWidth = strokeWidth + (strokeWidth % 2 === 1 ? 1 : 0);\n\n        const yZero: number = yScale.convert(0);\n        axisLine.translationY = yZero;\n    }\n\n    protected generateNodeData(): ColumnNodeDatum[] | undefined {\n        const { data, yData, xData, xScale, yScale, fill, stroke, strokeWidth, label } = this;\n\n        if (!data) {\n            return;\n        }\n\n        const {\n            fontStyle: labelFontStyle,\n            fontWeight: labelFontWeight,\n            fontSize: labelFontSize,\n            fontFamily: labelFontFamily,\n            color: labelColor,\n            formatter: labelFormatter,\n            placement: labelPlacement,\n        } = label;\n\n        const nodeData: ColumnNodeDatum[] = [];\n\n        const yZero = yScale.convert(0);\n        const continuous = !(xScale instanceof BandScale);\n\n        for (let i = 0, n = yData.length; i < n; i++) {\n            let yDatum = yData[i];\n            const xDatum = xData[i];\n            const invalidDatum = yDatum === undefined;\n\n            if (invalidDatum) {\n                yDatum = 0;\n            }\n\n            const y = Math.min(yDatum === undefined ? NaN : yScale.convert(yDatum), yZero);\n            const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum);\n\n            const bottom: number = Math.max(yDatum === undefined ? NaN : yScale.convert(yDatum), yZero);\n\n            // if the scale is a band scale, the width of the rects will be the bandwidth, otherwise the width of the rects will be the range / number of items in the data\n            const width = !continuous ? xScale.bandwidth : this.bandWidth;\n\n            const height = bottom - y;\n\n            const midPoint = {\n                x: x + width / 2,\n                y: yZero,\n            };\n\n            let labelText: string;\n            if (labelFormatter) {\n                labelText = labelFormatter({ value: yDatum });\n            } else {\n                labelText = yDatum !== undefined && isNumber(yDatum) ? this.formatLabelValue(yDatum) : '';\n            }\n\n            const labelX: number = x + width / 2;\n            let labelY: number;\n\n            const labelTextAlign: CanvasTextAlign = 'center';\n            let labelTextBaseline: CanvasTextBaseline;\n\n            const isPositiveY = yDatum !== undefined && yDatum >= 0;\n            const labelPadding = 2;\n\n            if (labelPlacement === BarColumnLabelPlacement.Center) {\n                labelY = y + height / 2;\n                labelTextBaseline = 'middle';\n            } else if (labelPlacement === BarColumnLabelPlacement.OutsideEnd) {\n                labelY = y + (isPositiveY ? -labelPadding : height + labelPadding);\n                labelTextBaseline = isPositiveY ? 'bottom' : 'top';\n            } else if (labelPlacement === BarColumnLabelPlacement.InsideEnd) {\n                labelY = y + (isPositiveY ? labelPadding : height - labelPadding);\n                labelTextBaseline = isPositiveY ? 'top' : 'bottom';\n\n                const textSize = _Scene.Text.getTextSize(labelText, labelFontFamily);\n                const textHeight = textSize.height || 10;\n                const positiveBoundary = yZero - textHeight;\n                const negativeBoundary = yZero + textHeight;\n                const exceedsBoundaries =\n                    (isPositiveY && labelY > positiveBoundary) || (!isPositiveY && labelY < negativeBoundary);\n\n                if (exceedsBoundaries) {\n                    // if labelY exceeds the y boundary, labels should be positioned at the insideBase\n                    labelY = yZero + labelPadding * (isPositiveY ? -1 : 1);\n                    labelTextBaseline = isPositiveY ? 'bottom' : 'top';\n                }\n            } else {\n                // if labelPlacement === BarColumnLabelPlacement.InsideBase\n                labelY = yZero + labelPadding * (isPositiveY ? -1 : 1);\n                labelTextBaseline = isPositiveY ? 'bottom' : 'top';\n            }\n\n            nodeData.push({\n                x,\n                y,\n                width,\n                height,\n                fill,\n                stroke,\n                strokeWidth,\n                seriesDatum: { x: xDatum, y: invalidDatum ? undefined : yDatum },\n                point: midPoint,\n                label: {\n                    x: labelX,\n                    y: labelY,\n                    text: labelText,\n                    fontStyle: labelFontStyle,\n                    fontWeight: labelFontWeight,\n                    fontSize: labelFontSize,\n                    fontFamily: labelFontFamily,\n                    textAlign: labelTextAlign,\n                    textBaseline: labelTextBaseline,\n                    fill: labelColor,\n                },\n            });\n        }\n        return nodeData;\n    }\n}\n", "import type { CrosshairLineOptions, MarkerFormat, MarkerFormatterParams } from '@ag-grid-community/core';\nimport { _Scale, _Scene, _Util } from 'ag-charts-community';\n\nimport { getLineDash } from '../../util/lineDash';\nimport { getMarker } from '../marker/markerFactory';\nimport type { Point, SeriesNodeDatum } from '../sparkline';\nimport { Sparkline, ZINDICIES } from '../sparkline';\nimport { toTooltipHtml } from '../tooltip/sparklineTooltip';\n\nconst { extent } = _Util;\nconst { BandScale } = _Scale;\n\ninterface LineNodeDatum extends SeriesNodeDatum {\n    readonly point: Point;\n}\n\nclass SparklineMarker {\n    enabled: boolean = true;\n    shape: string = 'circle';\n    size: number = 0;\n    fill?: string = 'rgb(124, 181, 236)';\n    stroke?: string = 'rgb(124, 181, 236)';\n    strokeWidth: number = 1;\n    formatter?: (params: MarkerFormatterParams) => MarkerFormat = undefined;\n}\n\nclass SparklineLine {\n    stroke: string = 'rgb(124, 181, 236)';\n    strokeWidth: number = 1;\n}\n\nclass SparklineCrosshairs {\n    xLine: CrosshairLineOptions = {\n        enabled: true,\n        stroke: 'rgba(0,0,0, 0.54)',\n        strokeWidth: 1,\n        lineDash: 'solid',\n        lineCap: undefined,\n    };\n    yLine: CrosshairLineOptions = {\n        enabled: false,\n        stroke: 'rgba(0,0,0, 0.54)',\n        strokeWidth: 1,\n        lineDash: 'solid',\n        lineCap: undefined,\n    };\n}\n\nexport class LineSparkline extends Sparkline {\n    protected linePath: _Scene.Path = new _Scene.Path();\n    protected xCrosshairLine: _Scene.Line = new _Scene.Line();\n    protected yCrosshairLine: _Scene.Line = new _Scene.Line();\n\n    private lineSparklineGroup: _Scene.Group = new _Scene.Group();\n    private markers: _Scene.Group = new _Scene.Group();\n    private markerSelection: _Scene.Selection<_Scene.Marker, LineNodeDatum> = _Scene.Selection.select(\n        this.markers,\n        () => this.markerFactory()\n    );\n    private markerSelectionData: LineNodeDatum[] = [];\n\n    readonly marker = new SparklineMarker();\n    readonly line = new SparklineLine();\n    readonly crosshairs = new SparklineCrosshairs();\n\n    constructor() {\n        super();\n        this.rootGroup.append(this.lineSparklineGroup);\n\n        this.linePath.zIndex = ZINDICIES.SERIES_STROKE_ZINDEX;\n        this.xCrosshairLine.zIndex = ZINDICIES.CROSSHAIR_ZINDEX;\n        this.yCrosshairLine.zIndex = ZINDICIES.CROSSHAIR_ZINDEX;\n        this.markers.zIndex = ZINDICIES.SERIES_MARKERS_ZINDEX;\n\n        this.lineSparklineGroup.append([this.linePath, this.xCrosshairLine, this.yCrosshairLine, this.markers]);\n    }\n\n    protected override getNodeData(): LineNodeDatum[] {\n        return this.markerSelectionData;\n    }\n\n    protected markerFactory(): _Scene.Marker {\n        const { shape } = this.marker;\n        const MarkerShape = getMarker(shape);\n        return new MarkerShape();\n    }\n\n    /**\n     * If marker shape is changed, this method should be called to remove the previous marker nodes selection.\n     */\n    private onMarkerShapeChange() {\n        this.markerSelection = this.markerSelection.clear();\n        this.scheduleLayout();\n    }\n\n    protected override update(): void {\n        const nodeData = this.generateNodeData();\n\n        if (!nodeData) {\n            return;\n        }\n\n        this.markerSelectionData = nodeData;\n\n        this.updateSelection(nodeData);\n        this.updateNodes();\n\n        this.updateLine();\n    }\n\n    protected override updateYScaleDomain(): void {\n        const { yData, yScale } = this;\n\n        const yMinMax = extent(yData as number[]);\n\n        let yMin = 0;\n        let yMax = 1;\n\n        if (yMinMax !== undefined) {\n            yMin = this.min = yMinMax[0] as number;\n            yMax = this.max = yMinMax[1] as number;\n        }\n\n        if (yMin === yMax) {\n            // if all values in the data are the same, yMin and yMax will be equal, need to adjust the domain with some padding\n            const padding = Math.abs(yMin * 0.01);\n            yMin -= padding;\n            yMax += padding;\n        }\n\n        yScale.domain = [yMin, yMax];\n    }\n\n    protected override generateNodeData(): LineNodeDatum[] | undefined {\n        const { data, yData, xData, xScale, yScale } = this;\n\n        if (!data) {\n            return;\n        }\n\n        const continuous = !(xScale instanceof BandScale);\n        const offsetX = !continuous ? xScale.bandwidth / 2 : 0;\n\n        const nodeData: LineNodeDatum[] = [];\n\n        for (let i = 0; i < yData.length; i++) {\n            const yDatum = yData[i];\n            const xDatum = xData[i];\n\n            if (yDatum == undefined) {\n                continue;\n            }\n\n            const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;\n            const y = yDatum === undefined ? NaN : yScale.convert(yDatum);\n\n            nodeData.push({\n                seriesDatum: { x: xDatum, y: yDatum },\n                point: { x, y },\n            });\n        }\n        return nodeData;\n    }\n\n    private updateSelection(selectionData: LineNodeDatum[]): void {\n        this.markerSelection.update(selectionData);\n    }\n\n    protected override updateNodes(): void {\n        const { highlightedDatum, highlightStyle, marker } = this;\n        const {\n            size: highlightSize,\n            fill: highlightFill,\n            stroke: highlightStroke,\n            strokeWidth: highlightStrokeWidth,\n        } = highlightStyle;\n        const markerFormatter = marker.formatter;\n\n        this.markerSelection.each((node, datum, index) => {\n            const highlighted = datum === highlightedDatum;\n            const markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill;\n            const markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke;\n            const markerStrokeWidth =\n                highlighted && highlightStrokeWidth !== undefined ? highlightStrokeWidth : marker.strokeWidth;\n            const markerSize = highlighted && highlightSize !== undefined ? highlightSize : marker.size;\n\n            let markerFormat: MarkerFormat | undefined;\n\n            const { seriesDatum, point } = datum;\n\n            if (markerFormatter) {\n                const first = index === 0;\n                const last = index === this.markerSelectionData.length - 1;\n                const min = seriesDatum.y === this.min;\n                const max = seriesDatum.y === this.max;\n\n                markerFormat = markerFormatter({\n                    datum,\n                    xValue: seriesDatum.x,\n                    yValue: seriesDatum.y,\n                    min,\n                    max,\n                    first,\n                    last,\n                    fill: markerFill,\n                    stroke: markerStroke,\n                    strokeWidth: markerStrokeWidth,\n                    size: markerSize,\n                    highlighted,\n                });\n            }\n\n            node.size = markerFormat && markerFormat.size != undefined ? markerFormat.size : markerSize;\n            node.fill = markerFormat && markerFormat.fill != undefined ? markerFormat.fill : markerFill;\n            node.stroke = markerFormat && markerFormat.stroke != undefined ? markerFormat.stroke : markerStroke;\n            node.strokeWidth =\n                markerFormat && markerFormat.strokeWidth != undefined ? markerFormat.strokeWidth : markerStrokeWidth;\n\n            node.translationX = point.x;\n            node.translationY = point.y;\n            node.visible =\n                markerFormat && markerFormat.enabled != undefined\n                    ? markerFormat.enabled\n                    : marker.enabled && node.size > 0;\n        });\n    }\n\n    protected updateLine(): void {\n        const { linePath, yData, xData, xScale, yScale, line } = this;\n\n        const path = linePath.path;\n        path.clear();\n\n        if (yData.length < 2) {\n            return;\n        }\n\n        const continuous = !(xScale instanceof BandScale);\n        const n = yData.length;\n        const offsetX = !continuous ? xScale.bandwidth / 2 : 0;\n        let moveTo = true;\n\n        for (let i = 0; i < n; i++) {\n            const xDatum = xData[i];\n            const yDatum = yData[i];\n\n            const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;\n            const y = yDatum === undefined ? NaN : yScale.convert(yDatum);\n\n            if (yDatum == undefined) {\n                moveTo = true;\n            } else {\n                if (moveTo) {\n                    path.moveTo(x, y);\n                    moveTo = false;\n                } else {\n                    path.lineTo(x, y);\n                }\n            }\n        }\n\n        linePath.fill = undefined;\n        linePath.stroke = line.stroke;\n        linePath.strokeWidth = line.strokeWidth;\n    }\n\n    protected override updateXCrosshairLine(): void {\n        const {\n            yScale,\n            xCrosshairLine,\n            highlightedDatum,\n            crosshairs: { xLine },\n        } = this;\n\n        if (!xLine.enabled || highlightedDatum == undefined) {\n            xCrosshairLine.strokeWidth = 0;\n            return;\n        }\n\n        xCrosshairLine.y1 = yScale.range[0];\n        xCrosshairLine.y2 = yScale.range[1];\n        xCrosshairLine.x1 = xCrosshairLine.x2 = 0;\n        xCrosshairLine.stroke = xLine.stroke;\n        xCrosshairLine.strokeWidth = xLine.strokeWidth ?? 1;\n\n        xCrosshairLine.lineCap = xLine.lineCap === 'round' || xLine.lineCap === 'square' ? xLine.lineCap : undefined;\n\n        const { lineDash } = xLine;\n        xCrosshairLine.lineDash = Array.isArray(lineDash)\n            ? lineDash\n            : getLineDash(xCrosshairLine.lineCap, xLine.lineDash as string);\n\n        xCrosshairLine.translationX = highlightedDatum.point!.x;\n    }\n\n    protected override updateYCrosshairLine() {\n        const {\n            xScale,\n            yCrosshairLine,\n            highlightedDatum,\n            crosshairs: { yLine },\n        } = this;\n\n        if (!yLine.enabled || highlightedDatum == undefined) {\n            yCrosshairLine.strokeWidth = 0;\n            return;\n        }\n\n        yCrosshairLine.x1 = xScale.range[0];\n        yCrosshairLine.x2 = xScale.range[1];\n        yCrosshairLine.y1 = yCrosshairLine.y2 = 0;\n        yCrosshairLine.stroke = yLine.stroke;\n        yCrosshairLine.strokeWidth = yLine.strokeWidth ?? 1;\n\n        yCrosshairLine.lineCap = yLine.lineCap === 'round' || yLine.lineCap === 'square' ? yLine.lineCap : undefined;\n\n        const { lineDash } = yLine;\n        yCrosshairLine.lineDash = Array.isArray(lineDash)\n            ? lineDash\n            : getLineDash(yCrosshairLine.lineCap, yLine.lineDash as string);\n\n        yCrosshairLine.translationY = highlightedDatum.point!.y;\n    }\n\n    getTooltipHtml(datum: SeriesNodeDatum): string | undefined {\n        const { dataType } = this;\n        const { seriesDatum } = datum;\n        const yValue = seriesDatum.y;\n        const xValue = seriesDatum.x;\n        const content = this.formatNumericDatum(yValue);\n        const title = dataType === 'array' || dataType === 'object' ? this.formatDatum(xValue) : undefined;\n\n        const defaults = {\n            content,\n            title,\n        };\n\n        const tooltipRenderer = this.processedOptions?.tooltip?.renderer;\n        if (tooltipRenderer) {\n            return toTooltipHtml(\n                tooltipRenderer({\n                    context: this.context,\n                    datum: seriesDatum,\n                    yValue,\n                    xValue,\n                }),\n                defaults\n            );\n        }\n\n        return toTooltipHtml(defaults);\n    }\n}\n", "import type { NamedBean } from '@ag-grid-community/core';\nimport { BeanStub } from '@ag-grid-community/core';\n\nimport { SparklineTooltip } from '../sparkline/tooltip/sparklineTooltip';\n\n/**\n * This 'bean' creates a single sparkline tooltip that is bound to the grid lifecycle.\n */\nexport class SparklineTooltipSingleton extends BeanStub implements NamedBean {\n    beanName = 'sparklineTooltipSingleton' as const;\n\n    private tooltip!: SparklineTooltip;\n\n    public postConstruct(): void {\n        this.tooltip = new SparklineTooltip();\n    }\n\n    public getSparklineTooltip() {\n        return this.tooltip;\n    }\n\n    public override destroy(): void {\n        if (this.tooltip) {\n            this.tooltip.destroy();\n        }\n        super.destroy();\n    }\n}\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '32.0.0';\n"],
  "mappings": "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",
  "names": ["_warnOnce", "_Util", "_Scale", "_Scene", "_Util", "_Scene", "_Scene", "extent", "_Util", "BandScale", "_Scale", "_Scene", "_Scale", "_Scene", "_Util", "_Scene", "_Util", "extent", "_Util", "_Scene", "extent", "isNumber", "_Util", "BandScale", "_Scale", "_Scene", "_Scale", "_Scene", "_Util", "isNumber", "_Util", "BandScale", "_Scale", "_Scene", "_Scale", "_Scene", "_Util", "extent", "_Util", "BandScale", "_Scale", "SparklineMarker", "SparklineLine", "SparklineCrosshairs", "_Scene", "isNumber", "_Util", "_warnOnce"]
}
