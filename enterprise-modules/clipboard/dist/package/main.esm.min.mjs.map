{
  "version": 3,
  "sources": ["<stdin>"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// enterprise-modules/clipboard/src/clipboardModule.ts\nimport { ModuleNames } from \"@ag-grid-community/core\";\nimport { EnterpriseCoreModule } from \"@ag-grid-enterprise/core\";\nimport { CsvExportModule } from \"@ag-grid-community/csv-export\";\n\n// enterprise-modules/clipboard/src/clipboard/clipboardService.ts\nimport {\n  _,\n  Autowired,\n  Bean,\n  BeanStub,\n  ChangedPath,\n  Events,\n  PostConstruct,\n  Optional\n} from \"@ag-grid-community/core\";\nvar SOURCE_PASTE = \"paste\";\nvar EXPORT_TYPE_DRAG_COPY = \"dragCopy\";\nvar EXPORT_TYPE_CLIPBOARD = \"clipboard\";\nvar apiError = (method) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${method}()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.`;\nvar ClipboardService = class extends BeanStub {\n  constructor() {\n    super(...arguments);\n    this.lastPasteOperationTime = 0;\n    this.navigatorApiFailed = false;\n  }\n  init() {\n    this.logger = this.loggerFactory.create(\"ClipboardService\");\n    if (this.rowModel.getType() === \"clientSide\") {\n      this.clientSideRowModel = this.rowModel;\n    }\n    this.ctrlsService.whenReady((p) => {\n      this.gridCtrl = p.gridCtrl;\n    });\n  }\n  pasteFromClipboard() {\n    this.logger.log(\"pasteFromClipboard\");\n    const allowNavigator = !this.gridOptionsService.get(\"suppressClipboardApi\");\n    if (allowNavigator && !this.navigatorApiFailed && navigator.clipboard && navigator.clipboard.readText) {\n      navigator.clipboard.readText().then(this.processClipboardData.bind(this)).catch((e) => {\n        _.doOnce(() => {\n          console.warn(e);\n          console.warn(apiError(\"readText\"));\n        }, \"clipboardApiError\");\n        this.navigatorApiFailed = true;\n        this.pasteFromClipboardLegacy();\n      });\n    } else {\n      this.pasteFromClipboardLegacy();\n    }\n  }\n  pasteFromClipboardLegacy() {\n    let defaultPrevented = false;\n    const handlePasteEvent = (e) => {\n      const currentPastOperationTime = (/* @__PURE__ */ new Date()).getTime();\n      if (currentPastOperationTime - this.lastPasteOperationTime < 50) {\n        defaultPrevented = true;\n        e.preventDefault();\n      }\n      this.lastPasteOperationTime = currentPastOperationTime;\n    };\n    this.executeOnTempElement(\n      (textArea) => {\n        textArea.addEventListener(\"paste\", handlePasteEvent);\n        textArea.focus({ preventScroll: true });\n      },\n      (element) => {\n        const data = element.value;\n        if (!defaultPrevented) {\n          this.processClipboardData(data);\n        } else {\n          this.refocusLastFocusedCell();\n        }\n        element.removeEventListener(\"paste\", handlePasteEvent);\n      }\n    );\n  }\n  refocusLastFocusedCell() {\n    const focusedCell = this.focusService.getFocusedCell();\n    if (focusedCell) {\n      this.focusService.setFocusedCell({\n        rowIndex: focusedCell.rowIndex,\n        column: focusedCell.column,\n        rowPinned: focusedCell.rowPinned,\n        forceBrowserFocus: true\n      });\n    }\n  }\n  getClipboardDelimiter() {\n    const delimiter = this.gridOptionsService.get(\"clipboardDelimiter\");\n    return _.exists(delimiter) ? delimiter : \"\t\";\n  }\n  processClipboardData(data) {\n    if (data == null) {\n      return;\n    }\n    let parsedData = ClipboardService.stringToArray(data, this.getClipboardDelimiter());\n    const userFunc = this.gridOptionsService.getCallback(\"processDataFromClipboard\");\n    if (userFunc) {\n      parsedData = userFunc({ data: parsedData });\n    }\n    if (parsedData == null) {\n      return;\n    }\n    if (this.gridOptionsService.get(\"suppressLastEmptyLineOnPaste\")) {\n      this.removeLastLineIfBlank(parsedData);\n    }\n    const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {\n      const rangeActive = this.rangeService && this.rangeService.isMoreThanOneCell();\n      const pasteIntoRange = rangeActive && !this.hasOnlyOneValueToPaste(parsedData);\n      if (pasteIntoRange) {\n        this.pasteIntoActiveRange(parsedData, cellsToFlash, updatedRowNodes, changedPath);\n      } else {\n        this.pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n      }\n    };\n    this.doPasteOperation(pasteOperation);\n  }\n  // This will parse a delimited string into an array of arrays.\n  static stringToArray(strData, delimiter = \",\") {\n    const data = [];\n    const isNewline = (char) => char === \"\\r\" || char === \"\\n\";\n    let insideQuotedField = false;\n    if (strData === \"\") {\n      return [[\"\"]];\n    }\n    for (let row = 0, column = 0, position = 0; position < strData.length; position++) {\n      const previousChar = strData[position - 1];\n      const currentChar = strData[position];\n      const nextChar = strData[position + 1];\n      const ensureDataExists = () => {\n        if (!data[row]) {\n          data[row] = [];\n        }\n        if (!data[row][column]) {\n          data[row][column] = \"\";\n        }\n      };\n      ensureDataExists();\n      if (currentChar === '\"') {\n        if (insideQuotedField) {\n          if (nextChar === '\"') {\n            data[row][column] += '\"';\n            position++;\n          } else {\n            insideQuotedField = false;\n          }\n        } else if (previousChar === void 0 || previousChar === delimiter || isNewline(previousChar)) {\n          insideQuotedField = true;\n        }\n      }\n      if (!insideQuotedField && currentChar !== '\"') {\n        if (currentChar === delimiter) {\n          column++;\n          ensureDataExists();\n          continue;\n        } else if (isNewline(currentChar)) {\n          column = 0;\n          row++;\n          ensureDataExists();\n          if (currentChar === \"\\r\" && nextChar === \"\\n\") {\n            position++;\n          }\n          continue;\n        }\n      }\n      data[row][column] += currentChar;\n    }\n    return data;\n  }\n  // common code to paste operations, e.g. paste to cell, paste to range, and copy range down\n  doPasteOperation(pasteOperationFunc) {\n    const source = \"clipboard\";\n    this.eventService.dispatchEvent({\n      type: Events.EVENT_PASTE_START,\n      source\n    });\n    let changedPath;\n    if (this.clientSideRowModel) {\n      const onlyChangedColumns = this.gridOptionsService.get(\"aggregateOnlyChangedColumns\");\n      changedPath = new ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());\n    }\n    const cellsToFlash = {};\n    const updatedRowNodes = [];\n    const focusedCell = this.focusService.getFocusedCell();\n    pasteOperationFunc(cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n    const nodesToRefresh = [...updatedRowNodes];\n    if (changedPath) {\n      this.clientSideRowModel.doAggregate(changedPath);\n      changedPath.forEachChangedNodeDepthFirst((rowNode) => {\n        nodesToRefresh.push(rowNode);\n      });\n    }\n    this.rowRenderer.refreshCells({ rowNodes: nodesToRefresh });\n    this.dispatchFlashCells(cellsToFlash);\n    this.fireRowChanged(updatedRowNodes);\n    this.refocusLastFocusedCell();\n    const event = {\n      type: Events.EVENT_PASTE_END,\n      source\n    };\n    this.eventService.dispatchEvent(event);\n  }\n  pasteIntoActiveRange(clipboardData, cellsToFlash, updatedRowNodes, changedPath) {\n    const abortRepeatingPasteIntoRows = this.getRangeSize() % clipboardData.length != 0;\n    let indexOffset = 0;\n    let dataRowIndex = 0;\n    const rowCallback = (currentRow, rowNode, columns, index) => {\n      const atEndOfClipboardData = index - indexOffset >= clipboardData.length;\n      if (atEndOfClipboardData) {\n        if (abortRepeatingPasteIntoRows) {\n          return;\n        }\n        indexOffset += dataRowIndex;\n        dataRowIndex = 0;\n      }\n      const currentRowData = clipboardData[index - indexOffset];\n      updatedRowNodes.push(rowNode);\n      const processCellFromClipboardFunc = this.gridOptionsService.getCallback(\"processCellFromClipboard\");\n      columns.forEach((column, idx) => {\n        if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n          return;\n        }\n        if (idx >= currentRowData.length) {\n          idx = idx % currentRowData.length;\n        }\n        const newValue = this.processCell(\n          rowNode,\n          column,\n          currentRowData[idx],\n          EXPORT_TYPE_DRAG_COPY,\n          processCellFromClipboardFunc,\n          true\n        );\n        rowNode.setDataValue(column, newValue, SOURCE_PASTE);\n        if (changedPath) {\n          changedPath.addParentNode(rowNode.parent, [column]);\n        }\n        const { rowIndex, rowPinned } = currentRow;\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n        cellsToFlash[cellId] = true;\n      });\n      dataRowIndex++;\n    };\n    this.iterateActiveRanges(false, rowCallback);\n  }\n  pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath) {\n    if (!focusedCell) {\n      return;\n    }\n    const currentRow = { rowIndex: focusedCell.rowIndex, rowPinned: focusedCell.rowPinned };\n    const columnsToPasteInto = this.columnModel.getDisplayedColumnsStartingAt(focusedCell.column);\n    if (this.isPasteSingleValueIntoRange(parsedData)) {\n      this.pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath);\n    } else {\n      this.pasteMultipleValues(\n        parsedData,\n        currentRow,\n        updatedRowNodes,\n        columnsToPasteInto,\n        cellsToFlash,\n        EXPORT_TYPE_CLIPBOARD,\n        changedPath\n      );\n    }\n  }\n  // if range is active, and only one cell, then we paste this cell into all cells in the active range.\n  isPasteSingleValueIntoRange(parsedData) {\n    return this.hasOnlyOneValueToPaste(parsedData) && this.rangeService != null && !this.rangeService.isEmpty();\n  }\n  pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath) {\n    const value = parsedData[0][0];\n    const rowCallback = (currentRow, rowNode, columns) => {\n      updatedRowNodes.push(rowNode);\n      columns.forEach((column) => this.updateCellValue(rowNode, column, value, cellsToFlash, EXPORT_TYPE_CLIPBOARD, changedPath));\n    };\n    this.iterateActiveRanges(false, rowCallback);\n  }\n  hasOnlyOneValueToPaste(parsedData) {\n    return parsedData.length === 1 && parsedData[0].length === 1;\n  }\n  copyRangeDown() {\n    if (!this.rangeService || this.rangeService.isEmpty()) {\n      return;\n    }\n    const firstRowValues = [];\n    const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {\n      const processCellForClipboardFunc = this.gridOptionsService.getCallback(\"processCellForClipboard\");\n      const processCellFromClipboardFunc = this.gridOptionsService.getCallback(\"processCellFromClipboard\");\n      const rowCallback = (currentRow, rowNode, columns) => {\n        if (!firstRowValues.length) {\n          columns.forEach((column) => {\n            const value = this.processCell(\n              rowNode,\n              column,\n              this.valueService.getValue(column, rowNode),\n              EXPORT_TYPE_DRAG_COPY,\n              processCellForClipboardFunc,\n              false,\n              true\n            );\n            firstRowValues.push(value);\n          });\n        } else {\n          updatedRowNodes.push(rowNode);\n          columns.forEach((column, index) => {\n            if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n              return;\n            }\n            const firstRowValue = this.processCell(\n              rowNode,\n              column,\n              firstRowValues[index],\n              EXPORT_TYPE_DRAG_COPY,\n              processCellFromClipboardFunc,\n              true\n            );\n            rowNode.setDataValue(column, firstRowValue, SOURCE_PASTE);\n            if (changedPath) {\n              changedPath.addParentNode(rowNode.parent, [column]);\n            }\n            const { rowIndex, rowPinned } = currentRow;\n            const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n            cellsToFlash[cellId] = true;\n          });\n        }\n      };\n      this.iterateActiveRanges(true, rowCallback);\n    };\n    this.doPasteOperation(pasteOperation);\n  }\n  removeLastLineIfBlank(parsedData) {\n    const lastLine = _.last(parsedData);\n    const lastLineIsBlank = lastLine && lastLine.length === 1 && lastLine[0] === \"\";\n    if (lastLineIsBlank) {\n      if (parsedData.length === 1) {\n        return;\n      }\n      _.removeFromArray(parsedData, lastLine);\n    }\n  }\n  fireRowChanged(rowNodes) {\n    if (this.gridOptionsService.get(\"editType\") !== \"fullRow\") {\n      return;\n    }\n    rowNodes.forEach((rowNode) => {\n      const event = {\n        type: Events.EVENT_ROW_VALUE_CHANGED,\n        node: rowNode,\n        data: rowNode.data,\n        rowIndex: rowNode.rowIndex,\n        rowPinned: rowNode.rowPinned\n      };\n      this.eventService.dispatchEvent(event);\n    });\n  }\n  pasteMultipleValues(clipboardGridData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, type, changedPath) {\n    let rowPointer = currentRow;\n    const skipGroupRows = this.clientSideRowModel != null && !this.gridOptionsService.get(\"enableGroupEdit\") && !this.gridOptionsService.get(\"treeData\");\n    const getNextGoodRowNode = () => {\n      while (true) {\n        if (!rowPointer) {\n          return null;\n        }\n        const res = this.rowPositionUtils.getRowNode(rowPointer);\n        rowPointer = this.cellNavigationService.getRowBelow({ rowPinned: rowPointer.rowPinned, rowIndex: rowPointer.rowIndex });\n        if (res == null) {\n          return null;\n        }\n        const skipRow = res.detail || res.footer || skipGroupRows && res.group;\n        if (!skipRow) {\n          return res;\n        }\n      }\n    };\n    clipboardGridData.forEach((clipboardRowData) => {\n      const rowNode = getNextGoodRowNode();\n      if (!rowNode) {\n        return;\n      }\n      clipboardRowData.forEach((value, index) => this.updateCellValue(rowNode, columnsToPasteInto[index], value, cellsToFlash, type, changedPath));\n      updatedRowNodes.push(rowNode);\n    });\n  }\n  updateCellValue(rowNode, column, value, cellsToFlash, type, changedPath) {\n    if (!rowNode || !column || !column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n      return;\n    }\n    if (rowNode.group && column.isValueActive()) {\n      return;\n    }\n    const processedValue = this.processCell(rowNode, column, value, type, this.gridOptionsService.getCallback(\"processCellFromClipboard\"), true);\n    rowNode.setDataValue(column, processedValue, SOURCE_PASTE);\n    const { rowIndex, rowPinned } = rowNode;\n    const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n    cellsToFlash[cellId] = true;\n    if (changedPath) {\n      changedPath.addParentNode(rowNode.parent, [column]);\n    }\n  }\n  copyToClipboard(params = {}) {\n    this.copyOrCutToClipboard(params);\n  }\n  cutToClipboard(params = {}, source = \"api\") {\n    if (this.gridOptionsService.get(\"suppressCutToClipboard\")) {\n      return;\n    }\n    const startEvent = {\n      type: Events.EVENT_CUT_START,\n      source\n    };\n    this.eventService.dispatchEvent(startEvent);\n    this.copyOrCutToClipboard(params, true);\n    const endEvent = {\n      type: Events.EVENT_CUT_END,\n      source\n    };\n    this.eventService.dispatchEvent(endEvent);\n  }\n  copyOrCutToClipboard(params, cut) {\n    let { includeHeaders, includeGroupHeaders } = params;\n    this.logger.log(`copyToClipboard: includeHeaders = ${includeHeaders}`);\n    if (includeHeaders == null) {\n      includeHeaders = this.gridOptionsService.get(\"copyHeadersToClipboard\");\n    }\n    if (includeGroupHeaders == null) {\n      includeGroupHeaders = this.gridOptionsService.get(\"copyGroupHeadersToClipboard\");\n    }\n    const copyParams = { includeHeaders, includeGroupHeaders };\n    const shouldCopyRows = !this.gridOptionsService.get(\"suppressCopyRowsToClipboard\");\n    let cellClearType = null;\n    if (this.rangeService && !this.rangeService.isEmpty() && !this.shouldSkipSingleCellRange()) {\n      this.copySelectedRangeToClipboard(copyParams);\n      cellClearType = 0 /* CellRange */;\n    } else if (shouldCopyRows && !this.selectionService.isEmpty()) {\n      this.copySelectedRowsToClipboard(copyParams);\n      cellClearType = 1 /* SelectedRows */;\n    } else if (this.focusService.isAnyCellFocused()) {\n      this.copyFocusedCellToClipboard(copyParams);\n      cellClearType = 2 /* FocusedCell */;\n    }\n    if (cut && cellClearType !== null) {\n      this.clearCellsAfterCopy(cellClearType);\n    }\n  }\n  clearCellsAfterCopy(type) {\n    this.eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START });\n    if (type === 0 /* CellRange */) {\n      this.rangeService.clearCellRangeCellValues({ cellEventSource: \"clipboardService\" });\n    } else if (type === 1 /* SelectedRows */) {\n      this.clearSelectedRows();\n    } else {\n      const focusedCell = this.focusService.getFocusedCell();\n      if (focusedCell == null) {\n        return;\n      }\n      const rowNode = this.rowPositionUtils.getRowNode(focusedCell);\n      if (rowNode) {\n        this.clearCellValue(rowNode, focusedCell.column);\n      }\n    }\n    this.eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END });\n  }\n  clearSelectedRows() {\n    const selected = this.selectionService.getSelectedNodes();\n    const columns = this.columnModel.getAllDisplayedColumns();\n    for (const row of selected) {\n      for (const col of columns) {\n        this.clearCellValue(row, col);\n      }\n    }\n  }\n  clearCellValue(rowNode, column) {\n    if (!column.isCellEditable(rowNode)) {\n      return;\n    }\n    rowNode.setDataValue(column, null, \"clipboardService\");\n  }\n  shouldSkipSingleCellRange() {\n    return this.gridOptionsService.get(\"suppressCopySingleCellRanges\") && !this.rangeService.isMoreThanOneCell();\n  }\n  iterateActiveRanges(onlyFirst, rowCallback, columnCallback) {\n    if (!this.rangeService || this.rangeService.isEmpty()) {\n      return;\n    }\n    const cellRanges = this.rangeService.getCellRanges();\n    if (onlyFirst) {\n      this.iterateActiveRange(cellRanges[0], rowCallback, columnCallback, true);\n    } else {\n      cellRanges.forEach((range, idx) => this.iterateActiveRange(range, rowCallback, columnCallback, idx === cellRanges.length - 1));\n    }\n  }\n  iterateActiveRange(range, rowCallback, columnCallback, isLastRange) {\n    if (!this.rangeService) {\n      return;\n    }\n    let currentRow = this.rangeService.getRangeStartRow(range);\n    const lastRow = this.rangeService.getRangeEndRow(range);\n    if (columnCallback && range.columns) {\n      columnCallback(range.columns);\n    }\n    let rangeIndex = 0;\n    let isLastRow = false;\n    while (!isLastRow && currentRow != null) {\n      const rowNode = this.rowPositionUtils.getRowNode(currentRow);\n      isLastRow = this.rowPositionUtils.sameRow(currentRow, lastRow);\n      rowCallback(currentRow, rowNode, range.columns, rangeIndex++, isLastRow && isLastRange);\n      currentRow = this.cellNavigationService.getRowBelow(currentRow);\n    }\n  }\n  copySelectedRangeToClipboard(params = {}) {\n    if (!this.rangeService || this.rangeService.isEmpty()) {\n      return;\n    }\n    const allRangesMerge = this.rangeService.areAllRangesAbleToMerge();\n    const { data, cellsToFlash } = allRangesMerge ? this.buildDataFromMergedRanges(params) : this.buildDataFromRanges(params);\n    this.copyDataToClipboard(data);\n    this.dispatchFlashCells(cellsToFlash);\n  }\n  buildDataFromMergedRanges(params) {\n    const columnsSet = /* @__PURE__ */ new Set();\n    const ranges = this.rangeService.getCellRanges();\n    const rowPositionsMap = /* @__PURE__ */ new Map();\n    const allRowPositions = [];\n    const allCellsToFlash = {};\n    ranges.forEach((range) => {\n      range.columns.forEach((col) => columnsSet.add(col));\n      const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(range);\n      rowPositions.forEach((rowPosition) => {\n        const rowPositionAsString = `${rowPosition.rowIndex}-${rowPosition.rowPinned || \"null\"}`;\n        if (!rowPositionsMap.get(rowPositionAsString)) {\n          rowPositionsMap.set(rowPositionAsString, true);\n          allRowPositions.push(rowPosition);\n        }\n      });\n      Object.assign(allCellsToFlash, cellsToFlash);\n    });\n    const allColumns = this.columnModel.getAllDisplayedColumns();\n    const exportedColumns = Array.from(columnsSet);\n    exportedColumns.sort((a, b) => {\n      const posA = allColumns.indexOf(a);\n      const posB = allColumns.indexOf(b);\n      return posA - posB;\n    });\n    const data = this.buildExportParams({\n      columns: exportedColumns,\n      rowPositions: allRowPositions,\n      includeHeaders: params.includeHeaders,\n      includeGroupHeaders: params.includeGroupHeaders\n    });\n    return { data, cellsToFlash: allCellsToFlash };\n  }\n  buildDataFromRanges(params) {\n    const ranges = this.rangeService.getCellRanges();\n    const data = [];\n    const allCellsToFlash = {};\n    ranges.forEach((range) => {\n      const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(range);\n      Object.assign(allCellsToFlash, cellsToFlash);\n      data.push(this.buildExportParams({\n        columns: range.columns,\n        rowPositions,\n        includeHeaders: params.includeHeaders,\n        includeGroupHeaders: params.includeGroupHeaders\n      }));\n    });\n    return { data: data.join(\"\\n\"), cellsToFlash: allCellsToFlash };\n  }\n  getRangeRowPositionsAndCellsToFlash(range) {\n    const rowPositions = [];\n    const cellsToFlash = {};\n    const startRow = this.rangeService.getRangeStartRow(range);\n    const lastRow = this.rangeService.getRangeEndRow(range);\n    let node = startRow;\n    while (node) {\n      rowPositions.push(node);\n      range.columns.forEach((column) => {\n        const { rowIndex, rowPinned } = node;\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n        cellsToFlash[cellId] = true;\n      });\n      if (this.rowPositionUtils.sameRow(node, lastRow)) {\n        break;\n      }\n      node = this.cellNavigationService.getRowBelow(node);\n    }\n    return { rowPositions, cellsToFlash };\n  }\n  getCellsToFlashFromRowNodes(rowNodes) {\n    const allDisplayedColumns = this.columnModel.getAllDisplayedColumns();\n    const cellsToFlash = {};\n    for (let i = 0; i < rowNodes.length; i++) {\n      const { rowIndex, rowPinned } = rowNodes[i];\n      if (rowIndex == null) {\n        continue;\n      }\n      for (let j = 0; j < allDisplayedColumns.length; j++) {\n        const column = allDisplayedColumns[j];\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n        cellsToFlash[cellId] = true;\n      }\n    }\n    return cellsToFlash;\n  }\n  copyFocusedCellToClipboard(params = {}) {\n    const focusedCell = this.focusService.getFocusedCell();\n    if (focusedCell == null) {\n      return;\n    }\n    const cellId = this.cellPositionUtils.createId(focusedCell);\n    const currentRow = { rowPinned: focusedCell.rowPinned, rowIndex: focusedCell.rowIndex };\n    const column = focusedCell.column;\n    const data = this.buildExportParams({\n      columns: [column],\n      rowPositions: [currentRow],\n      includeHeaders: params.includeHeaders,\n      includeGroupHeaders: params.includeGroupHeaders\n    });\n    this.copyDataToClipboard(data);\n    this.dispatchFlashCells({ [cellId]: true });\n  }\n  copySelectedRowsToClipboard(params = {}) {\n    const { columnKeys, includeHeaders, includeGroupHeaders } = params;\n    const data = this.buildExportParams({\n      columns: columnKeys,\n      includeHeaders,\n      includeGroupHeaders\n    });\n    this.copyDataToClipboard(data);\n    const rowNodes = this.selectionService.getSelectedNodes() || [];\n    this.dispatchFlashCells(this.getCellsToFlashFromRowNodes(rowNodes));\n  }\n  buildExportParams(params) {\n    const { columns, rowPositions, includeHeaders = false, includeGroupHeaders = false } = params;\n    const exportParams = {\n      columnKeys: columns,\n      rowPositions,\n      skipColumnHeaders: !includeHeaders,\n      skipColumnGroupHeaders: !includeGroupHeaders,\n      suppressQuotes: true,\n      columnSeparator: this.getClipboardDelimiter(),\n      onlySelected: !rowPositions,\n      processCellCallback: this.gridOptionsService.getCallback(\"processCellForClipboard\"),\n      processRowGroupCallback: (params2) => this.processRowGroupCallback(params2),\n      processHeaderCallback: this.gridOptionsService.getCallback(\"processHeaderForClipboard\"),\n      processGroupHeaderCallback: this.gridOptionsService.getCallback(\"processGroupHeaderForClipboard\")\n    };\n    return this.csvCreator.getDataAsCsv(exportParams, true);\n  }\n  processRowGroupCallback(params) {\n    const { node, column } = params;\n    const isTreeData = this.gridOptionsService.get(\"treeData\");\n    const isSuppressGroupMaintainValueType = this.gridOptionsService.get(\"suppressGroupMaintainValueType\");\n    const getValueFromNode = () => {\n      var _a, _b;\n      if (isTreeData || isSuppressGroupMaintainValueType || !column) {\n        return node.key;\n      }\n      const value2 = (_a = node.groupData) == null ? void 0 : _a[column.getId()];\n      if (!value2 || !node.rowGroupColumn || node.rowGroupColumn.getColDef().useValueFormatterForExport === false) {\n        return value2;\n      }\n      return (_b = this.valueFormatterService.formatValue(node.rowGroupColumn, node, value2)) != null ? _b : value2;\n    };\n    let value = getValueFromNode();\n    if (params.node.footer) {\n      let suffix = \"\";\n      if (value && value.length) {\n        suffix = ` ${value}`;\n      }\n      value = `Total${suffix}`;\n    }\n    const processCellForClipboard = this.gridOptionsService.getCallback(\"processCellForClipboard\");\n    if (processCellForClipboard) {\n      let column2 = node.rowGroupColumn;\n      if (!column2 && node.footer && node.level === -1) {\n        column2 = this.columnModel.getRowGroupColumns()[0];\n      }\n      return processCellForClipboard({\n        value,\n        node,\n        column: column2,\n        type: \"clipboard\",\n        formatValue: (valueToFormat) => {\n          var _a;\n          return (_a = this.valueFormatterService.formatValue(column2, node, valueToFormat)) != null ? _a : valueToFormat;\n        },\n        parseValue: (valueToParse) => this.valueParserService.parseValue(column2, node, valueToParse, this.valueService.getValue(column2, node))\n      });\n    }\n    return value;\n  }\n  dispatchFlashCells(cellsToFlash) {\n    window.setTimeout(() => {\n      const event = {\n        type: Events.EVENT_FLASH_CELLS,\n        cells: cellsToFlash\n      };\n      this.eventService.dispatchEvent(event);\n    }, 0);\n  }\n  processCell(rowNode, column, value, type, func, canParse, canFormat) {\n    var _a;\n    if (func) {\n      const params = {\n        column,\n        node: rowNode,\n        value,\n        type,\n        formatValue: (valueToFormat) => {\n          var _a2;\n          return (_a2 = this.valueFormatterService.formatValue(column, rowNode != null ? rowNode : null, valueToFormat)) != null ? _a2 : valueToFormat;\n        },\n        parseValue: (valueToParse) => this.valueParserService.parseValue(column, rowNode != null ? rowNode : null, valueToParse, this.valueService.getValue(column, rowNode))\n      };\n      return func(params);\n    }\n    if (canParse && column.getColDef().useValueParserForImport !== false) {\n      return this.valueParserService.parseValue(column, rowNode != null ? rowNode : null, value, this.valueService.getValue(column, rowNode));\n    } else if (canFormat && column.getColDef().useValueFormatterForExport !== false) {\n      return (_a = this.valueFormatterService.formatValue(column, rowNode != null ? rowNode : null, value)) != null ? _a : value;\n    }\n    return value;\n  }\n  copyDataToClipboard(data) {\n    const userProvidedFunc = this.gridOptionsService.getCallback(\"sendToClipboard\");\n    if (userProvidedFunc) {\n      userProvidedFunc({ data });\n      return;\n    }\n    const allowNavigator = !this.gridOptionsService.get(\"suppressClipboardApi\");\n    if (allowNavigator && navigator.clipboard) {\n      navigator.clipboard.writeText(data).catch((e) => {\n        _.doOnce(() => {\n          console.warn(e);\n          console.warn(apiError(\"writeText\"));\n        }, \"clipboardApiError\");\n        this.copyDataToClipboardLegacy(data);\n      });\n      return;\n    }\n    this.copyDataToClipboardLegacy(data);\n  }\n  copyDataToClipboardLegacy(data) {\n    this.executeOnTempElement((element) => {\n      const eDocument = this.gridOptionsService.getDocument();\n      const focusedElementBefore = eDocument.activeElement;\n      element.value = data || \" \";\n      element.select();\n      element.focus({ preventScroll: true });\n      const result = eDocument.execCommand(\"copy\");\n      if (!result) {\n        console.warn(\"AG Grid: Browser did not allow document.execCommand('copy'). Ensure api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons.\");\n      }\n      if (focusedElementBefore != null && focusedElementBefore.focus != null) {\n        focusedElementBefore.focus({ preventScroll: true });\n      }\n    });\n  }\n  executeOnTempElement(callbackNow, callbackAfter) {\n    const eDoc = this.gridOptionsService.getDocument();\n    const eTempInput = eDoc.createElement(\"textarea\");\n    eTempInput.style.width = \"1px\";\n    eTempInput.style.height = \"1px\";\n    eTempInput.style.top = eDoc.documentElement.scrollTop + \"px\";\n    eTempInput.style.left = eDoc.documentElement.scrollLeft + \"px\";\n    eTempInput.style.position = \"absolute\";\n    eTempInput.style.opacity = \"0\";\n    const guiRoot = this.gridCtrl.getGui();\n    guiRoot.appendChild(eTempInput);\n    try {\n      callbackNow(eTempInput);\n    } catch (err) {\n      console.warn(\"AG Grid: Browser does not support document.execCommand('copy') for clipboard operations\");\n    }\n    if (callbackAfter) {\n      window.setTimeout(() => {\n        callbackAfter(eTempInput);\n        guiRoot.removeChild(eTempInput);\n      }, 100);\n    } else {\n      guiRoot.removeChild(eTempInput);\n    }\n  }\n  getRangeSize() {\n    const ranges = this.rangeService.getCellRanges();\n    let startRangeIndex = 0;\n    let endRangeIndex = 0;\n    if (ranges.length > 0) {\n      startRangeIndex = this.rangeService.getRangeStartRow(ranges[0]).rowIndex;\n      endRangeIndex = this.rangeService.getRangeEndRow(ranges[0]).rowIndex;\n    }\n    return startRangeIndex - endRangeIndex + 1;\n  }\n};\n__decorateClass([\n  Autowired(\"csvCreator\")\n], ClipboardService.prototype, \"csvCreator\", 2);\n__decorateClass([\n  Autowired(\"loggerFactory\")\n], ClipboardService.prototype, \"loggerFactory\", 2);\n__decorateClass([\n  Autowired(\"selectionService\")\n], ClipboardService.prototype, \"selectionService\", 2);\n__decorateClass([\n  Optional(\"rangeService\")\n], ClipboardService.prototype, \"rangeService\", 2);\n__decorateClass([\n  Autowired(\"rowModel\")\n], ClipboardService.prototype, \"rowModel\", 2);\n__decorateClass([\n  Autowired(\"ctrlsService\")\n], ClipboardService.prototype, \"ctrlsService\", 2);\n__decorateClass([\n  Autowired(\"valueService\")\n], ClipboardService.prototype, \"valueService\", 2);\n__decorateClass([\n  Autowired(\"focusService\")\n], ClipboardService.prototype, \"focusService\", 2);\n__decorateClass([\n  Autowired(\"rowRenderer\")\n], ClipboardService.prototype, \"rowRenderer\", 2);\n__decorateClass([\n  Autowired(\"columnModel\")\n], ClipboardService.prototype, \"columnModel\", 2);\n__decorateClass([\n  Autowired(\"cellNavigationService\")\n], ClipboardService.prototype, \"cellNavigationService\", 2);\n__decorateClass([\n  Autowired(\"cellPositionUtils\")\n], ClipboardService.prototype, \"cellPositionUtils\", 2);\n__decorateClass([\n  Autowired(\"rowPositionUtils\")\n], ClipboardService.prototype, \"rowPositionUtils\", 2);\n__decorateClass([\n  Autowired(\"valueFormatterService\")\n], ClipboardService.prototype, \"valueFormatterService\", 2);\n__decorateClass([\n  Autowired(\"valueParserService\")\n], ClipboardService.prototype, \"valueParserService\", 2);\n__decorateClass([\n  PostConstruct\n], ClipboardService.prototype, \"init\", 1);\nClipboardService = __decorateClass([\n  Bean(\"clipboardService\")\n], ClipboardService);\n\n// enterprise-modules/clipboard/src/version.ts\nvar VERSION = \"31.2.0\";\n\n// enterprise-modules/clipboard/src/clipboardModule.ts\nvar ClipboardModule = {\n  version: VERSION,\n  moduleName: ModuleNames.ClipboardModule,\n  beans: [ClipboardService],\n  dependantModules: [\n    EnterpriseCoreModule,\n    CsvExportModule\n  ]\n};\nexport {\n  ClipboardModule\n};\n"],
  "mappings": "AAAA,IAAIA,EAAY,OAAO,eACnBC,EAAmB,OAAO,yBAC1BC,EAAkB,CAACC,EAAYC,EAAQC,EAAKC,IAAS,CAEvD,QADIC,EAASD,EAAO,EAAI,OAASA,EAAOL,EAAiBG,EAAQC,CAAG,EAAID,EAC/D,EAAID,EAAW,OAAS,EAAGK,EAAW,GAAK,EAAG,KACjDA,EAAYL,EAAW,CAAC,KAC1BI,GAAUD,EAAOE,EAAUJ,EAAQC,EAAKE,CAAM,EAAIC,EAAUD,CAAM,IAAMA,GAC5E,OAAID,GAAQC,GACVP,EAAUI,EAAQC,EAAKE,CAAM,EACxBA,CACT,EAGA,OAAS,eAAAE,MAAmB,0BAC5B,OAAS,wBAAAC,MAA4B,2BACrC,OAAS,mBAAAC,MAAuB,gCAGhC,OACE,KAAAC,EACA,aAAAC,EACA,QAAAC,EACA,YAAAC,EACA,eAAAC,EACA,UAAAC,EACA,iBAAAC,EACA,YAAAC,MACK,0BACP,IAAIC,EAAe,QACfC,EAAwB,WACxBC,EAAwB,YACxBC,EAAYC,GAAW,iEAAiEA,CAAM,uXAC9FC,EAAmB,cAAcV,CAAS,CAC5C,aAAc,CACZ,MAAM,GAAG,SAAS,EAClB,KAAK,uBAAyB,EAC9B,KAAK,mBAAqB,EAC5B,CACA,MAAO,CACL,KAAK,OAAS,KAAK,cAAc,OAAO,kBAAkB,EACtD,KAAK,SAAS,QAAQ,IAAM,eAC9B,KAAK,mBAAqB,KAAK,UAEjC,KAAK,aAAa,UAAWW,GAAM,CACjC,KAAK,SAAWA,EAAE,QACpB,CAAC,CACH,CACA,oBAAqB,CACnB,KAAK,OAAO,IAAI,oBAAoB,EACb,CAAC,KAAK,mBAAmB,IAAI,sBAAsB,GACpD,CAAC,KAAK,oBAAsB,UAAU,WAAa,UAAU,UAAU,SAC3F,UAAU,UAAU,SAAS,EAAE,KAAK,KAAK,qBAAqB,KAAK,IAAI,CAAC,EAAE,MAAOC,GAAM,CACrFf,EAAE,OAAO,IAAM,CACb,QAAQ,KAAKe,CAAC,EACd,QAAQ,KAAKJ,EAAS,UAAU,CAAC,CACnC,EAAG,mBAAmB,EACtB,KAAK,mBAAqB,GAC1B,KAAK,yBAAyB,CAChC,CAAC,EAED,KAAK,yBAAyB,CAElC,CACA,0BAA2B,CACzB,IAAIK,EAAmB,GACvB,MAAMC,EAAoBF,GAAM,CAC9B,MAAMG,EAA4C,IAAI,KAAK,EAAG,QAAQ,EAClEA,EAA2B,KAAK,uBAAyB,KAC3DF,EAAmB,GACnBD,EAAE,eAAe,GAEnB,KAAK,uBAAyBG,CAChC,EACA,KAAK,qBACFC,GAAa,CACZA,EAAS,iBAAiB,QAASF,CAAgB,EACnDE,EAAS,MAAM,CAAE,cAAe,EAAK,CAAC,CACxC,EACCC,GAAY,CACX,MAAMC,EAAOD,EAAQ,MAChBJ,EAGH,KAAK,uBAAuB,EAF5B,KAAK,qBAAqBK,CAAI,EAIhCD,EAAQ,oBAAoB,QAASH,CAAgB,CACvD,CACF,CACF,CACA,wBAAyB,CACvB,MAAMK,EAAc,KAAK,aAAa,eAAe,EACjDA,GACF,KAAK,aAAa,eAAe,CAC/B,SAAUA,EAAY,SACtB,OAAQA,EAAY,OACpB,UAAWA,EAAY,UACvB,kBAAmB,EACrB,CAAC,CAEL,CACA,uBAAwB,CACtB,MAAMC,EAAY,KAAK,mBAAmB,IAAI,oBAAoB,EAClE,OAAOvB,EAAE,OAAOuB,CAAS,EAAIA,EAAY,GAC3C,CACA,qBAAqBF,EAAM,CACzB,GAAIA,GAAQ,KACV,OAEF,IAAIG,EAAaX,EAAiB,cAAcQ,EAAM,KAAK,sBAAsB,CAAC,EAClF,MAAMI,EAAW,KAAK,mBAAmB,YAAY,0BAA0B,EAI/E,GAHIA,IACFD,EAAaC,EAAS,CAAE,KAAMD,CAAW,CAAC,GAExCA,GAAc,KAChB,OAEE,KAAK,mBAAmB,IAAI,8BAA8B,GAC5D,KAAK,sBAAsBA,CAAU,EAEvC,MAAME,EAAiB,CAACC,EAAcC,EAAiBN,EAAaO,IAAgB,CAC9D,KAAK,cAAgB,KAAK,aAAa,kBAAkB,GACvC,CAAC,KAAK,uBAAuBL,CAAU,EAE3E,KAAK,qBAAqBA,EAAYG,EAAcC,EAAiBC,CAAW,EAEhF,KAAK,6BAA6BL,EAAYG,EAAcC,EAAiBN,EAAaO,CAAW,CAEzG,EACA,KAAK,iBAAiBH,CAAc,CACtC,CAEA,OAAO,cAAcI,EAASP,EAAY,IAAK,CAC7C,MAAMF,EAAO,CAAC,EACRU,EAAaC,GAASA,IAAS,MAAQA,IAAS;AAAA,EACtD,IAAIC,EAAoB,GACxB,GAAIH,IAAY,GACd,MAAO,CAAC,CAAC,EAAE,CAAC,EAEd,QAASI,EAAM,EAAGC,EAAS,EAAGC,EAAW,EAAGA,EAAWN,EAAQ,OAAQM,IAAY,CACjF,MAAMC,EAAeP,EAAQM,EAAW,CAAC,EACnCE,EAAcR,EAAQM,CAAQ,EAC9BG,EAAWT,EAAQM,EAAW,CAAC,EAC/BI,EAAmB,IAAM,CACxBnB,EAAKa,CAAG,IACXb,EAAKa,CAAG,EAAI,CAAC,GAEVb,EAAKa,CAAG,EAAEC,CAAM,IACnBd,EAAKa,CAAG,EAAEC,CAAM,EAAI,GAExB,EAcA,GAbAK,EAAiB,EACbF,IAAgB,MACdL,EACEM,IAAa,KACflB,EAAKa,CAAG,EAAEC,CAAM,GAAK,IACrBC,KAEAH,EAAoB,IAEbI,IAAiB,QAAUA,IAAiBd,GAAaQ,EAAUM,CAAY,KACxFJ,EAAoB,KAGpB,CAACA,GAAqBK,IAAgB,KACxC,GAAIA,IAAgBf,EAAW,CAC7BY,IACAK,EAAiB,EACjB,QACF,SAAWT,EAAUO,CAAW,EAAG,CACjCH,EAAS,EACTD,IACAM,EAAiB,EACbF,IAAgB,MAAQC,IAAa;AAAA,GACvCH,IAEF,QACF,EAEFf,EAAKa,CAAG,EAAEC,CAAM,GAAKG,CACvB,CACA,OAAOjB,CACT,CAEA,iBAAiBoB,EAAoB,CACnC,MAAMC,EAAS,YACf,KAAK,aAAa,cAAc,CAC9B,KAAMrC,EAAO,kBACb,OAAAqC,CACF,CAAC,EACD,IAAIb,EACJ,GAAI,KAAK,mBAAoB,CAC3B,MAAMc,EAAqB,KAAK,mBAAmB,IAAI,6BAA6B,EACpFd,EAAc,IAAIzB,EAAYuC,EAAoB,KAAK,mBAAmB,YAAY,CAAC,CACzF,CACA,MAAMhB,EAAe,CAAC,EAChBC,EAAkB,CAAC,EACnBN,EAAc,KAAK,aAAa,eAAe,EACrDmB,EAAmBd,EAAcC,EAAiBN,EAAaO,CAAW,EAC1E,MAAMe,EAAiB,CAAC,GAAGhB,CAAe,EACtCC,IACF,KAAK,mBAAmB,YAAYA,CAAW,EAC/CA,EAAY,6BAA8BgB,GAAY,CACpDD,EAAe,KAAKC,CAAO,CAC7B,CAAC,GAEH,KAAK,YAAY,aAAa,CAAE,SAAUD,CAAe,CAAC,EAC1D,KAAK,mBAAmBjB,CAAY,EACpC,KAAK,eAAeC,CAAe,EACnC,KAAK,uBAAuB,EAC5B,MAAMkB,EAAQ,CACZ,KAAMzC,EAAO,gBACb,OAAAqC,CACF,EACA,KAAK,aAAa,cAAcI,CAAK,CACvC,CACA,qBAAqBC,EAAepB,EAAcC,EAAiBC,EAAa,CAC9E,MAAMmB,EAA8B,KAAK,aAAa,EAAID,EAAc,QAAU,EAClF,IAAIE,EAAc,EACdC,EAAe,EACnB,MAAMC,EAAc,CAACC,EAAYP,EAASQ,EAASC,IAAU,CAE3D,GAD6BA,EAAQL,GAAeF,EAAc,OACxC,CACxB,GAAIC,EACF,OAEFC,GAAeC,EACfA,EAAe,CACjB,CACA,MAAMK,EAAiBR,EAAcO,EAAQL,CAAW,EACxDrB,EAAgB,KAAKiB,CAAO,EAC5B,MAAMW,EAA+B,KAAK,mBAAmB,YAAY,0BAA0B,EACnGH,EAAQ,QAAQ,CAAClB,EAAQsB,IAAQ,CAC/B,GAAI,CAACtB,EAAO,eAAeU,CAAO,GAAKV,EAAO,gBAAgBU,CAAO,EACnE,OAEEY,GAAOF,EAAe,SACxBE,EAAMA,EAAMF,EAAe,QAE7B,MAAMG,EAAW,KAAK,YACpBb,EACAV,EACAoB,EAAeE,CAAG,EAClBhD,EACA+C,EACA,EACF,EACAX,EAAQ,aAAaV,EAAQuB,EAAUlD,CAAY,EAC/CqB,GACFA,EAAY,cAAcgB,EAAQ,OAAQ,CAACV,CAAM,CAAC,EAEpD,KAAM,CAAE,SAAAwB,EAAU,UAAAC,CAAU,EAAIR,EAC1BS,EAAS,KAAK,kBAAkB,mBAAmB,CAAE,SAAAF,EAAU,OAAAxB,EAAQ,UAAAyB,CAAU,CAAC,EACxFjC,EAAakC,CAAM,EAAI,EACzB,CAAC,EACDX,GACF,EACA,KAAK,oBAAoB,GAAOC,CAAW,CAC7C,CACA,6BAA6B3B,EAAYG,EAAcC,EAAiBN,EAAaO,EAAa,CAChG,GAAI,CAACP,EACH,OAEF,MAAM8B,EAAa,CAAE,SAAU9B,EAAY,SAAU,UAAWA,EAAY,SAAU,EAChFwC,EAAqB,KAAK,YAAY,8BAA8BxC,EAAY,MAAM,EACxF,KAAK,4BAA4BE,CAAU,EAC7C,KAAK,0BAA0BA,EAAYI,EAAiBD,EAAcE,CAAW,EAErF,KAAK,oBACHL,EACA4B,EACAxB,EACAkC,EACAnC,EACAjB,EACAmB,CACF,CAEJ,CAEA,4BAA4BL,EAAY,CACtC,OAAO,KAAK,uBAAuBA,CAAU,GAAK,KAAK,cAAgB,MAAQ,CAAC,KAAK,aAAa,QAAQ,CAC5G,CACA,0BAA0BA,EAAYI,EAAiBD,EAAcE,EAAa,CAChF,MAAMkC,EAAQvC,EAAW,CAAC,EAAE,CAAC,EACvB2B,EAAc,CAACC,EAAYP,EAASQ,IAAY,CACpDzB,EAAgB,KAAKiB,CAAO,EAC5BQ,EAAQ,QAASlB,GAAW,KAAK,gBAAgBU,EAASV,EAAQ4B,EAAOpC,EAAcjB,EAAuBmB,CAAW,CAAC,CAC5H,EACA,KAAK,oBAAoB,GAAOsB,CAAW,CAC7C,CACA,uBAAuB3B,EAAY,CACjC,OAAOA,EAAW,SAAW,GAAKA,EAAW,CAAC,EAAE,SAAW,CAC7D,CACA,eAAgB,CACd,GAAI,CAAC,KAAK,cAAgB,KAAK,aAAa,QAAQ,EAClD,OAEF,MAAMwC,EAAiB,CAAC,EAClBtC,EAAiB,CAACC,EAAcC,EAAiBN,EAAaO,IAAgB,CAClF,MAAMoC,EAA8B,KAAK,mBAAmB,YAAY,yBAAyB,EAC3FT,EAA+B,KAAK,mBAAmB,YAAY,0BAA0B,EAC7FL,EAAc,CAACC,EAAYP,EAASQ,IAAY,CAC/CW,EAAe,QAclBpC,EAAgB,KAAKiB,CAAO,EAC5BQ,EAAQ,QAAQ,CAAClB,EAAQmB,IAAU,CACjC,GAAI,CAACnB,EAAO,eAAeU,CAAO,GAAKV,EAAO,gBAAgBU,CAAO,EACnE,OAEF,MAAMqB,EAAgB,KAAK,YACzBrB,EACAV,EACA6B,EAAeV,CAAK,EACpB7C,EACA+C,EACA,EACF,EACAX,EAAQ,aAAaV,EAAQ+B,EAAe1D,CAAY,EACpDqB,GACFA,EAAY,cAAcgB,EAAQ,OAAQ,CAACV,CAAM,CAAC,EAEpD,KAAM,CAAE,SAAAwB,EAAU,UAAAC,CAAU,EAAIR,EAC1BS,EAAS,KAAK,kBAAkB,mBAAmB,CAAE,SAAAF,EAAU,OAAAxB,EAAQ,UAAAyB,CAAU,CAAC,EACxFjC,EAAakC,CAAM,EAAI,EACzB,CAAC,GAjCDR,EAAQ,QAASlB,GAAW,CAC1B,MAAM4B,EAAQ,KAAK,YACjBlB,EACAV,EACA,KAAK,aAAa,SAASA,EAAQU,CAAO,EAC1CpC,EACAwD,EACA,GACA,EACF,EACAD,EAAe,KAAKD,CAAK,CAC3B,CAAC,CAwBL,EACA,KAAK,oBAAoB,GAAMZ,CAAW,CAC5C,EACA,KAAK,iBAAiBzB,CAAc,CACtC,CACA,sBAAsBF,EAAY,CAChC,MAAM2C,EAAWnE,EAAE,KAAKwB,CAAU,EAElC,GADwB2C,GAAYA,EAAS,SAAW,GAAKA,EAAS,CAAC,IAAM,GACxD,CACnB,GAAI3C,EAAW,SAAW,EACxB,OAEFxB,EAAE,gBAAgBwB,EAAY2C,CAAQ,CACxC,CACF,CACA,eAAeC,EAAU,CACnB,KAAK,mBAAmB,IAAI,UAAU,IAAM,WAGhDA,EAAS,QAASvB,GAAY,CAC5B,MAAMC,EAAQ,CACZ,KAAMzC,EAAO,wBACb,KAAMwC,EACN,KAAMA,EAAQ,KACd,SAAUA,EAAQ,SAClB,UAAWA,EAAQ,SACrB,EACA,KAAK,aAAa,cAAcC,CAAK,CACvC,CAAC,CACH,CACA,oBAAoBuB,EAAmBjB,EAAYxB,EAAiBkC,EAAoBnC,EAAc2C,EAAMzC,EAAa,CACvH,IAAI0C,EAAanB,EACjB,MAAMoB,EAAgB,KAAK,oBAAsB,MAAQ,CAAC,KAAK,mBAAmB,IAAI,iBAAiB,GAAK,CAAC,KAAK,mBAAmB,IAAI,UAAU,EAC7IC,EAAqB,IAAM,CAC/B,OAAa,CACX,GAAI,CAACF,EACH,OAAO,KAET,MAAMG,EAAM,KAAK,iBAAiB,WAAWH,CAAU,EAEvD,GADAA,EAAa,KAAK,sBAAsB,YAAY,CAAE,UAAWA,EAAW,UAAW,SAAUA,EAAW,QAAS,CAAC,EAClHG,GAAO,KACT,OAAO,KAGT,GAAI,EADYA,EAAI,QAAUA,EAAI,QAAUF,GAAiBE,EAAI,OAE/D,OAAOA,CAEX,CACF,EACAL,EAAkB,QAASM,GAAqB,CAC9C,MAAM9B,EAAU4B,EAAmB,EAC9B5B,IAGL8B,EAAiB,QAAQ,CAACZ,EAAOT,IAAU,KAAK,gBAAgBT,EAASiB,EAAmBR,CAAK,EAAGS,EAAOpC,EAAc2C,EAAMzC,CAAW,CAAC,EAC3ID,EAAgB,KAAKiB,CAAO,EAC9B,CAAC,CACH,CACA,gBAAgBA,EAASV,EAAQ4B,EAAOpC,EAAc2C,EAAMzC,EAAa,CAIvE,GAHI,CAACgB,GAAW,CAACV,GAAU,CAACA,EAAO,eAAeU,CAAO,GAAKV,EAAO,gBAAgBU,CAAO,GAGxFA,EAAQ,OAASV,EAAO,cAAc,EACxC,OAEF,MAAMyC,EAAiB,KAAK,YAAY/B,EAASV,EAAQ4B,EAAOO,EAAM,KAAK,mBAAmB,YAAY,0BAA0B,EAAG,EAAI,EAC3IzB,EAAQ,aAAaV,EAAQyC,EAAgBpE,CAAY,EACzD,KAAM,CAAE,SAAAmD,EAAU,UAAAC,CAAU,EAAIf,EAC1BgB,EAAS,KAAK,kBAAkB,mBAAmB,CAAE,SAAAF,EAAU,OAAAxB,EAAQ,UAAAyB,CAAU,CAAC,EACxFjC,EAAakC,CAAM,EAAI,GACnBhC,GACFA,EAAY,cAAcgB,EAAQ,OAAQ,CAACV,CAAM,CAAC,CAEtD,CACA,gBAAgB0C,EAAS,CAAC,EAAG,CAC3B,KAAK,qBAAqBA,CAAM,CAClC,CACA,eAAeA,EAAS,CAAC,EAAGnC,EAAS,MAAO,CAC1C,GAAI,KAAK,mBAAmB,IAAI,wBAAwB,EACtD,OAEF,MAAMoC,EAAa,CACjB,KAAMzE,EAAO,gBACb,OAAAqC,CACF,EACA,KAAK,aAAa,cAAcoC,CAAU,EAC1C,KAAK,qBAAqBD,EAAQ,EAAI,EACtC,MAAME,EAAW,CACf,KAAM1E,EAAO,cACb,OAAAqC,CACF,EACA,KAAK,aAAa,cAAcqC,CAAQ,CAC1C,CACA,qBAAqBF,EAAQG,EAAK,CAChC,GAAI,CAAE,eAAAC,EAAgB,oBAAAC,CAAoB,EAAIL,EAC9C,KAAK,OAAO,IAAI,qCAAqCI,CAAc,EAAE,EACjEA,GAAkB,OACpBA,EAAiB,KAAK,mBAAmB,IAAI,wBAAwB,GAEnEC,GAAuB,OACzBA,EAAsB,KAAK,mBAAmB,IAAI,6BAA6B,GAEjF,MAAMC,EAAa,CAAE,eAAAF,EAAgB,oBAAAC,CAAoB,EACnDE,EAAiB,CAAC,KAAK,mBAAmB,IAAI,6BAA6B,EACjF,IAAIC,EAAgB,KAChB,KAAK,cAAgB,CAAC,KAAK,aAAa,QAAQ,GAAK,CAAC,KAAK,0BAA0B,GACvF,KAAK,6BAA6BF,CAAU,EAC5CE,EAAgB,GACPD,GAAkB,CAAC,KAAK,iBAAiB,QAAQ,GAC1D,KAAK,4BAA4BD,CAAU,EAC3CE,EAAgB,GACP,KAAK,aAAa,iBAAiB,IAC5C,KAAK,2BAA2BF,CAAU,EAC1CE,EAAgB,GAEdL,GAAOK,IAAkB,MAC3B,KAAK,oBAAoBA,CAAa,CAE1C,CACA,oBAAoBf,EAAM,CAExB,GADA,KAAK,aAAa,cAAc,CAAE,KAAMjE,EAAO,qCAAsC,CAAC,EAClFiE,IAAS,EACX,KAAK,aAAa,yBAAyB,CAAE,gBAAiB,kBAAmB,CAAC,UACzEA,IAAS,EAClB,KAAK,kBAAkB,MAClB,CACL,MAAMhD,EAAc,KAAK,aAAa,eAAe,EACrD,GAAIA,GAAe,KACjB,OAEF,MAAMuB,EAAU,KAAK,iBAAiB,WAAWvB,CAAW,EACxDuB,GACF,KAAK,eAAeA,EAASvB,EAAY,MAAM,CAEnD,CACA,KAAK,aAAa,cAAc,CAAE,KAAMjB,EAAO,mCAAoC,CAAC,CACtF,CACA,mBAAoB,CAClB,MAAMiF,EAAW,KAAK,iBAAiB,iBAAiB,EAClDjC,EAAU,KAAK,YAAY,uBAAuB,EACxD,UAAWnB,KAAOoD,EAChB,UAAWC,KAAOlC,EAChB,KAAK,eAAenB,EAAKqD,CAAG,CAGlC,CACA,eAAe1C,EAASV,EAAQ,CACzBA,EAAO,eAAeU,CAAO,GAGlCA,EAAQ,aAAaV,EAAQ,KAAM,kBAAkB,CACvD,CACA,2BAA4B,CAC1B,OAAO,KAAK,mBAAmB,IAAI,8BAA8B,GAAK,CAAC,KAAK,aAAa,kBAAkB,CAC7G,CACA,oBAAoBqD,EAAWrC,EAAasC,EAAgB,CAC1D,GAAI,CAAC,KAAK,cAAgB,KAAK,aAAa,QAAQ,EAClD,OAEF,MAAMC,EAAa,KAAK,aAAa,cAAc,EAC/CF,EACF,KAAK,mBAAmBE,EAAW,CAAC,EAAGvC,EAAasC,EAAgB,EAAI,EAExEC,EAAW,QAAQ,CAACC,EAAOlC,IAAQ,KAAK,mBAAmBkC,EAAOxC,EAAasC,EAAgBhC,IAAQiC,EAAW,OAAS,CAAC,CAAC,CAEjI,CACA,mBAAmBC,EAAOxC,EAAasC,EAAgBG,EAAa,CAClE,GAAI,CAAC,KAAK,aACR,OAEF,IAAIxC,EAAa,KAAK,aAAa,iBAAiBuC,CAAK,EACzD,MAAME,EAAU,KAAK,aAAa,eAAeF,CAAK,EAClDF,GAAkBE,EAAM,SAC1BF,EAAeE,EAAM,OAAO,EAE9B,IAAIG,EAAa,EACbC,EAAY,GAChB,KAAO,CAACA,GAAa3C,GAAc,MAAM,CACvC,MAAMP,EAAU,KAAK,iBAAiB,WAAWO,CAAU,EAC3D2C,EAAY,KAAK,iBAAiB,QAAQ3C,EAAYyC,CAAO,EAC7D1C,EAAYC,EAAYP,EAAS8C,EAAM,QAASG,IAAcC,GAAaH,CAAW,EACtFxC,EAAa,KAAK,sBAAsB,YAAYA,CAAU,CAChE,CACF,CACA,6BAA6ByB,EAAS,CAAC,EAAG,CACxC,GAAI,CAAC,KAAK,cAAgB,KAAK,aAAa,QAAQ,EAClD,OAEF,MAAMmB,EAAiB,KAAK,aAAa,wBAAwB,EAC3D,CAAE,KAAA3E,EAAM,aAAAM,CAAa,EAAIqE,EAAiB,KAAK,0BAA0BnB,CAAM,EAAI,KAAK,oBAAoBA,CAAM,EACxH,KAAK,oBAAoBxD,CAAI,EAC7B,KAAK,mBAAmBM,CAAY,CACtC,CACA,0BAA0BkD,EAAQ,CAChC,MAAMoB,EAA6B,IAAI,IACjCC,EAAS,KAAK,aAAa,cAAc,EACzCC,EAAkC,IAAI,IACtCC,EAAkB,CAAC,EACnBC,EAAkB,CAAC,EACzBH,EAAO,QAASP,GAAU,CACxBA,EAAM,QAAQ,QAASJ,GAAQU,EAAW,IAAIV,CAAG,CAAC,EAClD,KAAM,CAAE,aAAAe,EAAc,aAAA3E,CAAa,EAAI,KAAK,oCAAoCgE,CAAK,EACrFW,EAAa,QAASC,GAAgB,CACpC,MAAMC,EAAsB,GAAGD,EAAY,QAAQ,IAAIA,EAAY,WAAa,MAAM,GACjFJ,EAAgB,IAAIK,CAAmB,IAC1CL,EAAgB,IAAIK,EAAqB,EAAI,EAC7CJ,EAAgB,KAAKG,CAAW,EAEpC,CAAC,EACD,OAAO,OAAOF,EAAiB1E,CAAY,CAC7C,CAAC,EACD,MAAM8E,EAAa,KAAK,YAAY,uBAAuB,EACrDC,EAAkB,MAAM,KAAKT,CAAU,EAC7C,OAAAS,EAAgB,KAAK,CAACC,EAAGC,IAAM,CAC7B,MAAMC,EAAOJ,EAAW,QAAQE,CAAC,EAC3BG,EAAOL,EAAW,QAAQG,CAAC,EACjC,OAAOC,EAAOC,CAChB,CAAC,EAOM,CAAE,KANI,KAAK,kBAAkB,CAClC,QAASJ,EACT,aAAcN,EACd,eAAgBvB,EAAO,eACvB,oBAAqBA,EAAO,mBAC9B,CAAC,EACc,aAAcwB,CAAgB,CAC/C,CACA,oBAAoBxB,EAAQ,CAC1B,MAAMqB,EAAS,KAAK,aAAa,cAAc,EACzC7E,EAAO,CAAC,EACRgF,EAAkB,CAAC,EACzB,OAAAH,EAAO,QAASP,GAAU,CACxB,KAAM,CAAE,aAAAW,EAAc,aAAA3E,CAAa,EAAI,KAAK,oCAAoCgE,CAAK,EACrF,OAAO,OAAOU,EAAiB1E,CAAY,EAC3CN,EAAK,KAAK,KAAK,kBAAkB,CAC/B,QAASsE,EAAM,QACf,aAAAW,EACA,eAAgBzB,EAAO,eACvB,oBAAqBA,EAAO,mBAC9B,CAAC,CAAC,CACJ,CAAC,EACM,CAAE,KAAMxD,EAAK,KAAK;AAAA,CAAI,EAAG,aAAcgF,CAAgB,CAChE,CACA,oCAAoCV,EAAO,CACzC,MAAMW,EAAe,CAAC,EAChB3E,EAAe,CAAC,EAChBoF,EAAW,KAAK,aAAa,iBAAiBpB,CAAK,EACnDE,EAAU,KAAK,aAAa,eAAeF,CAAK,EACtD,IAAIqB,EAAOD,EACX,KAAOC,IACLV,EAAa,KAAKU,CAAI,EACtBrB,EAAM,QAAQ,QAASxD,GAAW,CAChC,KAAM,CAAE,SAAAwB,EAAU,UAAAC,CAAU,EAAIoD,EAC1BnD,EAAS,KAAK,kBAAkB,mBAAmB,CAAE,SAAAF,EAAU,OAAAxB,EAAQ,UAAAyB,CAAU,CAAC,EACxFjC,EAAakC,CAAM,EAAI,EACzB,CAAC,EACG,MAAK,iBAAiB,QAAQmD,EAAMnB,CAAO,IAG/CmB,EAAO,KAAK,sBAAsB,YAAYA,CAAI,EAEpD,MAAO,CAAE,aAAAV,EAAc,aAAA3E,CAAa,CACtC,CACA,4BAA4ByC,EAAU,CACpC,MAAM6C,EAAsB,KAAK,YAAY,uBAAuB,EAC9DtF,EAAe,CAAC,EACtB,QAASuF,EAAI,EAAGA,EAAI9C,EAAS,OAAQ8C,IAAK,CACxC,KAAM,CAAE,SAAAvD,EAAU,UAAAC,CAAU,EAAIQ,EAAS8C,CAAC,EAC1C,GAAIvD,GAAY,KAGhB,QAASwD,EAAI,EAAGA,EAAIF,EAAoB,OAAQE,IAAK,CACnD,MAAMhF,EAAS8E,EAAoBE,CAAC,EAC9BtD,EAAS,KAAK,kBAAkB,mBAAmB,CAAE,SAAAF,EAAU,OAAAxB,EAAQ,UAAAyB,CAAU,CAAC,EACxFjC,EAAakC,CAAM,EAAI,EACzB,CACF,CACA,OAAOlC,CACT,CACA,2BAA2BkD,EAAS,CAAC,EAAG,CACtC,MAAMvD,EAAc,KAAK,aAAa,eAAe,EACrD,GAAIA,GAAe,KACjB,OAEF,MAAMuC,EAAS,KAAK,kBAAkB,SAASvC,CAAW,EACpD8B,EAAa,CAAE,UAAW9B,EAAY,UAAW,SAAUA,EAAY,QAAS,EAChFa,EAASb,EAAY,OACrBD,EAAO,KAAK,kBAAkB,CAClC,QAAS,CAACc,CAAM,EAChB,aAAc,CAACiB,CAAU,EACzB,eAAgByB,EAAO,eACvB,oBAAqBA,EAAO,mBAC9B,CAAC,EACD,KAAK,oBAAoBxD,CAAI,EAC7B,KAAK,mBAAmB,CAAE,CAACwC,CAAM,EAAG,EAAK,CAAC,CAC5C,CACA,4BAA4BgB,EAAS,CAAC,EAAG,CACvC,KAAM,CAAE,WAAAuC,EAAY,eAAAnC,EAAgB,oBAAAC,CAAoB,EAAIL,EACtDxD,EAAO,KAAK,kBAAkB,CAClC,QAAS+F,EACT,eAAAnC,EACA,oBAAAC,CACF,CAAC,EACD,KAAK,oBAAoB7D,CAAI,EAC7B,MAAM+C,EAAW,KAAK,iBAAiB,iBAAiB,GAAK,CAAC,EAC9D,KAAK,mBAAmB,KAAK,4BAA4BA,CAAQ,CAAC,CACpE,CACA,kBAAkBS,EAAQ,CACxB,KAAM,CAAE,QAAAxB,EAAS,aAAAiD,EAAc,eAAArB,EAAiB,GAAO,oBAAAC,EAAsB,EAAM,EAAIL,EACjFwC,EAAe,CACnB,WAAYhE,EACZ,aAAAiD,EACA,kBAAmB,CAACrB,EACpB,uBAAwB,CAACC,EACzB,eAAgB,GAChB,gBAAiB,KAAK,sBAAsB,EAC5C,aAAc,CAACoB,EACf,oBAAqB,KAAK,mBAAmB,YAAY,yBAAyB,EAClF,wBAA0BgB,GAAY,KAAK,wBAAwBA,CAAO,EAC1E,sBAAuB,KAAK,mBAAmB,YAAY,2BAA2B,EACtF,2BAA4B,KAAK,mBAAmB,YAAY,gCAAgC,CAClG,EACA,OAAO,KAAK,WAAW,aAAaD,EAAc,EAAI,CACxD,CACA,wBAAwBxC,EAAQ,CAC9B,KAAM,CAAE,KAAAmC,EAAM,OAAA7E,CAAO,EAAI0C,EACnB0C,EAAa,KAAK,mBAAmB,IAAI,UAAU,EACnDC,EAAmC,KAAK,mBAAmB,IAAI,gCAAgC,EAYrG,IAAIzD,GAXqB,IAAM,CAC7B,IAAI0D,EAAIC,EACR,GAAIH,GAAcC,GAAoC,CAACrF,EACrD,OAAO6E,EAAK,IAEd,MAAMW,GAAUF,EAAKT,EAAK,YAAc,KAAO,OAASS,EAAGtF,EAAO,MAAM,CAAC,EACzE,MAAI,CAACwF,GAAU,CAACX,EAAK,gBAAkBA,EAAK,eAAe,UAAU,EAAE,6BAA+B,GAC7FW,GAEDD,EAAK,KAAK,sBAAsB,YAAYV,EAAK,eAAgBA,EAAMW,CAAM,IAAM,KAAOD,EAAKC,CACzG,GAC6B,EAC7B,GAAI9C,EAAO,KAAK,OAAQ,CACtB,IAAI+C,EAAS,GACT7D,GAASA,EAAM,SACjB6D,EAAS,IAAI7D,CAAK,IAEpBA,EAAQ,QAAQ6D,CAAM,EACxB,CACA,MAAMC,EAA0B,KAAK,mBAAmB,YAAY,yBAAyB,EAC7F,GAAIA,EAAyB,CAC3B,IAAIC,EAAUd,EAAK,eACnB,MAAI,CAACc,GAAWd,EAAK,QAAUA,EAAK,QAAU,KAC5Cc,EAAU,KAAK,YAAY,mBAAmB,EAAE,CAAC,GAE5CD,EAAwB,CAC7B,MAAA9D,EACA,KAAAiD,EACA,OAAQc,EACR,KAAM,YACN,YAAcC,GAAkB,CAC9B,IAAIN,EACJ,OAAQA,EAAK,KAAK,sBAAsB,YAAYK,EAASd,EAAMe,CAAa,IAAM,KAAON,EAAKM,CACpG,EACA,WAAaC,GAAiB,KAAK,mBAAmB,WAAWF,EAASd,EAAMgB,EAAc,KAAK,aAAa,SAASF,EAASd,CAAI,CAAC,CACzI,CAAC,CACH,CACA,OAAOjD,CACT,CACA,mBAAmBpC,EAAc,CAC/B,OAAO,WAAW,IAAM,CACtB,MAAMmB,EAAQ,CACZ,KAAMzC,EAAO,kBACb,MAAOsB,CACT,EACA,KAAK,aAAa,cAAcmB,CAAK,CACvC,EAAG,CAAC,CACN,CACA,YAAYD,EAASV,EAAQ4B,EAAOO,EAAM2D,EAAMC,EAAUC,EAAW,CACnE,IAAIV,EACJ,OAAIQ,EAYKA,EAXQ,CACb,OAAA9F,EACA,KAAMU,EACN,MAAAkB,EACA,KAAAO,EACA,YAAcyD,GAAkB,CAC9B,IAAIK,EACJ,OAAQA,EAAM,KAAK,sBAAsB,YAAYjG,EAAQU,GAA4B,KAAMkF,CAAa,IAAM,KAAOK,EAAML,CACjI,EACA,WAAaC,GAAiB,KAAK,mBAAmB,WAAW7F,EAAQU,GAA4B,KAAMmF,EAAc,KAAK,aAAa,SAAS7F,EAAQU,CAAO,CAAC,CACtK,CACkB,EAEhBqF,GAAY/F,EAAO,UAAU,EAAE,0BAA4B,GACtD,KAAK,mBAAmB,WAAWA,EAAQU,GAA4B,KAAMkB,EAAO,KAAK,aAAa,SAAS5B,EAAQU,CAAO,CAAC,EAC7HsF,GAAahG,EAAO,UAAU,EAAE,6BAA+B,KAChEsF,EAAK,KAAK,sBAAsB,YAAYtF,EAAQU,GAA4B,KAAMkB,CAAK,IAAM,KAAO0D,EAE3G1D,CACT,CACA,oBAAoB1C,EAAM,CACxB,MAAMgH,EAAmB,KAAK,mBAAmB,YAAY,iBAAiB,EAC9E,GAAIA,EAAkB,CACpBA,EAAiB,CAAE,KAAAhH,CAAK,CAAC,EACzB,MACF,CAEA,GADuB,CAAC,KAAK,mBAAmB,IAAI,sBAAsB,GACpD,UAAU,UAAW,CACzC,UAAU,UAAU,UAAUA,CAAI,EAAE,MAAON,GAAM,CAC/Cf,EAAE,OAAO,IAAM,CACb,QAAQ,KAAKe,CAAC,EACd,QAAQ,KAAKJ,EAAS,WAAW,CAAC,CACpC,EAAG,mBAAmB,EACtB,KAAK,0BAA0BU,CAAI,CACrC,CAAC,EACD,MACF,CACA,KAAK,0BAA0BA,CAAI,CACrC,CACA,0BAA0BA,EAAM,CAC9B,KAAK,qBAAsBD,GAAY,CACrC,MAAMkH,EAAY,KAAK,mBAAmB,YAAY,EAChDC,EAAuBD,EAAU,cACvClH,EAAQ,MAAQC,GAAQ,IACxBD,EAAQ,OAAO,EACfA,EAAQ,MAAM,CAAE,cAAe,EAAK,CAAC,EACtBkH,EAAU,YAAY,MAAM,GAEzC,QAAQ,KAAK,mNAAmN,EAE9NC,GAAwB,MAAQA,EAAqB,OAAS,MAChEA,EAAqB,MAAM,CAAE,cAAe,EAAK,CAAC,CAEtD,CAAC,CACH,CACA,qBAAqBC,EAAaC,EAAe,CAC/C,MAAMC,EAAO,KAAK,mBAAmB,YAAY,EAC3CC,EAAaD,EAAK,cAAc,UAAU,EAChDC,EAAW,MAAM,MAAQ,MACzBA,EAAW,MAAM,OAAS,MAC1BA,EAAW,MAAM,IAAMD,EAAK,gBAAgB,UAAY,KACxDC,EAAW,MAAM,KAAOD,EAAK,gBAAgB,WAAa,KAC1DC,EAAW,MAAM,SAAW,WAC5BA,EAAW,MAAM,QAAU,IAC3B,MAAMC,EAAU,KAAK,SAAS,OAAO,EACrCA,EAAQ,YAAYD,CAAU,EAC9B,GAAI,CACFH,EAAYG,CAAU,CACxB,MAAc,CACZ,QAAQ,KAAK,yFAAyF,CACxG,CACIF,EACF,OAAO,WAAW,IAAM,CACtBA,EAAcE,CAAU,EACxBC,EAAQ,YAAYD,CAAU,CAChC,EAAG,GAAG,EAENC,EAAQ,YAAYD,CAAU,CAElC,CACA,cAAe,CACb,MAAMzC,EAAS,KAAK,aAAa,cAAc,EAC/C,IAAI2C,EAAkB,EAClBC,EAAgB,EACpB,OAAI5C,EAAO,OAAS,IAClB2C,EAAkB,KAAK,aAAa,iBAAiB3C,EAAO,CAAC,CAAC,EAAE,SAChE4C,EAAgB,KAAK,aAAa,eAAe5C,EAAO,CAAC,CAAC,EAAE,UAEvD2C,EAAkBC,EAAgB,CAC3C,CACF,EACAxJ,EAAgB,CACdW,EAAU,YAAY,CACxB,EAAGY,EAAiB,UAAW,aAAc,CAAC,EAC9CvB,EAAgB,CACdW,EAAU,eAAe,CAC3B,EAAGY,EAAiB,UAAW,gBAAiB,CAAC,EACjDvB,EAAgB,CACdW,EAAU,kBAAkB,CAC9B,EAAGY,EAAiB,UAAW,mBAAoB,CAAC,EACpDvB,EAAgB,CACdiB,EAAS,cAAc,CACzB,EAAGM,EAAiB,UAAW,eAAgB,CAAC,EAChDvB,EAAgB,CACdW,EAAU,UAAU,CACtB,EAAGY,EAAiB,UAAW,WAAY,CAAC,EAC5CvB,EAAgB,CACdW,EAAU,cAAc,CAC1B,EAAGY,EAAiB,UAAW,eAAgB,CAAC,EAChDvB,EAAgB,CACdW,EAAU,cAAc,CAC1B,EAAGY,EAAiB,UAAW,eAAgB,CAAC,EAChDvB,EAAgB,CACdW,EAAU,cAAc,CAC1B,EAAGY,EAAiB,UAAW,eAAgB,CAAC,EAChDvB,EAAgB,CACdW,EAAU,aAAa,CACzB,EAAGY,EAAiB,UAAW,cAAe,CAAC,EAC/CvB,EAAgB,CACdW,EAAU,aAAa,CACzB,EAAGY,EAAiB,UAAW,cAAe,CAAC,EAC/CvB,EAAgB,CACdW,EAAU,uBAAuB,CACnC,EAAGY,EAAiB,UAAW,wBAAyB,CAAC,EACzDvB,EAAgB,CACdW,EAAU,mBAAmB,CAC/B,EAAGY,EAAiB,UAAW,oBAAqB,CAAC,EACrDvB,EAAgB,CACdW,EAAU,kBAAkB,CAC9B,EAAGY,EAAiB,UAAW,mBAAoB,CAAC,EACpDvB,EAAgB,CACdW,EAAU,uBAAuB,CACnC,EAAGY,EAAiB,UAAW,wBAAyB,CAAC,EACzDvB,EAAgB,CACdW,EAAU,oBAAoB,CAChC,EAAGY,EAAiB,UAAW,qBAAsB,CAAC,EACtDvB,EAAgB,CACdgB,CACF,EAAGO,EAAiB,UAAW,OAAQ,CAAC,EACxCA,EAAmBvB,EAAgB,CACjCY,EAAK,kBAAkB,CACzB,EAAGW,CAAgB,EAGnB,IAAIkI,EAAU,SAGVC,EAAkB,CACpB,QAASD,EACT,WAAYlJ,EAAY,gBACxB,MAAO,CAACgB,CAAgB,EACxB,iBAAkB,CAChBf,EACAC,CACF,CACF,EACA,OACEiJ,KAAA",
  "names": ["__defProp", "__getOwnPropDesc", "__decorateClass", "decorators", "target", "key", "kind", "result", "decorator", "ModuleNames", "EnterpriseCoreModule", "CsvExportModule", "_", "Autowired", "Bean", "BeanStub", "ChangedPath", "Events", "PostConstruct", "Optional", "SOURCE_PASTE", "EXPORT_TYPE_DRAG_COPY", "EXPORT_TYPE_CLIPBOARD", "apiError", "method", "ClipboardService", "p", "e", "defaultPrevented", "handlePasteEvent", "currentPastOperationTime", "textArea", "element", "data", "focusedCell", "delimiter", "parsedData", "userFunc", "pasteOperation", "cellsToFlash", "updatedRowNodes", "changedPath", "strData", "isNewline", "char", "insideQuotedField", "row", "column", "position", "previousChar", "currentChar", "nextChar", "ensureDataExists", "pasteOperationFunc", "source", "onlyChangedColumns", "nodesToRefresh", "rowNode", "event", "clipboardData", "abortRepeatingPasteIntoRows", "indexOffset", "dataRowIndex", "rowCallback", "currentRow", "columns", "index", "currentRowData", "processCellFromClipboardFunc", "idx", "newValue", "rowIndex", "rowPinned", "cellId", "columnsToPasteInto", "value", "firstRowValues", "processCellForClipboardFunc", "firstRowValue", "lastLine", "rowNodes", "clipboardGridData", "type", "rowPointer", "skipGroupRows", "getNextGoodRowNode", "res", "clipboardRowData", "processedValue", "params", "startEvent", "endEvent", "cut", "includeHeaders", "includeGroupHeaders", "copyParams", "shouldCopyRows", "cellClearType", "selected", "col", "onlyFirst", "columnCallback", "cellRanges", "range", "isLastRange", "lastRow", "rangeIndex", "isLastRow", "allRangesMerge", "columnsSet", "ranges", "rowPositionsMap", "allRowPositions", "allCellsToFlash", "rowPositions", "rowPosition", "rowPositionAsString", "allColumns", "exportedColumns", "a", "b", "posA", "posB", "startRow", "node", "allDisplayedColumns", "i", "j", "columnKeys", "exportParams", "params2", "isTreeData", "isSuppressGroupMaintainValueType", "_a", "_b", "value2", "suffix", "processCellForClipboard", "column2", "valueToFormat", "valueToParse", "func", "canParse", "canFormat", "_a2", "userProvidedFunc", "eDocument", "focusedElementBefore", "callbackNow", "callbackAfter", "eDoc", "eTempInput", "guiRoot", "startRangeIndex", "endRangeIndex", "VERSION", "ClipboardModule"]
}
