{
  "version": 3,
  "sources": ["<stdin>"],
  "sourcesContent": ["// enterprise-modules/clipboard/src/clipboardModule.ts\nimport { ModuleNames } from \"@ag-grid-community/core\";\nimport { CsvExportModule } from \"@ag-grid-community/csv-export\";\nimport { EnterpriseCoreModule } from \"@ag-grid-enterprise/core\";\n\n// enterprise-modules/clipboard/src/clipboard/clipboardApi.ts\nfunction copyToClipboard(beans, params) {\n  beans.clipboardService?.copyToClipboard(params);\n}\nfunction cutToClipboard(beans, params) {\n  beans.clipboardService?.cutToClipboard(params);\n}\nfunction copySelectedRowsToClipboard(beans, params) {\n  beans.clipboardService?.copySelectedRowsToClipboard(params);\n}\nfunction copySelectedRangeToClipboard(beans, params) {\n  beans.clipboardService?.copySelectedRangeToClipboard(params);\n}\nfunction copySelectedRangeDown(beans) {\n  beans.clipboardService?.copyRangeDown();\n}\nfunction pasteFromClipboard(beans) {\n  beans.clipboardService?.pasteFromClipboard();\n}\n\n// enterprise-modules/clipboard/src/clipboard/clipboardService.ts\nimport { BeanStub, ChangedPath, _exists, _last, _removeFromArray, _warnOnce } from \"@ag-grid-community/core\";\nvar SOURCE_PASTE = \"paste\";\nvar EXPORT_TYPE_DRAG_COPY = \"dragCopy\";\nvar EXPORT_TYPE_CLIPBOARD = \"clipboard\";\nvar apiError = (method) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${method}()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.`;\nvar ClipboardService = class _ClipboardService extends BeanStub {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"clipboardService\";\n    this.lastPasteOperationTime = 0;\n    this.navigatorApiFailed = false;\n  }\n  wireBeans(beans) {\n    this.csvCreator = beans.csvCreator;\n    this.selectionService = beans.selectionService;\n    this.rowModel = beans.rowModel;\n    this.ctrlsService = beans.ctrlsService;\n    this.valueService = beans.valueService;\n    this.focusService = beans.focusService;\n    this.rowRenderer = beans.rowRenderer;\n    this.visibleColsService = beans.visibleColsService;\n    this.funcColsService = beans.funcColsService;\n    this.cellNavigationService = beans.cellNavigationService;\n    this.cellPositionUtils = beans.cellPositionUtils;\n    this.rowPositionUtils = beans.rowPositionUtils;\n    this.rangeService = beans.rangeService;\n  }\n  postConstruct() {\n    if (this.rowModel.getType() === \"clientSide\") {\n      this.clientSideRowModel = this.rowModel;\n    }\n    this.ctrlsService.whenReady((p) => {\n      this.gridCtrl = p.gridCtrl;\n    });\n  }\n  pasteFromClipboard() {\n    const allowNavigator = !this.gos.get(\"suppressClipboardApi\");\n    if (allowNavigator && !this.navigatorApiFailed && navigator.clipboard && navigator.clipboard.readText) {\n      navigator.clipboard.readText().then(this.processClipboardData.bind(this)).catch((e) => {\n        _warnOnce(`${e}\n${apiError(\"readText\")}`);\n        this.navigatorApiFailed = true;\n        this.pasteFromClipboardLegacy();\n      });\n    } else {\n      this.pasteFromClipboardLegacy();\n    }\n  }\n  pasteFromClipboardLegacy() {\n    let defaultPrevented = false;\n    const handlePasteEvent = (e) => {\n      const currentPastOperationTime = (/* @__PURE__ */ new Date()).getTime();\n      if (currentPastOperationTime - this.lastPasteOperationTime < 50) {\n        defaultPrevented = true;\n        e.preventDefault();\n      }\n      this.lastPasteOperationTime = currentPastOperationTime;\n    };\n    this.executeOnTempElement(\n      (textArea) => {\n        textArea.addEventListener(\"paste\", handlePasteEvent);\n        textArea.focus({ preventScroll: true });\n      },\n      (element) => {\n        const data = element.value;\n        if (!defaultPrevented) {\n          this.processClipboardData(data);\n        } else {\n          this.refocusLastFocusedCell();\n        }\n        element.removeEventListener(\"paste\", handlePasteEvent);\n      }\n    );\n  }\n  refocusLastFocusedCell() {\n    const focusedCell = this.focusService.getFocusedCell();\n    if (focusedCell) {\n      this.focusService.setFocusedCell({\n        rowIndex: focusedCell.rowIndex,\n        column: focusedCell.column,\n        rowPinned: focusedCell.rowPinned,\n        forceBrowserFocus: true\n      });\n    }\n  }\n  getClipboardDelimiter() {\n    const delimiter = this.gos.get(\"clipboardDelimiter\");\n    return _exists(delimiter) ? delimiter : \"\t\";\n  }\n  processClipboardData(data) {\n    if (data == null) {\n      return;\n    }\n    let parsedData = _ClipboardService.stringToArray(data, this.getClipboardDelimiter());\n    const userFunc = this.gos.getCallback(\"processDataFromClipboard\");\n    if (userFunc) {\n      parsedData = userFunc({ data: parsedData });\n    }\n    if (parsedData == null) {\n      return;\n    }\n    if (this.gos.get(\"suppressLastEmptyLineOnPaste\")) {\n      this.removeLastLineIfBlank(parsedData);\n    }\n    const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {\n      const rangeActive = this.rangeService?.isMoreThanOneCell();\n      const pasteIntoRange = rangeActive && !this.hasOnlyOneValueToPaste(parsedData);\n      if (pasteIntoRange) {\n        this.pasteIntoActiveRange(this.rangeService, parsedData, cellsToFlash, updatedRowNodes, changedPath);\n      } else {\n        this.pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n      }\n    };\n    this.doPasteOperation(pasteOperation);\n  }\n  // This will parse a delimited string into an array of arrays.\n  static stringToArray(strData, delimiter = \",\") {\n    const data = [];\n    const isNewline = (char) => char === \"\\r\" || char === \"\\n\";\n    let insideQuotedField = false;\n    if (strData === \"\") {\n      return [[\"\"]];\n    }\n    for (let row = 0, column = 0, position = 0; position < strData.length; position++) {\n      const previousChar = strData[position - 1];\n      const currentChar = strData[position];\n      const nextChar = strData[position + 1];\n      const ensureDataExists = () => {\n        if (!data[row]) {\n          data[row] = [];\n        }\n        if (!data[row][column]) {\n          data[row][column] = \"\";\n        }\n      };\n      ensureDataExists();\n      if (currentChar === '\"') {\n        if (insideQuotedField) {\n          if (nextChar === '\"') {\n            data[row][column] += '\"';\n            position++;\n          } else {\n            insideQuotedField = false;\n          }\n        } else if (previousChar === void 0 || previousChar === delimiter || isNewline(previousChar)) {\n          insideQuotedField = true;\n        }\n      }\n      if (!insideQuotedField && currentChar !== '\"') {\n        if (currentChar === delimiter) {\n          column++;\n          ensureDataExists();\n          continue;\n        } else if (isNewline(currentChar)) {\n          column = 0;\n          row++;\n          ensureDataExists();\n          if (currentChar === \"\\r\" && nextChar === \"\\n\") {\n            position++;\n          }\n          continue;\n        }\n      }\n      data[row][column] += currentChar;\n    }\n    return data;\n  }\n  // common code to paste operations, e.g. paste to cell, paste to range, and copy range down\n  doPasteOperation(pasteOperationFunc) {\n    const source = \"clipboard\";\n    this.eventService.dispatchEvent({\n      type: \"pasteStart\",\n      source\n    });\n    let changedPath;\n    if (this.clientSideRowModel) {\n      const onlyChangedColumns = this.gos.get(\"aggregateOnlyChangedColumns\");\n      changedPath = new ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());\n    }\n    const cellsToFlash = {};\n    const updatedRowNodes = [];\n    const focusedCell = this.focusService.getFocusedCell();\n    pasteOperationFunc(cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n    const nodesToRefresh = [...updatedRowNodes];\n    if (changedPath) {\n      this.clientSideRowModel.doAggregate(changedPath);\n      changedPath.forEachChangedNodeDepthFirst((rowNode) => {\n        nodesToRefresh.push(rowNode);\n      });\n    }\n    this.rowRenderer.refreshCells({ rowNodes: nodesToRefresh });\n    this.dispatchFlashCells(cellsToFlash);\n    this.fireRowChanged(updatedRowNodes);\n    this.refocusLastFocusedCell();\n    const event = {\n      type: \"pasteEnd\",\n      source\n    };\n    this.eventService.dispatchEvent(event);\n  }\n  pasteIntoActiveRange(rangeService, clipboardData, cellsToFlash, updatedRowNodes, changedPath) {\n    const abortRepeatingPasteIntoRows = this.getRangeSize(rangeService) % clipboardData.length != 0;\n    let indexOffset = 0;\n    let dataRowIndex = 0;\n    const rowCallback = (currentRow, rowNode, columns, index) => {\n      const atEndOfClipboardData = index - indexOffset >= clipboardData.length;\n      if (atEndOfClipboardData) {\n        if (abortRepeatingPasteIntoRows) {\n          return;\n        }\n        indexOffset += dataRowIndex;\n        dataRowIndex = 0;\n      }\n      const currentRowData = clipboardData[index - indexOffset];\n      updatedRowNodes.push(rowNode);\n      const processCellFromClipboardFunc = this.gos.getCallback(\"processCellFromClipboard\");\n      columns.forEach((column, idx) => {\n        if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n          return;\n        }\n        if (idx >= currentRowData.length) {\n          idx = idx % currentRowData.length;\n        }\n        const newValue = this.processCell(\n          rowNode,\n          column,\n          currentRowData[idx],\n          EXPORT_TYPE_DRAG_COPY,\n          processCellFromClipboardFunc,\n          true\n        );\n        rowNode.setDataValue(column, newValue, SOURCE_PASTE);\n        if (changedPath) {\n          changedPath.addParentNode(rowNode.parent, [column]);\n        }\n        const { rowIndex, rowPinned } = currentRow;\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n        cellsToFlash[cellId] = true;\n      });\n      dataRowIndex++;\n    };\n    this.iterateActiveRanges(false, rowCallback);\n  }\n  getDisplayedColumnsStartingAt(column) {\n    let currentColumn = column;\n    const columns = [];\n    while (currentColumn != null) {\n      columns.push(currentColumn);\n      currentColumn = this.visibleColsService.getColAfter(currentColumn);\n    }\n    return columns;\n  }\n  pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath) {\n    if (!focusedCell) {\n      return;\n    }\n    const currentRow = { rowIndex: focusedCell.rowIndex, rowPinned: focusedCell.rowPinned };\n    const columnsToPasteInto = this.getDisplayedColumnsStartingAt(focusedCell.column);\n    if (this.isPasteSingleValueIntoRange(parsedData)) {\n      this.pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath);\n    } else {\n      this.pasteMultipleValues(\n        parsedData,\n        currentRow,\n        updatedRowNodes,\n        columnsToPasteInto,\n        cellsToFlash,\n        EXPORT_TYPE_CLIPBOARD,\n        changedPath\n      );\n    }\n  }\n  // if range is active, and only one cell, then we paste this cell into all cells in the active range.\n  isPasteSingleValueIntoRange(parsedData) {\n    return this.hasOnlyOneValueToPaste(parsedData) && this.rangeService != null && !this.rangeService.isEmpty();\n  }\n  pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath) {\n    const value = parsedData[0][0];\n    const rowCallback = (currentRow, rowNode, columns) => {\n      updatedRowNodes.push(rowNode);\n      columns.forEach(\n        (column) => this.updateCellValue(rowNode, column, value, cellsToFlash, EXPORT_TYPE_CLIPBOARD, changedPath)\n      );\n    };\n    this.iterateActiveRanges(false, rowCallback);\n  }\n  hasOnlyOneValueToPaste(parsedData) {\n    return parsedData.length === 1 && parsedData[0].length === 1;\n  }\n  copyRangeDown() {\n    if (!this.rangeService || this.rangeService.isEmpty()) {\n      return;\n    }\n    const firstRowValues = [];\n    const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {\n      const processCellForClipboardFunc = this.gos.getCallback(\"processCellForClipboard\");\n      const processCellFromClipboardFunc = this.gos.getCallback(\"processCellFromClipboard\");\n      const rowCallback = (currentRow, rowNode, columns) => {\n        if (!firstRowValues.length) {\n          columns.forEach((column) => {\n            const value = this.processCell(\n              rowNode,\n              column,\n              this.valueService.getValue(column, rowNode),\n              EXPORT_TYPE_DRAG_COPY,\n              processCellForClipboardFunc,\n              false,\n              true\n            );\n            firstRowValues.push(value);\n          });\n        } else {\n          updatedRowNodes.push(rowNode);\n          columns.forEach((column, index) => {\n            if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n              return;\n            }\n            const firstRowValue = this.processCell(\n              rowNode,\n              column,\n              firstRowValues[index],\n              EXPORT_TYPE_DRAG_COPY,\n              processCellFromClipboardFunc,\n              true\n            );\n            rowNode.setDataValue(column, firstRowValue, SOURCE_PASTE);\n            if (changedPath) {\n              changedPath.addParentNode(rowNode.parent, [column]);\n            }\n            const { rowIndex, rowPinned } = currentRow;\n            const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n            cellsToFlash[cellId] = true;\n          });\n        }\n      };\n      this.iterateActiveRanges(true, rowCallback);\n    };\n    this.doPasteOperation(pasteOperation);\n  }\n  removeLastLineIfBlank(parsedData) {\n    const lastLine = _last(parsedData);\n    const lastLineIsBlank = lastLine && lastLine.length === 1 && lastLine[0] === \"\";\n    if (lastLineIsBlank) {\n      if (parsedData.length === 1) {\n        return;\n      }\n      _removeFromArray(parsedData, lastLine);\n    }\n  }\n  fireRowChanged(rowNodes) {\n    if (this.gos.get(\"editType\") !== \"fullRow\") {\n      return;\n    }\n    rowNodes.forEach((rowNode) => {\n      const event = {\n        type: \"rowValueChanged\",\n        node: rowNode,\n        data: rowNode.data,\n        rowIndex: rowNode.rowIndex,\n        rowPinned: rowNode.rowPinned\n      };\n      this.eventService.dispatchEvent(event);\n    });\n  }\n  pasteMultipleValues(clipboardGridData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, type, changedPath) {\n    let rowPointer = currentRow;\n    const skipGroupRows = this.clientSideRowModel != null && !this.gos.get(\"enableGroupEdit\") && !this.gos.get(\"treeData\");\n    const getNextGoodRowNode = () => {\n      while (true) {\n        if (!rowPointer) {\n          return null;\n        }\n        const res = this.rowPositionUtils.getRowNode(rowPointer);\n        rowPointer = this.cellNavigationService.getRowBelow({\n          rowPinned: rowPointer.rowPinned,\n          rowIndex: rowPointer.rowIndex\n        });\n        if (res == null) {\n          return null;\n        }\n        const skipRow = res.detail || res.footer || skipGroupRows && res.group;\n        if (!skipRow) {\n          return res;\n        }\n      }\n    };\n    clipboardGridData.forEach((clipboardRowData) => {\n      const rowNode = getNextGoodRowNode();\n      if (!rowNode) {\n        return;\n      }\n      clipboardRowData.forEach(\n        (value, index) => this.updateCellValue(rowNode, columnsToPasteInto[index], value, cellsToFlash, type, changedPath)\n      );\n      updatedRowNodes.push(rowNode);\n    });\n  }\n  updateCellValue(rowNode, column, value, cellsToFlash, type, changedPath) {\n    if (!rowNode || !column || !column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n      return;\n    }\n    if (rowNode.group && column.isValueActive()) {\n      return;\n    }\n    const processedValue = this.processCell(\n      rowNode,\n      column,\n      value,\n      type,\n      this.gos.getCallback(\"processCellFromClipboard\"),\n      true\n    );\n    rowNode.setDataValue(column, processedValue, SOURCE_PASTE);\n    const { rowIndex, rowPinned } = rowNode;\n    const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n    cellsToFlash[cellId] = true;\n    if (changedPath) {\n      changedPath.addParentNode(rowNode.parent, [column]);\n    }\n  }\n  copyToClipboard(params = {}) {\n    this.copyOrCutToClipboard(params);\n  }\n  cutToClipboard(params = {}, source = \"api\") {\n    if (this.gos.get(\"suppressCutToClipboard\")) {\n      return;\n    }\n    const startEvent = {\n      type: \"cutStart\",\n      source\n    };\n    this.eventService.dispatchEvent(startEvent);\n    this.copyOrCutToClipboard(params, true);\n    const endEvent = {\n      type: \"cutEnd\",\n      source\n    };\n    this.eventService.dispatchEvent(endEvent);\n  }\n  copyOrCutToClipboard(params, cut) {\n    let { includeHeaders, includeGroupHeaders } = params;\n    if (includeHeaders == null) {\n      includeHeaders = this.gos.get(\"copyHeadersToClipboard\");\n    }\n    if (includeGroupHeaders == null) {\n      includeGroupHeaders = this.gos.get(\"copyGroupHeadersToClipboard\");\n    }\n    const copyParams = { includeHeaders, includeGroupHeaders };\n    const shouldCopyRows = !this.gos.get(\"suppressCopyRowsToClipboard\");\n    let cellClearType = null;\n    if (this.rangeService && !this.rangeService.isEmpty() && !this.shouldSkipSingleCellRange(this.rangeService)) {\n      this.copySelectedRangeToClipboard(copyParams);\n      cellClearType = 0 /* CellRange */;\n    } else if (shouldCopyRows && !this.selectionService.isEmpty()) {\n      this.copySelectedRowsToClipboard(copyParams);\n      cellClearType = 1 /* SelectedRows */;\n    } else if (this.focusService.isAnyCellFocused()) {\n      this.copyFocusedCellToClipboard(copyParams);\n      cellClearType = 2 /* FocusedCell */;\n    }\n    if (cut && cellClearType !== null) {\n      this.clearCellsAfterCopy(cellClearType);\n    }\n  }\n  clearCellsAfterCopy(type) {\n    this.eventService.dispatchEvent({ type: \"keyShortcutChangedCellStart\" });\n    if (type === 0 /* CellRange */) {\n      this.rangeService.clearCellRangeCellValues({ cellEventSource: \"clipboardService\" });\n    } else if (type === 1 /* SelectedRows */) {\n      this.clearSelectedRows();\n    } else {\n      const focusedCell = this.focusService.getFocusedCell();\n      if (focusedCell == null) {\n        return;\n      }\n      const rowNode = this.rowPositionUtils.getRowNode(focusedCell);\n      if (rowNode) {\n        this.clearCellValue(rowNode, focusedCell.column);\n      }\n    }\n    this.eventService.dispatchEvent({ type: \"keyShortcutChangedCellEnd\" });\n  }\n  clearSelectedRows() {\n    const selected = this.selectionService.getSelectedNodes();\n    const columns = this.visibleColsService.getAllCols();\n    for (const row of selected) {\n      for (const col of columns) {\n        this.clearCellValue(row, col);\n      }\n    }\n  }\n  clearCellValue(rowNode, column) {\n    if (!column.isCellEditable(rowNode)) {\n      return;\n    }\n    const emptyValue = this.valueService.parseValue(column, rowNode, \"\", rowNode.getValueFromValueService(column)) ?? null;\n    rowNode.setDataValue(column, emptyValue, \"clipboardService\");\n  }\n  shouldSkipSingleCellRange(rangeService) {\n    return this.gos.get(\"suppressCopySingleCellRanges\") && !rangeService.isMoreThanOneCell();\n  }\n  iterateActiveRanges(onlyFirst, rowCallback, columnCallback) {\n    if (!this.rangeService || this.rangeService.isEmpty()) {\n      return;\n    }\n    const cellRanges = this.rangeService.getCellRanges();\n    if (onlyFirst) {\n      this.iterateActiveRange(cellRanges[0], rowCallback, columnCallback, true);\n    } else {\n      cellRanges.forEach(\n        (range, idx) => this.iterateActiveRange(range, rowCallback, columnCallback, idx === cellRanges.length - 1)\n      );\n    }\n  }\n  iterateActiveRange(range, rowCallback, columnCallback, isLastRange) {\n    if (!this.rangeService) {\n      return;\n    }\n    let currentRow = this.rangeService.getRangeStartRow(range);\n    const lastRow = this.rangeService.getRangeEndRow(range);\n    if (columnCallback && range.columns) {\n      columnCallback(range.columns);\n    }\n    let rangeIndex = 0;\n    let isLastRow = false;\n    while (!isLastRow && currentRow != null) {\n      const rowNode = this.rowPositionUtils.getRowNode(currentRow);\n      isLastRow = this.rowPositionUtils.sameRow(currentRow, lastRow);\n      rowCallback(currentRow, rowNode, range.columns, rangeIndex++, isLastRow && isLastRange);\n      currentRow = this.cellNavigationService.getRowBelow(currentRow);\n    }\n  }\n  copySelectedRangeToClipboard(params = {}) {\n    if (!this.rangeService || this.rangeService.isEmpty()) {\n      return;\n    }\n    const allRangesMerge = this.rangeService.areAllRangesAbleToMerge();\n    const { data, cellsToFlash } = allRangesMerge ? this.buildDataFromMergedRanges(this.rangeService, params) : this.buildDataFromRanges(this.rangeService, params);\n    this.copyDataToClipboard(data);\n    this.dispatchFlashCells(cellsToFlash);\n  }\n  buildDataFromMergedRanges(rangeService, params) {\n    const columnsSet = /* @__PURE__ */ new Set();\n    const ranges = rangeService.getCellRanges();\n    const rowPositionsMap = /* @__PURE__ */ new Map();\n    const allRowPositions = [];\n    const allCellsToFlash = {};\n    ranges.forEach((range) => {\n      range.columns.forEach((col) => columnsSet.add(col));\n      const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(rangeService, range);\n      rowPositions.forEach((rowPosition) => {\n        const rowPositionAsString = `${rowPosition.rowIndex}-${rowPosition.rowPinned || \"null\"}`;\n        if (!rowPositionsMap.get(rowPositionAsString)) {\n          rowPositionsMap.set(rowPositionAsString, true);\n          allRowPositions.push(rowPosition);\n        }\n      });\n      Object.assign(allCellsToFlash, cellsToFlash);\n    });\n    const allColumns = this.visibleColsService.getAllCols();\n    const exportedColumns = Array.from(columnsSet);\n    exportedColumns.sort((a, b) => {\n      const posA = allColumns.indexOf(a);\n      const posB = allColumns.indexOf(b);\n      return posA - posB;\n    });\n    const data = this.buildExportParams({\n      columns: exportedColumns,\n      rowPositions: allRowPositions,\n      includeHeaders: params.includeHeaders,\n      includeGroupHeaders: params.includeGroupHeaders\n    });\n    return { data, cellsToFlash: allCellsToFlash };\n  }\n  buildDataFromRanges(rangeService, params) {\n    const ranges = rangeService.getCellRanges();\n    const data = [];\n    const allCellsToFlash = {};\n    ranges.forEach((range) => {\n      const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(rangeService, range);\n      Object.assign(allCellsToFlash, cellsToFlash);\n      data.push(\n        this.buildExportParams({\n          columns: range.columns,\n          rowPositions,\n          includeHeaders: params.includeHeaders,\n          includeGroupHeaders: params.includeGroupHeaders\n        })\n      );\n    });\n    return { data: data.join(\"\\n\"), cellsToFlash: allCellsToFlash };\n  }\n  getRangeRowPositionsAndCellsToFlash(rangeService, range) {\n    const rowPositions = [];\n    const cellsToFlash = {};\n    const startRow = rangeService.getRangeStartRow(range);\n    const lastRow = rangeService.getRangeEndRow(range);\n    let node = startRow;\n    while (node) {\n      rowPositions.push(node);\n      range.columns.forEach((column) => {\n        const { rowIndex, rowPinned } = node;\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n        cellsToFlash[cellId] = true;\n      });\n      if (this.rowPositionUtils.sameRow(node, lastRow)) {\n        break;\n      }\n      node = this.cellNavigationService.getRowBelow(node);\n    }\n    return { rowPositions, cellsToFlash };\n  }\n  getCellsToFlashFromRowNodes(rowNodes) {\n    const allDisplayedColumns = this.visibleColsService.getAllCols();\n    const cellsToFlash = {};\n    for (let i = 0; i < rowNodes.length; i++) {\n      const { rowIndex, rowPinned } = rowNodes[i];\n      if (rowIndex == null) {\n        continue;\n      }\n      for (let j = 0; j < allDisplayedColumns.length; j++) {\n        const column = allDisplayedColumns[j];\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n        cellsToFlash[cellId] = true;\n      }\n    }\n    return cellsToFlash;\n  }\n  copyFocusedCellToClipboard(params = {}) {\n    const focusedCell = this.focusService.getFocusedCell();\n    if (focusedCell == null) {\n      return;\n    }\n    const cellId = this.cellPositionUtils.createId(focusedCell);\n    const currentRow = { rowPinned: focusedCell.rowPinned, rowIndex: focusedCell.rowIndex };\n    const column = focusedCell.column;\n    const data = this.buildExportParams({\n      columns: [column],\n      rowPositions: [currentRow],\n      includeHeaders: params.includeHeaders,\n      includeGroupHeaders: params.includeGroupHeaders\n    });\n    this.copyDataToClipboard(data);\n    this.dispatchFlashCells({ [cellId]: true });\n  }\n  copySelectedRowsToClipboard(params = {}) {\n    const { columnKeys, includeHeaders, includeGroupHeaders } = params;\n    const data = this.buildExportParams({\n      columns: columnKeys,\n      includeHeaders,\n      includeGroupHeaders\n    });\n    this.copyDataToClipboard(data);\n    const rowNodes = this.selectionService.getSelectedNodes() || [];\n    this.dispatchFlashCells(this.getCellsToFlashFromRowNodes(rowNodes));\n  }\n  buildExportParams(params) {\n    const { columns, rowPositions, includeHeaders = false, includeGroupHeaders = false } = params;\n    const exportParams = {\n      columnKeys: columns,\n      rowPositions,\n      skipColumnHeaders: !includeHeaders,\n      skipColumnGroupHeaders: !includeGroupHeaders,\n      suppressQuotes: true,\n      columnSeparator: this.getClipboardDelimiter(),\n      onlySelected: !rowPositions,\n      processCellCallback: this.gos.getCallback(\"processCellForClipboard\"),\n      processRowGroupCallback: (params2) => this.processRowGroupCallback(params2),\n      processHeaderCallback: this.gos.getCallback(\"processHeaderForClipboard\"),\n      processGroupHeaderCallback: this.gos.getCallback(\"processGroupHeaderForClipboard\")\n    };\n    return this.csvCreator.getDataAsCsv(exportParams, true);\n  }\n  processRowGroupCallback(params) {\n    const { node, column } = params;\n    const isTreeData = this.gos.get(\"treeData\");\n    const isSuppressGroupMaintainValueType = this.gos.get(\"suppressGroupMaintainValueType\");\n    const getValueFromNode = () => {\n      if (isTreeData || isSuppressGroupMaintainValueType || !column) {\n        return node.key;\n      }\n      const value2 = node.groupData?.[column.getId()];\n      if (!value2 || !node.rowGroupColumn || node.rowGroupColumn.getColDef().useValueFormatterForExport === false) {\n        return value2;\n      }\n      return this.valueService.formatValue(node.rowGroupColumn, node, value2) ?? value2;\n    };\n    let value = getValueFromNode();\n    if (params.node.footer) {\n      let suffix = \"\";\n      if (value && value.length) {\n        suffix = ` ${value}`;\n      }\n      value = `Total${suffix}`;\n    }\n    const processCellForClipboard = this.gos.getCallback(\"processCellForClipboard\");\n    if (processCellForClipboard) {\n      let column2 = node.rowGroupColumn;\n      if (!column2 && node.footer && node.level === -1) {\n        column2 = this.funcColsService.getRowGroupColumns()[0];\n      }\n      return processCellForClipboard({\n        value,\n        node,\n        column: column2,\n        type: \"clipboard\",\n        formatValue: (valueToFormat) => this.valueService.formatValue(column2, node, valueToFormat) ?? valueToFormat,\n        parseValue: (valueToParse) => this.valueService.parseValue(column2, node, valueToParse, this.valueService.getValue(column2, node))\n      });\n    }\n    return value;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  dispatchFlashCells(cellsToFlash) {\n    window.setTimeout(() => {\n      const event = {\n        type: \"flashCells\",\n        cells: cellsToFlash\n      };\n      this.eventService.dispatchEvent(event);\n    }, 0);\n  }\n  processCell(rowNode, column, value, type, func, canParse, canFormat) {\n    if (func) {\n      const params = {\n        column,\n        node: rowNode,\n        value,\n        type,\n        formatValue: (valueToFormat) => this.valueService.formatValue(column, rowNode ?? null, valueToFormat) ?? valueToFormat,\n        parseValue: (valueToParse) => this.valueService.parseValue(\n          column,\n          rowNode ?? null,\n          valueToParse,\n          this.valueService.getValue(column, rowNode)\n        )\n      };\n      return func(params);\n    }\n    if (canParse && column.getColDef().useValueParserForImport !== false) {\n      return this.valueService.parseValue(\n        column,\n        rowNode ?? null,\n        value,\n        this.valueService.getValue(column, rowNode)\n      );\n    }\n    if (canFormat && column.getColDef().useValueFormatterForExport !== false) {\n      return this.valueService.formatValue(column, rowNode ?? null, value) ?? value;\n    }\n    return value;\n  }\n  copyDataToClipboard(data) {\n    const userProvidedFunc = this.gos.getCallback(\"sendToClipboard\");\n    if (userProvidedFunc) {\n      userProvidedFunc({ data });\n      return;\n    }\n    const allowNavigator = !this.gos.get(\"suppressClipboardApi\");\n    if (allowNavigator && navigator.clipboard) {\n      navigator.clipboard.writeText(data).catch((e) => {\n        _warnOnce(`${e}\n${apiError(\"writeText\")}`);\n        this.copyDataToClipboardLegacy(data);\n      });\n      return;\n    }\n    this.copyDataToClipboardLegacy(data);\n  }\n  copyDataToClipboardLegacy(data) {\n    this.executeOnTempElement((element) => {\n      const eDocument = this.gos.getDocument();\n      const focusedElementBefore = this.gos.getActiveDomElement();\n      element.value = data || \" \";\n      element.select();\n      element.focus({ preventScroll: true });\n      const result = eDocument.execCommand(\"copy\");\n      if (!result) {\n        _warnOnce(\n          \"Browser did not allow document.execCommand('copy'). Ensure api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons.\"\n        );\n      }\n      if (focusedElementBefore != null && focusedElementBefore.focus != null) {\n        focusedElementBefore.focus({ preventScroll: true });\n      }\n    });\n  }\n  executeOnTempElement(callbackNow, callbackAfter) {\n    const eDoc = this.gos.getDocument();\n    const eTempInput = eDoc.createElement(\"textarea\");\n    eTempInput.style.width = \"1px\";\n    eTempInput.style.height = \"1px\";\n    eTempInput.style.top = eDoc.documentElement.scrollTop + \"px\";\n    eTempInput.style.left = eDoc.documentElement.scrollLeft + \"px\";\n    eTempInput.style.position = \"absolute\";\n    eTempInput.style.opacity = \"0\";\n    const guiRoot = this.gridCtrl.getGui();\n    guiRoot.appendChild(eTempInput);\n    try {\n      callbackNow(eTempInput);\n    } catch (err) {\n      _warnOnce(\"Browser does not support document.execCommand('copy') for clipboard operations\");\n    }\n    if (callbackAfter) {\n      window.setTimeout(() => {\n        callbackAfter(eTempInput);\n        guiRoot.removeChild(eTempInput);\n      }, 100);\n    } else {\n      guiRoot.removeChild(eTempInput);\n    }\n  }\n  getRangeSize(rangeService) {\n    const ranges = rangeService.getCellRanges();\n    let startRangeIndex = 0;\n    let endRangeIndex = 0;\n    if (ranges.length > 0) {\n      startRangeIndex = rangeService.getRangeStartRow(ranges[0]).rowIndex;\n      endRangeIndex = rangeService.getRangeEndRow(ranges[0]).rowIndex;\n    }\n    return startRangeIndex - endRangeIndex + 1;\n  }\n};\n\n// enterprise-modules/clipboard/src/version.ts\nvar VERSION = \"32.0.0\";\n\n// enterprise-modules/clipboard/src/clipboardModule.ts\nvar ClipboardCoreModule = {\n  version: VERSION,\n  moduleName: `${ModuleNames.ClipboardModule}-core`,\n  beans: [ClipboardService],\n  dependantModules: [EnterpriseCoreModule, CsvExportModule]\n};\nvar ClipboardApiModule = {\n  version: VERSION,\n  moduleName: `${ModuleNames.ClipboardModule}-api`,\n  apiFunctions: {\n    copyToClipboard,\n    cutToClipboard,\n    copySelectedRowsToClipboard,\n    copySelectedRangeToClipboard,\n    copySelectedRangeDown,\n    pasteFromClipboard\n  },\n  dependantModules: [ClipboardCoreModule]\n};\nvar ClipboardModule = {\n  version: VERSION,\n  moduleName: ModuleNames.ClipboardModule,\n  dependantModules: [ClipboardCoreModule, ClipboardApiModule]\n};\nexport {\n  ClipboardModule\n};\n//# sourceMappingURL=main.esm.mjs.map\n"],
  "mappings": "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",
  "names": ["ModuleNames", "CsvExportModule", "EnterpriseCoreModule", "copyToClipboard", "beans", "params", "cutToClipboard", "copySelectedRowsToClipboard", "copySelectedRangeToClipboard", "copySelectedRangeDown", "pasteFromClipboard", "BeanStub", "ChangedPath", "_exists", "_last", "_removeFromArray", "_warnOnce", "SOURCE_PASTE", "EXPORT_TYPE_DRAG_COPY", "EXPORT_TYPE_CLIPBOARD", "apiError", "method", "ClipboardService", "_ClipboardService", "p", "e", "defaultPrevented", "handlePasteEvent", "currentPastOperationTime", "textArea", "element", "data", "focusedCell", "delimiter", "parsedData", "userFunc", "pasteOperation", "cellsToFlash", "updatedRowNodes", "changedPath", "strData", "isNewline", "char", "insideQuotedField", "row", "column", "position", "previousChar", "currentChar", "nextChar", "ensureDataExists", "pasteOperationFunc", "source", "onlyChangedColumns", "nodesToRefresh", "rowNode", "event", "rangeService", "clipboardData", "abortRepeatingPasteIntoRows", "indexOffset", "dataRowIndex", "rowCallback", "currentRow", "columns", "index", "currentRowData", "processCellFromClipboardFunc", "idx", "newValue", "rowIndex", "rowPinned", "cellId", "currentColumn", "columnsToPasteInto", "value", "firstRowValues", "processCellForClipboardFunc", "firstRowValue", "lastLine", "rowNodes", "clipboardGridData", "type", "rowPointer", "skipGroupRows", "getNextGoodRowNode", "res", "clipboardRowData", "processedValue", "startEvent", "endEvent", "cut", "includeHeaders", "includeGroupHeaders", "copyParams", "shouldCopyRows", "cellClearType", "selected", "col", "emptyValue", "onlyFirst", "columnCallback", "cellRanges", "range", "isLastRange", "lastRow", "rangeIndex", "isLastRow", "allRangesMerge", "columnsSet", "ranges", "rowPositionsMap", "allRowPositions", "allCellsToFlash", "rowPositions", "rowPosition", "rowPositionAsString", "allColumns", "exportedColumns", "a", "b", "posA", "posB", "startRow", "node", "allDisplayedColumns", "i", "j", "columnKeys", "exportParams", "params2", "isTreeData", "isSuppressGroupMaintainValueType", "value2", "suffix", "processCellForClipboard", "column2", "valueToFormat", "valueToParse", "func", "canParse", "canFormat", "userProvidedFunc", "eDocument", "focusedElementBefore", "callbackNow", "callbackAfter", "eDoc", "eTempInput", "guiRoot", "startRangeIndex", "endRangeIndex", "VERSION", "ClipboardCoreModule", "ClipboardApiModule", "ClipboardModule"]
}
