{
  "version": 3,
  "sources": ["../../src/rangeSelectionModule.ts", "../../src/rangeSelection/rangeSelectionApi.ts", "../../src/rangeSelection/rangeService.ts", "../../src/rangeSelection/selectionHandleFactory.ts", "../../src/rangeSelection/agFillHandle.ts", "../../src/rangeSelection/abstractSelectionHandle.ts", "../../src/rangeSelection/utils.ts", "../../src/rangeSelection/agRangeHandle.ts", "../../src/version.ts"],
  "sourcesContent": ["import type { Module } from '@ag-grid-community/core';\nimport { ModuleNames } from '@ag-grid-community/core';\nimport { EnterpriseCoreModule } from '@ag-grid-enterprise/core';\n\nimport { addCellRange, clearRangeSelection, getCellRanges } from './rangeSelection/rangeSelectionApi';\nimport { RangeService } from './rangeSelection/rangeService';\nimport { SelectionHandleFactory } from './rangeSelection/selectionHandleFactory';\nimport { VERSION } from './version';\n\nexport const RangeSelectionCoreModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.RangeSelectionModule}-core`,\n    beans: [RangeService, SelectionHandleFactory],\n    dependantModules: [EnterpriseCoreModule],\n};\n\nexport const RangeSelectionApiModule: Module = {\n    version: VERSION,\n    moduleName: `${ModuleNames.RangeSelectionModule}-api`,\n    apiFunctions: {\n        getCellRanges,\n        addCellRange,\n        clearRangeSelection,\n    },\n    dependantModules: [RangeSelectionCoreModule],\n};\n\nexport const RangeSelectionModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.RangeSelectionModule,\n    dependantModules: [RangeSelectionCoreModule, RangeSelectionApiModule],\n};\n", "import type { BeanCollection, CellRange, CellRangeParams } from '@ag-grid-community/core';\n\nexport function getCellRanges(beans: BeanCollection): CellRange[] | null {\n    return beans.rangeService?.getCellRanges() ?? null;\n}\n\nexport function addCellRange(beans: BeanCollection, params: CellRangeParams): void {\n    beans.rangeService?.addCellRange(params);\n}\n\nexport function clearRangeSelection(beans: BeanCollection): void {\n    beans.rangeService?.removeAllCellRanges();\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    CellNavigationService,\n    CellPosition,\n    CellPositionUtils,\n    CellRange,\n    CellRangeParams,\n    ClearCellRangeParams,\n    ColumnModel,\n    CtrlsService,\n    DragService,\n    IRangeService,\n    IRowModel,\n    NamedBean,\n    PartialCellRange,\n    PinnedRowModel,\n    RangeDeleteEndEvent,\n    RangeDeleteStartEvent,\n    RangeSelectionChangedEvent,\n    RowPinnedType,\n    RowPosition,\n    RowPositionUtils,\n    ValueService,\n    VisibleColsService,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport {\n    AutoScrollService,\n    BeanStub,\n    CellCtrl,\n    _areEqual,\n    _exists,\n    _existsAndNotEmpty,\n    _getCtrlForEventTarget,\n    _includes,\n    _last,\n    _makeNull,\n    _missing,\n    _shallowCompare,\n    _warnOnce,\n} from '@ag-grid-community/core';\n\nexport class RangeService extends BeanStub implements NamedBean, IRangeService {\n    beanName = 'rangeService' as const;\n\n    private rowModel: IRowModel;\n    private dragService: DragService;\n    private columnModel: ColumnModel;\n    private visibleColsService: VisibleColsService;\n    private cellNavigationService: CellNavigationService;\n    private pinnedRowModel: PinnedRowModel;\n    private rowPositionUtils: RowPositionUtils;\n    private cellPositionUtils: CellPositionUtils;\n    private ctrlsService: CtrlsService;\n    private valueService: ValueService;\n\n    public wireBeans(beans: BeanCollection) {\n        this.rowModel = beans.rowModel;\n        this.dragService = beans.dragService;\n        this.columnModel = beans.columnModel;\n        this.visibleColsService = beans.visibleColsService;\n        this.cellNavigationService = beans.cellNavigationService;\n        this.pinnedRowModel = beans.pinnedRowModel;\n        this.rowPositionUtils = beans.rowPositionUtils;\n        this.cellPositionUtils = beans.cellPositionUtils;\n        this.ctrlsService = beans.ctrlsService;\n        this.valueService = beans.valueService;\n    }\n\n    private cellRanges: CellRange[] = [];\n    private lastMouseEvent: MouseEvent | null;\n    private bodyScrollListener = this.onBodyScroll.bind(this);\n\n    private lastCellHovered: CellPosition | undefined;\n    private cellHasChanged: boolean;\n\n    // when a range is created, we mark the 'start cell' for further processing as follows:\n    // 1) if dragging, then the new range is extended from the start position\n    // 2) if user hits 'shift' click on a cell, the previous range is extended from the start position\n    private newestRangeStartCell?: CellPosition;\n\n    private dragging = false;\n    private draggingRange?: CellRange;\n\n    private intersectionRange = false; // When dragging ends, the current range will be used to intersect all other ranges\n\n    public autoScrollService: AutoScrollService;\n\n    public postConstruct(): void {\n        const onColumnsChanged = this.onColumnsChanged.bind(this);\n        const removeAllCellRanges = () => this.removeAllCellRanges();\n        const refreshLastRangeStart = this.refreshLastRangeStart.bind(this);\n        this.addManagedEventListeners({\n            newColumnsLoaded: onColumnsChanged,\n            columnVisible: onColumnsChanged,\n            columnValueChanged: onColumnsChanged,\n            columnPivotModeChanged: removeAllCellRanges,\n            columnRowGroupChanged: removeAllCellRanges,\n            columnPivotChanged: removeAllCellRanges,\n            columnGroupOpened: refreshLastRangeStart,\n            columnMoved: refreshLastRangeStart,\n            columnPinned: refreshLastRangeStart,\n        });\n\n        this.ctrlsService.whenReady((p) => {\n            const gridBodyCtrl = p.gridBodyCtrl;\n            this.autoScrollService = new AutoScrollService({\n                scrollContainer: gridBodyCtrl.getBodyViewportElement()!,\n                scrollAxis: 'xy',\n                getVerticalPosition: () => gridBodyCtrl.getScrollFeature().getVScrollPosition().top,\n                setVerticalPosition: (position) => gridBodyCtrl.getScrollFeature().setVerticalScrollPosition(position),\n                getHorizontalPosition: () => gridBodyCtrl.getScrollFeature().getHScrollPosition().left,\n                setHorizontalPosition: (position) =>\n                    gridBodyCtrl.getScrollFeature().setHorizontalScrollPosition(position),\n                shouldSkipVerticalScroll: () => !this.gos.isDomLayout('normal'),\n                shouldSkipHorizontalScroll: () => !gridBodyCtrl.getScrollFeature().isHorizontalScrollShowing(),\n            });\n        });\n    }\n\n    // Called for both columns loaded & column visibility events\n    public onColumnsChanged(): void {\n        // first move start column in last cell range (i.e. series chart range)\n        this.refreshLastRangeStart();\n\n        const allColumns = this.visibleColsService.getAllCols();\n\n        // check that the columns in each range still exist and are visible\n        this.cellRanges.forEach((cellRange) => {\n            const beforeCols = cellRange.columns;\n\n            // remove hidden or removed cols from cell range\n            cellRange.columns = cellRange.columns.filter(\n                (col: AgColumn) => col.isVisible() && allColumns.indexOf(col) !== -1\n            );\n\n            const colsInRangeChanged = !_areEqual(beforeCols, cellRange.columns);\n\n            if (colsInRangeChanged) {\n                // notify users and other parts of grid (i.e. status panel) that range has changed\n                this.dispatchChangedEvent(false, true, cellRange.id);\n            }\n        });\n        // Remove empty cell ranges\n        const countBefore = this.cellRanges.length;\n        this.cellRanges = this.cellRanges.filter((range) => range.columns.length > 0);\n        if (countBefore > this.cellRanges.length) {\n            this.dispatchChangedEvent(false, true);\n        }\n    }\n\n    public refreshLastRangeStart(): void {\n        const lastRange = _last(this.cellRanges);\n\n        if (!lastRange) {\n            return;\n        }\n\n        this.refreshRangeStart(lastRange);\n    }\n\n    public isContiguousRange(cellRange: CellRange): boolean {\n        const rangeColumns = cellRange.columns as AgColumn[];\n\n        if (!rangeColumns.length) {\n            return false;\n        }\n\n        const allColumns = this.visibleColsService.getAllCols();\n        const allPositions = rangeColumns.map((c) => allColumns.indexOf(c)).sort((a, b) => a - b);\n\n        return _last(allPositions) - allPositions[0] + 1 === rangeColumns.length;\n    }\n\n    public getRangeStartRow(cellRange: PartialCellRange): RowPosition {\n        if (cellRange.startRow && cellRange.endRow) {\n            return this.rowPositionUtils.before(cellRange.startRow, cellRange.endRow)\n                ? cellRange.startRow\n                : cellRange.endRow;\n        }\n\n        const rowPinned = this.pinnedRowModel.getPinnedTopRowCount() > 0 ? 'top' : null;\n\n        return { rowIndex: 0, rowPinned };\n    }\n\n    public getRangeEndRow(cellRange: PartialCellRange): RowPosition {\n        if (cellRange.startRow && cellRange.endRow) {\n            return this.rowPositionUtils.before(cellRange.startRow, cellRange.endRow)\n                ? cellRange.endRow\n                : cellRange.startRow;\n        }\n\n        const pinnedBottomRowCount = this.pinnedRowModel.getPinnedBottomRowCount();\n        const pinnedBottom = pinnedBottomRowCount > 0;\n\n        if (pinnedBottom) {\n            return {\n                rowIndex: pinnedBottomRowCount - 1,\n                rowPinned: 'bottom',\n            };\n        }\n\n        return {\n            rowIndex: this.rowModel.getRowCount() - 1,\n            rowPinned: null,\n        };\n    }\n\n    public setRangeToCell(cell: CellPosition, appendRange = false): void {\n        if (!this.gos.get('enableRangeSelection')) {\n            return;\n        }\n\n        const columns = this.calculateColumnsBetween(cell.column as AgColumn, cell.column as AgColumn);\n\n        if (!columns) {\n            return;\n        }\n\n        const suppressMultiRangeSelections = this.gos.get('suppressMultiRangeSelection');\n\n        // if not appending, then clear previous range selections\n        if (suppressMultiRangeSelections || !appendRange || _missing(this.cellRanges)) {\n            this.removeAllCellRanges(true);\n        }\n\n        const rowForCell: RowPosition = {\n            rowIndex: cell.rowIndex,\n            rowPinned: cell.rowPinned,\n        };\n\n        const cellRange = {\n            startRow: rowForCell,\n            endRow: rowForCell,\n            columns,\n            startColumn: cell.column,\n        };\n\n        this.cellRanges.push(cellRange);\n\n        this.setNewestRangeStartCell(cell);\n        this.onDragStop();\n        this.dispatchChangedEvent(true, true);\n    }\n\n    public extendLatestRangeToCell(cellPosition: CellPosition): void {\n        if (this.isEmpty() || !this.newestRangeStartCell) {\n            return;\n        }\n\n        const cellRange = _last(this.cellRanges);\n\n        this.updateRangeEnd(cellRange, cellPosition);\n    }\n\n    public updateRangeEnd(cellRange: CellRange, cellPosition: CellPosition, silent = false): void {\n        const endColumn = cellPosition.column as AgColumn;\n        const colsToAdd = this.calculateColumnsBetween(cellRange.startColumn as AgColumn, endColumn);\n\n        if (!colsToAdd || this.isLastCellOfRange(cellRange, cellPosition)) {\n            return;\n        }\n\n        cellRange.columns = colsToAdd;\n        cellRange.endRow = { rowIndex: cellPosition.rowIndex, rowPinned: cellPosition.rowPinned };\n\n        if (!silent) {\n            this.dispatchChangedEvent(true, true, cellRange.id);\n        }\n    }\n\n    private refreshRangeStart(cellRange: CellRange) {\n        const { startColumn, columns } = cellRange;\n\n        const moveColInCellRange = (colToMove: AgColumn, moveToFront: boolean) => {\n            const otherCols = cellRange.columns.filter((col) => col !== colToMove);\n\n            if (colToMove) {\n                cellRange.startColumn = colToMove;\n                cellRange.columns = moveToFront ? [colToMove, ...otherCols] : [...otherCols, colToMove];\n            } else {\n                cellRange.columns = otherCols;\n            }\n        };\n\n        const { left, right } = this.getRangeEdgeColumns(cellRange);\n        const shouldMoveLeftCol = startColumn === columns[0] && startColumn !== left;\n\n        if (shouldMoveLeftCol) {\n            moveColInCellRange(left, true);\n            return;\n        }\n\n        const shouldMoveRightCol = startColumn === _last(columns) && startColumn === right;\n\n        if (shouldMoveRightCol) {\n            moveColInCellRange(right, false);\n            return;\n        }\n    }\n\n    public getRangeEdgeColumns(cellRange: CellRange): { left: AgColumn; right: AgColumn } {\n        const allColumns = this.visibleColsService.getAllCols();\n        const allIndices = cellRange.columns\n            .map((c: AgColumn) => allColumns.indexOf(c))\n            .filter((i) => i > -1)\n            .sort((a, b) => a - b);\n\n        return {\n            left: allColumns[allIndices[0]],\n            right: allColumns[_last(allIndices)!],\n        };\n    }\n\n    // returns true if successful, false if not successful\n    public extendLatestRangeInDirection(event: KeyboardEvent): CellPosition | undefined {\n        if (this.isEmpty() || !this.newestRangeStartCell) {\n            return;\n        }\n\n        const key = event.key;\n        const ctrlKey = event.ctrlKey || event.metaKey;\n\n        const lastRange = _last(this.cellRanges)!;\n        const startCell = this.newestRangeStartCell;\n        const firstCol = lastRange.columns[0];\n        const lastCol = _last(lastRange.columns)!;\n\n        // find the cell that is at the furthest away corner from the starting cell\n        const endCellIndex = lastRange.endRow!.rowIndex;\n        const endCellFloating = lastRange.endRow!.rowPinned;\n        const endCellColumn = startCell.column === firstCol ? lastCol : firstCol;\n\n        const endCell: CellPosition = { column: endCellColumn, rowIndex: endCellIndex, rowPinned: endCellFloating };\n        const newEndCell = this.cellNavigationService.getNextCellToFocus(key, endCell, ctrlKey);\n\n        // if user is at end of grid, so no cell to extend to, we return false\n        if (!newEndCell) {\n            return;\n        }\n\n        this.setCellRange({\n            rowStartIndex: startCell.rowIndex,\n            rowStartPinned: startCell.rowPinned,\n            rowEndIndex: newEndCell.rowIndex,\n            rowEndPinned: newEndCell.rowPinned,\n            columnStart: startCell.column,\n            columnEnd: newEndCell.column,\n        });\n\n        return newEndCell;\n    }\n\n    public setCellRange(params: CellRangeParams): void {\n        if (!this.gos.get('enableRangeSelection')) {\n            return;\n        }\n\n        this.removeAllCellRanges(true);\n        this.addCellRange(params);\n    }\n\n    public setCellRanges(cellRanges: CellRange[]): void {\n        if (_shallowCompare(this.cellRanges, cellRanges)) {\n            return;\n        }\n\n        this.removeAllCellRanges(true);\n\n        cellRanges.forEach((newRange) => {\n            if (newRange.columns && newRange.startRow) {\n                this.setNewestRangeStartCell({\n                    rowIndex: newRange.startRow.rowIndex,\n                    rowPinned: newRange.startRow.rowPinned,\n                    column: newRange.columns[0],\n                });\n            }\n\n            this.cellRanges.push(newRange);\n        });\n\n        this.dispatchChangedEvent(false, true);\n    }\n\n    private setNewestRangeStartCell(position: CellPosition) {\n        this.newestRangeStartCell = position;\n    }\n\n    public clearCellRangeCellValues(params: ClearCellRangeParams): void {\n        let { cellRanges } = params;\n        const { cellEventSource = 'rangeService', dispatchWrapperEvents, wrapperEventSource = 'deleteKey' } = params;\n\n        if (dispatchWrapperEvents) {\n            const startEvent: WithoutGridCommon<RangeDeleteStartEvent> = {\n                type: 'rangeDeleteStart',\n                source: wrapperEventSource,\n            };\n            this.eventService.dispatchEvent(startEvent);\n        }\n\n        if (!cellRanges) {\n            cellRanges = this.cellRanges;\n        }\n\n        cellRanges.forEach((cellRange) => {\n            this.forEachRowInRange(cellRange, (rowPosition) => {\n                const rowNode = this.rowPositionUtils.getRowNode(rowPosition);\n                if (!rowNode) {\n                    return;\n                }\n                for (let i = 0; i < cellRange.columns.length; i++) {\n                    const column = this.columnModel.getCol(cellRange.columns[i]);\n                    if (!column || !column.isCellEditable(rowNode)) {\n                        continue;\n                    }\n                    const emptyValue =\n                        this.valueService.parseValue(column, rowNode, '', rowNode.getValueFromValueService(column)) ??\n                        null;\n                    rowNode.setDataValue(column, emptyValue, cellEventSource);\n                }\n            });\n        });\n\n        if (dispatchWrapperEvents) {\n            const endEvent: WithoutGridCommon<RangeDeleteEndEvent> = {\n                type: 'rangeDeleteEnd',\n                source: wrapperEventSource,\n            };\n            this.eventService.dispatchEvent(endEvent);\n        }\n    }\n\n    public createCellRangeFromCellRangeParams(params: CellRangeParams): CellRange | undefined {\n        return this.createPartialCellRangeFromRangeParams(params, false) as CellRange | undefined;\n    }\n\n    // Range service can't normally support a range without columns, but charts can\n    public createPartialCellRangeFromRangeParams(\n        params: CellRangeParams,\n        allowEmptyColumns: boolean\n    ): PartialCellRange | undefined {\n        let columns: AgColumn[] | undefined;\n        let startsOnTheRight: boolean = false;\n\n        if (params.columns) {\n            columns = params.columns.map((c) => this.columnModel.getCol(c)!).filter((c) => c);\n        } else {\n            const columnStart = this.columnModel.getCol(params.columnStart);\n            const columnEnd = this.columnModel.getCol(params.columnEnd);\n\n            if (!columnStart || !columnEnd) {\n                return;\n            }\n\n            columns = this.calculateColumnsBetween(columnStart, columnEnd);\n\n            if (columns && columns.length) {\n                startsOnTheRight = columns[0] !== columnStart;\n            }\n        }\n\n        if (!columns || (!allowEmptyColumns && columns.length === 0)) {\n            return;\n        }\n\n        const startRow =\n            params.rowStartIndex != null\n                ? {\n                      rowIndex: params.rowStartIndex,\n                      rowPinned: params.rowStartPinned || null,\n                  }\n                : undefined;\n\n        const endRow =\n            params.rowEndIndex != null\n                ? {\n                      rowIndex: params.rowEndIndex,\n                      rowPinned: params.rowEndPinned || null,\n                  }\n                : undefined;\n\n        return {\n            startRow,\n            endRow,\n            columns,\n            startColumn: startsOnTheRight ? _last(columns) : columns[0],\n        };\n    }\n\n    public addCellRange(params: CellRangeParams): void {\n        if (!this.gos.get('enableRangeSelection')) {\n            return;\n        }\n\n        const newRange = this.createCellRangeFromCellRangeParams(params);\n\n        if (newRange) {\n            if (newRange.startRow) {\n                this.setNewestRangeStartCell({\n                    rowIndex: newRange.startRow.rowIndex,\n                    rowPinned: newRange.startRow.rowPinned,\n                    column: newRange.startColumn,\n                });\n            }\n\n            this.cellRanges.push(newRange);\n            this.dispatchChangedEvent(false, true, newRange.id);\n        }\n    }\n\n    public getCellRanges(): CellRange[] {\n        return this.cellRanges;\n    }\n\n    public isEmpty(): boolean {\n        return this.cellRanges.length === 0;\n    }\n\n    public isMoreThanOneCell(): boolean {\n        const len = this.cellRanges.length;\n\n        if (len === 0) {\n            return false;\n        }\n        if (len > 1) {\n            return true; // Assumes a cell range must contain at least one cell\n        }\n\n        // only one range, return true if range has more than one\n        const range = this.cellRanges[0];\n        const startRow = this.getRangeStartRow(range);\n        const endRow = this.getRangeEndRow(range);\n\n        return (\n            startRow.rowPinned !== endRow.rowPinned ||\n            startRow.rowIndex !== endRow.rowIndex ||\n            range.columns.length !== 1\n        );\n    }\n\n    public areAllRangesAbleToMerge(): boolean {\n        const rowToColumnMap: Map<string, string[]> = new Map();\n        const len = this.cellRanges.length;\n\n        if (len <= 1) return true;\n\n        this.cellRanges.forEach((range) => {\n            this.forEachRowInRange(range, (row) => {\n                const rowName = `${row.rowPinned || 'normal'}_${row.rowIndex}`;\n                const columns = rowToColumnMap.get(rowName);\n                const currentRangeColIds = range.columns.map((col) => col.getId());\n                if (columns) {\n                    const filteredColumns = currentRangeColIds.filter((col) => columns.indexOf(col) === -1);\n                    columns.push(...filteredColumns);\n                } else {\n                    rowToColumnMap.set(rowName, currentRangeColIds);\n                }\n            });\n        });\n\n        let columnsString: string | undefined;\n\n        for (const val of rowToColumnMap.values()) {\n            const currentValString = val.sort().join();\n            if (columnsString === undefined) {\n                columnsString = currentValString;\n                continue;\n            }\n            if (columnsString !== currentValString) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private forEachRowInRange(cellRange: CellRange, callback: (row: RowPosition) => void) {\n        const topRow = this.getRangeStartRow(cellRange);\n        const bottomRow = this.getRangeEndRow(cellRange);\n        let currentRow: RowPosition | null = topRow;\n\n        while (currentRow) {\n            callback(currentRow);\n\n            if (this.rowPositionUtils.sameRow(currentRow, bottomRow)) {\n                break;\n            }\n            currentRow = this.cellNavigationService.getRowBelow(currentRow);\n        }\n    }\n\n    public removeAllCellRanges(silent?: boolean): void {\n        if (this.isEmpty()) {\n            return;\n        }\n\n        this.onDragStop();\n        this.cellRanges.length = 0;\n\n        if (!silent) {\n            this.dispatchChangedEvent(false, true);\n        }\n    }\n\n    // as the user is dragging outside of the panel, the div starts to scroll, which in turn\n    // means we are selection more (or less) cells, but the mouse isn't moving, so we recalculate\n    // the selection my mimicking a new mouse event\n    private onBodyScroll(): void {\n        if (this.dragging && this.lastMouseEvent) {\n            this.onDragging(this.lastMouseEvent);\n        }\n    }\n\n    public isCellInAnyRange(cell: CellPosition): boolean {\n        return this.getCellRangeCount(cell) > 0;\n    }\n\n    public isCellInSpecificRange(cell: CellPosition, range: CellRange): boolean {\n        const columnInRange = range.columns !== null && _includes(range.columns, cell.column);\n        const rowInRange = this.isRowInRange(cell.rowIndex, cell.rowPinned, range);\n\n        return columnInRange && rowInRange;\n    }\n\n    private isLastCellOfRange(cellRange: CellRange, cell: CellPosition): boolean {\n        const { startRow, endRow } = cellRange;\n        const lastRow = this.rowPositionUtils.before(startRow!, endRow!) ? endRow : startRow;\n        const isLastRow = cell.rowIndex === lastRow!.rowIndex && cell.rowPinned === lastRow!.rowPinned;\n        const rangeFirstIndexColumn = cellRange.columns[0];\n        const rangeLastIndexColumn = _last(cellRange.columns);\n        const lastRangeColumn =\n            cellRange.startColumn === rangeFirstIndexColumn ? rangeLastIndexColumn : rangeFirstIndexColumn;\n        const isLastColumn = cell.column === lastRangeColumn;\n\n        return isLastColumn && isLastRow;\n    }\n\n    public isBottomRightCell(cellRange: CellRange, cell: CellPosition): boolean {\n        const allColumns = this.visibleColsService.getAllCols();\n        const allPositions = cellRange.columns.map((c: AgColumn) => allColumns.indexOf(c)).sort((a, b) => a - b);\n        const { startRow, endRow } = cellRange;\n        const lastRow = this.rowPositionUtils.before(startRow!, endRow!) ? endRow : startRow;\n\n        const isRightColumn = allColumns.indexOf(cell.column as AgColumn) === _last(allPositions);\n        const isLastRow =\n            cell.rowIndex === lastRow!.rowIndex && _makeNull(cell.rowPinned) === _makeNull(lastRow!.rowPinned);\n\n        return isRightColumn && isLastRow;\n    }\n\n    // returns the number of ranges this cell is in\n    public getCellRangeCount(cell: CellPosition): number {\n        if (this.isEmpty()) {\n            return 0;\n        }\n\n        return this.cellRanges.filter((cellRange) => this.isCellInSpecificRange(cell, cellRange)).length;\n    }\n\n    private isRowInRange(rowIndex: number, rowPinned: RowPinnedType, cellRange: CellRange): boolean {\n        const firstRow = this.getRangeStartRow(cellRange);\n        const lastRow = this.getRangeEndRow(cellRange);\n        const thisRow: RowPosition = { rowIndex, rowPinned: rowPinned || null };\n\n        // compare rowPinned with == instead of === because it can be `null` or `undefined`\n        const equalsFirstRow = thisRow.rowIndex === firstRow.rowIndex && thisRow.rowPinned == firstRow.rowPinned;\n        const equalsLastRow = thisRow.rowIndex === lastRow.rowIndex && thisRow.rowPinned == lastRow.rowPinned;\n\n        if (equalsFirstRow || equalsLastRow) {\n            return true;\n        }\n\n        const afterFirstRow = !this.rowPositionUtils.before(thisRow, firstRow);\n        const beforeLastRow = this.rowPositionUtils.before(thisRow, lastRow);\n\n        return afterFirstRow && beforeLastRow;\n    }\n\n    public getDraggingRange(): CellRange | undefined {\n        return this.draggingRange;\n    }\n\n    public onDragStart(mouseEvent: MouseEvent): void {\n        if (!this.gos.get('enableRangeSelection')) {\n            return;\n        }\n\n        const { ctrlKey, metaKey, shiftKey } = mouseEvent;\n\n        // ctrlKey for windows, metaKey for Apple\n        const isMultiKey = ctrlKey || metaKey;\n        const allowMulti = !this.gos.get('suppressMultiRangeSelection');\n        const isMultiSelect = allowMulti ? isMultiKey : false;\n        const extendRange = shiftKey && _existsAndNotEmpty(this.cellRanges);\n\n        if (!isMultiSelect && (!extendRange || _exists(_last(this.cellRanges)!.type))) {\n            this.removeAllCellRanges(true);\n        }\n\n        // The browser changes the Event target of cached events when working with the ShadowDOM\n        // so we need to retrieve the initial DragStartTarget.\n        const startTarget = this.dragService.getStartTarget();\n\n        if (startTarget) {\n            this.updateValuesOnMove(startTarget);\n        }\n\n        if (!this.lastCellHovered) {\n            return;\n        }\n\n        this.dragging = true;\n        this.lastMouseEvent = mouseEvent;\n        this.intersectionRange = isMultiSelect && this.getCellRangeCount(this.lastCellHovered) > 1;\n\n        if (!extendRange) {\n            this.setNewestRangeStartCell(this.lastCellHovered);\n        }\n\n        // if we didn't clear the ranges, then dragging means the user clicked, and when the\n        // user clicks it means a range of one cell was created. we need to extend this range\n        // rather than creating another range. otherwise we end up with two distinct ranges\n        // from a drag operation (one from click, and one from drag).\n        if (this.cellRanges.length > 0) {\n            this.draggingRange = _last(this.cellRanges);\n        } else {\n            const mouseRowPosition: RowPosition = {\n                rowIndex: this.lastCellHovered.rowIndex,\n                rowPinned: this.lastCellHovered.rowPinned,\n            };\n\n            this.draggingRange = {\n                startRow: mouseRowPosition,\n                endRow: mouseRowPosition,\n                columns: [this.lastCellHovered.column],\n                startColumn: this.newestRangeStartCell!.column,\n            };\n\n            this.cellRanges.push(this.draggingRange);\n        }\n\n        this.ctrlsService.getGridBodyCtrl().addScrollEventListener(this.bodyScrollListener);\n\n        this.dispatchChangedEvent(true, false, this.draggingRange.id);\n    }\n\n    public intersectLastRange(fromMouseClick?: boolean) {\n        // when ranges are created due to a mouse click without drag (happens in cellMouseListener)\n        // this method will be called with `fromMouseClick=true`.\n        if (fromMouseClick && this.dragging) {\n            return;\n        }\n        if (this.gos.get('suppressMultiRangeSelection')) {\n            return;\n        }\n        if (this.isEmpty()) {\n            return;\n        }\n        const rowPosUtils = this.rowPositionUtils;\n        const lastRange = _last(this.cellRanges);\n\n        const intersectionStartRow = this.getRangeStartRow(lastRange);\n        const intersectionEndRow = this.getRangeEndRow(lastRange);\n\n        const newRanges: CellRange[] = [];\n\n        this.cellRanges.slice(0, -1).forEach((range) => {\n            const startRow = this.getRangeStartRow(range);\n            const endRow = this.getRangeEndRow(range);\n            const cols = range.columns;\n            const intersectCols = cols.filter((col) => lastRange.columns.indexOf(col) === -1);\n            if (intersectCols.length === cols.length) {\n                // No overlapping columns, retain previous range\n                newRanges.push(range);\n                return;\n            }\n            if (rowPosUtils.before(intersectionEndRow, startRow) || rowPosUtils.before(endRow, intersectionStartRow)) {\n                // No overlapping rows, retain previous range\n                newRanges.push(range);\n                return;\n            }\n            const rangeCountBefore = newRanges.length;\n            // Top\n            if (rowPosUtils.before(startRow, intersectionStartRow)) {\n                const top: CellRange = {\n                    columns: [...cols],\n                    startColumn: lastRange.startColumn,\n                    startRow: { ...startRow },\n                    endRow: this.cellNavigationService.getRowAbove(intersectionStartRow)!,\n                };\n                newRanges.push(top);\n            }\n            // Left & Right (not contiguous with columns)\n            if (intersectCols.length > 0) {\n                const middle: CellRange = {\n                    columns: intersectCols,\n                    startColumn: _includes(intersectCols, lastRange.startColumn)\n                        ? lastRange.startColumn\n                        : intersectCols[0],\n                    startRow: this.rowMax([{ ...intersectionStartRow }, { ...startRow }]),\n                    endRow: this.rowMin([{ ...intersectionEndRow }, { ...endRow }]),\n                };\n                newRanges.push(middle);\n            }\n            // Bottom\n            if (rowPosUtils.before(intersectionEndRow, endRow)) {\n                newRanges.push({\n                    columns: [...cols],\n                    startColumn: lastRange.startColumn,\n                    startRow: this.cellNavigationService.getRowBelow(intersectionEndRow)!,\n                    endRow: { ...endRow },\n                });\n            }\n            if (newRanges.length - rangeCountBefore === 1) {\n                // Only one range result from the intersection.\n                // Copy the source range's id, since essentially we just reduced it's size\n                newRanges[newRanges.length - 1].id = range.id;\n            }\n        });\n        this.cellRanges = newRanges;\n\n        // when this is called because of a clickEvent and the ranges were changed\n        // we need to force a dragEnd event to update the UI.\n        if (fromMouseClick) {\n            this.dispatchChangedEvent(false, true);\n        }\n    }\n\n    private rowMax(rows: RowPosition[]): RowPosition | undefined {\n        let max: RowPosition | undefined;\n        rows.forEach((row) => {\n            if (max === undefined || this.rowPositionUtils.before(max, row)) {\n                max = row;\n            }\n        });\n        return max;\n    }\n\n    private rowMin(rows: RowPosition[]): RowPosition | undefined {\n        let min: RowPosition | undefined;\n        rows.forEach((row) => {\n            if (min === undefined || this.rowPositionUtils.before(row, min)) {\n                min = row;\n            }\n        });\n        return min;\n    }\n\n    private updateValuesOnMove(eventTarget: EventTarget | null) {\n        const cellCtrl = _getCtrlForEventTarget<CellCtrl>(this.gos, eventTarget, CellCtrl.DOM_DATA_KEY_CELL_CTRL);\n        const cell = cellCtrl?.getCellPosition();\n\n        this.cellHasChanged = false;\n\n        if (!cell || (this.lastCellHovered && this.cellPositionUtils.equals(cell, this.lastCellHovered))) {\n            return;\n        }\n\n        if (this.lastCellHovered) {\n            this.cellHasChanged = true;\n        }\n\n        this.lastCellHovered = cell;\n    }\n\n    public onDragging(mouseEvent: MouseEvent | null): void {\n        if (!this.dragging || !mouseEvent) {\n            return;\n        }\n\n        this.updateValuesOnMove(mouseEvent.target);\n\n        this.lastMouseEvent = mouseEvent;\n\n        const cellPosition = this.lastCellHovered!;\n        const isMouseAndStartInPinned = (position: string) =>\n            cellPosition && cellPosition.rowPinned === position && this.newestRangeStartCell!.rowPinned === position;\n\n        const skipVerticalScroll = isMouseAndStartInPinned('top') || isMouseAndStartInPinned('bottom');\n\n        this.autoScrollService.check(mouseEvent, skipVerticalScroll!);\n\n        if (!this.cellHasChanged) {\n            return;\n        }\n\n        const columns = this.calculateColumnsBetween(\n            this.newestRangeStartCell!.column as AgColumn,\n            cellPosition.column as AgColumn\n        );\n\n        if (!columns) {\n            return;\n        }\n\n        this.draggingRange!.endRow = {\n            rowIndex: cellPosition.rowIndex,\n            rowPinned: cellPosition.rowPinned,\n        };\n\n        this.draggingRange!.columns = columns;\n\n        this.dispatchChangedEvent(false, false, this.draggingRange!.id);\n    }\n\n    public onDragStop(): void {\n        if (!this.dragging) {\n            return;\n        }\n\n        const { id } = this.draggingRange!;\n\n        this.autoScrollService.ensureCleared();\n\n        this.ctrlsService.getGridBodyCtrl().removeScrollEventListener(this.bodyScrollListener);\n        this.lastMouseEvent = null;\n        this.dragging = false;\n        this.draggingRange = undefined;\n        this.lastCellHovered = undefined;\n\n        if (this.intersectionRange) {\n            this.intersectionRange = false;\n            this.intersectLastRange();\n        }\n\n        this.dispatchChangedEvent(false, true, id);\n    }\n\n    private dispatchChangedEvent(started: boolean, finished: boolean, id?: string): void {\n        const event: WithoutGridCommon<RangeSelectionChangedEvent> = {\n            type: 'rangeSelectionChanged',\n            started,\n            finished,\n            id,\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private calculateColumnsBetween(columnFrom: AgColumn, columnTo: AgColumn): AgColumn[] | undefined {\n        const allColumns = this.visibleColsService.getAllCols();\n        const isSameColumn = columnFrom === columnTo;\n        const fromIndex = allColumns.indexOf(columnFrom as AgColumn);\n\n        const logMissing = (column: AgColumn) => _warnOnce(`column ${column.getId()} is not visible`);\n        if (fromIndex < 0) {\n            logMissing(columnFrom);\n            return;\n        }\n\n        const toIndex = isSameColumn ? fromIndex : allColumns.indexOf(columnTo as AgColumn);\n\n        if (toIndex < 0) {\n            logMissing(columnTo);\n            return;\n        }\n\n        if (isSameColumn) {\n            return [columnFrom];\n        }\n\n        const firstIndex = Math.min(fromIndex, toIndex);\n        const lastIndex = firstIndex === fromIndex ? toIndex : fromIndex;\n        const columns: AgColumn[] = [];\n\n        for (let i = firstIndex; i <= lastIndex; i++) {\n            columns.push(allColumns[i]);\n        }\n\n        return columns;\n    }\n}\n", "import type { ISelectionHandle, ISelectionHandleFactory, NamedBean } from '@ag-grid-community/core';\nimport { BeanStub, SelectionHandleType } from '@ag-grid-community/core';\n\nimport { AgFillHandle } from './agFillHandle';\nimport { AgRangeHandle } from './agRangeHandle';\n\nexport class SelectionHandleFactory extends BeanStub implements NamedBean, ISelectionHandleFactory {\n    beanName = 'selectionHandleFactory' as const;\n\n    public createSelectionHandle(type: SelectionHandleType): ISelectionHandle {\n        return this.createBean(type === SelectionHandleType.RANGE ? new AgRangeHandle() : new AgFillHandle());\n    }\n}\n", "import type {\n    AgColumn,\n    BeanCollection,\n    CellCtrl,\n    CellNavigationService,\n    CellPosition,\n    CellRange,\n    FillEndEvent,\n    FillOperationParams,\n    FillStartEvent,\n    NavigationService,\n    RowNode,\n    RowPosition,\n    ValueService,\n    VisibleColsService,\n    WithoutGridCommon,\n} from '@ag-grid-community/core';\nimport { SelectionHandleType, _last, _toStringOrNull, _warnOnce } from '@ag-grid-community/core';\n\nimport { AbstractSelectionHandle } from './abstractSelectionHandle';\nimport { findLineByLeastSquares } from './utils';\n\ninterface FillValues {\n    position: CellPosition;\n    value: any;\n}\n\ninterface ValueContext {\n    value: any;\n    column: AgColumn;\n    rowNode: RowNode;\n}\n\ntype Direction = 'x' | 'y';\n\nexport class AgFillHandle extends AbstractSelectionHandle {\n    private valueService: ValueService;\n    private navigationService: NavigationService;\n    private cellNavigationService: CellNavigationService;\n    private visibleColsService: VisibleColsService;\n\n    public override wireBeans(beans: BeanCollection) {\n        super.wireBeans(beans);\n        this.valueService = beans.valueService;\n        this.navigationService = beans.navigationService;\n        this.cellNavigationService = beans.cellNavigationService;\n        this.visibleColsService = beans.visibleColsService;\n    }\n\n    private initialPosition: CellPosition | undefined;\n    private initialXY: { x: number; y: number } | null;\n    private lastCellMarked: CellPosition | undefined;\n    private markedCells: CellCtrl[] = [];\n    private cellValues: FillValues[][] = [];\n\n    private dragAxis: Direction;\n    private isUp: boolean = false;\n    private isLeft: boolean = false;\n    private isReduce: boolean = false;\n\n    protected type = SelectionHandleType.FILL;\n\n    constructor() {\n        super(/* html */ `<div class=\"ag-fill-handle\"></div>`);\n    }\n\n    protected override updateValuesOnMove(e: MouseEvent) {\n        super.updateValuesOnMove(e);\n\n        if (!this.initialXY) {\n            this.initialXY = this.mouseEventService.getNormalisedPosition(e);\n        }\n\n        const { x, y } = this.initialXY;\n        const { x: newX, y: newY } = this.mouseEventService.getNormalisedPosition(e);\n        const diffX = Math.abs(x - newX);\n        const diffY = Math.abs(y - newY);\n        const allowedDirection = this.getFillHandleDirection();\n        let direction: Direction;\n\n        if (allowedDirection === 'xy') {\n            direction = diffX > diffY ? 'x' : 'y';\n        } else {\n            direction = allowedDirection;\n        }\n\n        if (direction !== this.dragAxis) {\n            this.dragAxis = direction;\n            this.changedCalculatedValues = true;\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    protected onDrag(_e: MouseEvent) {\n        if (!this.initialPosition) {\n            const cellCtrl = this.getCellCtrl();\n            if (!cellCtrl) {\n                return;\n            }\n\n            this.initialPosition = cellCtrl.getCellPosition();\n        }\n\n        const lastCellHovered = this.getLastCellHovered();\n\n        if (lastCellHovered) {\n            this.markPathFrom(this.initialPosition, lastCellHovered);\n        }\n    }\n\n    protected onDragEnd(e: MouseEvent) {\n        this.initialXY = null;\n        if (!this.markedCells.length) {\n            return;\n        }\n\n        const isX = this.dragAxis === 'x';\n        const initialRange = this.getCellRange();\n        const colLen = initialRange.columns.length;\n        const rangeStartRow = this.getRangeStartRow();\n        const rangeEndRow = this.getRangeEndRow();\n\n        let finalRange: CellRange | undefined;\n\n        if (!this.isUp && !this.isLeft) {\n            finalRange = this.rangeService.createCellRangeFromCellRangeParams({\n                rowStartIndex: rangeStartRow.rowIndex,\n                rowStartPinned: rangeStartRow.rowPinned,\n                columnStart: initialRange.columns[0],\n                rowEndIndex: isX ? rangeEndRow.rowIndex : this.lastCellMarked!.rowIndex,\n                rowEndPinned: isX ? rangeEndRow.rowPinned : this.lastCellMarked!.rowPinned,\n                columnEnd: isX ? this.lastCellMarked!.column : initialRange.columns[colLen - 1],\n            });\n        } else {\n            const startRow = isX ? rangeStartRow : this.lastCellMarked;\n\n            finalRange = this.rangeService.createCellRangeFromCellRangeParams({\n                rowStartIndex: startRow!.rowIndex,\n                rowStartPinned: startRow!.rowPinned,\n                columnStart: isX ? this.lastCellMarked!.column : initialRange.columns[0],\n                rowEndIndex: rangeEndRow.rowIndex,\n                rowEndPinned: rangeEndRow.rowPinned,\n                columnEnd: initialRange.columns[colLen - 1],\n            });\n        }\n\n        if (finalRange) {\n            // raising fill events for undo / redo\n            this.raiseFillStartEvent();\n\n            this.handleValueChanged(initialRange, finalRange, e);\n            this.rangeService.setCellRanges([finalRange]);\n\n            this.raiseFillEndEvent(initialRange, finalRange);\n        }\n    }\n\n    private getFillHandleDirection(): 'x' | 'y' | 'xy' {\n        const direction = this.gos.get('fillHandleDirection');\n\n        if (!direction) {\n            return 'xy';\n        }\n\n        if (direction !== 'x' && direction !== 'y' && direction !== 'xy') {\n            _warnOnce(`valid values for fillHandleDirection are 'x', 'y' and 'xy'. Default to 'xy'.`);\n            return 'xy';\n        }\n\n        return direction;\n    }\n\n    private raiseFillStartEvent() {\n        const fillStartEvent: WithoutGridCommon<FillStartEvent> = {\n            type: 'fillStart',\n        };\n        this.eventService.dispatchEvent(fillStartEvent);\n    }\n\n    private raiseFillEndEvent(initialRange: CellRange, finalRange: CellRange) {\n        const fillEndEvent: WithoutGridCommon<FillEndEvent> = {\n            type: 'fillEnd',\n            initialRange: initialRange,\n            finalRange: finalRange,\n        };\n        this.eventService.dispatchEvent(fillEndEvent);\n    }\n\n    private handleValueChanged(initialRange: CellRange, finalRange: CellRange, e: MouseEvent) {\n        const initialRangeEndRow = this.rangeService.getRangeEndRow(initialRange);\n        const initialRangeStartRow = this.rangeService.getRangeStartRow(initialRange);\n        const finalRangeEndRow = this.rangeService.getRangeEndRow(finalRange);\n        const finalRangeStartRow = this.rangeService.getRangeStartRow(finalRange);\n        const isVertical = this.dragAxis === 'y';\n\n        // if the range is being reduced in size, all we need to do is\n        // clear the cells that are no longer part of the range\n        if (this.isReduce && !this.gos.get('suppressClearOnFillReduction')) {\n            const columns = (\n                isVertical\n                    ? initialRange.columns\n                    : initialRange.columns.filter((col) => finalRange.columns.indexOf(col) < 0)\n            ) as AgColumn[];\n\n            const startRow = isVertical ? this.cellNavigationService.getRowBelow(finalRangeEndRow) : finalRangeStartRow;\n\n            if (startRow) {\n                this.clearCellsInRange(startRow, initialRangeEndRow, columns);\n            }\n            return;\n        }\n\n        const values: ValueContext[] = [];\n        const initialValues: any[] = [];\n        const initialNonAggregatedValues: any[] = [];\n        const initialFormattedValues: any[] = [];\n\n        let withinInitialRange = true;\n        let idx = 0;\n\n        const resetValues = () => {\n            values.length = 0;\n            initialValues.length = 0;\n            initialNonAggregatedValues.length = 0;\n            initialFormattedValues.length = 0;\n            idx = 0;\n        };\n\n        const iterateAcrossCells = (column?: AgColumn, columns?: AgColumn[]) => {\n            let currentRow: RowPosition | undefined | null = this.isUp ? initialRangeEndRow : initialRangeStartRow;\n            let finished = false;\n\n            if (isVertical) {\n                withinInitialRange = true;\n                resetValues();\n            }\n\n            while (!finished && currentRow) {\n                const rowNode = this.rowPositionUtils.getRowNode(currentRow);\n                if (!rowNode) {\n                    break;\n                }\n\n                if (isVertical && column) {\n                    fillValues(values, column, rowNode, () => {\n                        return !this.rowPositionUtils.sameRow(\n                            currentRow!,\n                            this.isUp ? initialRangeStartRow : initialRangeEndRow\n                        );\n                    });\n                } else if (columns) {\n                    withinInitialRange = true;\n                    resetValues();\n                    columns.forEach((col) =>\n                        fillValues(\n                            values,\n                            col,\n                            rowNode,\n                            () => col !== (this.isLeft ? initialRange.columns[0] : _last(initialRange.columns))\n                        )\n                    );\n                }\n\n                finished = this.rowPositionUtils.sameRow(currentRow, this.isUp ? finalRangeStartRow : finalRangeEndRow);\n\n                currentRow = this.isUp\n                    ? this.cellNavigationService.getRowAbove(currentRow)\n                    : this.cellNavigationService.getRowBelow(currentRow);\n            }\n        };\n\n        const fillValues = (\n            currentValues: ValueContext[],\n            col: AgColumn,\n            rowNode: RowNode,\n            updateInitialSet: () => boolean\n        ) => {\n            let currentValue: any;\n            let skipValue: boolean = false;\n\n            if (withinInitialRange) {\n                currentValue = this.valueService.getValue(col, rowNode);\n                initialValues.push(currentValue);\n                initialNonAggregatedValues.push(this.valueService.getValue(col, rowNode, undefined, true));\n                initialFormattedValues.push(this.valueService.formatValue(col, rowNode, currentValue));\n                withinInitialRange = updateInitialSet();\n            } else {\n                const { value, fromUserFunction, sourceCol, sourceRowNode } = this.processValues({\n                    event: e,\n                    values: currentValues,\n                    initialValues,\n                    initialNonAggregatedValues,\n                    initialFormattedValues,\n                    col,\n                    rowNode,\n                    idx: idx++,\n                });\n\n                currentValue = value;\n                if (col.isCellEditable(rowNode)) {\n                    const cellValue = this.valueService.getValue(col, rowNode);\n\n                    if (!fromUserFunction) {\n                        if (sourceCol && sourceCol.getColDef()?.useValueFormatterForExport !== false) {\n                            currentValue =\n                                this.valueService.formatValue(sourceCol, sourceRowNode!, currentValue) ?? currentValue;\n                        }\n                        if (col.getColDef().useValueParserForImport !== false) {\n                            currentValue = this.valueService.parseValue(\n                                col,\n                                rowNode,\n                                // if no sourceCol, then currentValue is a number\n                                sourceCol ? currentValue : _toStringOrNull(currentValue),\n                                cellValue\n                            );\n                        }\n                    }\n                    if (!fromUserFunction || cellValue !== currentValue) {\n                        rowNode.setDataValue(col, currentValue, 'rangeService');\n                    } else {\n                        skipValue = true;\n                    }\n                }\n            }\n\n            if (!skipValue) {\n                currentValues.push({\n                    value: currentValue,\n                    column: col,\n                    rowNode,\n                });\n            }\n        };\n\n        if (isVertical) {\n            initialRange.columns.forEach((col: AgColumn) => {\n                iterateAcrossCells(col);\n            });\n        } else {\n            const columns = (this.isLeft ? [...finalRange.columns].reverse() : finalRange.columns) as AgColumn[];\n            iterateAcrossCells(undefined, columns);\n        }\n    }\n\n    private clearCellsInRange(startRow: RowPosition, endRow: RowPosition, columns: AgColumn[]) {\n        const cellRange: CellRange = {\n            startRow,\n            endRow,\n            columns,\n            startColumn: columns[0],\n        };\n        this.rangeService.clearCellRangeCellValues({ cellRanges: [cellRange] });\n    }\n\n    private processValues(params: {\n        event: MouseEvent;\n        values: ValueContext[];\n        initialValues: any[];\n        initialNonAggregatedValues: any[];\n        initialFormattedValues: any[];\n        col: AgColumn;\n        rowNode: RowNode;\n        idx: number;\n    }): { value: any; fromUserFunction: boolean; sourceCol?: AgColumn; sourceRowNode?: RowNode } {\n        const { event, values, initialValues, initialNonAggregatedValues, initialFormattedValues, col, rowNode, idx } =\n            params;\n\n        const userFillOperation = this.gos.getCallback('fillOperation');\n        const isVertical = this.dragAxis === 'y';\n        let direction: 'up' | 'down' | 'left' | 'right';\n\n        if (isVertical) {\n            direction = this.isUp ? 'up' : 'down';\n        } else {\n            direction = this.isLeft ? 'left' : 'right';\n        }\n\n        if (userFillOperation) {\n            const params: WithoutGridCommon<FillOperationParams> = {\n                event,\n                values: values.map(({ value }) => value),\n                initialValues,\n                initialNonAggregatedValues,\n                initialFormattedValues,\n                currentIndex: idx,\n                currentCellValue: this.valueService.getValue(col, rowNode),\n                direction,\n                column: col,\n                rowNode: rowNode,\n            };\n            const userResult = userFillOperation(params);\n            if (userResult !== false) {\n                return { value: userResult, fromUserFunction: true };\n            }\n        }\n\n        const allNumbers = !values.some(({ value }) => {\n            const asFloat = parseFloat(value);\n            return isNaN(asFloat) || asFloat.toString() !== value.toString();\n        });\n\n        // values should be copied in order if the alt key is pressed\n        // or if the values contain strings and numbers\n        // However, if we only have one initial value selected, and that\n        // value is a number and we are also pressing alt, then we should\n        // increment or decrement the value by 1 based on direction.\n        if (event.altKey || !allNumbers) {\n            if (allNumbers && initialValues.length === 1) {\n                const multiplier = this.isUp || this.isLeft ? -1 : 1;\n                return { value: parseFloat(_last(values).value) + 1 * multiplier, fromUserFunction: false };\n            }\n            const { value, column: sourceCol, rowNode: sourceRowNode } = values[idx % values.length];\n            return { value, fromUserFunction: false, sourceCol, sourceRowNode };\n        }\n\n        return {\n            value: _last(findLineByLeastSquares(values.map(({ value }) => Number(value)))),\n            fromUserFunction: false,\n        };\n    }\n\n    protected override clearValues() {\n        this.clearMarkedPath();\n        this.clearCellValues();\n\n        this.lastCellMarked = undefined;\n\n        super.clearValues();\n    }\n\n    private clearMarkedPath() {\n        this.markedCells.forEach((cell) => {\n            if (!cell.isAlive()) {\n                return;\n            }\n            const comp = cell.getComp();\n            comp.addOrRemoveCssClass('ag-selection-fill-top', false);\n            comp.addOrRemoveCssClass('ag-selection-fill-right', false);\n            comp.addOrRemoveCssClass('ag-selection-fill-bottom', false);\n            comp.addOrRemoveCssClass('ag-selection-fill-left', false);\n        });\n\n        this.markedCells.length = 0;\n\n        this.isUp = false;\n        this.isLeft = false;\n        this.isReduce = false;\n    }\n\n    private clearCellValues() {\n        this.cellValues.length = 0;\n    }\n\n    private markPathFrom(initialPosition: CellPosition, currentPosition: CellPosition) {\n        this.clearMarkedPath();\n        this.clearCellValues();\n\n        if (this.dragAxis === 'y') {\n            if (this.rowPositionUtils.sameRow(currentPosition, initialPosition)) {\n                return;\n            }\n\n            const isBefore = this.rowPositionUtils.before(currentPosition, initialPosition);\n            const rangeStartRow = this.getRangeStartRow();\n            const rangeEndRow = this.getRangeEndRow();\n\n            if (\n                isBefore &&\n                ((currentPosition.rowPinned == rangeStartRow.rowPinned &&\n                    currentPosition.rowIndex >= rangeStartRow.rowIndex) ||\n                    (rangeStartRow.rowPinned != rangeEndRow.rowPinned &&\n                        currentPosition.rowPinned == rangeEndRow.rowPinned &&\n                        currentPosition.rowIndex <= rangeEndRow.rowIndex))\n            ) {\n                this.reduceVertical(initialPosition, currentPosition);\n                this.isReduce = true;\n            } else {\n                this.extendVertical(initialPosition, currentPosition, isBefore);\n                this.isReduce = false;\n            }\n        } else {\n            const initialColumn = initialPosition.column as AgColumn;\n            const currentColumn = currentPosition.column as AgColumn;\n\n            if (initialColumn === currentColumn) {\n                return;\n            }\n            const displayedColumns = this.visibleColsService.getAllCols();\n            const initialIndex = displayedColumns.indexOf(initialColumn);\n            const currentIndex = displayedColumns.indexOf(currentColumn);\n\n            if (\n                currentIndex <= initialIndex &&\n                currentIndex >= displayedColumns.indexOf(this.getCellRange().columns[0] as AgColumn)\n            ) {\n                this.reduceHorizontal(initialPosition, currentPosition);\n                this.isReduce = true;\n            } else {\n                this.extendHorizontal(initialPosition, currentPosition, currentIndex < initialIndex);\n                this.isReduce = false;\n            }\n        }\n        this.lastCellMarked = currentPosition;\n    }\n\n    private extendVertical(initialPosition: CellPosition, endPosition: CellPosition, isMovingUp?: boolean) {\n        const { navigationService, rangeService } = this;\n\n        let row: RowPosition | null = initialPosition;\n\n        do {\n            const cellRange = this.getCellRange();\n            const colLen = cellRange.columns.length;\n\n            for (let i = 0; i < colLen; i++) {\n                const column = cellRange.columns[i];\n                const rowPos = { rowIndex: row.rowIndex, rowPinned: row.rowPinned };\n                const cellPos = { ...rowPos, column };\n                const cellInRange = rangeService.isCellInSpecificRange(cellPos, cellRange);\n                const isInitialRow = this.rowPositionUtils.sameRow(row, initialPosition);\n\n                if (isMovingUp) {\n                    this.isUp = true;\n                }\n\n                if (!isInitialRow) {\n                    const cell = navigationService.getCellByPosition(cellPos);\n\n                    if (cell) {\n                        this.markedCells.push(cell);\n                        const cellCtrl = cell.getComp();\n\n                        if (!cellInRange) {\n                            cellCtrl.addOrRemoveCssClass('ag-selection-fill-left', i === 0);\n                            cellCtrl.addOrRemoveCssClass('ag-selection-fill-right', i === colLen - 1);\n                        }\n\n                        cellCtrl.addOrRemoveCssClass(\n                            isMovingUp ? 'ag-selection-fill-top' : 'ag-selection-fill-bottom',\n                            this.rowPositionUtils.sameRow(row, endPosition)\n                        );\n                    }\n                }\n            }\n\n            if (this.rowPositionUtils.sameRow(row, endPosition)) {\n                break;\n            }\n        } while (\n            // tslint:disable-next-line\n            (row = isMovingUp\n                ? this.cellNavigationService.getRowAbove(row)\n                : this.cellNavigationService.getRowBelow(row))\n        );\n    }\n\n    private reduceVertical(initialPosition: CellPosition, endPosition: CellPosition) {\n        let row: RowPosition | null = initialPosition;\n\n        do {\n            const cellRange = this.getCellRange();\n            const colLen = cellRange.columns.length;\n            const isLastRow = this.rowPositionUtils.sameRow(row, endPosition);\n\n            for (let i = 0; i < colLen; i++) {\n                const rowPos = { rowIndex: row.rowIndex, rowPinned: row.rowPinned };\n                const celPos = { ...rowPos, column: cellRange.columns[i] };\n                const cell = this.navigationService.getCellByPosition(celPos);\n\n                if (cell) {\n                    this.markedCells.push(cell);\n\n                    const cellComp = cell.getComp();\n\n                    cellComp.addOrRemoveCssClass(\n                        'ag-selection-fill-bottom',\n                        this.rowPositionUtils.sameRow(row, endPosition)\n                    );\n                }\n            }\n            if (isLastRow) {\n                break;\n            }\n            // tslint:disable-next-line\n        } while ((row = this.cellNavigationService.getRowAbove(row)));\n    }\n\n    private extendHorizontal(initialPosition: CellPosition, endPosition: CellPosition, isMovingLeft?: boolean) {\n        const allCols = this.visibleColsService.getAllCols();\n        const startCol = allCols.indexOf((isMovingLeft ? endPosition.column : initialPosition.column) as AgColumn);\n        const endCol = allCols.indexOf(\n            (isMovingLeft ? this.getCellRange().columns[0] : endPosition.column) as AgColumn\n        );\n        const offset = isMovingLeft ? 0 : 1;\n\n        const colsToMark = allCols.slice(startCol + offset, endCol + offset);\n        const rangeStartRow = this.getRangeStartRow();\n        const rangeEndRow = this.getRangeEndRow();\n\n        colsToMark.forEach((column) => {\n            let row: RowPosition = rangeStartRow;\n            let isLastRow = false;\n\n            do {\n                isLastRow = this.rowPositionUtils.sameRow(row, rangeEndRow);\n                const cell = this.navigationService.getCellByPosition({\n                    rowIndex: row.rowIndex,\n                    rowPinned: row.rowPinned,\n                    column: column,\n                });\n\n                if (cell) {\n                    this.markedCells.push(cell);\n                    const cellComp = cell.getComp();\n\n                    cellComp.addOrRemoveCssClass(\n                        'ag-selection-fill-top',\n                        this.rowPositionUtils.sameRow(row, rangeStartRow)\n                    );\n                    cellComp.addOrRemoveCssClass(\n                        'ag-selection-fill-bottom',\n                        this.rowPositionUtils.sameRow(row, rangeEndRow)\n                    );\n                    if (isMovingLeft) {\n                        this.isLeft = true;\n                        cellComp.addOrRemoveCssClass('ag-selection-fill-left', column === colsToMark[0]);\n                    } else {\n                        cellComp.addOrRemoveCssClass('ag-selection-fill-right', column === _last(colsToMark));\n                    }\n                }\n\n                row = this.cellNavigationService.getRowBelow(row)!;\n            } while (!isLastRow);\n        });\n    }\n\n    private reduceHorizontal(initialPosition: CellPosition, endPosition: CellPosition) {\n        const allCols = this.visibleColsService.getAllCols();\n        const startCol = allCols.indexOf(endPosition.column as AgColumn);\n        const endCol = allCols.indexOf(initialPosition.column as AgColumn);\n\n        const colsToMark = allCols.slice(startCol, endCol);\n        const rangeStartRow = this.getRangeStartRow();\n        const rangeEndRow = this.getRangeEndRow();\n\n        colsToMark.forEach((column) => {\n            let row: RowPosition = rangeStartRow;\n            let isLastRow: boolean = false;\n\n            do {\n                isLastRow = this.rowPositionUtils.sameRow(row, rangeEndRow);\n                const cell = this.navigationService.getCellByPosition({\n                    rowIndex: row.rowIndex,\n                    rowPinned: row.rowPinned,\n                    column: column,\n                });\n\n                if (cell) {\n                    this.markedCells.push(cell);\n                    const cellComp = cell.getComp();\n                    cellComp.addOrRemoveCssClass('ag-selection-fill-right', column === colsToMark[0]);\n                }\n\n                row = this.cellNavigationService.getRowBelow(row)!;\n            } while (!isLastRow);\n        });\n    }\n\n    public override refresh(cellCtrl: CellCtrl) {\n        const cellRange = this.rangeService.getCellRanges()[0];\n        const isColumnRange = !cellRange.startRow || !cellRange.endRow;\n\n        if (isColumnRange) {\n            this.destroy();\n            return;\n        }\n\n        super.refresh(cellCtrl);\n    }\n}\n", "import type {\n    BeanCollection,\n    CellCtrl,\n    CellPosition,\n    CellPositionUtils,\n    CellRange,\n    CtrlsService,\n    DragService,\n    ISelectionHandle,\n    MouseEventService,\n    RowPosition,\n    RowPositionUtils,\n} from '@ag-grid-community/core';\nimport { Component, SelectionHandleType, _isVisible, _last, _setDisplayed } from '@ag-grid-community/core';\n\nimport type { RangeService } from './rangeService';\n\nexport abstract class AbstractSelectionHandle extends Component implements ISelectionHandle {\n    protected dragService: DragService;\n    protected rangeService: RangeService;\n    protected mouseEventService: MouseEventService;\n    protected rowPositionUtils: RowPositionUtils;\n    protected cellPositionUtils: CellPositionUtils;\n    protected ctrlsService: CtrlsService;\n\n    public wireBeans(beans: BeanCollection) {\n        this.dragService = beans.dragService;\n        this.rangeService = beans.rangeService as RangeService;\n        this.mouseEventService = beans.mouseEventService;\n        this.rowPositionUtils = beans.rowPositionUtils;\n        this.cellPositionUtils = beans.cellPositionUtils;\n        this.ctrlsService = beans.ctrlsService;\n    }\n\n    private cellCtrl: CellCtrl;\n    private cellRange: CellRange;\n\n    private rangeStartRow: RowPosition;\n    private rangeEndRow: RowPosition;\n\n    private cellHoverListener: (() => void) | undefined;\n    private lastCellHovered: CellPosition | null | undefined;\n    protected changedCalculatedValues: boolean = false;\n    private dragging: boolean = false;\n\n    protected abstract type: SelectionHandleType;\n    protected shouldDestroyOnEndDragging: boolean = false;\n\n    public postConstruct() {\n        this.dragService.addDragSource({\n            dragStartPixels: 0,\n            eElement: this.getGui(),\n            onDragStart: this.onDragStart.bind(this),\n            onDragging: (e: MouseEvent | Touch) => {\n                this.dragging = true;\n                this.rangeService.autoScrollService.check(e as MouseEvent);\n\n                if (this.changedCalculatedValues) {\n                    this.onDrag(e);\n                    this.changedCalculatedValues = false;\n                }\n            },\n            onDragStop: (e: MouseEvent | Touch) => {\n                this.dragging = false;\n                this.onDragEnd(e);\n                this.clearValues();\n                this.rangeService.autoScrollService.ensureCleared();\n\n                // TODO: this causes a bug where if there are multiple grids in the same page, all of them will\n                // be affected by a drag on any. Move it to the root element.\n                document.body.classList.remove(this.getDraggingCssClass());\n\n                if (this.shouldDestroyOnEndDragging) {\n                    this.destroy();\n                }\n            },\n        });\n\n        this.addManagedElementListeners(this.getGui(), { mousedown: this.preventRangeExtension.bind(this) });\n    }\n\n    protected abstract onDrag(e: MouseEvent | Touch): void;\n    protected abstract onDragEnd(e: MouseEvent | Touch): void;\n\n    protected isDragging(): boolean {\n        return this.dragging;\n    }\n\n    protected getCellCtrl(): CellCtrl | undefined {\n        return this.cellCtrl;\n    }\n\n    protected setCellCtrl(cellComp: CellCtrl) {\n        this.cellCtrl = cellComp;\n    }\n\n    protected getCellRange(): CellRange {\n        return this.cellRange;\n    }\n\n    protected setCellRange(range: CellRange) {\n        this.cellRange = range;\n    }\n\n    protected getRangeStartRow(): RowPosition {\n        return this.rangeStartRow;\n    }\n\n    protected setRangeStartRow(row: RowPosition) {\n        this.rangeStartRow = row;\n    }\n\n    protected getRangeEndRow(): RowPosition {\n        return this.rangeEndRow;\n    }\n\n    protected setRangeEndRow(row: RowPosition) {\n        this.rangeEndRow = row;\n    }\n\n    protected getLastCellHovered(): CellPosition | null | undefined {\n        return this.lastCellHovered;\n    }\n\n    private preventRangeExtension(e: MouseEvent) {\n        e.stopPropagation();\n    }\n\n    protected onDragStart(e: MouseEvent) {\n        [this.cellHoverListener] = this.addManagedElementListeners(this.ctrlsService.get('gridCtrl').getGui(), {\n            mousemove: this.updateValuesOnMove.bind(this),\n        });\n\n        document.body.classList.add(this.getDraggingCssClass());\n    }\n\n    private getDraggingCssClass(): string {\n        return `ag-dragging-${this.type === SelectionHandleType.FILL ? 'fill' : 'range'}-handle`;\n    }\n\n    protected updateValuesOnMove(e: MouseEvent) {\n        const cell = this.mouseEventService.getCellPositionForEvent(e);\n\n        if (!cell || (this.lastCellHovered && this.cellPositionUtils.equals(cell, this.lastCellHovered))) {\n            return;\n        }\n\n        this.lastCellHovered = cell;\n        this.changedCalculatedValues = true;\n    }\n\n    public getType(): SelectionHandleType {\n        return this.type;\n    }\n\n    public refresh(cellCtrl: CellCtrl) {\n        const oldCellComp = this.getCellCtrl();\n        const eGui = this.getGui();\n\n        const cellRange = _last(this.rangeService.getCellRanges());\n\n        const start = cellRange.startRow;\n        const end = cellRange.endRow;\n\n        if (start && end) {\n            const isBefore = this.rowPositionUtils.before(end, start);\n\n            if (isBefore) {\n                this.setRangeStartRow(end);\n                this.setRangeEndRow(start);\n            } else {\n                this.setRangeStartRow(start);\n                this.setRangeEndRow(end);\n            }\n        }\n\n        if (oldCellComp !== cellCtrl || !_isVisible(eGui)) {\n            this.setCellCtrl(cellCtrl);\n            const eParentOfValue = cellCtrl.getComp().getParentOfValue();\n            if (eParentOfValue) {\n                eParentOfValue.appendChild(eGui);\n            }\n        }\n\n        this.setCellRange(cellRange);\n    }\n\n    protected clearValues() {\n        this.lastCellHovered = undefined;\n        this.removeListeners();\n    }\n\n    private removeListeners() {\n        if (this.cellHoverListener) {\n            this.cellHoverListener();\n            this.cellHoverListener = undefined;\n        }\n    }\n\n    public override destroy() {\n        if (!this.shouldDestroyOnEndDragging && this.isDragging()) {\n            _setDisplayed(this.getGui(), false);\n            this.shouldDestroyOnEndDragging = true;\n            return;\n        }\n\n        this.shouldDestroyOnEndDragging = false;\n\n        super.destroy();\n        this.removeListeners();\n\n        const eGui = this.getGui();\n\n        if (eGui.parentElement) {\n            eGui.parentElement.removeChild(eGui);\n        }\n    }\n}\n", "export function findLineByLeastSquares(values: number[]) {\n    const len = values.length;\n    let maxDecimals = 0;\n\n    if (len <= 1) {\n        return values;\n    }\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        const splitExponent = value.toString().split('e-');\n\n        if (splitExponent.length > 1) {\n            maxDecimals = Math.max(maxDecimals, parseInt(splitExponent[1], 10));\n            continue;\n        }\n\n        if (Math.floor(value) === value) {\n            continue;\n        }\n\n        maxDecimals = Math.max(maxDecimals, value.toString().split('.')[1].length);\n    }\n\n    let sum_x = 0;\n    let sum_y = 0;\n    let sum_xy = 0;\n    let sum_xx = 0;\n\n    let y = 0;\n\n    for (let x = 0; x < len; x++) {\n        y = values[x];\n        sum_x += x;\n        sum_y += y;\n        sum_xx += x * x;\n        sum_xy += x * y;\n    }\n\n    const m = (len * sum_xy - sum_x * sum_y) / (len * sum_xx - sum_x * sum_x);\n    const b = sum_y / len - (m * sum_x) / len;\n\n    const result: number[] = [];\n\n    for (let x = 0; x <= len; x++) {\n        result.push(parseFloat((x * m + b).toFixed(maxDecimals)));\n    }\n\n    return result;\n}\n", "import type { CellPosition, CellRange } from '@ag-grid-community/core';\nimport { CellRangeType, SelectionHandleType, _last } from '@ag-grid-community/core';\n\nimport { AbstractSelectionHandle } from './abstractSelectionHandle';\n\nexport class AgRangeHandle extends AbstractSelectionHandle {\n    protected type = SelectionHandleType.RANGE;\n    private endPosition: CellPosition;\n    private rangeFixed: boolean = false;\n\n    constructor() {\n        super(/* html */ `<div class=\"ag-range-handle\"></div>`);\n    }\n\n    protected onDrag(e: MouseEvent) {\n        const lastCellHovered = this.getLastCellHovered();\n\n        if (!lastCellHovered) {\n            return;\n        }\n\n        const cellRanges = this.rangeService.getCellRanges();\n        const lastRange = _last(cellRanges);\n\n        if (!this.rangeFixed) {\n            this.fixRangeStartEnd(lastRange);\n            this.rangeFixed = true;\n        }\n\n        this.endPosition = {\n            rowIndex: lastCellHovered.rowIndex,\n            rowPinned: lastCellHovered.rowPinned,\n            column: lastCellHovered.column,\n        };\n\n        // check if the cell ranges are for a chart\n        if (\n            cellRanges.length === 2 &&\n            cellRanges[0].type === CellRangeType.DIMENSION &&\n            lastRange.type === CellRangeType.VALUE\n        ) {\n            const rowChanged = !this.rowPositionUtils.sameRow(\n                this.endPosition,\n                this.rangeService.getRangeEndRow(lastRange)\n            );\n\n            if (rowChanged) {\n                // ensure the dimension range is kept in sync with the value range (which has the handle)\n                this.rangeService.updateRangeEnd(\n                    cellRanges[0],\n                    {\n                        ...this.endPosition,\n                        column: cellRanges[0].columns[0],\n                    },\n                    true\n                );\n            }\n        }\n\n        this.rangeService.extendLatestRangeToCell(this.endPosition);\n    }\n\n    protected onDragEnd(e: MouseEvent) {\n        const cellRange = _last(this.rangeService.getCellRanges())!;\n\n        this.fixRangeStartEnd(cellRange);\n        this.rangeFixed = false;\n    }\n\n    private fixRangeStartEnd(cellRange: CellRange): void {\n        const startRow = this.rangeService.getRangeStartRow(cellRange);\n        const endRow = this.rangeService.getRangeEndRow(cellRange);\n        const column = cellRange.columns[0];\n\n        cellRange.startRow = startRow;\n        cellRange.endRow = endRow;\n        cellRange.startColumn = column;\n    }\n}\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '32.0.0';\n"],
  "mappings": "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",
  "names": ["BeanStub", "SelectionHandleType", "SelectionHandleType", "_last", "_warnOnce", "_last", "SelectionHandleType", "_warnOnce", "_last", "params", "SelectionHandleType", "_last", "SelectionHandleType", "_last", "BeanStub", "SelectionHandleType"]
}
