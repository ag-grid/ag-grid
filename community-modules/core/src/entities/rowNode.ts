import type { DetailGridInfo } from '../api/gridApi';
import type { BeanCollection } from '../context/context';
import type { AgEventType } from '../eventTypes';
import type { RowEvent, SelectionEventSourceType } from '../events';
import type { IServerSideStore } from '../interfaces/IServerSideStore';
import type { IClientSideRowModel } from '../interfaces/iClientSideRowModel';
import type { IEventEmitter } from '../interfaces/iEventEmitter';
import type {
    AgRowNodeEventListener,
    CellChangedEvent,
    DataChangedEvent,
    IRowNode,
    RowHighlightPosition,
    RowNodeEvent,
    RowNodeEventType,
    RowPinnedType,
    SetSelectedParams,
} from '../interfaces/iRowNode';
import type { IServerSideRowModel } from '../interfaces/iServerSideRowModel';
import { LocalEventService } from '../localEventService';
import { FrameworkEventListenerService } from '../misc/frameworkEventListenerService';
import { _debounce, _errorOnce, _warnOnce } from '../utils/function';
import { _exists, _missing } from '../utils/generic';
import type { AgColumn } from './agColumn';

/**
 * When creating sibling nodes (e.g. footers), we don't copy these properties as they
 * cause the sibling to have properties which should be unique to the row.
 *
 * Note that `keyof T` does not include private members of `T`, so these need to be
 * added explicitly to this list. Take care when adding or renaming private properties
 * of `RowNode`.
 */
const IGNORED_SIBLING_PROPERTIES = new Set<keyof RowNode | 'localEventService'>([
    'localEventService',
    '__objectId',
    'sticky',
]);

/**
 * This is used only when using tree data.
 * Implementation in enterprise-modules/row-grouping/src/rowGrouping/groupStage/treeStrategy/treeNode.ts
 */
export interface ITreeNode {}

export class RowNode<TData = any> implements IEventEmitter<RowNodeEventType>, IRowNode<TData> {
    public static ID_PREFIX_ROW_GROUP = 'row-group-';
    public static ID_PREFIX_TOP_PINNED = 't-';
    public static ID_PREFIX_BOTTOM_PINNED = 'b-';

    private static OBJECT_ID_SEQUENCE = 0;

    /** Unique ID for the node. Either provided by the application, or generated by the grid if not. */
    public id: string | undefined;

    /** If using row grouping, contains the group values for this group. */
    public groupData: { [key: string]: any | null } | null;

    /** If using row grouping and aggregation, contains the aggregation data. */
    public aggData: any;

    /**
     * The data as provided by the application.
     * Can be `undefined` when using row grouping or during grid initialisation.
     */
    public data: TData | undefined;

    /** The parent node to this node, or empty if top level */
    public parent: RowNode<TData> | null;

    /** How many levels this node is from the top when grouping. */
    public level: number;

    /** How many levels this node is from the top when grouping in the UI (only different to `parent` when `groupRemoveSingleChildren=true`)*/
    public uiLevel: number;

    /**
     * If doing in-memory (client-side) grouping, this is the index of the group column this cell is for.
     * This will always be the same as the level, unless we are collapsing groups, i.e. `groupRemoveSingleChildren=true`.
     */
    public rowGroupIndex: number | null;

    /** `true` if this node is a group node (i.e. it has children) */
    public group: boolean | undefined;

    /** `true` if this row is getting dragged */
    public dragging: boolean;

    /** `true` if this row is a master row, part of master / detail (ie row can be expanded to show detail) */
    public master: boolean;

    /** `true` if this row is a detail row, part of master / detail (ie child row of an expanded master row)*/
    public detail: boolean | undefined;

    /** If this row is a master row that was expanded, this points to the associated detail row. */
    public detailNode: RowNode;

    /** If master detail, this contains details about the detail grid */
    public detailGridInfo: DetailGridInfo | null;

    /** `true` if this node is a group and the group is the bottom level in the tree. */
    public leafGroup: boolean | undefined;

    /** `true` if this is the first child in this group. Changes when data is sorted. */
    public firstChild: boolean;

    /** `true` if this is the last child in this group. Changes when data is sorted. */
    public lastChild: boolean;

    /** Index of this row with respect to its parent when grouping. Changes when data is sorted. */
    public childIndex: number;

    /** The current row index. If the row is filtered out or in a collapsed group, this value will be `null`. */
    public rowIndex: number | null = null;

    /** Either 'top' or 'bottom' if row pinned, otherwise `undefined` or `null`. */
    public rowPinned: RowPinnedType;

    /** When true, this row will appear in the top */
    public sticky: boolean;

    /** If row is pinned, then pinnedRowTop is used rather than rowTop */
    public stickyRowTop: number;

    /** If using quick filter, stores a string representation of the row for searching against. */
    public quickFilterAggregateText: string | null;

    /** `true` if row is a footer. Footers have `group = true` and `footer = true`. */
    public footer: boolean | undefined;

    /** The field we are grouping on eg 'country'. */
    public field: string | null;

    /** The row group column used for this group, e.g. the Country column instance. */
    public rowGroupColumn: AgColumn | null;

    /** The key for the group eg Ireland, UK, USA */
    public key: string | null = null;

    /** Used by server-side row model. `true` if this row node is a stub. A stub is a placeholder row with loading icon while waiting from row to be loaded. */
    public stub: boolean | undefined;

    /** Used by server side row model, true if this row node failed a load */
    public failedLoad: boolean | undefined;

    /** Used by server side row model, true if this node needs refreshed by the server when in viewport */
    public __needsRefreshWhenVisible: boolean;

    /** All lowest level nodes beneath this node, no groups. */
    public allLeafChildren: RowNode<TData>[] | null;

    /** Children of this group. If multi levels of grouping, shows only immediate children. */
    public childrenAfterGroup: RowNode<TData>[] | null;

    /** Filtered children of this group. */
    public childrenAfterFilter: RowNode<TData>[] | null;

    /** Aggregated and re-filtered children of this group. */
    public childrenAfterAggFilter: RowNode<TData>[] | null;

    /** Sorted children of this group. */
    public childrenAfterSort: RowNode<TData>[] | null;

    /** Number of children and grand children. */
    public allChildrenCount: number | null;

    /** Children mapped by the pivot columns. */
    public childrenMapped: { [key: string]: any } | null = null;

    /** The TreeNode associated to this row. Used only with tree data. */
    public treeNode: ITreeNode | null = null;

    /** The flags associated to this node. Used only with tree data. */
    public treeNodeFlags: number = 0;

    /** Server Side Row Model Only - the children are in an infinite cache. */
    public childStore: IServerSideStore | null;

    /** `true` if group is expanded, otherwise `false`. */
    public expanded: boolean;

    /** If using footers, reference to the footer node for this group. */
    public sibling: RowNode;

    /** The height, in pixels, of this row */
    public rowHeight: number | null | undefined;

    /** Dynamic row heights are done on demand, only when row is visible. However for row virtualisation
     * we need a row height to do the 'what rows are in viewport' maths. So we assign a row height to each
     * row based on defaults and rowHeightEstimated=true, then when the row is needed for drawing we do
     * the row height calculation and set rowHeightEstimated=false.*/
    public rowHeightEstimated: boolean;

    /**
     * This will be `true` if it has a rowIndex assigned, otherwise `false`.
     */
    public displayed: boolean = false;

    /** The row top position in pixels. */
    public rowTop: number | null = null;

    /** The top pixel for this row last time, makes sense if data set was ordered or filtered,
     * it is used so new rows can animate in from their old position. */
    public oldRowTop: number | null = null;

    /** `true` by default - can be overridden via gridOptions.isRowSelectable(rowNode) */
    public selectable = true;

    /** `true` if this node is a daemon. This means row is not part of the model. Can happen when then
     * the row is selected and then the user sets a different ID onto the node. The nodes is then
     * representing a different entity, so the selection controller, if the node is selected, takes
     * a copy where daemon=true. */
    public __daemon: boolean;

    /** Used by the value service, stores values for a particular change detection turn. */
    public __cacheData: { [colId: string]: any };
    public __cacheVersion: number;

    /** Used by sorting service - to give deterministic sort to groups. Previously we
     * just id for this, however id is a string and had slower sorting compared to numbers. */
    public __objectId: number = RowNode.OBJECT_ID_SEQUENCE++;

    /** We cache the result of hasChildren() so that we can be aware of when it has changed, and hence
     * fire the event. Really we should just have hasChildren as an attribute and do away with hasChildren()
     * method, however that would be a breaking change. */
    private __hasChildren: boolean;

    /** When one or more Columns are using autoHeight, this keeps track of height of each autoHeight Cell,
     * indexed by the Column ID. */
    private __autoHeights?: { [id: string]: number | undefined } = {};

    /** `true` when nodes with the same id are being removed and added as part of the same batch transaction */
    public alreadyRendered = false;

    public highlighted: RowHighlightPosition | null = null;

    private hovered: boolean = false;

    private selected: boolean | undefined = false;
    /** If re-naming this property, you must also update `IGNORED_SIBLING_PROPERTIES` */
    private localEventService: LocalEventService<RowNodeEventType> | null;
    private frameworkEventListenerService: FrameworkEventListenerService<any, any> | null;

    private beans: BeanCollection;

    private checkAutoHeightsDebounced: () => void;

    constructor(beans: BeanCollection) {
        this.beans = beans;
    }

    /**
     * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
     */
    public setData(data: TData): void {
        this.setDataCommon(data, false);
    }

    // similar to setRowData, however it is expected that the data is the same data item. this
    // is intended to be used with Redux type stores, where the whole data can be changed. we are
    // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
    // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
    // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).

    /**
     * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
     */
    public updateData(data: TData): void {
        this.setDataCommon(data, true);
    }

    private setDataCommon(data: TData, update: boolean): void {
        const oldData = this.data;

        this.data = data;
        this.beans.valueCache.onDataChanged();
        this.updateDataOnDetailNode();
        this.checkRowSelectable();
        this.resetQuickFilterAggregateText();

        const event: DataChangedEvent<TData> = this.createDataChangedEvent(data, oldData, update);

        this.localEventService?.dispatchEvent(event);
    }

    // when we are doing master / detail, the detail node is lazy created, but then kept around.
    // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
    // in sync, otherwise expand/collapse of the detail would still show the old values.
    private updateDataOnDetailNode(): void {
        if (this.detailNode) {
            this.detailNode.data = this.data;
        }
    }

    private createDataChangedEvent(
        newData: TData,
        oldData: TData | undefined,
        update: boolean
    ): DataChangedEvent<TData> {
        return {
            type: 'dataChanged',
            node: this,
            oldData: oldData,
            newData: newData,
            update: update,
        };
    }

    public getRowIndexString(): string | null {
        if (this.rowIndex == null) {
            _errorOnce(
                'Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid.'
            );
            return null;
        }

        if (this.rowPinned === 'top') {
            return RowNode.ID_PREFIX_TOP_PINNED + this.rowIndex;
        }

        if (this.rowPinned === 'bottom') {
            return RowNode.ID_PREFIX_BOTTOM_PINNED + this.rowIndex;
        }

        return this.rowIndex.toString();
    }

    private createDaemonNode(): RowNode {
        const oldNode = new RowNode(this.beans);

        // just copy the id and data, this is enough for the node to be used
        // in the selection controller (the selection controller is the only
        // place where daemon nodes can live).
        oldNode.id = this.id;
        oldNode.data = this.data;
        oldNode.__daemon = true;
        oldNode.selected = this.selected;
        oldNode.level = this.level;

        return oldNode;
    }

    public setDataAndId(data: TData, id: string | undefined): void {
        const oldNode = _exists(this.id) ? this.createDaemonNode() : null;
        const oldData = this.data;

        this.data = data;
        this.updateDataOnDetailNode();
        this.setId(id);
        this.checkRowSelectable();
        this.beans.selectionService.syncInRowNode(this, oldNode);

        const event: DataChangedEvent<TData> = this.createDataChangedEvent(data, oldData, false);

        this.localEventService?.dispatchEvent(event);
    }

    private checkRowSelectable() {
        const isRowSelectableFunc = this.beans.gos.get('isRowSelectable');
        this.setRowSelectable(isRowSelectableFunc ? isRowSelectableFunc!(this) : true);
    }

    public setRowSelectable(newVal: boolean, suppressSelectionUpdate?: boolean) {
        if (this.selectable !== newVal) {
            this.selectable = newVal;
            this.dispatchRowEvent('selectableChanged');

            if (suppressSelectionUpdate) {
                return;
            }

            const isGroupSelectsChildren = this.beans.gos.get('groupSelectsChildren');
            if (isGroupSelectsChildren) {
                const selected = this.calculateSelectedFromChildren();
                this.setSelectedParams({
                    newValue: selected ?? false,
                    source: 'selectableChanged',
                });
                return;
            }

            // if row is selected but shouldn't be selectable, then deselect.
            if (this.isSelected() && !this.selectable) {
                this.setSelectedParams({
                    newValue: false,
                    source: 'selectableChanged',
                });
            }
        }
    }

    public setId(id?: string): void {
        // see if user is providing the id's
        const getRowIdFunc = this.beans.gos.getRowIdCallback();

        if (getRowIdFunc) {
            // if user is providing the id's, then we set the id only after the data has been set.
            // this is important for virtual pagination and viewport, where empty rows exist.
            if (this.data) {
                // we pass 'true' as we skip this level when generating keys,
                // as we don't always have the key for this level (eg when updating
                // data via transaction on SSRM, we are getting key to look up the
                // RowNode, don't have the RowNode yet, thus no way to get the current key)
                const parentKeys = this.parent?.getRoute() ?? [];
                this.id = getRowIdFunc({
                    data: this.data,
                    parentKeys: parentKeys.length > 0 ? parentKeys : undefined,
                    level: this.level,
                    rowPinned: this.rowPinned,
                });

                // make sure id provided doesn't start with 'row-group-' as this is reserved.
                if (this.id.startsWith(RowNode.ID_PREFIX_ROW_GROUP)) {
                    _errorOnce(
                        `Row IDs cannot start with ${RowNode.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`
                    );
                }
            } else {
                // this can happen if user has set blank into the rowNode after the row previously
                // having data. this happens in virtual page row model, when data is delete and
                // the page is refreshed.
                this.id = undefined;
            }
        } else {
            this.id = id;
        }
    }

    public setRowTop(rowTop: number | null): void {
        this.oldRowTop = this.rowTop;

        if (this.rowTop === rowTop) {
            return;
        }

        this.rowTop = rowTop;

        this.dispatchRowEvent('topChanged');

        this.setDisplayed(rowTop !== null);
    }

    public clearRowTopAndRowIndex(): void {
        this.oldRowTop = null;
        this.setRowTop(null);
        this.setRowIndex(null);
    }

    public setHovered(hovered: boolean): void {
        this.hovered = hovered;
    }

    public isHovered(): boolean {
        return this.hovered;
    }

    public setMaster(master: boolean): void {
        if (this.master === master) {
            return;
        }

        // if changing AWAY from master, then unexpand, otherwise
        // next time it's shown it is expanded again
        if (this.master && !master) {
            this.expanded = false;
        }

        this.master = master;
        this.dispatchRowEvent('masterChanged');
    }

    public setGroup(group: boolean): void {
        if (this.group === group) {
            return;
        }

        // if we used to be a group, and no longer, then close the node
        if (this.group && !group) {
            this.expanded = false;
        }

        this.group = group;
        this.updateHasChildren();
        this.checkRowSelectable();
        this.dispatchRowEvent('groupChanged');
    }

    /**
     * Sets the row height.
     * Call if you want to change the height initially assigned to the row.
     * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
    public setRowHeight(rowHeight: number | undefined | null, estimated: boolean = false): void {
        this.rowHeight = rowHeight;
        this.rowHeightEstimated = estimated;

        this.dispatchRowEvent('heightChanged');
    }

    public setRowAutoHeight(cellHeight: number | undefined, column: AgColumn): void {
        if (!this.__autoHeights) {
            this.__autoHeights = {};
        }
        this.__autoHeights[column.getId()] = cellHeight;

        if (cellHeight != null) {
            if (this.checkAutoHeightsDebounced == null) {
                this.checkAutoHeightsDebounced = _debounce(this.checkAutoHeights.bind(this), 1);
            }
            this.checkAutoHeightsDebounced();
        }
    }

    public checkAutoHeights(): void {
        let notAllPresent = false;
        let nonePresent = true;
        let newRowHeight = 0;

        const autoHeights = this.__autoHeights!;
        if (autoHeights == null) {
            return;
        }

        const displayedAutoHeightCols = this.beans.visibleColsService.getAllAutoHeightCols();
        displayedAutoHeightCols.forEach((col) => {
            let cellHeight = autoHeights[col.getId()];

            if (cellHeight == null) {
                // If column spanning is active a column may not provide auto height for a row if that
                // cell is not present for the given row due to a previous cell spanning over the auto height column.
                if (this.beans.columnModel.isColSpanActive()) {
                    let activeColsForRow: AgColumn[] = [];
                    switch (col.getPinned()) {
                        case 'left':
                            activeColsForRow = this.beans.visibleColsService.getLeftColsForRow(this);
                            break;
                        case 'right':
                            activeColsForRow = this.beans.visibleColsService.getRightColsForRow(this);
                            break;
                        case null:
                            activeColsForRow = this.beans.columnViewportService.getColsWithinViewport(this);
                            break;
                    }
                    if (activeColsForRow.includes(col)) {
                        // Column is present in the row, i.e not spanned over, but no auto height was provided so we cannot calculate the row height
                        notAllPresent = true;
                        return;
                    }
                    // Ignore this column as it is spanned over and not present in the row
                    cellHeight = -1;
                } else {
                    notAllPresent = true;
                    return;
                }
            } else {
                // At least one auto height is present
                nonePresent = false;
            }

            if (cellHeight > newRowHeight) {
                newRowHeight = cellHeight;
            }
        });

        if (notAllPresent) {
            return;
        }

        // we take min of 10, so we don't adjust for empty rows. if <10, we put to default.
        // this prevents the row starting very small when waiting for async components,
        // which would then mean the grid squashes in far to many rows (as small heights
        // means more rows fit in) which looks crap. so best ignore small values and assume
        // we are still waiting for values to render.
        if (nonePresent || newRowHeight < 10) {
            newRowHeight = this.beans.gos.getRowHeightForNode(this).height;
        }

        if (newRowHeight == this.rowHeight) {
            return;
        }

        this.setRowHeight(newRowHeight);

        const rowModel = this.beans.rowModel as IClientSideRowModel | IServerSideRowModel;
        rowModel.onRowHeightChangedDebounced?.();
    }

    /**
     * Set the expanded state of this rowNode. Pass `true` to expand and `false` to collapse.
     */
    public setExpanded(expanded: boolean, e?: MouseEvent | KeyboardEvent, forceSync?: boolean): void {
        if (this.expanded === expanded) {
            return;
        }

        this.expanded = expanded;

        this.dispatchRowEvent('expandedChanged');

        const event = { ...this.createGlobalRowEvent('rowGroupOpened'), expanded, event: e || null };

        this.beans.rowNodeEventThrottle.dispatchExpanded(event, forceSync);

        // when using footers we need to refresh the group row, as the aggregation
        // values jump between group and footer, because the footer can be callback
        // we refresh regardless as the output of the callback could be a moving target
        this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
    }

    private createGlobalRowEvent<T extends AgEventType>(type: T): RowEvent<T, TData> {
        return this.beans.gos.addGridCommonParams({
            type: type,
            node: this,
            data: this.data,
            rowIndex: this.rowIndex,
            rowPinned: this.rowPinned,
        });
    }

    /**
     * Replaces the value on the `rowNode` for the specified column. When complete,
     * the grid will refresh the rendered cell on the required row only.
     * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
     *
     * @param colKey The column where the value should be updated
     * @param newValue The new value
     * @param eventSource The source of the event
     * @returns `true` if the value was changed, otherwise `false`.
     */
    public setDataValue(colKey: string | AgColumn, newValue: any, eventSource?: string): boolean {
        const getColumnFromKey = () => {
            if (typeof colKey !== 'string') {
                return colKey;
            }
            // if in pivot mode, grid columns wont include primary columns
            return this.beans.columnModel.getCol(colKey) ?? this.beans.columnModel.getColDefCol(colKey);
        };
        // When it is done via the editors, no 'cell changed' event gets fired, as it's assumed that
        // the cell knows about the change given it's in charge of the editing.
        // this method is for the client to call, so the cell listens for the change
        // event, and also flashes the cell when the change occurs.
        const column = getColumnFromKey()!;
        const oldValue = this.getValueFromValueService(column);

        if (this.beans.gos.get('readOnlyEdit')) {
            this.beans.eventService.dispatchEvent({
                type: 'cellEditRequest',
                event: null,
                rowIndex: this.rowIndex!,
                rowPinned: this.rowPinned,
                column: column,
                colDef: column.getColDef(),
                data: this.data,
                node: this,
                oldValue,
                newValue,
                value: newValue,
                source: eventSource,
            });
            return false;
        }

        const valueChanged = this.beans.valueService.setValue(this, column, newValue, eventSource);

        this.dispatchCellChangedEvent(column, newValue, oldValue);
        this.checkRowSelectable();

        return valueChanged;
    }

    public getValueFromValueService(column: AgColumn): any {
        // if we don't check this, then the grid will render leaf groups as open even if we are not
        // allowing the user to open leaf groups. confused? remember for pivot mode we don't allow
        // opening leaf groups, so we have to force leafGroups to be closed in case the user expanded
        // them via the API, or user user expanded them in the UI before turning on pivot mode
        const lockedClosedGroup = this.leafGroup && this.beans.columnModel.isPivotMode();

        const isOpenGroup = this.group && this.expanded && !this.footer && !lockedClosedGroup;

        let includeFooter = false;
        // are we showing group footers
        const groupIncludeFooterOpt = this.beans.gos.get('groupTotalRow') ?? this.beans.gos.get('groupIncludeFooter');
        if (typeof groupIncludeFooterOpt !== 'function') {
            includeFooter = !!groupIncludeFooterOpt;
        } else {
            const groupIncludeFooterCb: any =
                this.beans.gos.getCallback('groupTotalRow' as any) ??
                this.beans.gos.getCallback('groupIncludeFooter' as any);
            includeFooter = !!groupIncludeFooterCb({ node: this });
        }

        // if doing footers, we normally don't show agg data at group level when group is open
        const groupAlwaysShowAggData = this.beans.gos.get('groupSuppressBlankHeader');

        // if doing grouping and footers, we don't want to include the agg value
        // in the header when the group is open
        const ignoreAggData = isOpenGroup && includeFooter && !groupAlwaysShowAggData;

        const value = this.beans.valueService.getValue(column, this, false, ignoreAggData);

        return value;
    }

    public setGroupValue(colKey: string | AgColumn, newValue: any): void {
        const column = this.beans.columnModel.getCol(colKey)!;

        if (_missing(this.groupData)) {
            this.groupData = {};
        }

        const columnId = column.getColId();
        const oldValue = this.groupData[columnId];

        if (oldValue === newValue) {
            return;
        }

        this.groupData[columnId] = newValue;
        this.dispatchCellChangedEvent(column, newValue, oldValue);
    }

    // sets the data for an aggregation
    public setAggData(newAggData: any): void {
        const oldAggData = this.aggData;
        this.aggData = newAggData;

        // if no event service, nobody has registered for events, so no need fire event
        if (this.localEventService) {
            const eventFunc = (colId: string) => {
                const value = this.aggData ? this.aggData[colId] : undefined;
                const oldValue = oldAggData ? oldAggData[colId] : undefined;

                if (value === oldValue) {
                    return;
                }

                // do a quick lookup - despite the event it's possible the column no longer exists
                const column = this.beans.columnModel.getCol(colId)!;
                if (!column) {
                    return;
                }

                this.dispatchCellChangedEvent(column, value, oldValue);
            };

            for (const key in this.aggData) {
                eventFunc(key);
            }
            for (const key in newAggData) {
                if (key in this.aggData) {
                    continue;
                } // skip if already fired an event.
                eventFunc(key);
            }
        }
    }

    public updateHasChildren(): void {
        // in CSRM, the group property will be set before the childrenAfterGroup property, check both to prevent flickering
        let newValue: boolean | null =
            (this.group && !this.footer) || (this.childrenAfterGroup && this.childrenAfterGroup.length > 0);

        const isSsrm = this.beans.gos.isRowModelType('serverSide');
        if (isSsrm) {
            const isTreeData = this.beans.gos.get('treeData');
            const isGroupFunc = this.beans.gos.get('isServerSideGroup');
            // stubs and footers can never have children, as they're grid rows. if tree data the presence of children
            // is determined by the isServerSideGroup callback, if not tree data then the rows group property will be set.
            newValue =
                !this.stub && !this.footer && (isTreeData ? !!isGroupFunc && isGroupFunc(this.data) : !!this.group);
        }

        if (newValue !== this.__hasChildren) {
            this.__hasChildren = !!newValue;
            this.dispatchRowEvent('hasChildrenChanged');
        }
    }

    public hasChildren(): boolean {
        if (this.__hasChildren == null) {
            this.updateHasChildren();
        }
        return this.__hasChildren;
    }

    private dispatchCellChangedEvent(column: AgColumn, newValue: TData, oldValue: TData): void {
        const cellChangedEvent: CellChangedEvent<TData> = {
            type: 'cellChanged',
            node: this,
            column: column,
            newValue: newValue,
            oldValue: oldValue,
        };
        this.localEventService?.dispatchEvent(cellChangedEvent);
    }

    /**
     * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
     * This string is then used for the quick filter instead of hitting each column separately.
     * When you edit, using grid editing, this string gets cleared down.
     * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
     * Otherwise new values will not work with the `quickFilter`. */
    public resetQuickFilterAggregateText(): void {
        this.quickFilterAggregateText = null;
    }

    /** Returns:
     * - `true` if the node can be expanded, i.e it is a group or master row.
     * - `false` if the node cannot be expanded
     */
    public isExpandable(): boolean {
        if (this.footer) {
            return false;
        }

        if (this.beans.columnModel.isPivotMode()) {
            // master detail and leaf groups aren't expandable in pivot mode.
            return this.hasChildren() && !this.leafGroup;
        }
        return this.hasChildren() || !!this.master;
    }

    /** Returns:
     * - `true` if node is selected,
     * - `false` if the node isn't selected
     * - `undefined` if it's partially selected (group where not all children are selected). */
    public isSelected(): boolean | undefined {
        // for footers, we just return what our sibling selected state is, as cannot select a footer
        if (this.footer) {
            return this.sibling.isSelected();
        }

        return this.selected;
    }

    /** Perform a depth-first search of this node and its children. */
    public depthFirstSearch(callback: (rowNode: RowNode<TData>) => void): void {
        if (this.childrenAfterGroup) {
            this.childrenAfterGroup.forEach((child) => child.depthFirstSearch(callback));
        }
        callback(this);
    }

    // + selectionController.calculatedSelectedForAllGroupNodes()
    public calculateSelectedFromChildren(): boolean | undefined | null {
        let atLeastOneSelected = false;
        let atLeastOneDeSelected = false;

        if (!this.childrenAfterGroup?.length) {
            return this.selectable ? this.selected : null;
        }

        for (let i = 0; i < this.childrenAfterGroup.length; i++) {
            const child = this.childrenAfterGroup[i];

            let childState = child.isSelected();
            // non-selectable nodes must be calculated from their children, or ignored if no value results.
            if (!child.selectable) {
                const selectable = child.calculateSelectedFromChildren();
                if (selectable === null) {
                    continue;
                }
                childState = selectable;
            }

            switch (childState) {
                case true:
                    atLeastOneSelected = true;
                    break;
                case false:
                    atLeastOneDeSelected = true;
                    break;
                default:
                    return undefined;
            }
        }

        if (atLeastOneSelected && atLeastOneDeSelected) {
            return undefined;
        }

        if (atLeastOneSelected) {
            return true;
        }

        if (atLeastOneDeSelected) {
            return false;
        }

        if (!this.selectable) {
            return null;
        }

        return this.selected;
    }

    public setSelectedInitialValue(selected?: boolean): void {
        this.selected = selected;
    }

    private dispatchRowEvent<T extends RowNodeEventType>(type: T): void {
        this.localEventService?.dispatchEvent({
            type: type,
            node: this,
        } as RowNodeEvent<T, TData>);
    }

    public selectThisNode(newValue?: boolean, e?: Event, source: SelectionEventSourceType = 'api'): boolean {
        // we only check selectable when newValue=true (ie selecting) to allow unselecting values,
        // as selectable is dynamic, need a way to unselect rows when selectable becomes false.
        const selectionNotAllowed = !this.selectable && newValue;
        const selectionNotChanged = this.selected === newValue;

        if (selectionNotAllowed || selectionNotChanged) {
            return false;
        }

        this.selected = newValue;

        this.dispatchRowEvent('rowSelected');

        // in case of root node, sibling may have service while this row may not
        const sibling = this.sibling;
        if (sibling && sibling.footer && sibling.localEventService) {
            sibling.dispatchRowEvent('rowSelected');
        }

        this.beans.eventService.dispatchEvent({
            ...this.createGlobalRowEvent('rowSelected'),
            event: e || null,
            source,
        });

        return true;
    }

    /**
     * Select (or deselect) the node.
     * @param newValue -`true` for selection, `false` for deselection.
     * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
     * @param source - Source property that will appear in the `selectionChanged` event.
     */
    public setSelected(newValue: boolean, clearSelection: boolean = false, source: SelectionEventSourceType = 'api') {
        if (typeof source === 'boolean') {
            _warnOnce(
                'since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead.'
            );
            return;
        }

        this.setSelectedParams({
            newValue,
            clearSelection,
            rangeSelect: false,
            source,
        });
    }

    // this is for internal use only. To make calling code more readable, this is the same method as setSelected except it takes names parameters
    public setSelectedParams(params: SetSelectedParams & { event?: Event }): number {
        if (this.rowPinned) {
            _warnOnce('cannot select pinned rows');
            return 0;
        }

        if (this.id === undefined) {
            _warnOnce('cannot select node until id for node is known');
            return 0;
        }

        return this.beans.selectionService.setNodesSelected({ ...params, nodes: [this.footer ? this.sibling : this] });
    }

    /**
     * Returns:
     * - `true` if node is either pinned to the `top` or `bottom`
     * - `false` if the node isn't pinned
     */
    public isRowPinned(): boolean {
        return !!this.rowPinned;
    }

    /** Add an event listener. */
    public addEventListener<T extends RowNodeEventType>(eventType: T, userListener: AgRowNodeEventListener<T>): void {
        if (!this.localEventService) {
            this.localEventService = new LocalEventService();
        }
        if (this.beans.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService) {
            this.localEventService.setFrameworkOverrides(this.beans.frameworkOverrides);
            this.frameworkEventListenerService = new FrameworkEventListenerService(this.beans.frameworkOverrides);
        }

        const listener = this.frameworkEventListenerService?.wrap(userListener) ?? userListener;
        this.localEventService.addEventListener(eventType, listener);
    }

    /** Remove event listener. */
    public removeEventListener<T extends RowNodeEventType>(
        eventType: T,
        userListener: AgRowNodeEventListener<T>
    ): void {
        if (!this.localEventService) {
            return;
        }

        const listener = this.frameworkEventListenerService?.unwrap(userListener) ?? userListener;
        this.localEventService.removeEventListener(eventType, listener);
        if (this.localEventService.noRegisteredListenersExist()) {
            this.localEventService = null;
        }
    }

    public onMouseEnter(): void {
        this.dispatchRowEvent('mouseEnter');
    }

    public onMouseLeave(): void {
        this.dispatchRowEvent('mouseLeave');
    }

    /**
     * @deprecated v32.2.0
     *
     * Returns:
     * - `true` if the node is a full width cell
     * - `false` if the node is not a full width cell
     */
    public isFullWidthCell(): boolean {
        if (this.detail) {
            return true;
        }

        const isFullWidthCellFunc = this.beans.gos.getCallback('isFullWidthRow');
        return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this }) : false;
    }

    /**
     * Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.
     * If the Row Node is not a group, it returns `undefined`.
     */
    public getRoute(): string[] | undefined {
        if (!this.group) {
            return undefined;
        }

        const res: string[] = [];
        let pointer: RowNode | null = this;
        while (pointer && pointer.key != null) {
            res.push(pointer.key);
            pointer = pointer.parent;
        }

        return res.reverse();
    }

    public createFooter(): void {
        // only create footer node once, otherwise we have daemons and
        // the animate screws up with the daemons hanging around
        if (this.sibling) {
            return;
        }

        const footerNode = new RowNode(this.beans);

        Object.keys(this).forEach((key: keyof RowNode) => {
            if (IGNORED_SIBLING_PROPERTIES.has(key)) {
                return;
            }
            (footerNode as any)[key] = (this as any)[key];
        });

        footerNode.footer = true;
        footerNode.setRowTop(null);
        footerNode.setRowIndex(null);

        // manually set oldRowTop to null so we discard any
        // previous information about its position.
        footerNode.oldRowTop = null;

        footerNode.id = 'rowGroupFooter_' + this.id;

        // get both header and footer to reference each other as siblings. this is never undone,
        // only overwritten. so if a group is expanded, then contracted, it will have a ghost
        // sibling - but that's fine, as we can ignore this if the header is contracted.
        footerNode.sibling = this;
        this.sibling = footerNode;
    }

    public destroyFooter(): void {
        if (!this.sibling) {
            return;
        }

        this.sibling.setRowTop(null);
        this.sibling.setRowIndex(null);

        this.sibling = undefined as any;
    }

    public setFirstChild(firstChild: boolean): void {
        if (this.firstChild !== firstChild) {
            this.firstChild = firstChild;
            this.dispatchRowEvent('firstChildChanged');
        }
    }

    public setLastChild(lastChild: boolean): void {
        if (this.lastChild !== lastChild) {
            this.lastChild = lastChild;
            this.dispatchRowEvent('lastChildChanged');
        }
    }

    public setChildIndex(childIndex: number): void {
        if (this.childIndex !== childIndex) {
            this.childIndex = childIndex;
            this.dispatchRowEvent('childIndexChanged');
        }
    }

    private setDisplayed(displayed: boolean): void {
        if (this.displayed !== displayed) {
            this.displayed = displayed;
            this.dispatchRowEvent('displayedChanged');
        }
    }

    public setDragging(dragging: boolean): void {
        if (this.dragging !== dragging) {
            this.dragging = dragging;
            this.dispatchRowEvent('draggingChanged');
        }
    }

    public setHighlighted(highlighted: RowHighlightPosition | null): void {
        if (this.highlighted !== highlighted) {
            this.highlighted = highlighted;
            this.dispatchRowEvent('rowHighlightChanged');
        }
    }

    public setAllChildrenCount(allChildrenCount: number | null): void {
        if (this.allChildrenCount !== allChildrenCount) {
            this.allChildrenCount = allChildrenCount;
            this.dispatchRowEvent('allChildrenCountChanged');
        }
    }

    public setRowIndex(rowIndex: number | null): void {
        if (this.rowIndex !== rowIndex) {
            this.rowIndex = rowIndex;
            this.dispatchRowEvent('rowIndexChanged');
        }
    }

    public setUiLevel(uiLevel: number): void {
        if (this.uiLevel !== uiLevel) {
            this.uiLevel = uiLevel;
            this.dispatchRowEvent('uiLevelChanged');
        }
    }
}
