{"version":3,"sources":["../../src/ts/rowNodes/rowNodeSorter.ts"],"names":[],"mappings":"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","file":"rowNodeSorter.js","sourcesContent":["import { Column } from \"../entities/column\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { Autowired, Bean } from \"../context/context\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { ValueService } from \"../valueService/valueService\";\nimport { _ } from \"../utils\";\nimport { Constants } from \"../constants/constants\";\nimport { ColumnModel } from \"../columns/columnModel\";\n\nexport interface SortOption {\n    sort: string;\n    column: Column;\n}\n\nexport interface SortedRowNode {\n    currentPos: number;\n    rowNode: RowNode;\n}\n\n// this logic is used by both SSRM and CSRM\n\n@Bean('rowNodeSorter')\nexport class RowNodeSorter {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired('valueService') private valueService: ValueService;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n\n    public doFullSort(rowNodes: RowNode[], sortOptions: SortOption[]): RowNode[] {\n\n        const mapper = (rowNode: RowNode, pos: number) => ({currentPos: pos, rowNode: rowNode});\n        const sortedRowNodes: SortedRowNode[] = rowNodes.map(mapper);\n\n        sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));\n\n        return sortedRowNodes.map(item => item.rowNode);\n    }\n\n    public compareRowNodes(sortOptions: SortOption[], sortedNodeA: SortedRowNode, sortedNodeB: SortedRowNode): number {\n        const nodeA: RowNode = sortedNodeA.rowNode;\n        const nodeB: RowNode = sortedNodeB.rowNode;\n\n        // Iterate columns, return the first that doesn't match\n        for (let i = 0, len = sortOptions.length; i < len; i++) {\n            const sortOption = sortOptions[i];\n            const isInverted = sortOption.sort === Constants.SORT_DESC;\n\n            const valueA: any = this.getValue(nodeA, sortOption.column);\n            const valueB: any = this.getValue(nodeB, sortOption.column);\n\n            let comparatorResult: number;\n            const providedComparator = this.getComparator(sortOption, nodeA);\n            if (providedComparator) {\n                //if comparator provided, use it\n                comparatorResult = providedComparator(valueA, valueB, nodeA, nodeB, isInverted);\n            } else {\n                //otherwise do our own comparison\n                comparatorResult = _.defaultComparator(valueA, valueB, this.gridOptionsWrapper.isAccentedSort());\n            }\n\n            // user provided comparators can return 'NaN' if they don't correctly handle 'undefined' values, this\n            // typically occurs when the comparator is used on a group row\n            const validResult = !isNaN(comparatorResult);\n\n            if (validResult && comparatorResult !== 0) {\n                return sortOption.sort === Constants.SORT_ASC ? comparatorResult : comparatorResult * -1;\n            }\n        }\n        // All matched, we make is so that the original sort order is kept:\n        return sortedNodeA.currentPos - sortedNodeB.currentPos;\n    }\n\n    private getComparator(sortOption: SortOption, rowNode: RowNode):\n        ((valueA: any, valueB: any, nodeA: RowNode, nodeB: RowNode, isInverted: boolean) => number) | undefined {\n\n        const column = sortOption.column;\n\n        // comparator on col get preference over everything else\n        const comparatorOnCol = column.getColDef().comparator;\n        if (comparatorOnCol != null) {\n            return comparatorOnCol;\n        }\n\n        // if no comparator on col, see if we are showing a group, and if we are, get comparator from row group col\n        if (rowNode.rowGroupColumn) {\n            return rowNode.rowGroupColumn.getColDef().comparator;\n        }\n\n        if (column.getColDef().showRowGroup) {\n            // if a 'field' is supplied on the autoGroupColumnDef we need to use the associated column comparator\n            const groupLeafField = !rowNode.group && column.getColDef().field;\n            if (groupLeafField) {\n                const primaryColumn = this.columnModel.getPrimaryColumn(column.getColDef().field!);\n                const groupLeafComparator = primaryColumn!.getColDef().comparator;\n                if (groupLeafComparator) {\n                    return groupLeafComparator;\n                }\n            }\n        }\n    }\n\n    private getValue(nodeA: RowNode, column: Column): string {\n        return this.valueService.getValue(column, nodeA, false, false);\n    }\n}"]}