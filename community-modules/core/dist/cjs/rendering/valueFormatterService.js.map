{"version":3,"sources":["../../src/ts/rendering/valueFormatterService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,8CAAqD;AAQrD;IAAA;IA2DA,CAAC;IAtDU,2CAAW,GAAlB,UACI,MAAc,EACd,OAAuB,EACvB,MAAW,EACX,KAAU,EACV,iBAA0C;QAE1C,IAAI,MAAM,GAAW,IAAI,CAAC;QAC1B,IAAI,SAA4C,CAAC;QACjD,IAAM,MAAM,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;QAElC,IAAI,iBAAiB,EAAE;YACnB,6EAA6E;YAC7E,SAAS,GAAG,iBAAiB,CAAC;SACjC;aAAM;YACH,yDAAyD;YACzD,IAAI,OAAO,IAAI,OAAO,CAAC,SAAS,EAAE;gBAC9B,SAAS,GAAG,MAAM,CAAC,uBAAuB,CAAC,CAAC,CAAC,MAAM,CAAC,uBAAuB,CAAC,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC;aACvG;iBAAM;gBACH,SAAS,GAAG,MAAM,CAAC,cAAc,CAAC;aACrC;SACJ;QAED,IAAI,SAAS,EAAE;YACX,IAAM,MAAM,GAAyB;gBACjC,KAAK,EAAE,KAAK;gBACZ,IAAI,EAAE,OAAO;gBACb,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI;gBACnC,MAAM,EAAE,MAAM,CAAC,SAAS,EAAE;gBAC1B,MAAM,EAAE,MAAM;gBACd,GAAG,EAAE,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE;gBACrC,SAAS,EAAE,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE;gBACjD,OAAO,EAAE,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE;aAChD,CAAC;YAEF,0EAA0E;YAC1E,2EAA2E;YAC3E,0EAA0E;YAC1E,mFAAmF;YACnF,0EAA0E;YACzE,MAAc,CAAC,MAAM,GAAG,MAAM,CAAC;YAEhC,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;SAC/D;aAAM,IAAI,MAAM,CAAC,OAAO,EAAE;YACvB,OAAO,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;SACtC;QAED,gGAAgG;QAChG,IAAI,CAAC,MAAM,KAAK,IAAI,IAAI,MAAM,KAAK,SAAS,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACnE,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC7B;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAxDgC;QAAhC,mBAAS,CAAC,oBAAoB,CAAC;qEAAgD;IAChD;QAA/B,mBAAS,CAAC,mBAAmB,CAAC;oEAA8C;IAHpE,qBAAqB;QADjC,cAAI,CAAC,uBAAuB,CAAC;OACjB,qBAAqB,CA2DjC;IAAD,4BAAC;CA3DD,AA2DC,IAAA;AA3DY,sDAAqB","file":"valueFormatterService.js","sourcesContent":["import { Bean, Autowired } from \"../context/context\";\nimport { Column } from \"../entities/column\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { ExpressionService } from \"../valueService/expressionService\";\nimport { ValueFormatterParams } from \"../entities/colDef\";\n\n@Bean('valueFormatterService')\nexport class ValueFormatterService {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired('expressionService') private expressionService: ExpressionService;\n\n    public formatValue(\n        column: Column,\n        rowNode: RowNode | null,\n        $scope: any,\n        value: any,\n        suppliedFormatter?: (value: any) => string\n    ): string {\n        let result: string = null;\n        let formatter: ((value: any) => string) | string;\n        const colDef = column.getColDef();\n\n        if (suppliedFormatter) {\n            // favour supplied, e.g. set filter items can have their own value formatters\n            formatter = suppliedFormatter;\n        } else {\n            // if floating, give preference to the floating formatter\n            if (rowNode && rowNode.rowPinned) {\n                formatter = colDef.pinnedRowValueFormatter ? colDef.pinnedRowValueFormatter : colDef.valueFormatter;\n            } else {\n                formatter = colDef.valueFormatter;\n            }\n        }\n\n        if (formatter) {\n            const params: ValueFormatterParams = {\n                value: value,\n                node: rowNode,\n                data: rowNode ? rowNode.data : null,\n                colDef: column.getColDef(),\n                column: column,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n\n            // originally we put the angular 1 scope here, but we don't want the scope\n            // in the params interface, as other frameworks will see the interface, and\n            // angular 1 is not cool any more. so we hack the scope in here (we cannot\n            // include it above, as it's not in the interface, so would cause a compile error).\n            // in the future, when we stop supporting angular 1, we can take this out.\n            (params as any).$scope = $scope;\n\n            result = this.expressionService.evaluate(formatter, params);\n        } else if (colDef.refData) {\n            return colDef.refData[value] || '';\n        }\n\n        // if we don't do this, then arrays get displayed as 1,2,3, but we want 1, 2, 3 (ie with spaces)\n        if ((result === null || result === undefined) && Array.isArray(value)) {\n            result = value.join(', ');\n        }\n\n        return result;\n    }\n}\n"]}