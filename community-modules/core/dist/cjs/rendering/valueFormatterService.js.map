{"version":3,"sources":["../../src/ts/rendering/valueFormatterService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8CAAqD;AAKrD,gDAA+C;AAG/C;IAA2C,yCAAQ;IAAnD;;IAyDA,CAAC;IArDU,2CAAW,GAAlB,UACI,MAAc,EACd,IAAoB,EACpB,MAAW,EACX,KAAU,EACV,iBAA0C,EAC1C,sBAA6B;QAA7B,uCAAA,EAAA,6BAA6B;QAE7B,IAAI,MAAM,GAAkB,IAAI,CAAC;QACjC,IAAI,SAAwD,CAAC;QAE7D,IAAM,MAAM,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;QAElC,IAAI,iBAAiB,EAAE;YACnB,gGAAgG;YAChG,SAAS,GAAG,iBAAiB,CAAC;SACjC;aAAM,IAAI,sBAAsB,EAAE;YAC/B,4DAA4D;YAC5D,SAAS,GAAG,IAAI,IAAI,IAAI,CAAC,SAAS,IAAI,MAAM,CAAC,uBAAuB,CAAC,CAAC;gBAClE,MAAM,CAAC,uBAAuB,CAAC,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC;SAC9D;QAED,IAAI,SAAS,EAAE;YACX,IAAM,MAAM,GAAyB;gBACjC,KAAK,OAAA;gBACL,IAAI,MAAA;gBACJ,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI;gBAC7B,MAAM,QAAA;gBACN,MAAM,QAAA;gBACN,GAAG,EAAE,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE;gBACrC,SAAS,EAAE,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE;gBACjD,OAAO,EAAE,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE;aAChD,CAAC;YAEF,0EAA0E;YAC1E,2EAA2E;YAC3E,0EAA0E;YAC1E,mFAAmF;YACnF,0EAA0E;YACzE,MAAc,CAAC,MAAM,GAAG,MAAM,CAAC;YAEhC,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;SAC/D;aAAM,IAAI,MAAM,CAAC,OAAO,EAAE;YACvB,OAAO,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;SACtC;QAED,kGAAkG;QAClG,IAAI,MAAM,IAAI,IAAI,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACxC,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC7B;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAtD+B;QAA/B,mBAAS,CAAC,mBAAmB,CAAC;oEAA8C;IAFpE,qBAAqB;QADjC,cAAI,CAAC,uBAAuB,CAAC;OACjB,qBAAqB,CAyDjC;IAAD,4BAAC;CAzDD,AAyDC,CAzD0C,mBAAQ,GAyDlD;AAzDY,sDAAqB","file":"valueFormatterService.js","sourcesContent":["import { Bean, Autowired } from '../context/context';\nimport { Column } from '../entities/column';\nimport { RowNode } from '../entities/rowNode';\nimport { ExpressionService } from '../valueService/expressionService';\nimport { ValueFormatterParams } from '../entities/colDef';\nimport { BeanStub } from \"../context/beanStub\";\n\n@Bean('valueFormatterService')\nexport class ValueFormatterService extends BeanStub {\n\n    @Autowired('expressionService') private expressionService: ExpressionService;\n\n    public formatValue(\n        column: Column,\n        node: RowNode | null,\n        $scope: any,\n        value: any,\n        suppliedFormatter?: (value: any) => string,\n        useFormatterFromColumn = true\n    ): string | null {\n        let result: string | null = null;\n        let formatter: ((value: any) => string) | string | undefined;\n\n        const colDef = column.getColDef();\n\n        if (suppliedFormatter) {\n            // use supplied formatter if provided, e.g. set filter items can have their own value formatters\n            formatter = suppliedFormatter;\n        } else if (useFormatterFromColumn) {\n            // if row is pinned, give preference to the pinned formatter\n            formatter = node && node.rowPinned && colDef.pinnedRowValueFormatter ?\n                colDef.pinnedRowValueFormatter : colDef.valueFormatter;\n        }\n\n        if (formatter) {\n            const params: ValueFormatterParams = {\n                value,\n                node,\n                data: node ? node.data : null,\n                colDef,\n                column,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n\n            // originally we put the angular 1 scope here, but we don't want the scope\n            // in the params interface, as other frameworks will see the interface, and\n            // angular 1 is not cool any more. so we hack the scope in here (we cannot\n            // include it above, as it's not in the interface, so would cause a compile error).\n            // in the future, when we stop supporting angular 1, we can take this out.\n            (params as any).$scope = $scope;\n\n            result = this.expressionService.evaluate(formatter, params);\n        } else if (colDef.refData) {\n            return colDef.refData[value] || '';\n        }\n\n        // if we don't do this, then arrays get displayed as 1,2,3, but we want 1, 2, 3 (i.e. with spaces)\n        if (result == null && Array.isArray(value)) {\n            result = value.join(', ');\n        }\n\n        return result;\n    }\n}\n"]}