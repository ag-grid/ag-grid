{"version":3,"sources":["../../src/ts/rendering/autoWidthCalculator.ts"],"names":[],"mappings":"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","file":"autoWidthCalculator.js","sourcesContent":["import { RowRenderer } from \"./rowRenderer\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, PostConstruct } from \"../context/context\";\nimport { HeaderWrapperComp } from \"../headerRendering/header/headerWrapperComp\";\nimport { Component } from \"../widgets/component\";\nimport { HeaderRootComp } from \"../headerRendering/headerRootComp\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { containsClass, addCssClass } from \"../utils/dom\";\nimport { CtrlsService } from \"../ctrlsService\";\nimport { RowContainerCtrl } from \"../gridBodyComp/rowContainer/rowContainerCtrl\";\nimport { RowCssClassCalculator } from \"./row/rowCssClassCalculator\";\n\n@Bean('autoWidthCalculator')\nexport class AutoWidthCalculator extends BeanStub {\n\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('ctrlsService') private ctrlsService: CtrlsService;\n    @Autowired('rowCssClassCalculator') public rowCssClassCalculator: RowCssClassCalculator;\n\n    private centerRowContainerCon: RowContainerCtrl;\n    private headerRootComp: HeaderRootComp;\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.ctrlsService.whenReady(p => {\n            this.centerRowContainerCon = p.centerRowContainerCtrl;\n        });\n    }\n\n    public registerHeaderRootComp(headerRootComp: HeaderRootComp): void {\n        this.headerRootComp = headerRootComp;\n    }\n\n    // this is the trick: we create a dummy container and clone all the cells\n    // into the dummy, then check the dummy's width. then destroy the dummy\n    // as we don't need it any more.\n    // drawback: only the cells visible on the screen are considered\n    public getPreferredWidthForColumn(column: Column, skipHeader?: boolean): number {\n        const eHeaderCell = this.getHeaderCellForColumn(column);\n        // cell isn't visible\n        if (!eHeaderCell) { return -1; }\n\n        const eDummyContainer = document.createElement('span');\n        // position fixed, so it isn't restricted to the boundaries of the parent\n        eDummyContainer.style.position = 'fixed';\n\n        // we put the dummy into the body container, so it will inherit all the\n        // css styles that the real cells are inheriting\n        const eBodyContainer = this.centerRowContainerCon.getContainerElement();\n        eBodyContainer.appendChild(eDummyContainer);\n\n        // get all the cells that are currently displayed (this only brings back\n        // rendered cells, rows not rendered due to row visualisation will not be here)\n        this.putRowCellsIntoDummyContainer(column, eDummyContainer);\n\n        if (!skipHeader) {\n            // we only consider the lowest level cell, not the group cell. in 99% of the time, this\n            // will be enough. if we consider groups, then it gets too complicated for what it's worth,\n            // as the groups can span columns and this class only considers one column at a time.\n            this.cloneItemIntoDummy(eHeaderCell, eDummyContainer);\n        }\n\n        // at this point, all the clones are lined up vertically with natural widths. the dummy\n        // container will have a width wide enough just to fit the largest.\n        const dummyContainerWidth = eDummyContainer.offsetWidth;\n\n        // we are finished with the dummy container, so get rid of it\n        eBodyContainer.removeChild(eDummyContainer);\n\n        // we add padding as I found sometimes the gui still put '...' after some of the texts. so the\n        // user can configure the grid to add a few more pixels after the calculated width\n        const autoSizePadding = this.gridOptionsWrapper.getAutoSizePadding();\n        return dummyContainerWidth + autoSizePadding;\n    }\n\n    private getHeaderCellForColumn(column: Column): HTMLElement | null {\n\n        let comp: Component | null = null;\n\n        // find the rendered header cell\n        this.headerRootComp.forEachHeaderElement(headerElement => {\n            if (headerElement instanceof HeaderWrapperComp) {\n                const headerWrapperComp = headerElement;\n                if (headerWrapperComp.getColumn() === column) {\n                    comp = headerWrapperComp;\n                }\n            }\n        });\n\n        return comp ? (comp as Component).getGui() : null;\n    }\n\n    private putRowCellsIntoDummyContainer(column: Column, eDummyContainer: HTMLElement): void {\n        const eCellElements = this.rowRenderer.getAllCellsForColumn(column);\n        eCellElements.forEach(eCell  => this.cloneItemIntoDummy(eCell, eDummyContainer));\n    }\n\n    private cloneItemIntoDummy(eCell: HTMLElement, eDummyContainer: HTMLElement): void {\n        // make a deep clone of the cell\n        const eCellClone: HTMLElement = eCell.cloneNode(true) as HTMLElement;\n        // the original has a fixed width, we remove this to allow the natural width based on content\n        eCellClone.style.width = '';\n        // the original has position = absolute, we need to remove this so it's positioned normally\n        eCellClone.style.position = 'static';\n        eCellClone.style.left = '';\n        // we put the cell into a containing div, as otherwise the cells would just line up\n        // on the same line, standard flow layout, by putting them into divs, they are laid\n        // out one per line\n        const eCloneParent = document.createElement('div');\n\n        if (containsClass(eCellClone, 'ag-header-cell')) {\n            addCssClass(eCloneParent, 'ag-header');\n            addCssClass(eCloneParent, 'ag-header-row');\n            eCloneParent.style.position = 'static';\n        } else {\n            addCssClass(eCloneParent, 'ag-row');\n        }\n\n        // find parent using classes (headers have ag-header-cell, rows have ag-row), and copy classes from it.\n        // if we didn't do this, things like ag-row-level-2 would be missing if present, which sets indents\n        // onto group items.\n        let pointer = eCell.parentElement;\n        while (pointer) {\n            if (pointer.classList.contains('ag-header-row') || pointer.classList.contains('ag-row')) {\n                pointer.classList.forEach( item => {\n                    // we skit ag-row-position-absolute, as this has structural CSS applied that stops the\n                    // element from fitting into it's parent, and we need the element to stretch the parent\n                    // as we are measuring the parents width\n                    if (item != 'ag-row-position-absolute') {\n                        addCssClass(eCloneParent, item);\n                    }\n                });\n                break;\n            }\n            pointer = pointer.parentElement;\n        }\n\n        // table-row, so that each cell is on a row. i also tried display='block', but this\n        // didn't work in IE\n        eCloneParent.style.display = 'table-row';\n\n        // the twig on the branch, the branch on the tree, the tree in the hole,\n        // the hole in the bog, the bog in the clone, the clone in the parent,\n        // the parent in the dummy, and the dummy down in the vall-e-ooo, OOOOOOOOO! Oh row the rattling bog....\n        eCloneParent.appendChild(eCellClone);\n        eDummyContainer.appendChild(eCloneParent);\n    }\n}\n"]}