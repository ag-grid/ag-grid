{"version":3,"sources":["../../../src/ts/rowNodes/selectableService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AACA,gDAAyD;AAEzD,kDAA+C;AAC/C,8CAA0C;AAG1C,IAAa,iBAAiB,GAA9B,MAAa,iBAAkB,SAAQ,mBAAQ;IAMpC,IAAI;QACP,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,CAAC;QAC7E,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,CAAC;IAChF,CAAC;IAEM,6BAA6B,CAAC,OAAgB;QACjD,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC1B,MAAM,gBAAgB,GAAG,CAAC,IAAa,EAAE,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC;YACpE,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;SAClE;IACL,CAAC;IAEM,8BAA8B,CAAC,OAAgB;QAClD,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC1B,MAAM,gBAAgB,GAAG,CAAC,IAAa,EAAE,EAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC;YACrE,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,kBAAkB,EAAE,gBAAgB,CAAC,CAAC;SAClE;IACL,CAAC;IAEO,WAAW,CAAC,QAA0B,EAAE,gBAA0D;QACtG,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO;SAAE;QAE1B,QAAQ,CAAC,OAAO,CAAC,CAAC,KAAc,EAAE,EAAE;YAEhC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE;gBAAE,OAAO;aAAE,CAAC,4BAA4B;YAE1D,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE;gBACrB,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE,gBAAgB,CAAC,CAAC;aAC/D;YAED,IAAI,aAAsB,CAAC;YAE3B,IAAI,IAAI,CAAC,oBAAoB,EAAE;gBAC3B,wEAAwE;gBACxE,MAAM,eAAe,GAAG,CAAC,gBAAgB,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,UAAU,KAAM,IAAI,CAAC,CAAC;gBACtG,aAAa,GAAG,gBAAM,CAAC,eAAe,CAAC,CAAC;aAC3C;iBAAM;gBACH,wDAAwD;gBACxD,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;aACtF;YAED,KAAK,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;QAC1C,CAAC,CAAC,CAAC;IACP,CAAC;CAEJ,CAAA;AA7CG;IADC,uBAAa;6CAIb;AATQ,iBAAiB;IAD7B,cAAI,CAAC,mBAAmB,CAAC;GACb,iBAAiB,CAmD7B;AAnDY,8CAAiB","file":"selectableService.js","sourcesContent":["import { RowNode } from \"../entities/rowNode\";\nimport { Bean, PostConstruct } from \"../context/context\";\nimport { IsRowSelectable } from \"../entities/gridOptions\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { exists } from \"../utils/generic\";\n\n@Bean('selectableService')\nexport class SelectableService extends BeanStub {\n\n    private groupSelectsChildren: boolean;\n    private isRowSelectableFunc?: IsRowSelectable;\n\n    @PostConstruct\n    public init(): void {\n        this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n        this.isRowSelectableFunc = this.gridOptionsWrapper.getIsRowSelectableFunc();\n    }\n\n    public updateSelectableAfterGrouping(rowNode: RowNode): void {\n        if (this.isRowSelectableFunc) {\n            const nextChildrenFunc = (node: RowNode) => node.childrenAfterGroup;\n            this.recurseDown(rowNode.childrenAfterGroup, nextChildrenFunc);\n        }\n    }\n\n    public updateSelectableAfterFiltering(rowNode: RowNode): void {\n        if (this.isRowSelectableFunc) {\n            const nextChildrenFunc = (node: RowNode) => node.childrenAfterFilter;\n            this.recurseDown(rowNode.childrenAfterGroup, nextChildrenFunc);\n        }\n    }\n\n    private recurseDown(children: RowNode[] | null, nextChildrenFunc: ((rowNode: RowNode) => RowNode[] | null)): void {\n        if (!children) { return; }\n\n        children.forEach((child: RowNode) => {\n\n            if (!child.group) { return; } // only interested in groups\n\n            if (child.hasChildren()) {\n                this.recurseDown(nextChildrenFunc(child), nextChildrenFunc);\n            }\n\n            let rowSelectable: boolean;\n\n            if (this.groupSelectsChildren) {\n                // have this group selectable if at least one direct child is selectable\n                const firstSelectable = (nextChildrenFunc(child) || []).find(rowNode => rowNode.selectable ===  true);\n                rowSelectable = exists(firstSelectable);\n            } else {\n                // directly retrieve selectable value from user callback\n                rowSelectable = this.isRowSelectableFunc ? this.isRowSelectableFunc(child) : false;\n            }\n\n            child.setRowSelectable(rowSelectable);\n        });\n    }\n\n}\n"]}