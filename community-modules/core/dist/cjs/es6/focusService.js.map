{"version":3,"sources":["../../../src/ts/focusService.ts"],"names":[],"mappings":"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","file":"focusService.js","sourcesContent":["import { Autowired, Bean, Optional, PostConstruct } from \"./context/context\";\nimport { BeanStub } from \"./context/beanStub\";\nimport { Column } from \"./entities/column\";\nimport { CellFocusedEvent, Events } from \"./events\";\nimport { ColumnApi } from \"./columns/columnApi\";\nimport { ColumnModel } from \"./columns/columnModel\";\nimport { CellPosition } from \"./entities/cellPosition\";\nimport { RowNode } from \"./entities/rowNode\";\nimport { GridApi } from \"./gridApi\";\nimport { HeaderPosition } from \"./headerRendering/common/headerPosition\";\nimport { RowPositionUtils } from \"./entities/rowPosition\";\nimport { IRangeService } from \"./interfaces/IRangeService\";\nimport { RowRenderer } from \"./rendering/rowRenderer\";\nimport { HeaderNavigationService } from \"./headerRendering/common/headerNavigationService\";\nimport { ColumnGroup } from \"./entities/columnGroup\";\nimport { ManagedFocusFeature } from \"./widgets/managedFocusFeature\";\nimport { getTabIndex } from './utils/browser';\nimport { makeNull } from './utils/generic';\nimport { Constants } from \"./constants/constants\";\nimport { GridCtrl } from \"./gridComp/gridCtrl\";\nimport { NavigationService } from \"./gridBodyComp/navigationService\";\nimport { RowCtrl } from \"./rendering/row/rowCtrl\";\nimport { CtrlsService } from \"./ctrlsService\";\nimport { HeaderCellCtrl } from \"./headerRendering/cells/column/headerCellCtrl\";\nimport { TabToNextHeaderParams, NavigateToNextHeaderParams } from \"./entities/gridOptions\";\nimport { AbstractHeaderCellCtrl } from \"./headerRendering/cells/abstractCell/abstractHeaderCellCtrl\";\nimport { last } from \"./utils/array\";\n\n@Bean('focusService')\nexport class FocusService extends BeanStub {\n\n    @Autowired('eGridDiv') private eGridDiv: HTMLElement;\n    @Autowired('columnModel') private readonly columnModel: ColumnModel;\n    @Autowired('headerNavigationService') private readonly headerNavigationService: HeaderNavigationService;\n    @Autowired('columnApi') private readonly columnApi: ColumnApi;\n    @Autowired('gridApi') private readonly gridApi: GridApi;\n    @Autowired('rowRenderer') private readonly rowRenderer: RowRenderer;\n    @Autowired('rowPositionUtils') private readonly rowPositionUtils: RowPositionUtils;\n    @Optional('rangeService') private readonly rangeService: IRangeService;\n    @Autowired('navigationService') public navigationService: NavigationService;\n    @Autowired('ctrlsService') public ctrlsService: CtrlsService;\n\n    public static AG_KEYBOARD_FOCUS: string = 'ag-keyboard-focus';\n\n    private gridCtrl: GridCtrl;\n    private focusedCellPosition: CellPosition | null;\n    private focusedHeaderPosition: HeaderPosition | null;\n\n    private static keyboardModeActive: boolean = false;\n    private static instancesMonitored: Map<Document, GridCtrl[]> = new Map();\n\n    /**\n     * Adds a gridCore to the list of the gridCores monitoring Keyboard Mode\n     * in a specific HTMLDocument.\n     *\n     * @param doc {Document} - The Document containing the gridCore.\n     * @param gridCore {GridComp} - The GridCore to be monitored.\n     */\n    private static addKeyboardModeEvents(doc: Document, controller: GridCtrl): void {\n        const docControllers = FocusService.instancesMonitored.get(doc);\n\n        if (docControllers && docControllers.length > 0) {\n            if (docControllers.indexOf(controller) === -1) {\n                docControllers.push(controller);\n            }\n        } else {\n            FocusService.instancesMonitored.set(doc, [controller]);\n            doc.addEventListener('keydown', FocusService.toggleKeyboardMode);\n            doc.addEventListener('mousedown', FocusService.toggleKeyboardMode);\n        }\n    }\n\n    /**\n     * Removes a gridCore from the list of the gridCores monitoring Keyboard Mode\n     * in a specific HTMLDocument.\n     *\n     * @param doc {Document} - The Document containing the gridCore.\n     * @param gridCore {GridComp} - The GridCore to be removed.\n     */\n    private static removeKeyboardModeEvents(doc: Document, controller: GridCtrl): void {\n        const docControllers = FocusService.instancesMonitored.get(doc);\n\n        let newControllers: GridCtrl[] = [];\n\n        if (docControllers && docControllers.length) {\n            newControllers = [...docControllers].filter(\n                currentGridCore => currentGridCore !== controller\n            );\n            FocusService.instancesMonitored.set(doc, newControllers);\n        }\n\n        if (newControllers.length === 0) {\n            doc.removeEventListener('keydown', FocusService.toggleKeyboardMode);\n            doc.removeEventListener('mousedown', FocusService.toggleKeyboardMode);\n        }\n    }\n\n    /**\n     * This method will be called by `keydown` and `mousedown` events on all Documents monitoring\n     * KeyboardMode. It will then fire a KEYBOARD_FOCUS, MOUSE_FOCUS on each gridCore present in\n     * the Document allowing each gridCore to maintain a state for KeyboardMode.\n     *\n     * @param event {KeyboardEvent | MouseEvent | TouchEvent} - The event triggered.\n     */\n    private static toggleKeyboardMode(event: KeyboardEvent | MouseEvent | TouchEvent): void {\n        const isKeyboardActive = FocusService.keyboardModeActive;\n        const isKeyboardEvent = event.type === 'keydown';\n\n        if (isKeyboardEvent) {\n            // the following keys should not toggle keyboard mode.\n            if (event.ctrlKey || event.metaKey || event.altKey) { return; }\n        }\n\n        if (isKeyboardActive && isKeyboardEvent || !isKeyboardActive && !isKeyboardEvent) { return; }\n\n        FocusService.keyboardModeActive = isKeyboardEvent;\n        const doc = (event.target as HTMLElement).ownerDocument;\n\n        if (!doc) { return; }\n\n        const controllersForDoc = FocusService.instancesMonitored.get(doc);\n\n        if (controllersForDoc) {\n            controllersForDoc.forEach(controller => {\n                controller.dispatchEvent({ type: isKeyboardEvent ? Events.EVENT_KEYBOARD_FOCUS : Events.EVENT_MOUSE_FOCUS });\n            });\n        }\n    }\n\n    @PostConstruct\n    private init(): void {\n        const clearFocusedCellListener = this.clearFocusedCell.bind(this);\n\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, clearFocusedCellListener);\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverythingChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_GROUP_OPENED, clearFocusedCellListener);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, clearFocusedCellListener);\n\n        this.ctrlsService.whenReady(p => {\n            this.gridCtrl = p.gridCtrl;\n            const doc = this.gridOptionsWrapper.getDocument();\n            FocusService.addKeyboardModeEvents(doc, this.gridCtrl);\n            this.addDestroyFunc(() => this.unregisterGridCompController(this.gridCtrl));\n        });\n    }\n\n    public unregisterGridCompController(gridCompController: GridCtrl): void {\n        const doc = this.gridOptionsWrapper.getDocument();\n\n        FocusService.removeKeyboardModeEvents(doc, gridCompController);\n    }\n\n    public onColumnEverythingChanged(): void {\n        // if the columns change, check and see if this column still exists. if it does, then\n        // we can keep the focused cell. if it doesn't, then we need to drop the focused cell.\n        if (!this.focusedCellPosition) { return; }\n\n        const col = this.focusedCellPosition.column;\n        const colFromColumnModel = this.columnModel.getGridColumn(col.getId());\n\n        if (col !== colFromColumnModel) {\n            this.clearFocusedCell();\n        }\n    }\n\n    public isKeyboardMode(): boolean {\n        return FocusService.keyboardModeActive;\n    }\n\n    // we check if the browser is focusing something, and if it is, and\n    // it's the cell we think is focused, then return the cell. so this\n    // methods returns the cell if a) we think it has focus and b) the\n    // browser thinks it has focus. this then returns nothing if we\n    // first focus a cell, then second click outside the grid, as then the\n    // grid cell will still be focused as far as the grid is concerned,\n    // however the browser focus will have moved somewhere else.\n    public getFocusCellToUseAfterRefresh(): CellPosition | null {\n        const eDocument = this.gridOptionsWrapper.getDocument();\n        if (this.gridOptionsWrapper.isSuppressFocusAfterRefresh() || !this.focusedCellPosition) {\n            return null;\n        }\n\n        // we check that the browser is actually focusing on the grid, if it is not, then\n        // we have nothing to worry about. we check for ROW data, as this covers both focused Rows (for Full Width Rows)\n        // and Cells (covers cells as cells live in rows)\n        if (this.isDomDataMissingInHierarchy(eDocument.activeElement, RowCtrl.DOM_DATA_KEY_ROW_CTRL)) {\n            return null;\n        }\n\n        return this.focusedCellPosition;\n    }\n\n    public getFocusHeaderToUseAfterRefresh(): HeaderPosition | null {\n        const eDocument = this.gridOptionsWrapper.getDocument();\n        if (this.gridOptionsWrapper.isSuppressFocusAfterRefresh() || !this.focusedHeaderPosition) {\n            return null;\n        }\n\n        // we check that the browser is actually focusing on the grid, if it is not, then\n        // we have nothing to worry about\n        if (this.isDomDataMissingInHierarchy(eDocument.activeElement, AbstractHeaderCellCtrl.DOM_DATA_KEY_HEADER_CTRL)) {\n            return null;\n        }\n\n        return this.focusedHeaderPosition;\n    }\n\n    private isDomDataMissingInHierarchy(eBrowserCell: Node | null, key: string):boolean {\n        let ePointer = eBrowserCell;\n\n        while (ePointer) {\n            const data = this.gridOptionsWrapper.getDomData(ePointer, key);\n\n            if (data) {\n                return false;\n            }\n\n            ePointer = ePointer.parentNode;\n        }\n\n        return true;\n    }\n\n    public clearFocusedCell(): void {\n        this.focusedCellPosition = null;\n        this.onCellFocused(false);\n    }\n\n    public getFocusedCell(): CellPosition | null {\n        return this.focusedCellPosition;\n    }\n\n    public setFocusedCell(rowIndex: number, colKey: string | Column, floating: string | null | undefined, forceBrowserFocus = false): void {\n        const gridColumn = this.columnModel.getGridColumn(colKey);\n\n        // if column doesn't exist, then blank the focused cell and return. this can happen when user sets new columns,\n        // and the focused cell is in a column that no longer exists. after columns change, the grid refreshes and tries\n        // to re-focus the focused cell.\n        if (!gridColumn) {\n            this.focusedCellPosition = null;\n            return;\n        }\n\n        this.focusedCellPosition = gridColumn ? { rowIndex, rowPinned: makeNull(floating), column: gridColumn } : null;\n        this.onCellFocused(forceBrowserFocus);\n    }\n\n    public isCellFocused(cellPosition: CellPosition): boolean {\n        if (this.focusedCellPosition == null) { return false; }\n\n        return this.focusedCellPosition.column === cellPosition.column &&\n            this.isRowFocused(cellPosition.rowIndex, cellPosition.rowPinned);\n    }\n\n    public isRowNodeFocused(rowNode: RowNode): boolean {\n        return this.isRowFocused(rowNode.rowIndex!, rowNode.rowPinned);\n    }\n\n    public isHeaderWrapperFocused(headerCtrl: HeaderCellCtrl): boolean {\n        if (this.focusedHeaderPosition == null) { return false; }\n\n        const column = headerCtrl.getColumnGroupChild();\n        const headerRowIndex = headerCtrl.getRowIndex();\n        const pinned = headerCtrl.getPinned();\n\n        const { column: focusedColumn, headerRowIndex: focusedHeaderRowIndex } = this.focusedHeaderPosition;\n\n        return column === focusedColumn &&\n            headerRowIndex === focusedHeaderRowIndex &&\n            pinned == focusedColumn.getPinned();\n    }\n\n    public clearFocusedHeader(): void {\n        this.focusedHeaderPosition = null;\n    }\n\n    public getFocusedHeader(): HeaderPosition | null {\n        return this.focusedHeaderPosition;\n    }\n\n    public setFocusedHeader(headerRowIndex: number, column: ColumnGroup | Column): void {\n        this.focusedHeaderPosition = { headerRowIndex, column };\n    }\n\n    public focusHeaderPosition(params: {\n        headerPosition: HeaderPosition | null;\n        direction?: 'Before' | 'After' | null;\n        fromTab?: boolean;\n        allowUserOverride?: boolean;\n        event?: KeyboardEvent;\n    }): boolean {\n        const { direction, fromTab, allowUserOverride, event } = params;\n        let { headerPosition } = params;\n\n        if (allowUserOverride) {\n            const { gridOptionsWrapper } = this;\n            const currentPosition = this.getFocusedHeader();\n            const headerRowCount = this.headerNavigationService.getHeaderRowCount();\n\n            if (fromTab) {\n                const userFunc = gridOptionsWrapper.getTabToNextHeaderFunc();\n                if (userFunc) {\n                    const params: TabToNextHeaderParams = {\n                        backwards: direction === 'Before',\n                        previousHeaderPosition: currentPosition,\n                        nextHeaderPosition: headerPosition,\n                        headerRowCount,\n                        api: gridOptionsWrapper.getApi()!,\n                        columnApi: gridOptionsWrapper.getColumnApi()!\n                    };\n                    headerPosition = userFunc(params);\n                }\n            } else {\n                const userFunc = gridOptionsWrapper.getNavigateToNextHeaderFunc();\n                if (userFunc && event) {\n                    const params: NavigateToNextHeaderParams = {\n                        key: event.key,\n                        previousHeaderPosition: currentPosition,\n                        nextHeaderPosition: headerPosition,\n                        headerRowCount,\n                        event,\n                        api: gridOptionsWrapper.getApi()!,\n                        columnApi: gridOptionsWrapper.getColumnApi()!\n                    };\n                    headerPosition = userFunc(params);\n                }\n            }\n        }\n\n        if (!headerPosition) { return false; }\n\n        if (headerPosition.headerRowIndex === -1) {\n            return this.focusGridView(headerPosition.column as Column);\n        }\n\n        this.headerNavigationService.scrollToColumn(headerPosition.column, direction);\n\n        const headerRowContainerCtrl = this.ctrlsService.getHeaderRowContainerCtrl(headerPosition.column.getPinned());\n\n        // this will automatically call the setFocusedHeader method above\n        const focusSuccess = headerRowContainerCtrl.focusHeader(headerPosition.headerRowIndex, headerPosition.column, event);\n\n        return focusSuccess;\n    }\n\n    public focusFirstHeader(): boolean {\n        let firstColumn: Column | ColumnGroup = this.columnModel.getAllDisplayedColumns()[0];\n        if (!firstColumn) { return false; }\n\n        if (firstColumn.getParent()) {\n            firstColumn = this.columnModel.getColumnGroupAtLevel(firstColumn, 0)!;\n        }\n\n        return this.focusHeaderPosition({\n            headerPosition: { headerRowIndex: 0, column: firstColumn }\n        });\n    }\n\n    public focusLastHeader(event?: KeyboardEvent): boolean {\n        const headerRowIndex = this.headerNavigationService.getHeaderRowCount() - 1;\n        const column = last(this.columnModel.getAllDisplayedColumns());\n\n        return this.focusHeaderPosition({\n            headerPosition: { headerRowIndex, column },\n            event\n        });\n    }\n\n    public isAnyCellFocused(): boolean {\n        return !!this.focusedCellPosition;\n    }\n\n    public isRowFocused(rowIndex: number, floating?: string | null): boolean {\n        if (this.focusedCellPosition == null) { return false; }\n\n        return this.focusedCellPosition.rowIndex === rowIndex && this.focusedCellPosition.rowPinned === makeNull(floating);\n    }\n\n    public findFocusableElements(rootNode: HTMLElement, exclude?: string | null, onlyUnmanaged = false): HTMLElement[] {\n        const focusableString = Constants.FOCUSABLE_SELECTOR;\n        let excludeString = Constants.FOCUSABLE_EXCLUDE;\n\n        if (exclude) {\n            excludeString += ', ' + exclude;\n        }\n\n        if (onlyUnmanaged) {\n            excludeString += ', [tabindex=\"-1\"]';\n        }\n\n        const nodes = Array.prototype.slice.apply(rootNode.querySelectorAll(focusableString)) as HTMLElement[];\n        const excludeNodes = Array.prototype.slice.apply(rootNode.querySelectorAll(excludeString)) as HTMLElement[];\n\n        if (!excludeNodes.length) {\n            return nodes;\n        }\n\n        const diff = (a: HTMLElement[], b: HTMLElement[]) => a.filter(element => b.indexOf(element) === -1);\n        return diff(nodes, excludeNodes);\n    }\n\n    public focusInto(rootNode: HTMLElement, up = false, onlyUnmanaged = false): boolean {\n        const focusableElements = this.findFocusableElements(rootNode, null, onlyUnmanaged);\n        const toFocus = up ? last(focusableElements) : focusableElements[0];\n\n        if (toFocus) {\n            toFocus.focus();\n            return true;\n        }\n\n        return false;\n    }\n\n    public findNextFocusableElement(rootNode: HTMLElement = this.eGridDiv, onlyManaged?: boolean | null, backwards?: boolean): HTMLElement | null {\n        const focusable = this.findFocusableElements(rootNode, onlyManaged ? ':not([tabindex=\"-1\"])' : null);\n        const eDocument = this.gridOptionsWrapper.getDocument();\n        const activeEl = eDocument.activeElement as HTMLElement;\n        let currentIndex: number;\n\n        if (onlyManaged) {\n            currentIndex = focusable.findIndex(el => el.contains(activeEl));\n        } else {\n            currentIndex = focusable.indexOf(activeEl);\n        }\n\n        const nextIndex = currentIndex + (backwards ? -1 : 1);\n\n        if (nextIndex < 0 || nextIndex >= focusable.length) {\n            return null;\n        }\n\n        return focusable[nextIndex];\n    }\n\n    public isFocusUnderManagedComponent(rootNode: HTMLElement): boolean {\n        const eDocument = this.gridOptionsWrapper.getDocument();\n        const managedContainers = rootNode.querySelectorAll(`.${ManagedFocusFeature.FOCUS_MANAGED_CLASS}`);\n\n        if (!managedContainers.length) { return false; }\n\n        for (let i = 0; i < managedContainers.length; i++) {\n            if (managedContainers[i].contains(eDocument.activeElement)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public findTabbableParent(node: HTMLElement | null, limit: number = 5): HTMLElement | null {\n        let counter = 0;\n\n        while (node && getTabIndex(node) === null && ++counter <= limit) {\n            node = node.parentElement;\n        }\n\n        if (getTabIndex(node) === null) { return null; }\n\n        return node;\n    }\n\n    private onCellFocused(forceBrowserFocus: boolean): void {\n        const event: CellFocusedEvent = {\n            type: Events.EVENT_CELL_FOCUSED,\n            forceBrowserFocus: forceBrowserFocus,\n            rowIndex: null,\n            column: null,\n            floating: null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            rowPinned: null,\n            isFullWidthCell: false\n        };\n\n        if (this.focusedCellPosition) {\n            const rowIndex = event.rowIndex = this.focusedCellPosition.rowIndex;\n            const rowPinned = event.rowPinned = this.focusedCellPosition.rowPinned;\n\n            event.column = this.focusedCellPosition.column;\n\n            const rowCtrl = this.rowRenderer.getRowByPosition({ rowIndex, rowPinned });\n\n            if (rowCtrl) {\n                event.isFullWidthCell = rowCtrl.isFullWidth();\n            }\n        }\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public focusGridView(column?: Column, backwards?: boolean): boolean {\n        // if suppressCellFocus is `true`, it means the user does not want to\n        // navigate between the cells using tab. Instead, we put focus on either\n        // the header or after the grid, depending on whether tab or shift-tab was pressed.\n        if (this.gridOptionsWrapper.isSuppressCellFocus()) {\n\n            if (backwards) {\n                return this.focusLastHeader();\n            }\n\n            return this.focusNextGridCoreContainer(false);\n        }\n\n        const nextRow = backwards\n            ? this.rowPositionUtils.getLastRow()\n            : this.rowPositionUtils.getFirstRow();\n\n        if (!nextRow) { return false; }\n\n        const { rowIndex, rowPinned } = nextRow;\n        const focusedHeader = this.getFocusedHeader();\n\n        if (!column && focusedHeader) {\n            column = focusedHeader.column as Column;\n        }\n\n        if (rowIndex == null || !column) { return false; }\n\n        this.navigationService.ensureCellVisible({ rowIndex, column, rowPinned });\n\n        this.setFocusedCell(rowIndex, column, makeNull(rowPinned), true);\n\n        if (this.rangeService) {\n            const cellPosition = { rowIndex, rowPinned, column };\n            this.rangeService.setRangeToCell(cellPosition);\n        }\n\n        return true;\n    }\n\n    public focusNextGridCoreContainer(backwards: boolean): boolean {\n        if (this.gridCtrl.focusNextInnerContainer(backwards)) {\n            return true;\n        }\n\n        if (!backwards) {\n            this.gridCtrl.forceFocusOutOfContainer();\n        }\n\n        return false;\n    }\n}\n"]}