{"version":3,"sources":["../../../src/ts/utils/changedPath.ts"],"names":[],"mappings":"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","file":"changedPath.js","sourcesContent":["import { RowNode } from \"../entities/rowNode\";\nimport { Column } from \"../entities/column\";\n\n// the class below contains a tree of row nodes. each node is\n// represented by a PathItem\ninterface PathItem {\n    rowNode: RowNode; // the node this item points to\n    children: PathItem[] | null; // children of this node - will be a subset of all the nodes children\n}\n\n// when doing transactions, or change detection, and grouping is present\n// in the data, there is no need for the ClientSideRowModel to update each\n// group after an update, ony parts that were impacted by the change.\n// this class keeps track of all groups that were impacted by a transaction.\n// the the different CSRM operations (filter, sort etc) use the forEach method\n// to visit each group that was changed.\nexport class ChangedPath {\n\n    // we keep columns when doing changed detection after user edits.\n    // when a user edits, we only need to re-aggregate the column\n    // that was edited.\n    private readonly keepingColumns: boolean;\n\n    // the root path always points to RootNode, and RootNode\n    // is always in the changed path. over time, we add items to\n    // the path, but this stays as the root. when the changed path\n    // is ready, this will be the root of the tree of RowNodes that\n    // need to be refreshed (all the row nodes that were impacted by\n    // the transaction).\n    private readonly pathRoot: PathItem;\n\n    // whether changed path is active of not. it is active when a) doing\n    // a transaction update or b) doing change detection. if we are doing\n    // a CSRM refresh for other reasons (after sort or filter, or user calling\n    // setRowData() without delta mode) then we are not active. we are also\n    // marked as not active if secondary columns change in pivot (as this impacts\n    // aggregations)\n    private active = true;\n\n    // for each node in the change path, we also store which columns need\n    // to be re-aggregated.\n    private nodeIdsToColumns: {[nodeId:string]: {[colId:string]:boolean}} = {};\n\n    // for quick lookup, all items in the change path are mapped by nodeId\n    private mapToItems: {[id: string]: PathItem} = {};\n\n    public constructor(keepingColumns: boolean, rootNode: RowNode) {\n        this.keepingColumns = keepingColumns;\n\n        this.pathRoot = {\n            rowNode: rootNode,\n            children: null\n        };\n        this.mapToItems[rootNode.id!] = this.pathRoot;\n    }\n\n    // can be set inactive by:\n    // a) ClientSideRowModel, if no transactions or\n    // b) PivotService, if secondary columns changed\n    public setInactive(): void {\n        this.active = false;\n    }\n\n    public isActive(): boolean {\n        return this.active;\n    }\n\n    private depthFirstSearchChangedPath(pathItem: PathItem, callback: (rowNode: RowNode) => void): void {\n        if (pathItem.children) {\n            for (let i = 0; i < pathItem.children.length; i++) {\n                this.depthFirstSearchChangedPath(pathItem.children[i], callback);\n            }\n        }\n        callback(pathItem.rowNode);\n    }\n\n    private depthFirstSearchEverything(rowNode: RowNode, callback: (rowNode: RowNode) => void, traverseEverything: boolean): void {\n        if (rowNode.childrenAfterGroup) {\n            for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n                const childNode = rowNode.childrenAfterGroup[i];\n                if (childNode.childrenAfterGroup) {\n                    this.depthFirstSearchEverything(rowNode.childrenAfterGroup[i], callback, traverseEverything);\n                } else if (traverseEverything) {\n                    callback(childNode);\n                }\n            }\n        }\n        callback(rowNode);\n    }\n\n    // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback\n    // will be called for child nodes in addition to parent nodes.\n    public forEachChangedNodeDepthFirst(callback: (rowNode: RowNode) => void, traverseLeafNodes = false): void {\n        if (this.active) {\n            // if we are active, then use the change path to callback\n            // only for updated groups\n            this.depthFirstSearchChangedPath(this.pathRoot, callback);\n        } else {\n            // we are not active, so callback for everything, walk the entire path\n            this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);\n        }\n    }\n\n    public executeFromRootNode(callback: (rowNode: RowNode) => void) {\n        callback(this.pathRoot.rowNode);\n    }\n\n    private createPathItems(rowNode: RowNode): number {\n        let pointer = rowNode;\n        let newEntryCount = 0;\n        while (!this.mapToItems[pointer.id!]) {\n            const newEntry: PathItem = {\n                rowNode: pointer,\n                children: null\n            };\n            this.mapToItems[pointer.id!] = newEntry;\n            newEntryCount++;\n            pointer = pointer.parent!;\n        }\n        return newEntryCount;\n    }\n\n    private populateColumnsMap(rowNode: RowNode, columns: Column[]): void {\n        if (!this.keepingColumns || !columns) { return; }\n\n        let pointer = rowNode;\n        while (pointer) {\n            // if columns, add the columns in all the way to parent, merging\n            // in any other columns that might be there already\n            if (!this.nodeIdsToColumns[pointer.id!]) {\n                this.nodeIdsToColumns[pointer.id!] = {};\n            }\n            columns.forEach(col => this.nodeIdsToColumns[pointer.id!][col.getId()] = true);\n            pointer = pointer.parent!;\n        }\n    }\n\n    private linkPathItems(rowNode: RowNode, newEntryCount: number): void {\n        let pointer = rowNode;\n        for (let i = 0; i < newEntryCount; i++) {\n            const thisItem = this.mapToItems[pointer.id!];\n            const parentItem = this.mapToItems[pointer.parent!.id!];\n            if (!parentItem.children) {\n                parentItem.children = [];\n            }\n            parentItem.children.push(thisItem);\n            pointer = pointer.parent!;\n        }\n    }\n\n    // called by\n    // 1) change detection (provides cols) and\n    // 2) groupStage if doing transaction update (doesn't provide cols)\n    public addParentNode(rowNode: RowNode | null, columns?: Column[]): void {\n\n        if (!rowNode || rowNode.isRowPinned()) { return; }\n\n        // we cannot do  both steps below in the same loop as\n        // the second loop has a dependency on the first loop.\n        // ie the hierarchy cannot be stitched up yet because\n        // we don't have it built yet\n\n        // create the new PathItem objects.\n        const newEntryCount = this.createPathItems(rowNode);\n\n        // link in the node items\n        this.linkPathItems(rowNode, newEntryCount);\n\n        // update columns\n        this.populateColumnsMap(rowNode, columns!);\n    }\n\n    public canSkip(rowNode: RowNode): boolean {\n        return this.active && !this.mapToItems[rowNode.id!];\n    }\n\n    public getValueColumnsForNode(rowNode: RowNode, valueColumns: Column[]): Column[] {\n        if (!this.keepingColumns) { return valueColumns; }\n\n        const colsForThisNode = this.nodeIdsToColumns[rowNode.id!];\n        const result = valueColumns.filter(col => colsForThisNode[col.getId()]);\n        return result;\n    }\n\n    public getNotValueColumnsForNode(rowNode: RowNode, valueColumns: Column[]): Column[] | null {\n        if (!this.keepingColumns) { return null; }\n\n        const colsForThisNode = this.nodeIdsToColumns[rowNode.id!];\n        const result = valueColumns.filter(col => !colsForThisNode[col.getId()]);\n        return result;\n    }\n}\n"]}