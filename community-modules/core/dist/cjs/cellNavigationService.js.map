{"version":3,"sources":["../../src/ts/cellNavigationService.ts"],"names":[],"mappings":"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","file":"cellNavigationService.js","sourcesContent":["import { Autowired, Bean } from \"./context/context\";\nimport { BeanStub } from \"./context/beanStub\";\nimport { Constants } from \"./constants/constants\";\nimport { ColumnController } from \"./columnController/columnController\";\nimport { IRowModel } from \"./interfaces/iRowModel\";\nimport { CellPosition } from \"./entities/cellPosition\";\nimport { RowNode } from \"./entities/rowNode\";\nimport { Column } from \"./entities/column\";\nimport { RowPosition } from \"./entities/rowPosition\";\nimport { PinnedRowModel } from \"./pinnedRowModel/pinnedRowModel\";\nimport { missing } from \"./utils/generic\";\nimport { last } from \"./utils/array\";\nimport { KeyCode } from './constants/keyCode';\nimport { PaginationProxy } from \"./pagination/paginationProxy\";\n\n@Bean('cellNavigationService')\nexport class CellNavigationService extends BeanStub {\n\n    @Autowired('columnController') private columnController: ColumnController;\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('pinnedRowModel') private pinnedRowModel: PinnedRowModel;\n    @Autowired('paginationProxy') private paginationProxy: PaginationProxy;\n\n    // returns null if no cell to focus on, ie at the end of the grid\n    public getNextCellToFocus(key: any, lastCellToFocus: CellPosition): CellPosition | null {\n\n        // starting with the provided cell, we keep moving until we find a cell we can\n        // focus on.\n        let pointer: CellPosition | null = lastCellToFocus;\n        let finished = false;\n\n        // finished will be true when either:\n        // a) cell found that we can focus on\n        // b) run out of cells (ie the method returns null)\n        while (!finished) {\n\n            switch (key) {\n                case KeyCode.UP:\n                    pointer = this.getCellAbove(pointer);\n                    break;\n                case KeyCode.DOWN:\n                    pointer = this.getCellBelow(pointer);\n                    break;\n                case KeyCode.RIGHT:\n                    if (this.gridOptionsWrapper.isEnableRtl()) {\n                        pointer = this.getCellToLeft(pointer);\n                    } else {\n                        pointer = this.getCellToRight(pointer);\n                    }\n                    break;\n                case KeyCode.LEFT:\n                    if (this.gridOptionsWrapper.isEnableRtl()) {\n                        pointer = this.getCellToRight(pointer);\n                    } else {\n                        pointer = this.getCellToLeft(pointer);\n                    }\n                    break;\n                default:\n                    pointer = null;\n                    console.warn('AG Grid: unknown key for navigation ' + key);\n                    break;\n            }\n\n            if (pointer) {\n                finished = this.isCellGoodToFocusOn(pointer);\n            } else {\n                finished = true;\n            }\n        }\n\n        return pointer;\n    }\n\n    private isCellGoodToFocusOn(gridCell: CellPosition): boolean {\n        const column: Column = gridCell.column;\n        let rowNode: RowNode | null;\n\n        switch (gridCell.rowPinned) {\n            case Constants.PINNED_TOP:\n                rowNode = this.pinnedRowModel.getPinnedTopRow(gridCell.rowIndex);\n                break;\n            case Constants.PINNED_BOTTOM:\n                rowNode = this.pinnedRowModel.getPinnedBottomRow(gridCell.rowIndex);\n                break;\n            default:\n                rowNode = this.rowModel.getRow(gridCell.rowIndex);\n                break;\n        }\n\n        if (!rowNode) { return false; }\n\n        const suppressNavigable = column.isSuppressNavigable(rowNode);\n        return !suppressNavigable;\n    }\n\n    private getCellToLeft(lastCell: CellPosition | null): CellPosition | null {\n        if (!lastCell) { return null; }\n\n        const colToLeft = this.columnController.getDisplayedColBefore(lastCell.column);\n        if (!colToLeft) { return null; }\n\n        return {\n            rowIndex: lastCell.rowIndex,\n            column: colToLeft,\n            rowPinned: lastCell.rowPinned\n        } as CellPosition;\n    }\n\n    private getCellToRight(lastCell: CellPosition | null): CellPosition | null {\n        if (!lastCell) { return null; }\n\n        const colToRight = this.columnController.getDisplayedColAfter(lastCell.column);\n        // if already on right, do nothing\n        if (!colToRight) { return null; }\n\n        return {\n            rowIndex: lastCell.rowIndex,\n            column: colToRight,\n            rowPinned: lastCell.rowPinned\n        } as CellPosition;\n    }\n\n    public getRowBelow(rowPosition: RowPosition): RowPosition | null {\n        // if already on top row, do nothing\n        const index = rowPosition.rowIndex;\n        const pinned = rowPosition.rowPinned;\n        if (this.isLastRowInContainer(rowPosition)) {\n            switch (pinned) {\n                case Constants.PINNED_BOTTOM:\n                    // never any rows after pinned bottom\n                    return null;\n                case Constants.PINNED_TOP:\n                    // if on last row of pinned top, then next row is main body (if rows exist),\n                    // otherwise it's the pinned bottom\n                    if (this.rowModel.isRowsToRender()) {\n                        return { rowIndex: this.paginationProxy.getPageFirstRow(), rowPinned: null } as RowPosition;\n                    }\n\n                    if (this.pinnedRowModel.isRowsToRender(Constants.PINNED_BOTTOM)) {\n                        return { rowIndex: 0, rowPinned: Constants.PINNED_BOTTOM } as RowPosition;\n                    }\n\n                    return null;\n                default:\n                    // if in the main body, then try pinned bottom, otherwise return nothing\n                    if (this.pinnedRowModel.isRowsToRender(Constants.PINNED_BOTTOM)) {\n                        return { rowIndex: 0, rowPinned: Constants.PINNED_BOTTOM } as RowPosition;\n                    }\n                    return null;\n            }\n        }\n\n        return { rowIndex: index + 1, rowPinned: pinned } as RowPosition;\n    }\n\n    private getCellBelow(lastCell: CellPosition | null): CellPosition | null {\n        if (!lastCell) { return null; }\n\n        const rowBelow = this.getRowBelow(lastCell);\n        if (rowBelow) {\n            return {\n                rowIndex: rowBelow.rowIndex,\n                column: lastCell.column,\n                rowPinned: rowBelow.rowPinned\n            } as CellPosition;\n        }\n\n        return null;\n    }\n\n    private isLastRowInContainer(rowPosition: RowPosition): boolean {\n        const pinned = rowPosition.rowPinned;\n        const index = rowPosition.rowIndex;\n\n        if (pinned === Constants.PINNED_TOP) {\n            const lastTopIndex = this.pinnedRowModel.getPinnedTopRowData().length - 1;\n            return lastTopIndex <= index;\n        }\n\n        if (pinned === Constants.PINNED_BOTTOM) {\n            const lastBottomIndex = this.pinnedRowModel.getPinnedBottomRowData().length - 1;\n            return lastBottomIndex <= index;\n        }\n\n        const lastBodyIndex = this.paginationProxy.getPageLastRow();\n        return lastBodyIndex <= index;\n    }\n\n    public getRowAbove(rowPosition: RowPosition): RowPosition | null {\n        // if already on top row, do nothing\n        const index = rowPosition.rowIndex;\n        const pinned = rowPosition.rowPinned;\n        const isFirstRow = pinned ? index === 0 : index === this.paginationProxy.getPageFirstRow();\n\n        // if already on top row, do nothing\n        if (isFirstRow) {\n            if (pinned === Constants.PINNED_TOP) { return null; }\n\n            if (!pinned) {\n                if (this.pinnedRowModel.isRowsToRender(Constants.PINNED_TOP)) {\n                    return this.getLastFloatingTopRow();\n                }\n                return null;\n            }\n\n            // last floating bottom\n            if (this.rowModel.isRowsToRender()) {\n                return this.getLastBodyCell();\n            }\n\n            if (this.pinnedRowModel.isRowsToRender(Constants.PINNED_TOP)) {\n                return this.getLastFloatingTopRow();\n            }\n\n            return null;\n        }\n\n        return { rowIndex: index - 1, rowPinned: pinned } as RowPosition;\n    }\n\n    private getCellAbove(lastCell: CellPosition | null): CellPosition | null {\n        if (!lastCell) { return null; }\n\n        const rowAbove = this.getRowAbove({ rowIndex: lastCell.rowIndex, rowPinned: lastCell.rowPinned });\n\n        if (rowAbove) {\n            return {\n                rowIndex: rowAbove.rowIndex,\n                column: lastCell.column,\n                rowPinned: rowAbove.rowPinned\n            } as CellPosition;\n        }\n\n        return null;\n    }\n\n    private getLastBodyCell(): RowPosition {\n        const lastBodyRow = this.paginationProxy.getPageLastRow();\n\n        return { rowIndex: lastBodyRow, rowPinned: null } as RowPosition;\n    }\n\n    private getLastFloatingTopRow(): RowPosition {\n        const lastFloatingRow = this.pinnedRowModel.getPinnedTopRowData().length - 1;\n\n        return { rowIndex: lastFloatingRow, rowPinned: Constants.PINNED_TOP } as RowPosition;\n    }\n\n    public getNextTabbedCell(gridCell: CellPosition, backwards: boolean): CellPosition | null {\n        if (backwards) {\n            return this.getNextTabbedCellBackwards(gridCell);\n        }\n\n        return this.getNextTabbedCellForwards(gridCell);\n    }\n\n    public getNextTabbedCellForwards(gridCell: CellPosition): CellPosition | null {\n        const displayedColumns = this.columnController.getAllDisplayedColumns();\n\n        let newRowIndex: number | null = gridCell.rowIndex;\n        let newFloating: string | null | undefined = gridCell.rowPinned;\n\n        // move along to the next cell\n        let newColumn = this.columnController.getDisplayedColAfter(gridCell.column);\n\n        // check if end of the row, and if so, go forward a row\n        if (!newColumn) {\n            newColumn = displayedColumns[0];\n\n            const rowBelow = this.getRowBelow(gridCell);\n            if (missing(rowBelow)) { return null; }\n\n            // If we are tabbing and there is a paging panel present, tabbing should go\n            // to the paging panel instead of loading the next page.\n            if (!rowBelow.rowPinned && !this.paginationProxy.isRowInPage(rowBelow)) {\n                return null;\n            }\n\n            newRowIndex = rowBelow ? rowBelow.rowIndex : null;\n            newFloating = rowBelow ? rowBelow.rowPinned : null;\n        }\n\n        return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating } as CellPosition;\n    }\n\n    public getNextTabbedCellBackwards(gridCell: CellPosition): CellPosition | null {\n\n        const displayedColumns = this.columnController.getAllDisplayedColumns();\n\n        let newRowIndex: number | null = gridCell.rowIndex;\n        let newFloating: string | null | undefined = gridCell.rowPinned;\n\n        // move along to the next cell\n        let newColumn = this.columnController.getDisplayedColBefore(gridCell.column);\n\n        // check if end of the row, and if so, go forward a row\n        if (!newColumn) {\n            newColumn = last(displayedColumns);\n\n            const rowAbove = this.getRowAbove({ rowIndex: gridCell.rowIndex, rowPinned: gridCell.rowPinned });\n\n            if (missing(rowAbove)) { return null; }\n\n            // If we are tabbing and there is a paging panel present, tabbing should go\n            // to the paging panel instead of loading the next page.\n            if (!rowAbove.rowPinned && !this.paginationProxy.isRowInPage(rowAbove)) {\n                return null;\n            }\n\n            newRowIndex = rowAbove ? rowAbove.rowIndex : null;\n            newFloating = rowAbove ? rowAbove.rowPinned : null;\n        }\n\n        return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating } as CellPosition;\n    }\n\n}\n"]}