{"version":3,"sources":["../../src/ts/interfaces/iCellEditor.ts"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA","file":"iCellEditor.js","sourcesContent":["import { Column } from \"../entities/column\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { GridApi } from \"../gridApi\";\nimport { ColumnApi } from \"../columnController/columnApi\";\nimport { ColDef } from \"../entities/colDef\";\nimport { IPopupComponent } from \"./iPopupComponent\";\n\nexport interface ICellEditor {\n    /**\n     * Return the final value - called by the grid once after editing is complete\n     */\n    getValue(): any;\n\n    /** Gets called once after initialised. If you return true, the editor will\n     * appear in a popup, so is not constrained to the boundaries of the cell.\n     * This is great if you want to, for example, provide you own custom dropdown list\n     * for selection. Default is false (ie if you don't provide the method).\n     */\n    isPopup?(): boolean;\n\n    /** Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n     * should cover the cell, or \"under\" if it should be positioned below leaving the\n     * cell value visible. If this method is not present, the default is \"over\".\n     */\n    getPopupPosition?(): string | undefined;\n\n    /** Gets called once after initialised. If you return true, the editor will not be\n     * used and the grid will continue editing. Use this to make a decision on editing\n     * inside the init() function, eg maybe you want to only start editing if the user\n     * hits a numeric key, but not a letter, if the editor is for numbers.\n     */\n    isCancelBeforeStart?(): boolean;\n\n    /** Gets called once after editing is complete. If your return true, then the new\n     * value will not be used. The editing will have no impact on the record. Use this\n     * if you do not want a new value from your gui, i.e. you want to cancel the editing.\n     */\n    isCancelAfterEnd?(): boolean;\n\n    /**\n     * If doing full line edit, then gets called when focus should be put into the editor\n     */\n    focusIn?(): void;\n\n    /**\n     * If doing full line edit, then gets called when focus is leaving the editor\n     */\n    focusOut?(): void;\n\n    /** If using a framework this returns the underlying component instance, so you can call\n     * methods on it if you want.\n     */\n    getFrameworkComponentInstance?(): any;\n}\n\nexport interface ICellEditorParams {\n    // current value of the cell\n    value: any;\n    // key code of key that started the edit, eg 'Enter' or 'Delete' - non-printable\n    // characters appear here\n    keyPress: number | null;\n    // the string that started the edit, eg 'a' if letter 'a' was pressed, or 'A' if\n    // shift + letter 'a' only printable characters appear here\n    charPress: string | null;\n    // grid column\n    column: Column;\n    // column definition\n    colDef: ColDef;\n    // grid row node\n    node: RowNode;\n    // row data\n    data: any;\n    // editing row index\n    rowIndex: number;\n    // grid API\n    api: GridApi | null | undefined;\n    // column API\n    columnApi: ColumnApi | null | undefined;\n    // If doing full row edit, this is true if the cell is the one that started the edit\n    // (eg it is the cell the use double clicked on, or pressed a key on etc).\n    cellStartedEdit: boolean;\n    // the grid's context object\n    context: any;\n    // angular 1 scope - null if not using angular 1, this is legacy and not used if not\n    // using angular 1\n    $scope: any;\n    // callback to tell grid a key was pressed - useful to pass control key events (tab,\n    // arrows etc) back to grid - however you do\n    onKeyDown: (event: KeyboardEvent) => void;\n    // Callback to tell grid to stop editing the current cell. pass 'false' to prevent\n    // navigation moving to the next cell if grid property enterMovesDownAfterEdit=true\n    stopEditing: (suppressNavigateAfterEdit?: boolean) => void;\n    // A reference to the DOM element representing the grid cell that your component\n    // will live inside. Useful if you want to add event listeners or classes at this level.\n    // This is the DOM element that gets browser focus when selecting cells.\n    eGridCell: HTMLElement;\n    // Utility function to parse a value using the column's colDef.valueParser\n    parseValue: (value: any) => any;\n    // Utility function to format a value using the column's colDef.valueFormatter\n    formatValue: (value: any) => any;\n}\n\nexport interface ICellEditorComp extends ICellEditor, IPopupComponent<ICellEditorParams> {\n}\n"]}