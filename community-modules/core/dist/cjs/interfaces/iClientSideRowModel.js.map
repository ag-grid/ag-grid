{"version":3,"sources":["../../src/ts/interfaces/iClientSideRowModel.ts"],"names":[],"mappings":";;;;;;;;AAMA,IAAY,uBAQX;AARD,WAAY,uBAAuB;IAC/B,+CAAoB,CAAA;IACpB,4CAAiB,CAAA;IACjB,wCAAa,CAAA;IACb,sCAAW,CAAA;IACX,kDAAuB,CAAA;IACvB,0CAAe,CAAA;IACf,8CAAmB,CAAA;AACvB,CAAC,EARW,uBAAuB,GAAvB,+BAAuB,KAAvB,+BAAuB,QAQlC","file":"iClientSideRowModel.js","sourcesContent":["import { IRowModel } from './iRowModel';\nimport { RowNodeTransaction } from './rowNodeTransaction';\nimport { RowDataTransaction } from './rowDataTransaction';\nimport { RowNode } from '../entities/rowNode';\nimport { ChangedPath } from '../utils/changedPath';\n\nexport enum ClientSideRowModelSteps {\n    EVERYTHING = 'group',\n    FILTER = 'filter',\n    SORT = 'sort',\n    MAP = 'map',\n    AGGREGATE = 'aggregate',\n    PIVOT = 'pivot',\n    NOTHING = 'nothing'\n}\n\nexport interface IClientSideRowModel extends IRowModel {\n    updateRowData(rowDataTran: RowDataTransaction, rowNodeOrder?: { [id: string]: number; } | null): RowNodeTransaction | null;\n    setRowData(rowData: any[]): void;\n    refreshModel(params: RefreshModelParams): void;\n    expandOrCollapseAll(expand: boolean): void;\n    forEachLeafNode(callback: (node: RowNode, index: number) => void): void;\n    forEachNode(callback: (node: RowNode, index: number) => void): void;\n    forEachNodeAfterFilter(callback: (node: RowNode, index: number) => void): void;\n    forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void): void;\n    resetRowHeights(): void;\n    onRowHeightChanged(): void;\n    batchUpdateRowData(rowDataTransaction: RowDataTransaction, callback?: (res: RowNodeTransaction) => void): void;\n    flushAsyncTransactions(): void;\n    getRootNode(): RowNode;\n    doAggregate(changedPath?: ChangedPath): void;\n    getTopLevelNodes(): RowNode[] | null;\n    forEachPivotNode(callback: (node: RowNode, index: number) => void): void;\n    ensureRowsAtPixel(rowNode: RowNode[], pixel: number, increment: number): boolean;\n    highlightRowAtPixel(rowNode: RowNode | null, pixel?: number): void;\n    getHighlightPosition(pixel: number, rowNode?: RowNode): 'above' | 'below';\n    getLastHighlightedRowNode(): RowNode | null;\n}\n\nexport interface RefreshModelParams {\n    // how much of the pipeline to execute\n    step: ClientSideRowModelSteps;\n    // what state to reset the groups back to after the refresh\n    groupState?: any;\n    // if NOT new data, then this flag tells grid to check if rows already\n    // exist for the nodes (matching by node id) and reuses the row if it does.\n    keepRenderedRows?: boolean;\n    // if true, rows that are kept are animated to the new position\n    animate?: boolean;\n    // if true, then rows we are editing will be kept\n    keepEditingRows?: boolean;\n    // if doing delta updates, this has the changes that were done\n    rowNodeTransactions?: RowNodeTransaction[];\n    // if doing delta updates, this has the order of the nodes\n    rowNodeOrder?: { [id: string]: number };\n    // true user called setRowData() (or a new page in pagination). the grid scrolls\n    // back to the top when this is true.\n    newData?: boolean;\n    // true if this update is due to columns changing, ie no rows were changed\n    afterColumnsChanged?: boolean;\n}\n"]}