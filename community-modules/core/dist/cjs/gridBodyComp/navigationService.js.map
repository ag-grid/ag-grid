{"version":3,"sources":["../../src/ts/gridBodyComp/navigationService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8CAA8E;AAS9E,gDAA+C;AAC/C,4CAAmD;AACnD,wCAAsC;AACtC,gDAA+C;AAG/C,uDAAsD;AACtD,oDAAmD;AAEnD,8CAA2C;AAC3C,oDAAmD;AAoBnD;IAAuC,qCAAQ;IAA/C;QAAA,qEAitBC;QAhsBW,gCAA0B,GAAG,CAAC,CAAC;;IAgsB3C,CAAC;IA7rBW,yCAAa,GAArB;QADA,iBAKC;QAHG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,UAAA,CAAC;YACzB,KAAI,CAAC,WAAW,GAAG,CAAC,CAAC,YAAY,CAAC;QACtC,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,kDAAsB,GAA7B,UAA8B,KAAoB;QAC9C,IAAM,GAAG,GAAG,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC;QACzC,IAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;QACzB,IAAM,IAAI,GAAG,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC;QAE5C,IAAM,WAAW,GAAwB,IAAI,CAAC,iBAAiB,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC;QAC/F,IAAI,CAAC,WAAW,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEnC,IAAI,SAAS,GAAG,KAAK,CAAC;QAEtB,QAAQ,GAAG,EAAE;YACT,KAAK,iBAAO,CAAC,SAAS,CAAC;YACvB,KAAK,iBAAO,CAAC,QAAQ;gBACjB,sDAAsD;gBACtD,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE;oBACf,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;oBACzB,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,MAAM;YACV,KAAK,iBAAO,CAAC,IAAI,CAAC;YAClB,KAAK,iBAAO,CAAC,KAAK;gBACd,kDAAkD;gBAClD,IAAI,IAAI,IAAI,CAAC,GAAG,EAAE;oBACd,IAAI,CAAC,iBAAiB,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;oBACzC,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,MAAM;YACV,KAAK,iBAAO,CAAC,EAAE,CAAC;YAChB,KAAK,iBAAO,CAAC,IAAI;gBACb,+CAA+C;gBAC/C,IAAI,IAAI,IAAI,CAAC,GAAG,EAAE;oBACd,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;oBACtC,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,MAAM;YACV,KAAK,iBAAO,CAAC,SAAS;gBAClB,+DAA+D;gBAC/D,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE;oBACf,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;oBAC7B,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,MAAM;YACV,KAAK,iBAAO,CAAC,OAAO;gBAChB,+DAA+D;gBAC/D,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE;oBACf,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;oBAC3B,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,MAAM;SACb;QAED,IAAI,SAAS,EAAE;YACX,KAAK,CAAC,cAAc,EAAE,CAAC;SAC1B;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IAED,8DAA8D;IAC9D,gEAAgE;IAChE,kEAAkE;IAClE,qEAAqE;IACrE,sEAAsE;IACtE,0EAA0E;IAC1E,8DAA8D;IACtD,4DAAgC,GAAxC;QACI,IAAM,GAAG,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;QACjC,IAAM,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC,0BAA0B,CAAC;QAEnD,OAAO,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC;IACxB,CAAC;IAEO,yDAA6B,GAArC;QACI,IAAI,CAAC,0BAA0B,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;IAC3D,CAAC;IAEO,sCAAU,GAAlB,UAAmB,cAA8B;QACrC,IAAA,wCAAW,EAAE,sCAAU,EAAE,0CAAY,EAAE,sCAAU,EAAE,wCAAW,CAAoB;QAE1F,IAAI,gBAAM,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,EAAE;YAClD,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,mBAAmB,CAAC,YAAY,CAAC,CAAC;SACzE;QAED,IAAI,gBAAM,CAAC,WAAW,CAAC,EAAE;YACrB,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;SACnF;QAED,4DAA4D;QAC5D,IAAI,CAAC,qBAAqB,CAAC,cAAc,EAAE,CAAC;QAE5C,uGAAuG;QACvG,eAAe;QACf,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,UAAU,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QAEtE,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,IAAM,YAAY,GAAiB,EAAE,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,EAAE,WAAW,EAAE,CAAC;YAClG,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;SAClD;IACL,CAAC;IAEO,sCAAU,GAAlB,UAAmB,QAAsB;QACrC,IAAI,IAAI,CAAC,gCAAgC,EAAE,EAAE;YAAE,OAAO;SAAE;QAExD,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,CAAC;QACxD,IAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,EAAE,CAAC;QAC3E,IAAM,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,EAAE,CAAC;QACnE,IAAI,eAAe,GAAG,cAAc,CAAC,MAAM,GAAG,cAAc,CAAC,GAAG,CAAC;QAEjE,IAAI,IAAI,CAAC,YAAY,CAAC,yBAAyB,EAAE,CAAC,yBAAyB,EAAE,EAAE;YAC3E,eAAe,IAAI,cAAc,CAAC;SACrC;QAED,IAAM,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAEhE,IAAM,sBAAsB,GAAG,cAAc,CAAC,GAAG,GAAG,eAAe,CAAC;QACpE,IAAM,oBAAoB,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,sBAAsB,GAAG,iBAAiB,CAAC,CAAC;QACjH,IAAI,WAAW,GAAG,oBAAoB,CAAC;QAEvC,IAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAE,CAAC,MAAM,CAAC;QAChF,IAAM,aAAa,GAAG,gBAAiB,GAAG,eAAe,GAAG,iBAAiB,CAAC;QAC9E,IAAI,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,aAAa,GAAG,iBAAiB,CAAC,CAAC;QAE5F,IAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAE1D,IAAI,UAAU,GAAG,WAAW,EAAE;YAAE,UAAU,GAAG,WAAW,CAAC;SAAE;QAC3D,IAAI,WAAW,GAAG,WAAW,EAAE;YAAE,WAAW,GAAG,WAAW,CAAC;SAAE;QAE7D,IAAI,CAAC,UAAU,CAAC;YACZ,WAAW,aAAA;YACX,UAAU,EAAE,KAAK;YACjB,YAAY,EAAE,IAAI;YAClB,UAAU,YAAA;YACV,WAAW,EAAE,QAAQ,CAAC,MAAM;SAC/B,CAAC,CAAC;QAEH,IAAI,CAAC,6BAA6B,EAAE,CAAC;IACzC,CAAC;IAEO,oCAAQ,GAAhB,UAAiB,QAAsB;QACnC,IAAI,IAAI,CAAC,gCAAgC,EAAE,EAAE;YAAE,OAAO;SAAE;QAExD,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,CAAC;QACxD,IAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,EAAE,CAAC;QAC3E,IAAM,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,EAAE,CAAC;QACnE,IAAI,eAAe,GAAG,cAAc,CAAC,MAAM,GAAG,cAAc,CAAC,GAAG,CAAC;QAEjE,IAAI,IAAI,CAAC,YAAY,CAAC,yBAAyB,EAAE,CAAC,yBAAyB,EAAE,EAAE;YAC3E,eAAe,IAAI,cAAc,CAAC;SACrC;QAED,IAAM,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAEhE,IAAM,mBAAmB,GAAG,cAAc,CAAC,GAAG,CAAC;QAC/C,IAAM,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,mBAAmB,GAAG,iBAAiB,CAAC,CAAC;QAC3G,IAAI,WAAW,GAAG,iBAAiB,CAAC;QAEpC,IAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAE,CAAC;QACvE,IAAM,aAAa,GAAG,cAAc,CAAC,MAAO,GAAG,cAAc,CAAC,SAAU,GAAG,eAAe,GAAG,iBAAiB,CAAC;QAC/G,IAAI,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,aAAa,GAAG,iBAAiB,CAAC,CAAC;QAE5F,IAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC;QAExD,IAAI,UAAU,GAAG,QAAQ,EAAE;YAAE,UAAU,GAAG,QAAQ,CAAC;SAAE;QACrD,IAAI,WAAW,GAAG,QAAQ,EAAE;YAAE,WAAW,GAAG,QAAQ,CAAC;SAAE;QAEvD,IAAI,CAAC,UAAU,CAAC;YACZ,WAAW,aAAA;YACX,UAAU,EAAE,QAAQ;YACpB,YAAY,EAAE,IAAI;YAClB,UAAU,YAAA;YACV,WAAW,EAAE,QAAQ,CAAC,MAAM;SAC/B,CAAC,CAAC;QAEH,IAAI,CAAC,6BAA6B,EAAE,CAAC;IACzC,CAAC;IAEO,2CAAe,GAAvB,UAAwB,eAAuB,EAAE,MAAe;QAC5D,IAAI,YAAY,GAAG,eAAe,CAAC;QAEnC,qFAAqF;QACrF,mDAAmD;QACnD,IAAI,MAAM,EAAE;YACR,IAAM,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;YAC1D,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE;gBACnB,YAAY,IAAI,CAAC,CAAC;aACrB;SACJ;QAED,OAAO,YAAY,CAAC;IACxB,CAAC;IAED,2FAA2F;IACnF,0CAAc,GAAtB,UAAuB,GAAW,EAAE,QAAsB;QACtD,IAAM,KAAK,GAAG,GAAG,KAAK,iBAAO,CAAC,EAAE,CAAC;QACjC,IAAM,kBAAkB,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAElH,IAAI,CAAC,UAAU,CAAC;YACZ,WAAW,EAAE,kBAAkB;YAC/B,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,QAAQ,CAAC,MAAM;YAC7B,UAAU,EAAE,IAAI,CAAC,eAAe,CAAC,kBAAkB,EAAE,CAAC,KAAK,CAAC;YAC5D,WAAW,EAAE,QAAQ,CAAC,MAAM;SAC/B,CAAC,CAAC;IACP,CAAC;IAED,0FAA0F;IAClF,6CAAiB,GAAzB,UAA0B,GAAW,EAAE,QAAsB;QACzD,IAAM,OAAO,GAAG,GAAG,KAAK,iBAAO,CAAC,IAAI,CAAC;QACrC,IAAM,UAAU,GAAa,IAAI,CAAC,WAAW,CAAC,sBAAsB,EAAE,CAAC;QACvE,IAAM,cAAc,GAAW,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAI,CAAC,UAAU,CAAC,CAAC;QAE1E,IAAI,CAAC,UAAU,CAAC;YACZ,WAAW,EAAE,QAAQ,CAAC,QAAQ;YAC9B,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,cAAc;YAC5B,UAAU,EAAE,QAAQ,CAAC,QAAQ;YAC7B,WAAW,EAAE,cAAc;SAC9B,CAAC,CAAC;IACP,CAAC;IAED,+FAA+F;IAC/F,uFAAuF;IAC/E,0CAAc,GAAtB,UAAuB,GAAW;QAC9B,IAAM,OAAO,GAAG,GAAG,KAAK,iBAAO,CAAC,SAAS,CAAC;QAC1C,IAAM,UAAU,GAAa,IAAI,CAAC,WAAW,CAAC,sBAAsB,EAAE,CAAC;QACvE,IAAM,cAAc,GAAG,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAI,CAAC,UAAU,CAAC,CAAC;QAClE,IAAM,WAAW,GAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAE7G,IAAI,CAAC,UAAU,CAAC;YACZ,WAAW,EAAE,WAAW;YACxB,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,cAAc;YAC5B,UAAU,EAAE,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC;YACvD,WAAW,EAAE,cAAc;SAC9B,CAAC,CAAC;IACP,CAAC;IAED,2BAA2B;IACpB,wCAAY,GAAnB,UAAoB,QAA4B,EAAE,aAA4B;QAC1E,IAAM,SAAS,GAAG,aAAa,CAAC,QAAQ,CAAC;QACzC,IAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;QAEtE,IAAI,eAAe,EAAE;YACjB,oGAAoG;YACpG,mDAAmD;YACnD,aAAa,CAAC,cAAc,EAAE,CAAC;YAC/B,OAAO;SACV;QAED,gGAAgG;QAChG,aAAa;QACb,IAAI,SAAS,EAAE;YACL,IAAA,8BAAmD,EAAjD,sBAAQ,EAAE,wBAAuC,CAAC;YAC1D,IAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAK,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC;YAClG,IAAI,QAAQ,EAAE;gBACV,aAAa,CAAC,cAAc,EAAE,CAAC;gBAE/B,IAAM,cAAc,GAAG,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,GAAG,CAAC,CAAC;gBAC5E,IAAM,MAAM,GAAG,YAAI,CAAC,IAAI,CAAC,WAAW,CAAC,sBAAsB,EAAE,CAAC,CAAC;gBAE/D,IAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC,EAAE,cAAc,gBAAA,EAAE,MAAM,QAAA,EAAE,CAAC,CAAC;aACrE;SACJ;aAAM;YACH,yFAAyF;YACzF,sFAAsF;YACtF,iBAAiB;YACjB,IAAI,QAAQ,YAAY,mBAAQ,EAAE;gBAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;aAC5B;YAED,IAAI,IAAI,CAAC,YAAY,CAAC,0BAA0B,CAAC,KAAK,CAAC,EAAE;gBACrD,aAAa,CAAC,cAAc,EAAE,CAAC;aAClC;SACJ;IACL,CAAC;IAED,iBAAiB;IACV,yCAAa,GAApB,UAAqB,SAAkB;QACnC,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,CAAC;QACvD,oCAAoC;QACpC,IAAI,CAAC,WAAW,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEnC,IAAI,SAAS,GAA8B,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QAE/E,sEAAsE;QACtE,8CAA8C;QAC9C,IAAI,CAAC,SAAS,EAAE;YACZ,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;YAC3D,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,EAAE;gBACxC,OAAO,KAAK,CAAC;aAChB;SACJ;QAED,OAAO,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;IAC1D,CAAC;IAEO,+CAAmB,GAA3B,UAA4B,QAA4B,EAAE,SAAkB;QACxE,IAAI,OAAO,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;QAEnC,wFAAwF;QACxF,IAAI,CAAC,OAAO,IAAI,QAAQ,YAAY,mBAAQ,EAAE;YAC1C,IAAM,IAAI,GAAG,QAAoB,CAAC;YAClC,IAAM,GAAG,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;YAC9B,IAAI,GAAG,EAAE;gBACL,OAAO,GAAG,GAAG,CAAC,SAAS,EAAE,CAAC;aAC7B;SACJ;QAED,IAAI,GAAY,CAAC;QAEjB,IAAI,OAAO,EAAE;YACT,iEAAiE;YACjE,IAAI,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE,EAAE;gBACzC,GAAG,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAoB,EAAE,SAAS,CAAC,CAAC;aACpE;iBAAM;gBACH,GAAG,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAoB,EAAE,SAAS,CAAC,CAAC;aACrE;SACJ;aAAM;YACH,GAAG,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;SAC5D;QAED,2EAA2E;QAC3E,OAAO,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,gBAAgB,EAAE,CAAC;IACzD,CAAC;IAEO,iDAAqB,GAA7B,UAA8B,YAAsB,EAAE,SAAkB;QACpE,IAAM,WAAW,GAAG,YAAY,CAAC,eAAe,EAAE,CAAC;QAEnD,0EAA0E;QAC1E,2EAA2E;QAC3E,4EAA4E;QAC5E,2CAA2C;QAC3C,YAAY,CAAC,WAAW,EAAE,CAAC;QAE3B,sCAAsC;QACtC,IAAM,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,SAAS,EAAE,IAAI,CAAa,CAAC;QAEtF,IAAI,QAAQ,IAAI,IAAI,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEvC,oGAAoG;QACpG,mDAAmD;QACnD,QAAQ,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QACxC,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QAC1B,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,gDAAoB,GAA5B,UAA6B,YAAsB,EAAE,SAAkB;QACnE,IAAM,WAAW,GAAG,YAAY,CAAC,eAAe,EAAE,CAAC;QAEnD,sCAAsC;QACtC,IAAM,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,SAAS,EAAE,IAAI,CAAa,CAAC;QACtF,IAAI,QAAQ,IAAI,IAAI,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEvC,IAAM,OAAO,GAAG,QAAQ,CAAC,eAAe,EAAE,CAAC;QAE3C,IAAM,gBAAgB,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QAC1D,IAAM,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QAElD,IAAM,SAAS,GAAG,OAAO,IAAI,WAAW,CAAC,QAAQ,KAAK,OAAO,CAAC,QAAQ,IAAI,WAAW,CAAC,SAAS,KAAK,OAAO,CAAC,SAAS,CAAC;QAEtH,IAAI,gBAAgB,EAAE;YAClB,YAAY,CAAC,mBAAmB,EAAE,CAAC;SACtC;QAED,IAAI,CAAC,SAAS,EAAE;YACZ,IAAM,IAAI,GAAG,YAAY,CAAC,UAAU,EAAE,CAAC;YACvC,IAAK,CAAC,WAAW,EAAE,CAAC;YAEpB,IAAM,IAAI,GAAG,QAAQ,CAAC,UAAU,EAAE,CAAC;YACnC,IAAK,CAAC,eAAe,EAAE,CAAC;SAC3B;QAED,IAAI,YAAY,EAAE;YACd,QAAQ,CAAC,kBAAkB,EAAE,CAAC;YAC9B,QAAQ,CAAC,SAAS,EAAE,CAAC;SACxB;aAAM;YACH,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SAC5B;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,oDAAwB,GAAhC,UAAiC,YAAgC,EAAE,SAAkB;QACjF,IAAM,gBAAgB,GAAG,IAAI,CAAC,WAAW,CAAC,sBAAsB,EAAE,CAAC;QACnE,IAAI,OAAqB,CAAC;QAE1B,IAAI,YAAY,YAAY,iBAAO,EAAE;YACjC,OAAO,yBACA,YAAY,CAAC,cAAc,EAAE,KAChC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAI,CAAC,gBAAgB,CAAC,GACnE,CAAC;SACL;aAAM;YACH,OAAO,GAAG,YAAY,CAAC,eAAe,EAAE,CAAC;SAC5C;QACD,sCAAsC;QACtC,IAAM,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;QAEvE,oGAAoG;QACpG,mDAAmD;QACnD,IAAI,QAAQ,YAAY,mBAAQ,EAAE;YAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SAC5B;aAAM,IAAI,QAAQ,EAAE;YACjB,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE,SAAS,CAAC,CAAC;SAC5E;QAED,OAAO,gBAAM,CAAC,QAAQ,CAAC,CAAC;IAC5B,CAAC;IAED,yDAAyD;IACzD,mEAAmE;IAC3D,iDAAqB,GAA7B,UAA8B,gBAA8B,EAAE,SAAkB,EAAE,YAAqB;QACnG,IAAI,YAAY,GAAwB,gBAAgB,CAAC;QAEzD,OAAO,IAAI,EAAE;YACT,IAAI,CAAC,SAAS,EAAE;gBACZ,YAAY,GAAG,IAAI,CAAC,oBAAoB,CAAC,YAAY,CAAC,CAAC;aAC1D;YACD,YAAY,GAAG,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;YAErF,iDAAiD;YACjD,IAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,CAAC;YAEhE,IAAI,gBAAM,CAAC,QAAQ,CAAC,EAAE;gBAClB,IAAM,MAAM,GAAG;oBACX,SAAS,EAAE,SAAS;oBACpB,OAAO,EAAE,YAAY;oBACrB,oBAAoB,EAAE,gBAAgB;oBACtC,gBAAgB,EAAE,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI;iBAChC,CAAC;gBACzB,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;gBAClC,IAAI,gBAAM,CAAC,QAAQ,CAAC,EAAE;oBAClB,IAAK,QAAgB,CAAC,QAAQ,EAAE;wBAC5B,iBAAM,CAAC,cAAQ,OAAO,CAAC,IAAI,CAAC,sJAAsJ,CAAC,CAAC,CAAC,CAAC,EAAE,yBAAyB,CAAC,CAAC;wBACnN,QAAQ,CAAC,SAAS,GAAI,QAAgB,CAAC,QAAQ,CAAC;qBACnD;oBACD,YAAY,GAAG;wBACX,QAAQ,EAAE,QAAQ,CAAC,QAAQ;wBAC3B,MAAM,EAAE,QAAQ,CAAC,MAAM;wBACvB,SAAS,EAAE,QAAQ,CAAC,SAAS;qBAChB,CAAC;iBACrB;qBAAM;oBACH,YAAY,GAAG,IAAI,CAAC;iBACvB;aACJ;YAED,oFAAoF;YACpF,mEAAmE;YACnE,IAAI,CAAC,YAAY,EAAE;gBAAE,OAAO,IAAI,CAAC;aAAE;YAEnC,IAAI,YAAY,CAAC,QAAQ,GAAG,CAAC,EAAE;gBAC3B,IAAM,SAAS,GAAG,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;gBAEnE,IAAI,CAAC,YAAY,CAAC,mBAAmB,CACjC,EAAE,cAAc,EAAE,SAAS,GAAG,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,YAAY,CAAC,MAAM,EAAE,CACvF,CAAC;gBAEF,OAAO,IAAI,CAAC;aACf;YAED,+EAA+E;YAC/E,kFAAkF;YAClF,sFAAsF;YACtF,oEAAoE;YACpE,2FAA2F;YAC3F,IAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE,CAAC;YAC5D,IAAI,YAAY,IAAI,CAAC,WAAW,EAAE;gBAC9B,IAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;gBACzD,IAAI,CAAC,cAAc,EAAE;oBAAE,SAAS;iBAAE;aACrC;YAED,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;YAErC,0FAA0F;YAC1F,+EAA+E;YAC/E,IAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;YAEtD,wDAAwD;YACxD,iDAAiD;YACjD,IAAI,CAAC,QAAQ,EAAE;gBACX,IAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBAC5D,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE;oBAC5B,SAAS;iBACZ;qBAAM;oBACH,OAAO,GAAG,CAAC;iBACd;aACJ;YAED,IAAI,QAAQ,CAAC,mBAAmB,EAAE,EAAE;gBAAE,SAAS;aAAE;YAEjD,kGAAkG;YAClG,2CAA2C;YAC3C,IAAI,IAAI,CAAC,YAAY,EAAE;gBACnB,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;aAClD;YAED,0DAA0D;YAC1D,OAAO,QAAQ,CAAC;SACnB;IACL,CAAC;IAEO,0CAAc,GAAtB,UAAuB,IAAkB;QACrC,IAAM,OAAO,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;QAEhD,IAAI,OAAO,EAAE;YACT,OAAO,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;SAC9C;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAEM,6CAAiB,GAAxB,UAAyB,YAA0B;QAC/C,IAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;QAChE,IAAI,CAAC,OAAO,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAC9B,OAAO,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IACpD,CAAC;IAEO,gDAAoB,GAA5B,UAA6B,IAAkB;QAC3C,IAAI,IAAI,CAAC,SAAS,KAAK,qBAAS,CAAC,UAAU,EAAE;YACzC,OAAO,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SAC7D;QAED,IAAI,IAAI,CAAC,SAAS,KAAK,qBAAS,CAAC,aAAa,EAAE;YAC5C,OAAO,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SAChE;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtD,CAAC;IAEL,gGAAgG;IAC5F,yFAAyF;IAClF,8CAAkB,GAAzB,UAA0B,KAA2B,EAAE,GAAW,EAAE,WAAyB,EAAE,iBAA0B;QACrH,8FAA8F;QAC9F,IAAI,QAAQ,GAAwB,WAAW,CAAC;QAChD,IAAI,aAAa,GAAG,KAAK,CAAC;QAE1B,OAAO,QAAQ,IAAI,CAAC,QAAQ,KAAK,WAAW,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC,EAAE;YAClF,2EAA2E;YAC3E,2EAA2E;YAC3E,mBAAmB;YACnB,IAAI,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,EAAE;gBACvC,IAAI,GAAG,KAAK,iBAAO,CAAC,IAAI,EAAE;oBACtB,QAAQ,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;iBAClD;aACJ;iBAAM,IAAI,GAAG,KAAK,iBAAO,CAAC,KAAK,EAAE;gBAC9B,QAAQ,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;aAClD;YAED,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,kBAAkB,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;YAExE,gFAAgF;YAChF,aAAa,GAAG,iBAAO,CAAC,QAAQ,CAAC,CAAC;SACrC;QAED,IAAI,aAAa,IAAI,KAAK,IAAI,KAAK,CAAC,OAAO,KAAK,iBAAO,CAAC,EAAE,EAAE;YACxD,QAAQ,GAAG;gBACP,QAAQ,EAAE,CAAC,CAAC;gBACZ,SAAS,EAAE,IAAI;gBACf,MAAM,EAAE,WAAW,CAAC,MAAM;aAC7B,CAAC;SACL;QAED,gGAAgG;QAChG,kFAAkF;QAClF,IAAI,iBAAiB,EAAE;YACnB,IAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,CAAC;YACrE,IAAI,gBAAM,CAAC,QAAQ,CAAC,EAAE;gBAClB,IAAM,MAAM,GAA6B;oBACrC,GAAG,EAAE,GAAG;oBACR,oBAAoB,EAAE,WAAW;oBACjC,gBAAgB,EAAE,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI;oBAC5C,KAAK,EAAE,KAAK;iBACf,CAAC;gBACF,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;gBAClC,IAAI,gBAAM,CAAC,QAAQ,CAAC,EAAE;oBAClB,IAAK,QAAgB,CAAC,QAAQ,EAAE;wBAC5B,iBAAM,CAAC,cAAQ,OAAO,CAAC,IAAI,CAAC,sJAAsJ,CAAC,CAAC,CAAC,CAAC,EAAE,yBAAyB,CAAC,CAAC;wBACnN,QAAQ,CAAC,SAAS,GAAI,QAAgB,CAAC,QAAQ,CAAC;qBACnD;oBACD,QAAQ,GAAG;wBACP,SAAS,EAAE,QAAQ,CAAC,SAAS;wBAC7B,QAAQ,EAAE,QAAQ,CAAC,QAAQ;wBAC3B,MAAM,EAAE,QAAQ,CAAC,MAAM;qBACV,CAAC;iBACrB;qBAAM;oBACH,QAAQ,GAAG,IAAI,CAAC;iBACnB;aACJ;SACJ;QAED,4FAA4F;QAC5F,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO;SAAE;QAE1B,IAAI,QAAQ,CAAC,QAAQ,GAAG,CAAC,EAAE;YACvB,IAAM,SAAS,GAAG,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YAEnE,IAAI,CAAC,YAAY,CAAC,mBAAmB,CACjC,EAAE,cAAc,EAAE,SAAS,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,WAAW,CAAC,MAAM,EAAE,CAClF,CAAC;YAEF,OAAO;SACV;QAED,yEAAyE;QACzE,yEAAyE;QACzE,IAAM,kBAAkB,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;QAChE,IAAI,kBAAkB,EAAE;YACpB,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,CAAC;SAC1C;aAAM;YACH,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;SACzC;IACL,CAAC;IAEO,iDAAqB,GAA7B,UAA8B,YAA0B;QACpD,sEAAsE;QACtE,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;QACrC,IAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;QAEtD,+EAA+E;QAC/E,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAE/B,YAAY,GAAG,QAAQ,CAAC,eAAe,EAAE,CAAC;QAC1C,iGAAiG;QACjG,+FAA+F;QAC/F,6FAA6F;QAC7F,+FAA+F;QAC/F,gBAAgB;QAChB,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;QAErC,OAAO,YAAY,CAAC;IACxB,CAAC;IAEO,kDAAsB,GAA9B,UAA+B,QAAoC,EAAE,SAA0B;QAA1B,0BAAA,EAAA,iBAA0B;QAC3F,IAAM,gBAAgB,GAAG,IAAI,CAAC,WAAW,CAAC,sBAAsB,EAAE,CAAC;QACnE,IAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAC5D,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEzD,IAAM,YAAY,GAAiB;YAC/B,QAAQ,EAAE,QAAQ,CAAC,QAAQ;YAC3B,SAAS,EAAE,QAAQ,CAAC,SAAS;YAC7B,MAAM,EAAG,QAAyB,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,YAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;SAC1G,CAAC;QAEF,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;QAEjC,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,yCAAa,GAArB,UAAsB,YAA0B;QAC5C,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,YAAY,CAAC,QAAQ,EAAE,YAAY,CAAC,MAAM,EAAE,YAAY,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QAE3G,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;SAClD;IACL,CAAC;IAEO,+CAAmB,GAA3B,UAA4B,IAAkB;QAC1C,IAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAEvD,8DAA8D;QAC9D,OAAO,CAAC,CAAC,OAAO,CAAC;IACrB,CAAC;IAEO,gDAAoB,GAA5B,UAA6B,IAAkB;QAC3C,IAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;QAE9C,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAE/B,IAAM,eAAe,GAAG,QAAQ,CAAC,kBAAkB,EAAE,CAAC;QAEtD,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAElD,OAAO;YACH,QAAQ,EAAE,IAAI,CAAC,QAAQ;YACvB,MAAM,EAAE,YAAI,CAAC,eAAe,CAAC;YAC7B,SAAS,EAAE,IAAI,CAAC,SAAS;SAC5B,CAAC;IACN,CAAC;IAEM,6CAAiB,GAAxB,UAAyB,QAAsB;QAC3C,iCAAiC;QACjC,IAAI,iBAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;YAC7B,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;SAC7E;QAED,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE;YAC7B,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;SAC5E;QAED,iGAAiG;QACjG,6CAA6C;QAC7C,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,+CAA+C,EAAE,CAAC;QAEtF,oEAAoE;QACpE,IAAI,CAAC,qBAAqB,CAAC,cAAc,EAAE,CAAC;IAChD,CAAC;IA9sB+B;QAA/B,mBAAS,CAAC,mBAAmB,CAAC;gEAA8C;IAC/C;QAA7B,mBAAS,CAAC,iBAAiB,CAAC;8DAA0C;IAC5C;QAA1B,mBAAS,CAAC,cAAc,CAAC;2DAAoC;IAC1B;QAAnC,mBAAS,CAAC,uBAAuB,CAAC;oEAAsD;IAC/D;QAAzB,kBAAQ,CAAC,cAAc,CAAC;2DAAqC;IACpC;QAAzB,mBAAS,CAAC,aAAa,CAAC;0DAAkC;IAChC;QAA1B,mBAAS,CAAC,cAAc,CAAC;2DAAmC;IACnC;QAAzB,mBAAS,CAAC,aAAa,CAAC;0DAAiC;IACpB;QAArC,mBAAS,CAAC,yBAAyB,CAAC;sEAAyD;IAC/D;QAA9B,mBAAS,CAAC,kBAAkB,CAAC;+DAA4C;IACtC;QAAnC,mBAAS,CAAC,uBAAuB,CAAC;oEAAsD;IAC5D;QAA5B,mBAAS,CAAC,gBAAgB,CAAC;6DAAwC;IAOpE;QADC,uBAAa;0DAKb;IAxBQ,iBAAiB;QAD7B,cAAI,CAAC,mBAAmB,CAAC;OACb,iBAAiB,CAitB7B;IAAD,wBAAC;CAjtBD,AAitBC,CAjtBsC,mBAAQ,GAitB9C;AAjtBY,8CAAiB","file":"navigationService.js","sourcesContent":["import { Autowired, Bean, Optional, PostConstruct } from \"../context/context\";\nimport { CellPosition } from \"../entities/cellPosition\";\nimport { MouseEventService } from \"./mouseEventService\";\nimport { PaginationProxy } from \"../pagination/paginationProxy\";\nimport { Column } from \"../entities/column\";\nimport { FocusService } from \"../focusService\";\nimport { AnimationFrameService } from \"../misc/animationFrameService\";\nimport { IRangeService } from \"../interfaces/IRangeService\";\nimport { ColumnModel } from \"../columns/columnModel\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { exists, missing } from \"../utils/generic\";\nimport { last } from \"../utils/array\";\nimport { KeyCode } from '../constants/keyCode';\nimport { CtrlsService } from \"../ctrlsService\";\nimport { GridBodyCtrl } from \"./gridBodyCtrl\";\nimport { CellCtrl } from \"../rendering/cell/cellCtrl\";\nimport { RowCtrl } from \"../rendering/row/rowCtrl\";\nimport { NavigateToNextCellParams, TabToNextCellParams } from \"../entities/gridOptions\";\nimport { doOnce } from \"../utils/function\";\nimport { Constants } from \"../constants/constants\";\nimport { RowPosition, RowPositionUtils } from \"../entities/rowPosition\";\nimport { RowRenderer } from \"../rendering/rowRenderer\";\nimport { HeaderNavigationService } from \"../headerRendering/header/headerNavigationService\";\nimport { CellNavigationService } from \"../cellNavigationService\";\nimport { PinnedRowModel } from \"../pinnedRowModel/pinnedRowModel\";\n\ninterface NavigateParams {\n     // The rowIndex to vertically scroll to\n    scrollIndex: number;\n     // The position to put scroll index\n    scrollType: 'top' | 'bottom' | null;\n    //  The column to horizontally scroll to\n    scrollColumn: Column | null;\n    // For page up/down, we want to scroll to one row/column but focus another (ie. scrollRow could be stub).\n    focusIndex: number;\n    focusColumn: Column;\n}\n\n@Bean('navigationService')\nexport class NavigationService extends BeanStub {\n\n    @Autowired('mouseEventService') private mouseEventService: MouseEventService;\n    @Autowired('paginationProxy') private paginationProxy: PaginationProxy;\n    @Autowired('focusService') private focusService: FocusService;\n    @Autowired('animationFrameService') private animationFrameService: AnimationFrameService;\n    @Optional('rangeService') private rangeService: IRangeService;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('ctrlsService') public ctrlsService: CtrlsService;\n    @Autowired('rowRenderer') public rowRenderer: RowRenderer;\n    @Autowired('headerNavigationService') public headerNavigationService: HeaderNavigationService;\n    @Autowired(\"rowPositionUtils\") private rowPositionUtils: RowPositionUtils;\n    @Autowired(\"cellNavigationService\") private cellNavigationService: CellNavigationService;\n    @Autowired(\"pinnedRowModel\") private pinnedRowModel: PinnedRowModel;\n\n    private gridBodyCon: GridBodyCtrl;\n\n    private timeLastPageEventProcessed = 0;\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.ctrlsService.whenReady(p => {\n            this.gridBodyCon = p.gridBodyCtrl;\n        });\n    }\n\n    public handlePageScrollingKey(event: KeyboardEvent): boolean {\n        const key = event.which || event.keyCode;\n        const alt = event.altKey;\n        const ctrl = event.ctrlKey || event.metaKey;\n\n        const currentCell: CellPosition | null = this.mouseEventService.getCellPositionForEvent(event);\n        if (!currentCell) { return false; }\n\n        let processed = false;\n\n        switch (key) {\n            case KeyCode.PAGE_HOME:\n            case KeyCode.PAGE_END:\n                // handle home and end when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onHomeOrEndKey(key);\n                    processed = true;\n                }\n                break;\n            case KeyCode.LEFT:\n            case KeyCode.RIGHT:\n                // handle left and right when ctrl is pressed only\n                if (ctrl && !alt) {\n                    this.onCtrlLeftOrRight(key, currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.UP:\n            case KeyCode.DOWN:\n                // handle up and down when ctrl is pressed only\n                if (ctrl && !alt) {\n                    this.onCtrlUpOrDown(key, currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.PAGE_DOWN:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageDown(currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.PAGE_UP:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageUp(currentCell);\n                    processed = true;\n                }\n                break;\n        }\n\n        if (processed) {\n            event.preventDefault();\n        }\n\n        return processed;\n    }\n\n    // the page up/down keys caused a problem, in that if the user\n    // held the page up/down key down, lots of events got generated,\n    // which clogged up the event queue (as they take time to process)\n    // which in turn froze the grid. Logic below makes sure we wait 100ms\n    // between processing the page up/down events, so when user has finger\n    // held down on key, we ignore page up/down events until 100ms has passed,\n    // which effectively empties the queue of page up/down events.\n    private isTimeSinceLastPageEventToRecent(): boolean {\n        const now = new Date().getTime();\n        const diff = now - this.timeLastPageEventProcessed;\n\n        return (diff < 100);\n    }\n\n    private setTimeLastPageEventProcessed(): void {\n        this.timeLastPageEventProcessed = new Date().getTime();\n    }\n\n    private navigateTo(navigateParams: NavigateParams): void {\n        const { scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn } = navigateParams;\n\n        if (exists(scrollColumn) && !scrollColumn.isPinned()) {\n            this.gridBodyCon.getScrollFeature().ensureColumnVisible(scrollColumn);\n        }\n\n        if (exists(scrollIndex)) {\n            this.gridBodyCon.getScrollFeature().ensureIndexVisible(scrollIndex, scrollType);\n        }\n\n        // make sure the cell is rendered, needed if we are to focus\n        this.animationFrameService.flushAllFrames();\n\n        // if we don't do this, the range will be left on the last cell, which will leave the last focused cell\n        // highlighted.\n        this.focusService.setFocusedCell(focusIndex, focusColumn, null, true);\n\n        if (this.rangeService) {\n            const cellPosition: CellPosition = { rowIndex: focusIndex, rowPinned: null, column: focusColumn };\n            this.rangeService.setRangeToCell(cellPosition);\n        }\n    }\n\n    private onPageDown(gridCell: CellPosition): void {\n        if (this.isTimeSinceLastPageEventToRecent()) { return; }\n\n        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n        const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n        const scrollbarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n        let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;\n\n        if (this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing()) {\n            pixelsInOnePage -= scrollbarWidth;\n        }\n\n        const pagingPixelOffset = this.paginationProxy.getPixelOffset();\n\n        const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;\n        const currentPageBottomRow = this.paginationProxy.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);\n        let scrollIndex = currentPageBottomRow;\n\n        const currentCellPixel = this.paginationProxy.getRow(gridCell.rowIndex)!.rowTop;\n        const nextCellPixel = currentCellPixel! + pixelsInOnePage - pagingPixelOffset;\n        let focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n\n        const pageLastRow = this.paginationProxy.getPageLastRow();\n\n        if (focusIndex > pageLastRow) { focusIndex = pageLastRow; }\n        if (scrollIndex > pageLastRow) { scrollIndex = pageLastRow; }\n\n        this.navigateTo({\n            scrollIndex,\n            scrollType: 'top',\n            scrollColumn: null,\n            focusIndex,\n            focusColumn: gridCell.column\n        });\n\n        this.setTimeLastPageEventProcessed();\n    }\n\n    private onPageUp(gridCell: CellPosition): void {\n        if (this.isTimeSinceLastPageEventToRecent()) { return; }\n\n        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n        const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n        const scrollbarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n        let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;\n\n        if (this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing()) {\n            pixelsInOnePage -= scrollbarWidth;\n        }\n\n        const pagingPixelOffset = this.paginationProxy.getPixelOffset();\n\n        const currentPageTopPixel = scrollPosition.top;\n        const currentPageTopRow = this.paginationProxy.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);\n        let scrollIndex = currentPageTopRow;\n\n        const currentRowNode = this.paginationProxy.getRow(gridCell.rowIndex)!;\n        const nextCellPixel = currentRowNode.rowTop! + currentRowNode.rowHeight! - pixelsInOnePage - pagingPixelOffset;\n        let focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n\n        const firstRow = this.paginationProxy.getPageFirstRow();\n\n        if (focusIndex < firstRow) { focusIndex = firstRow; }\n        if (scrollIndex < firstRow) { scrollIndex = firstRow; }\n\n        this.navigateTo({\n            scrollIndex,\n            scrollType: 'bottom',\n            scrollColumn: null,\n            focusIndex,\n            focusColumn: gridCell.column\n        });\n\n        this.setTimeLastPageEventProcessed();\n    }\n\n    private getIndexToFocus(indexToScrollTo: number, isDown: boolean) {\n        let indexToFocus = indexToScrollTo;\n\n        // for SSRM, when user hits ctrl+down, we can end up trying to focus the loading row.\n        // instead we focus the last row with data instead.\n        if (isDown) {\n            const node = this.paginationProxy.getRow(indexToScrollTo);\n            if (node && node.stub) {\n                indexToFocus -= 1;\n            }\n        }\n\n        return indexToFocus;\n    }\n\n    // ctrl + up/down will bring focus to same column, first/last row. no horizontal scrolling.\n    private onCtrlUpOrDown(key: number, gridCell: CellPosition): void {\n        const upKey = key === KeyCode.UP;\n        const rowIndexToScrollTo = upKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();\n\n        this.navigateTo({\n            scrollIndex: rowIndexToScrollTo,\n            scrollType: null,\n            scrollColumn: gridCell.column,\n            focusIndex: this.getIndexToFocus(rowIndexToScrollTo, !upKey),\n            focusColumn: gridCell.column\n        });\n    }\n\n    // ctrl + left/right will bring focus to same row, first/last cell. no vertical scrolling.\n    private onCtrlLeftOrRight(key: number, gridCell: CellPosition): void {\n        const leftKey = key === KeyCode.LEFT;\n        const allColumns: Column[] = this.columnModel.getAllDisplayedColumns();\n        const columnToSelect: Column = leftKey ? allColumns[0] : last(allColumns);\n\n        this.navigateTo({\n            scrollIndex: gridCell.rowIndex,\n            scrollType: null,\n            scrollColumn: columnToSelect,\n            focusIndex: gridCell.rowIndex,\n            focusColumn: columnToSelect\n        });\n    }\n\n    // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring\n    // same cell into view (which means either scroll all the way up, or all the way down).\n    private onHomeOrEndKey(key: number): void {\n        const homeKey = key === KeyCode.PAGE_HOME;\n        const allColumns: Column[] = this.columnModel.getAllDisplayedColumns();\n        const columnToSelect = homeKey ? allColumns[0] : last(allColumns);\n        const scrollIndex = homeKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();\n\n        this.navigateTo({\n            scrollIndex: scrollIndex,\n            scrollType: null,\n            scrollColumn: columnToSelect,\n            focusIndex: this.getIndexToFocus(scrollIndex, !homeKey),\n            focusColumn: columnToSelect\n        });\n    }\n\n    // result of keyboard event\n    public onTabKeyDown(previous: CellCtrl | RowCtrl, keyboardEvent: KeyboardEvent): void {\n        const backwards = keyboardEvent.shiftKey;\n        const movedToNextCell = this.tabToNextCellCommon(previous, backwards);\n\n        if (movedToNextCell) {\n            // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n            // to the normal tabbing so user can exit the grid.\n            keyboardEvent.preventDefault();\n            return;\n        }\n\n        // if we didn't move to next cell, then need to tab out of the cells, ie to the header (if going\n        // backwards)\n        if (backwards) {\n            const { rowIndex, rowPinned } = previous.getRowPosition();\n            const firstRow = rowPinned ? rowIndex === 0 : rowIndex === this.paginationProxy.getPageFirstRow();\n            if (firstRow) {\n                keyboardEvent.preventDefault();\n\n                const headerRowIndex = this.headerNavigationService.getHeaderRowCount() - 1;\n                const column = last(this.columnModel.getAllDisplayedColumns());\n\n                this.focusService.focusHeaderPosition({ headerRowIndex, column });\n            }\n        } else {\n            // if the case it's a popup editor, the focus is on the editor and not the previous cell.\n            // in order for the tab navigation to work, we need to focus the browser back onto the\n            // previous cell.\n            if (previous instanceof CellCtrl) {\n                previous.focusCell(true);\n            }\n\n            if (this.focusService.focusNextGridCoreContainer(false)) {\n                keyboardEvent.preventDefault();\n            }\n        }\n    }\n\n    // comes from API\n    public tabToNextCell(backwards: boolean): boolean {\n        const focusedCell = this.focusService.getFocusedCell();\n        // if no focus, then cannot navigate\n        if (!focusedCell) { return false; }\n\n        let cellOrRow: CellCtrl | RowCtrl | null = this.getCellByPosition(focusedCell);\n\n        // if cell is not rendered, means user has scrolled away from the cell\n        // or that the focusedCell is a Full Width Row\n        if (!cellOrRow) {\n            cellOrRow = this.rowRenderer.getRowByPosition(focusedCell);\n            if (!cellOrRow || !cellOrRow.isFullWidth()) {\n                return false;\n            }\n        }\n\n        return this.tabToNextCellCommon(cellOrRow, backwards);\n    }\n\n    private tabToNextCellCommon(previous: CellCtrl | RowCtrl, backwards: boolean): boolean {\n        let editing = previous.isEditing();\n\n        // if cell is not editing, there is still chance row is editing if it's Full Row Editing\n        if (!editing && previous instanceof CellCtrl) {\n            const cell = previous as CellCtrl;\n            const row = cell.getRowCtrl();\n            if (row) {\n                editing = row.isEditing();\n            }\n        }\n\n        let res: boolean;\n\n        if (editing) {\n            // if we are editing, we know it's not a Full Width Row (RowComp)\n            if (this.gridOptionsWrapper.isFullRowEdit()) {\n                res = this.moveToNextEditingRow(previous as CellCtrl, backwards);\n            } else {\n                res = this.moveToNextEditingCell(previous as CellCtrl, backwards);\n            }\n        } else {\n            res = this.moveToNextCellNotEditing(previous, backwards);\n        }\n\n        // if a cell wasn't found, it's possible that focus was moved to the header\n        return res || !!this.focusService.getFocusedHeader();\n    }\n\n    private moveToNextEditingCell(previousCell: CellCtrl, backwards: boolean): boolean {\n        const previousPos = previousCell.getCellPosition();\n\n        // need to do this before getting next cell to edit, in case the next cell\n        // has editable function (eg colDef.editable=func() ) and it depends on the\n        // result of this cell, so need to save updates from the first edit, in case\n        // the value is referenced in the function.\n        previousCell.stopEditing();\n\n        // find the next cell to start editing\n        const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true) as CellCtrl;\n\n        if (nextCell == null) { return false; }\n\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        nextCell.startEditing(null, null, true);\n        nextCell.focusCell(false);\n        return true;\n    }\n\n    private moveToNextEditingRow(previousCell: CellCtrl, backwards: boolean): boolean {\n        const previousPos = previousCell.getCellPosition();\n\n        // find the next cell to start editing\n        const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true) as CellCtrl;\n        if (nextCell == null) { return false; }\n\n        const nextPos = nextCell.getCellPosition();\n\n        const previousEditable = this.isCellEditable(previousPos);\n        const nextEditable = this.isCellEditable(nextPos);\n\n        const rowsMatch = nextPos && previousPos.rowIndex === nextPos.rowIndex && previousPos.rowPinned === nextPos.rowPinned;\n\n        if (previousEditable) {\n            previousCell.setFocusOutOnEditor();\n        }\n\n        if (!rowsMatch) {\n            const pRow = previousCell.getRowCtrl();\n            pRow!.stopEditing();\n\n            const nRow = nextCell.getRowCtrl();\n            nRow!.startRowEditing();\n        }\n\n        if (nextEditable) {\n            nextCell.setFocusInOnEditor();\n            nextCell.focusCell();\n        } else {\n            nextCell.focusCell(true);\n        }\n\n        return true;\n    }\n\n    private moveToNextCellNotEditing(previousCell: CellCtrl | RowCtrl, backwards: boolean): boolean {\n        const displayedColumns = this.columnModel.getAllDisplayedColumns();\n        let cellPos: CellPosition;\n\n        if (previousCell instanceof RowCtrl) {\n            cellPos = {\n                ...previousCell.getRowPosition(),\n                column: backwards ? displayedColumns[0] : last(displayedColumns)\n            };\n        } else {\n            cellPos = previousCell.getCellPosition();\n        }\n        // find the next cell to start editing\n        const nextCell = this.findNextCellToFocusOn(cellPos, backwards, false);\n\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (nextCell instanceof CellCtrl) {\n            nextCell.focusCell(true);\n        } else if (nextCell) {\n            return this.tryToFocusFullWidthRow(nextCell.getRowPosition(), backwards);\n        }\n\n        return exists(nextCell);\n    }\n\n    // called by the cell, when tab is pressed while editing.\n    // @return: RenderedCell when navigation successful, otherwise null\n    private findNextCellToFocusOn(previousPosition: CellPosition, backwards: boolean, startEditing: boolean): CellCtrl | RowCtrl | null {\n        let nextPosition: CellPosition | null = previousPosition;\n\n        while (true) {\n            if (!backwards) {\n                nextPosition = this.getLastCellOfColSpan(nextPosition);\n            }\n            nextPosition = this.cellNavigationService.getNextTabbedCell(nextPosition, backwards);\n\n            // allow user to override what cell to go to next\n            const userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n\n            if (exists(userFunc)) {\n                const params = {\n                    backwards: backwards,\n                    editing: startEditing,\n                    previousCellPosition: previousPosition,\n                    nextCellPosition: nextPosition ? nextPosition : null\n                } as TabToNextCellParams;\n                const userCell = userFunc(params);\n                if (exists(userCell)) {\n                    if ((userCell as any).floating) {\n                        doOnce(() => { console.warn(`AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`); }, 'no floating in userCell');\n                        userCell.rowPinned = (userCell as any).floating;\n                    }\n                    nextPosition = {\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column,\n                        rowPinned: userCell.rowPinned\n                    } as CellPosition;\n                } else {\n                    nextPosition = null;\n                }\n            }\n\n            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n            // so bottom right cell going forwards, or top left going backwards\n            if (!nextPosition) { return null; }\n\n            if (nextPosition.rowIndex < 0) {\n                const headerLen = this.headerNavigationService.getHeaderRowCount();\n\n                this.focusService.focusHeaderPosition(\n                    { headerRowIndex: headerLen + (nextPosition.rowIndex), column: nextPosition.column }\n                );\n\n                return null;\n            }\n\n            // if editing, but cell not editable, skip cell. we do this before we do all of\n            // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n            // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n            // (except for the last one) which causes grid to stall for a while.\n            // note - for full row edit, we do focus non-editable cells, as the row stays in edit mode.\n            const fullRowEdit = this.gridOptionsWrapper.isFullRowEdit();\n            if (startEditing && !fullRowEdit) {\n                const cellIsEditable = this.isCellEditable(nextPosition);\n                if (!cellIsEditable) { continue; }\n            }\n\n            this.ensureCellVisible(nextPosition);\n\n            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n            // or row that is not currently in view, hence the renderedCell would not exist\n            const nextCell = this.getCellByPosition(nextPosition);\n\n            // if next cell is fullWidth row, then no rendered cell,\n            // as fullWidth rows have no cells, so we skip it\n            if (!nextCell) {\n                const row = this.rowRenderer.getRowByPosition(nextPosition);\n                if (!row || !row.isFullWidth()) {\n                    continue;\n                } else {\n                    return row;\n                }\n            }\n\n            if (nextCell.isSuppressNavigable()) { continue; }\n\n            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n            // consistent, we set into range here also.\n            if (this.rangeService) {\n                this.rangeService.setRangeToCell(nextPosition);\n            }\n\n            // we successfully tabbed onto a grid cell, so return true\n            return nextCell;\n        }\n    }\n\n    private isCellEditable(cell: CellPosition): boolean {\n        const rowNode = this.lookupRowNodeForCell(cell);\n\n        if (rowNode) {\n            return cell.column.isCellEditable(rowNode);\n        }\n\n        return false;\n    }\n\n    public getCellByPosition(cellPosition: CellPosition): CellCtrl | null {\n        const rowCtrl = this.rowRenderer.getRowByPosition(cellPosition);\n        if (!rowCtrl) { return null; }\n        return rowCtrl.getCellCtrl(cellPosition.column);\n    }\n\n    private lookupRowNodeForCell(cell: CellPosition) {\n        if (cell.rowPinned === Constants.PINNED_TOP) {\n            return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n        }\n\n        if (cell.rowPinned === Constants.PINNED_BOTTOM) {\n            return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n        }\n\n        return this.paginationProxy.getRow(cell.rowIndex);\n    }\n\n// we use index for rows, but column object for columns, as the next column (by index) might not\n    // be visible (header grouping) so it's not reliable, so using the column object instead.\n    public navigateToNextCell(event: KeyboardEvent | null, key: number, currentCell: CellPosition, allowUserOverride: boolean) {\n        // we keep searching for a next cell until we find one. this is how the group rows get skipped\n        let nextCell: CellPosition | null = currentCell;\n        let hitEdgeOfGrid = false;\n\n        while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {\n            // if the current cell is spanning across multiple columns, we need to move\n            // our current position to be the last cell on the right before finding the\n            // the next target.\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                if (key === KeyCode.LEFT) {\n                    nextCell = this.getLastCellOfColSpan(nextCell);\n                }\n            } else if (key === KeyCode.RIGHT) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n\n            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);\n\n            // eg if going down, and nextCell=undefined, means we are gone past the last row\n            hitEdgeOfGrid = missing(nextCell);\n        }\n\n        if (hitEdgeOfGrid && event && event.keyCode === KeyCode.UP) {\n            nextCell = {\n                rowIndex: -1,\n                rowPinned: null,\n                column: currentCell.column\n            };\n        }\n\n        // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n        // we allow this, however if processing 'enter after edit' we don't allow override\n        if (allowUserOverride) {\n            const userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n            if (exists(userFunc)) {\n                const params: NavigateToNextCellParams = {\n                    key: key,\n                    previousCellPosition: currentCell,\n                    nextCellPosition: nextCell ? nextCell : null,\n                    event: event\n                };\n                const userCell = userFunc(params);\n                if (exists(userCell)) {\n                    if ((userCell as any).floating) {\n                        doOnce(() => { console.warn(`AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`); }, 'no floating in userCell');\n                        userCell.rowPinned = (userCell as any).floating;\n                    }\n                    nextCell = {\n                        rowPinned: userCell.rowPinned,\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column\n                    } as CellPosition;\n                } else {\n                    nextCell = null;\n                }\n            }\n        }\n\n        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n        if (!nextCell) { return; }\n\n        if (nextCell.rowIndex < 0) {\n            const headerLen = this.headerNavigationService.getHeaderRowCount();\n\n            this.focusService.focusHeaderPosition(\n                { headerRowIndex: headerLen + (nextCell.rowIndex), column: currentCell.column }\n            );\n\n            return;\n        }\n\n        // in case we have col spanning we get the cellComp and use it to get the\n        // position. This was we always focus the first cell inside the spanning.\n        const normalisedPosition = this.getNormalisedPosition(nextCell);\n        if (normalisedPosition) {\n            this.focusPosition(normalisedPosition);\n        } else {\n            this.tryToFocusFullWidthRow(nextCell);\n        }\n    }\n\n    private getNormalisedPosition(cellPosition: CellPosition): CellPosition | null {\n        // ensureCellVisible first, to make sure cell at position is rendered.\n        this.ensureCellVisible(cellPosition);\n        const cellComp = this.getCellByPosition(cellPosition);\n\n        // not guaranteed to have a cellComp when using the SSRM as blocks are loading.\n        if (!cellComp) { return null; }\n\n        cellPosition = cellComp.getCellPosition();\n        // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n        // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n        // last column in the group, however now it's the first column in the group). if we didn't do\n        // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n        // merged cells.\n        this.ensureCellVisible(cellPosition);\n\n        return cellPosition;\n    }\n\n    private tryToFocusFullWidthRow(position: CellPosition | RowPosition, backwards: boolean = false): boolean {\n        const displayedColumns = this.columnModel.getAllDisplayedColumns();\n        const rowComp = this.rowRenderer.getRowByPosition(position);\n        if (!rowComp || !rowComp.isFullWidth()) { return false; }\n\n        const cellPosition: CellPosition = {\n            rowIndex: position.rowIndex,\n            rowPinned: position.rowPinned,\n            column: (position as CellPosition).column || (backwards ? last(displayedColumns) : displayedColumns[0])\n        };\n\n        this.focusPosition(cellPosition);\n\n        return true;\n    }\n\n    private focusPosition(cellPosition: CellPosition) {\n        this.focusService.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n\n        if (this.rangeService) {\n            this.rangeService.setRangeToCell(cellPosition);\n        }\n    }\n\n    private isValidNavigateCell(cell: CellPosition): boolean {\n        const rowNode = this.rowPositionUtils.getRowNode(cell);\n\n        // we do not allow focusing on detail rows and full width rows\n        return !!rowNode;\n    }\n\n    private getLastCellOfColSpan(cell: CellPosition): CellPosition {\n        const cellCtrl = this.getCellByPosition(cell);\n\n        if (!cellCtrl) { return cell; }\n\n        const colSpanningList = cellCtrl.getColSpanningList();\n\n        if (colSpanningList.length === 1) { return cell; }\n\n        return {\n            rowIndex: cell.rowIndex,\n            column: last(colSpanningList),\n            rowPinned: cell.rowPinned\n        };\n    }\n\n    public ensureCellVisible(gridCell: CellPosition): void {\n        // this scrolls the row into view\n        if (missing(gridCell.rowPinned)) {\n            this.gridBodyCon.getScrollFeature().ensureIndexVisible(gridCell.rowIndex);\n        }\n\n        if (!gridCell.column.isPinned()) {\n            this.gridBodyCon.getScrollFeature().ensureColumnVisible(gridCell.column);\n        }\n\n        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n        // floating cell, the scrolls get out of sync\n        this.gridBodyCon.getScrollFeature().horizontallyScrollHeaderCenterAndFloatingCenter();\n\n        // need to flush frames, to make sure the correct cells are rendered\n        this.animationFrameService.flushAllFrames();\n    }\n}\n"]}