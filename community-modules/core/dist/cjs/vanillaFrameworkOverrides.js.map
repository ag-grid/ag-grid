{"version":3,"sources":["../../src/ts/vanillaFrameworkOverrides.ts"],"names":[],"mappings":";;;;;;;;AACA,uCAAyC;AACzC,iCAAkC;AAElC,IAAM,sBAAsB,GAAG,CAAC,WAAW,EAAE,UAAU,EAAE,YAAY,EAAE,YAAY,CAAC,CAAC;AAErF,wHAAwH;AACxH;IAAA;QAYW,qBAAgB,GAAG,UAAC,SAAgB,IAAK,OAAA,gBAAQ,CAAC,sBAAsB,EAAE,SAAS,CAAC,EAA3C,CAA2C,CAAC;IAiBhG,CAAC;IA3BG,wCAAwC;IACjC,8CAAU,GAAjB,UAAkB,MAAW,EAAE,OAAa;QACxC,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IACvC,CAAC;IACM,+CAAW,GAAlB,UAAmB,MAAW,EAAE,OAAa;QACzC,OAAO,IAAI,iBAAS,CAAC,UAAA,OAAO;YACxB,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;QAChD,CAAC,CAAC,CAAA;IACN,CAAC;IAID,uDAAuD;IAChD,oDAAgB,GAAvB,UAAwB,OAAoB,EAAE,IAAY,EAClC,QAA4C,EAC5C,UAAoB;QACxC,OAAO,CAAC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;IACzD,CAAC;IAED,+CAA+C;IAC/C,iDAAa,GAAb,UAAc,SAAiB,EAAE,QAAkB,EAAE,MAAc;QAAd,uBAAA,EAAA,cAAc;QAC/D,QAAQ,EAAE,CAAC;IACf,CAAC;IAED,sDAAkB,GAAlB,UAAmB,IAAY;QAC3B,OAAO,IAAI,CAAC;IAChB,CAAC;IACL,gCAAC;AAAD,CA7BA,AA6BC,IAAA;AA7BY,8DAAyB","file":"vanillaFrameworkOverrides.js","sourcesContent":["import { IFrameworkOverrides } from \"./interfaces/iFrameworkOverrides\";\nimport { includes } from \"./utils/array\";\nimport {AgPromise} from \"./utils\";\n\nconst OUTSIDE_ANGULAR_EVENTS = ['mouseover', 'mouseout', 'mouseenter', 'mouseleave'];\n\n/** The base frameworks, eg React & Angular 2, override this bean with implementations specific to their requirement. */\nexport class VanillaFrameworkOverrides implements IFrameworkOverrides {\n\n    // for Vanilla JS, we use simple timeout\n    public setTimeout(action: any, timeout?: any): void {\n        window.setTimeout(action, timeout);\n    }\n    public setInterval(action: any, timeout?: any): AgPromise<number> {\n        return new AgPromise(resolve => {\n            resolve(window.setTimeout(action, timeout));\n        })\n    }\n\n    public isOutsideAngular = (eventType:string) => includes(OUTSIDE_ANGULAR_EVENTS, eventType);\n\n    // for Vanilla JS, we just add the event to the element\n    public addEventListener(element: HTMLElement, type: string,\n                            listener: EventListenerOrEventListenerObject,\n                            useCapture?: boolean): void {\n        element.addEventListener(type, listener, useCapture);\n    }\n\n    // for Vanilla JS, we just execute the listener\n    dispatchEvent(eventType: string, listener: () => {}, global = false): void {\n        listener();\n    }\n\n    frameworkComponent(name: string): any {\n        return null;\n    }\n}\n"]}