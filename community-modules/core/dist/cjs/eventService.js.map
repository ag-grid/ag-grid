{"version":3,"sources":["../../src/ts/eventService.ts"],"names":[],"mappings":"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","file":"eventService.js","sourcesContent":["import { Logger } from \"./logger\";\nimport { LoggerFactory } from \"./logger\";\nimport { Bean } from \"./context/context\";\nimport { Qualifier } from \"./context/context\";\nimport { IEventEmitter } from \"./interfaces/iEventEmitter\";\nimport { GridOptionsWrapper } from \"./gridOptionsWrapper\";\nimport { AgEvent } from \"./events\";\n\n@Bean('eventService')\nexport class EventService implements IEventEmitter {\n\n    private allSyncListeners = new Map<string, Set<Function>>();\n    private allAsyncListeners = new Map<string, Set<Function>>();\n\n    private globalSyncListeners = new Set<Function>();\n    private globalAsyncListeners = new Set<Function>();\n\n    private logger: Logger;\n\n    private asyncFunctionsQueue: Function[] = [];\n    private scheduled = false;\n\n    // using an object performs better than a Set for the number of different events we have\n    private firedEvents: { [key: string]: boolean; } = {};\n\n    // because this class is used both inside the context and outside the context, we do not\n    // use autowired attributes, as that would be confusing, as sometimes the attributes\n    // would be wired, and sometimes not.\n    //\n    // the global event servers used by ag-Grid is autowired by the context once, and this\n    // setBeans method gets called once.\n    //\n    // the times when this class is used outside of the context (eg RowNode has an instance of this\n    // class) then it is not a bean, and this setBeans method is not called.\n    public setBeans(\n        @Qualifier('loggerFactory') loggerFactory: LoggerFactory,\n        @Qualifier('gridOptionsWrapper') gridOptionsWrapper: GridOptionsWrapper,\n        @Qualifier('globalEventListener') globalEventListener: Function = null) {\n        this.logger = loggerFactory.create('EventService');\n\n        if (globalEventListener) {\n            const async = gridOptionsWrapper.useAsyncEvents();\n            this.addGlobalListener(globalEventListener, async);\n        }\n    }\n\n    private getListeners(eventType: string, async: boolean): Set<Function> {\n        const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n        let listeners = listenerMap.get(eventType);\n\n        if (!listeners) {\n            listeners = new Set<Function>();\n            listenerMap.set(eventType, listeners);\n        }\n\n        return listeners;\n    }\n\n    public addEventListener(eventType: string, listener: Function, async = false): void {\n        this.getListeners(eventType, async).add(listener);\n    }\n\n    public removeEventListener(eventType: string, listener: Function, async = false): void {\n        this.getListeners(eventType, async).delete(listener);\n    }\n\n    public addGlobalListener(listener: Function, async = false): void {\n        (async ? this.globalAsyncListeners : this.globalSyncListeners).add(listener);\n    }\n\n    public removeGlobalListener(listener: Function, async = false): void {\n        (async ? this.globalAsyncListeners : this.globalSyncListeners).delete(listener);\n    }\n\n    public dispatchEvent(event: AgEvent): void {\n        this.dispatchToListeners(event, true);\n        this.dispatchToListeners(event, false);\n\n        this.firedEvents[event.type] = true;\n    }\n\n    public dispatchEventOnce(event: AgEvent): void {\n        if (!this.firedEvents[event.type]) {\n            this.dispatchEvent(event);\n        }\n    }\n\n    private dispatchToListeners(event: AgEvent, async: boolean) {\n        const eventType = event.type;\n        const processEventListeners = (listeners: Set<Function>) => listeners.forEach(listener => {\n            if (async) {\n                this.dispatchAsync(() => listener(event));\n            } else {\n                listener(event);\n            }\n        });\n\n        processEventListeners(this.getListeners(eventType, async));\n\n        const globalListeners = async ? this.globalAsyncListeners : this.globalSyncListeners;\n\n        globalListeners.forEach(listener => {\n            if (async) {\n                this.dispatchAsync(() => listener(eventType, event));\n            } else {\n                listener(eventType, event);\n            }\n        });\n    }\n\n    // this gets called inside the grid's thread, for each event that it\n    // wants to set async. the grid then batches the events into one setTimeout()\n    // because setTimeout() is an expensive operation. ideally we would have\n    // each event in it's own setTimeout(), but we batch for performance.\n    private dispatchAsync(func: Function): void {\n        // add to the queue for executing later in the next VM turn\n        this.asyncFunctionsQueue.push(func);\n\n        // check if timeout is already scheduled. the first time the grid calls\n        // this within it's thread turn, this should be false, so it will schedule\n        // the 'flush queue' method the first time it comes here. then the flag is\n        // set to 'true' so it will know it's already scheduled for subsequent calls.\n        if (!this.scheduled) {\n            // if not scheduled, schedule one\n            window.setTimeout(this.flushAsyncQueue.bind(this), 0);\n            // mark that it is scheduled\n            this.scheduled = true;\n        }\n    }\n\n    // this happens in the next VM turn only, and empties the queue of events\n    private flushAsyncQueue(): void {\n        this.scheduled = false;\n\n        // we take a copy, because the event listener could be using\n        // the grid, which would cause more events, which would be potentially\n        // added to the queue, so safe to take a copy, the new events will\n        // get executed in a later VM turn rather than risk updating the\n        // queue as we are flushing it.\n        const queueCopy = this.asyncFunctionsQueue.slice();\n        this.asyncFunctionsQueue = [];\n\n        // execute the queue\n        queueCopy.forEach(func => func());\n    }\n}\n"]}