{"version":3,"sources":["../../src/ts/eventService.ts"],"names":[],"mappings":"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","file":"eventService.js","sourcesContent":["import { Logger, LoggerFactory } from \"./logger\";\nimport { Bean, Qualifier } from \"./context/context\";\nimport { IEventEmitter } from \"./interfaces/iEventEmitter\";\nimport { GridOptionsWrapper } from \"./gridOptionsWrapper\";\nimport { AgEvent } from \"./events\";\nimport { IFrameworkOverrides } from \"./interfaces/iFrameworkOverrides\";\n\n@Bean('eventService')\nexport class EventService implements IEventEmitter {\n\n    private allSyncListeners = new Map<string, Set<Function>>();\n    private allAsyncListeners = new Map<string, Set<Function>>();\n\n    private globalSyncListeners = new Set<Function>();\n    private globalAsyncListeners = new Set<Function>();\n\n    private logger: Logger;\n    private frameworkOverrides: IFrameworkOverrides;\n\n    private asyncFunctionsQueue: Function[] = [];\n    private scheduled = false;\n\n    // using an object performs better than a Set for the number of different events we have\n    private firedEvents: { [key: string]: boolean; } = {};\n\n    // because this class is used both inside the context and outside the context, we do not\n    // use autowired attributes, as that would be confusing, as sometimes the attributes\n    // would be wired, and sometimes not.\n    //\n    // the global event servers used by AG Grid is autowired by the context once, and this\n    // setBeans method gets called once.\n    //\n    // the times when this class is used outside of the context (eg RowNode has an instance of this\n    // class) then it is not a bean, and this setBeans method is not called.\n    public setBeans(\n        @Qualifier('loggerFactory') loggerFactory: LoggerFactory,\n        @Qualifier('gridOptionsWrapper') gridOptionsWrapper: GridOptionsWrapper,\n        @Qualifier('frameworkOverrides') frameworkOverrides: IFrameworkOverrides,\n        @Qualifier('globalEventListener') globalEventListener: Function | null = null) {\n        this.logger = loggerFactory.create('EventService');\n        this.frameworkOverrides = frameworkOverrides;\n\n        if (globalEventListener) {\n            const async = gridOptionsWrapper.useAsyncEvents();\n            this.addGlobalListener(globalEventListener, async);\n        }\n    }\n\n    private getListeners(eventType: string, async: boolean, autoCreateListenerCollection: boolean): Set<Function> | undefined {\n        const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n        let listeners = listenerMap.get(eventType);\n\n        // Note: 'autoCreateListenerCollection' should only be 'true' if a listener is about to be added. For instance\n        // getListeners() is also called during event dispatch even though no listeners are added. This measure protects\n        // against 'memory bloat' as empty collections will prevent the RowNode's event service from being removed after\n        // the RowComp is destroyed, see noRegisteredListenersExist() below.\n        if (!listeners && autoCreateListenerCollection) {\n            listeners = new Set<Function>();\n            listenerMap.set(eventType, listeners);\n        }\n\n        return listeners;\n    }\n\n    public noRegisteredListenersExist(): boolean {\n        return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 &&\n            this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;\n    }\n\n    public addEventListener(eventType: string, listener: Function, async = false): void {\n        this.getListeners(eventType, async, true)!.add(listener);\n    }\n\n    public removeEventListener(eventType: string, listener: Function, async = false): void {\n        const listeners = this.getListeners(eventType, async, false);\n        if (!listeners) { return; }\n\n        listeners.delete(listener);\n\n        if (listeners.size === 0) {\n            const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;\n            listenerMap.delete(eventType);\n        }\n    }\n\n    public addGlobalListener(listener: Function, async = false): void {\n        (async ? this.globalAsyncListeners : this.globalSyncListeners).add(listener);\n    }\n\n    public removeGlobalListener(listener: Function, async = false): void {\n        (async ? this.globalAsyncListeners : this.globalSyncListeners).delete(listener);\n    }\n\n    public dispatchEvent(event: AgEvent): void {\n        this.dispatchToListeners(event, true);\n        this.dispatchToListeners(event, false);\n\n        this.firedEvents[event.type] = true;\n    }\n\n    public dispatchEventOnce(event: AgEvent): void {\n        if (!this.firedEvents[event.type]) {\n            this.dispatchEvent(event);\n        }\n    }\n\n    private dispatchToListeners(event: AgEvent, async: boolean) {\n        const eventType = event.type;\n        const processEventListeners = (listeners: Set<Function>) => listeners.forEach(listener => {\n            if (async) {\n                this.dispatchAsync(() => listener(event));\n            } else {\n                listener(event);\n            }\n        });\n\n        const listeners = this.getListeners(eventType, async, false);\n        if (listeners) {\n            processEventListeners(listeners);\n        }\n\n        const globalListeners = async ? this.globalAsyncListeners : this.globalSyncListeners;\n\n        globalListeners.forEach(listener => {\n            if (async) {\n                this.dispatchAsync(\n                    () => this.frameworkOverrides.dispatchEvent(eventType, () => listener(eventType, event))\n                );\n            } else {\n                this.frameworkOverrides.dispatchEvent(eventType, () => listener(eventType, event));\n            }\n        });\n    }\n\n    // this gets called inside the grid's thread, for each event that it\n    // wants to set async. the grid then batches the events into one setTimeout()\n    // because setTimeout() is an expensive operation. ideally we would have\n    // each event in it's own setTimeout(), but we batch for performance.\n    private dispatchAsync(func: Function): void {\n        // add to the queue for executing later in the next VM turn\n        this.asyncFunctionsQueue.push(func);\n\n        // check if timeout is already scheduled. the first time the grid calls\n        // this within it's thread turn, this should be false, so it will schedule\n        // the 'flush queue' method the first time it comes here. then the flag is\n        // set to 'true' so it will know it's already scheduled for subsequent calls.\n        if (!this.scheduled) {\n            // if not scheduled, schedule one\n            window.setTimeout(this.flushAsyncQueue.bind(this), 0);\n            // mark that it is scheduled\n            this.scheduled = true;\n        }\n    }\n\n    // this happens in the next VM turn only, and empties the queue of events\n    private flushAsyncQueue(): void {\n        this.scheduled = false;\n\n        // we take a copy, because the event listener could be using\n        // the grid, which would cause more events, which would be potentially\n        // added to the queue, so safe to take a copy, the new events will\n        // get executed in a later VM turn rather than risk updating the\n        // queue as we are flushing it.\n        const queueCopy = this.asyncFunctionsQueue.slice();\n        this.asyncFunctionsQueue = [];\n\n        // execute the queue\n        queueCopy.forEach(func => func());\n    }\n}\n"]}