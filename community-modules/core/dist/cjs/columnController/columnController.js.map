{"version":3,"sources":["../../src/ts/columnController/columnController.ts"],"names":[],"mappings":"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","file":"columnController.js","sourcesContent":["import { ColumnGroup } from '../entities/columnGroup';\nimport { Column } from '../entities/column';\nimport { AbstractColDef, ColDef, ColGroupDef, IAggFunc } from '../entities/colDef';\nimport { ColumnGroupChild } from '../entities/columnGroupChild';\nimport { ExpressionService } from '../valueService/expressionService';\nimport { ColumnFactory } from './columnFactory';\nimport { DisplayedGroupCreator } from './displayedGroupCreator';\nimport { AutoWidthCalculator } from '../rendering/autoWidthCalculator';\nimport { OriginalColumnGroupChild } from '../entities/originalColumnGroupChild';\nimport { ColumnUtils } from './columnUtils';\nimport { Logger, LoggerFactory } from '../logger';\nimport {\n    ColumnEvent,\n    ColumnEventType,\n    ColumnEverythingChangedEvent,\n    ColumnGroupOpenedEvent,\n    ColumnMovedEvent,\n    ColumnPinnedEvent,\n    ColumnPivotModeChangedEvent,\n    ColumnResizedEvent,\n    ColumnRowGroupChangedEvent,\n    ColumnValueChangedEvent,\n    ColumnVisibleEvent,\n    DisplayedColumnsChangedEvent,\n    DisplayedColumnsWidthChangedEvent,\n    Events,\n    GridColumnsChangedEvent,\n    NewColumnsLoadedEvent,\n    VirtualColumnsChangedEvent\n} from '../events';\nimport { BeanStub } from \"../context/beanStub\";\nimport { OriginalColumnGroup } from '../entities/originalColumnGroup';\nimport { GroupInstanceIdCreator } from './groupInstanceIdCreator';\nimport { Autowired, Bean, Optional, PostConstruct, Qualifier } from '../context/context';\nimport { IAggFuncService } from '../interfaces/iAggFuncService';\nimport { ColumnAnimationService } from '../rendering/columnAnimationService';\nimport { AutoGroupColService } from './autoGroupColService';\nimport { RowNode } from '../entities/rowNode';\nimport { ValueCache } from '../valueService/valueCache';\nimport { GridApi } from '../gridApi';\nimport { ApplyColumnStateParams, ColumnApi } from './columnApi';\nimport { Constants } from '../constants/constants';\nimport { areEqual, last, removeFromArray, moveInArray, filter, includes, insertIntoArray, removeAllFromArray } from '../utils/array';\nimport { AnimationFrameService } from \"../misc/animationFrameService\";\nimport { SortController } from \"../sortController\";\nimport { missingOrEmpty, exists, missing, find, attrToBoolean, attrToNumber } from '../utils/generic';\nimport { camelCaseToHumanText, startsWith } from '../utils/string';\nimport { ColumnDefFactory } from \"./columnDefFactory\";\nimport { IRowModel } from \"../interfaces/iRowModel\";\nimport { IClientSideRowModel } from \"../interfaces/iClientSideRowModel\";\nimport { convertToMap } from '../utils/map';\n\nexport interface ColumnResizeSet {\n    columns: Column[];\n    ratios: number[];\n    width: number;\n}\n\nexport interface ColumnState {\n    colId?: string;\n    hide?: boolean | null;\n    aggFunc?: string | IAggFunc | null;\n    width?: number;\n    pivot?: boolean | null;\n    pivotIndex?: number | null;\n    pinned?: boolean | string | 'left' | 'right' | null;\n    rowGroup?: boolean | null;\n    rowGroupIndex?: number | null;\n    flex?: number | null;\n    sort?: string | null;\n    sortIndex?: number | null;\n}\n\n@Bean('columnController')\nexport class ColumnController extends BeanStub {\n\n    @Autowired('expressionService') private expressionService: ExpressionService;\n    @Autowired('columnFactory') private columnFactory: ColumnFactory;\n    @Autowired('displayedGroupCreator') private displayedGroupCreator: DisplayedGroupCreator;\n    @Autowired('autoWidthCalculator') private autoWidthCalculator: AutoWidthCalculator;\n    @Autowired('columnUtils') private columnUtils: ColumnUtils;\n    @Autowired('columnAnimationService') private columnAnimationService: ColumnAnimationService;\n    @Autowired('autoGroupColService') private autoGroupColService: AutoGroupColService;\n    @Optional('aggFuncService') private aggFuncService: IAggFuncService;\n    @Optional('valueCache') private valueCache: ValueCache;\n    @Optional('animationFrameService') private animationFrameService: AnimationFrameService;\n\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('columnApi') private columnApi: ColumnApi;\n    @Autowired('gridApi') private gridApi: GridApi;\n    @Autowired('sortController') private sortController: SortController;\n    @Autowired('columnDefFactory') private columnDefFactory: ColumnDefFactory;\n\n    // these are the columns provided by the client. this doesn't change, even if the\n    // order or state of the columns and groups change. it will only change if the client\n    // provides a new set of column definitions. otherwise this tree is used to build up\n    // the groups for displaying.\n    private primaryColumnTree: OriginalColumnGroupChild[];\n    // header row count, based on user provided columns\n    private primaryHeaderRowCount = 0;\n    // all columns provided by the user. basically it's the leaf level nodes of the\n    // tree above (originalBalancedTree)\n    private primaryColumns: Column[]; // every column available\n    private primaryColumnsMap: {[id: string]: Column};\n\n    // if pivoting, these are the generated columns as a result of the pivot\n    private secondaryBalancedTree: OriginalColumnGroupChild[] | null;\n    private secondaryColumns: Column[] | null;\n    private secondaryHeaderRowCount = 0;\n    private secondaryColumnsPresent = false;\n\n    // the columns the quick filter should use. this will be all primary columns\n    // plus the autoGroupColumns if any exist\n    private columnsForQuickFilter: Column[];\n\n    // these are all columns that are available to the grid for rendering after pivot\n    private gridBalancedTree: OriginalColumnGroupChild[];\n    private gridColumns: Column[];\n    private gridColumnsMap: {[id: string]: Column};\n\n    // header row count, either above, or based on pivoting if we are pivoting\n    private gridHeaderRowCount = 0;\n\n    private lastPrimaryOrder: Column[];\n    private gridColsArePrimary: boolean;\n\n    // primary columns -> what the user provides\n    // secondary columns -> columns generated as a result of a pivot\n    // displayed columns -> columns that are 1) visible and 2) parent groups are opened. thus can be rendered\n    // viewport columns -> centre columns only, what columns are to be rendered due to column virtualisation\n\n    // tree of columns to be displayed for each section\n    private displayedTreeLeft: ColumnGroupChild[];\n    private displayedTreeRight: ColumnGroupChild[];\n    private displayedTreeCentre: ColumnGroupChild[];\n\n    // leave level columns of the displayed trees\n    private displayedColumnsLeft: Column[] = [];\n    private displayedColumnsRight: Column[] = [];\n    private displayedColumnsCenter: Column[] = [];\n    // all three lists above combined\n    private displayedColumns: Column[] = [];\n\n    // for fast lookup, to see if a column or group is still displayed\n    private displayedColumnsAndGroupsMap: {[id:string]:ColumnGroupChild} = {};\n\n    // all columns to be rendered\n    private viewportColumns: Column[] = [];\n    // all columns to be rendered in the centre\n    private viewportColumnsCenter: Column[] = [];\n\n    // all columns & groups to be rendered, index by row. used by header rows to get all items\n    // to render for that row.\n    private viewportRowLeft: { [row: number]: ColumnGroupChild[]; };\n    private viewportRowRight: { [row: number]: ColumnGroupChild[]; };\n    private viewportRowCenter: { [row: number]: ColumnGroupChild[]; };\n\n    // true if we are doing column spanning\n    private colSpanActive: boolean;\n\n    // grid columns that have colDef.autoHeight set\n    private autoRowHeightColumns: Column[];\n\n    private suppressColumnVirtualisation: boolean;\n\n    private rowGroupColumns: Column[] = [];\n    private valueColumns: Column[] = [];\n    private pivotColumns: Column[] = [];\n\n    private groupAutoColumns: Column[] | null;\n\n    private groupDisplayColumns: Column[];\n\n    private ready = false;\n    private logger: Logger;\n\n    private autoGroupsNeedBuilding = false;\n    private forceRecreateAutoGroups = false;\n\n    private pivotMode = false;\n    private usingTreeData: boolean;\n\n    // for horizontal visualisation of columns\n    private scrollWidth: number;\n    private scrollPosition: number;\n\n    private bodyWidth = 0;\n    private leftWidth = 0;\n    private rightWidth = 0;\n\n    private bodyWidthDirty = true;\n\n    private viewportLeft: number;\n    private viewportRight: number;\n    private flexViewportWidth: number;\n\n    private columnDefs: (ColDef | ColGroupDef)[];\n\n    private colDefVersion = 0;\n\n    private flexColsCalculatedAtLestOnce = false;\n\n    @PostConstruct\n    public init(): void {\n        this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();\n\n        const pivotMode = this.gridOptionsWrapper.isPivotMode();\n\n        if (this.isPivotSettingAllowed(pivotMode)) {\n            this.pivotMode = pivotMode;\n        }\n\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n\n        this.addManagedListener(this.gridOptionsWrapper, 'autoGroupColumnDef', this.onAutoGroupColumnDefChanged.bind(this));\n    }\n\n    public onAutoGroupColumnDefChanged() {\n        this.autoGroupsNeedBuilding = true;\n        this.forceRecreateAutoGroups = true;\n        this.updateGridColumns();\n        this.updateDisplayedColumns('gridOptionsChanged');\n    }\n\n    public getColDefVersion(): number {\n        return this.colDefVersion;\n    }\n\n    public setColumnDefs(columnDefs: (ColDef | ColGroupDef)[], source: ColumnEventType = 'api') {\n\n        const colsPreviouslyExisted = !!this.columnDefs;\n\n        this.colDefVersion++;\n\n        const raiseEventsFunc = this.compareColumnStatesAndRaiseEvents(source);\n\n        this.columnDefs = columnDefs;\n\n        // always invalidate cache on changing columns, as the column id's for the new columns\n        // could overlap with the old id's, so the cache would return old values for new columns.\n        this.valueCache.expire();\n\n        // NOTE ==================\n        // we should be destroying the existing columns and groups if they exist, for example, the original column\n        // group adds a listener to the columns, it should be also removing the listeners\n        this.autoGroupsNeedBuilding = true;\n\n        const oldPrimaryColumns = this.primaryColumns;\n        const oldPrimaryTree = this.primaryColumnTree;\n        const balancedTreeResult = this.columnFactory.createColumnTree(columnDefs, true, oldPrimaryTree);\n\n        this.primaryColumnTree = balancedTreeResult.columnTree;\n        this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n\n        this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n        this.primaryColumnsMap = {};\n        this.primaryColumns.forEach(col => this.primaryColumnsMap[col.getId()] = col);\n\n        this.extractRowGroupColumns(source, oldPrimaryColumns);\n        this.extractPivotColumns(source, oldPrimaryColumns);\n        this.extractValueColumns(source, oldPrimaryColumns);\n\n        this.ready = true;\n\n        this.updateGridColumns();\n        if (colsPreviouslyExisted && this.gridColsArePrimary && this.gridOptionsWrapper.isApplyColumnDefOrder()) {\n            this.orderGridColumnsLikePrimary();\n        }\n        this.updateDisplayedColumns(source);\n        this.checkViewportColumns();\n\n        // this event is not used by AG Grid, but left here for backwards compatibility,\n        // in case applications use it\n        this.dispatchEverythingChanged(source);\n\n        raiseEventsFunc();\n        this.dispatchNewColumnsLoaded();\n    }\n\n    private dispatchNewColumnsLoaded(): void {\n        const newColumnsLoadedEvent: NewColumnsLoadedEvent = {\n            type: Events.EVENT_NEW_COLUMNS_LOADED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n\n        this.eventService.dispatchEvent(newColumnsLoadedEvent);\n    }\n\n    // this event is legacy, no grid code listens to it. instead the grid listens to New Columns Loaded\n    private dispatchEverythingChanged(source: ColumnEventType = 'api'): void {\n        const eventEverythingChanged: ColumnEverythingChangedEvent = {\n            type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source\n        };\n        this.eventService.dispatchEvent(eventEverythingChanged);\n    }\n\n    private orderGridColumnsLikePrimary(): void {\n        this.gridColumns.sort((colA: Column, colB: Column) => {\n            const primaryIndexA = this.primaryColumns.indexOf(colA);\n            const primaryIndexB = this.primaryColumns.indexOf(colB);\n            // if both cols are present in primary, then we just return the position,\n            // so position is maintained.\n            const indexAPresent = primaryIndexA >= 0;\n            const indexBPresent = primaryIndexB >= 0;\n\n            if (indexAPresent && indexBPresent) {\n                return primaryIndexA - primaryIndexB;\n            }\n\n            if (indexAPresent) {\n                // B is auto group column, so put B first\n                return 1;\n            }\n\n            if (indexBPresent) {\n                // A is auto group column, so put A first\n                return -1;\n            }\n\n            // otherwise both A and B are auto-group columns. so we just keep the order\n            // as they were already in.\n            const gridIndexA = this.gridColumns.indexOf(colA);\n            const gridIndexB = this.gridColumns.indexOf(colB);\n            return gridIndexA - gridIndexB;\n        });\n    }\n\n    public isAutoRowHeightActive(): boolean {\n        return this.autoRowHeightColumns && this.autoRowHeightColumns.length > 0;\n    }\n\n    public getAllAutoRowHeightCols(): Column[] {\n        return this.autoRowHeightColumns;\n    }\n\n    private setViewport(): void {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;\n            this.viewportRight = this.bodyWidth - this.scrollPosition;\n        } else {\n            this.viewportLeft = this.scrollPosition;\n            this.viewportRight = this.scrollWidth + this.scrollPosition;\n        }\n    }\n\n    // used by clipboard service, to know what columns to paste into\n    public getDisplayedColumnsStartingAt(column: Column): Column[] {\n        let currentColumn: Column | null = column;\n        const columns: Column[] = [];\n\n        while (currentColumn != null) {\n            columns.push(currentColumn);\n            currentColumn = this.getDisplayedColAfter(currentColumn);\n        }\n\n        return columns;\n    }\n\n    // checks what columns are currently displayed due to column virtualisation. fires an event\n    // if the list of columns has changed.\n    // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()\n    private checkViewportColumns(): void {\n        // check displayCenterColumnTree exists first, as it won't exist when grid is initialising\n        if (this.displayedColumnsCenter == null) { return; }\n\n        const hashBefore = this.viewportColumns.map(column => column.getId()).join('#');\n\n        this.extractViewport();\n\n        const hashAfter = this.viewportColumns.map(column => column.getId()).join('#');\n\n        if (hashBefore !== hashAfter) {\n            const event: VirtualColumnsChangedEvent = {\n                type: Events.EVENT_VIRTUAL_COLUMNS_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    public setViewportPosition(scrollWidth: number, scrollPosition: number): void {\n        if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {\n            this.scrollWidth = scrollWidth;\n            this.scrollPosition = scrollPosition;\n            // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,\n            // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the\n            // virtual columns again\n            this.bodyWidthDirty = true;\n            this.setViewport();\n\n            if (this.ready) {\n                this.checkViewportColumns();\n            }\n        }\n    }\n\n    public isPivotMode(): boolean {\n        return this.pivotMode;\n    }\n\n    private isPivotSettingAllowed(pivot: boolean): boolean {\n        if (pivot && this.gridOptionsWrapper.isTreeData()) {\n            console.warn(\"AG Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'\");\n            return false;\n        }\n\n        return true;\n    }\n\n    public setPivotMode(pivotMode: boolean, source: ColumnEventType = 'api'): void {\n        if (pivotMode === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode)) { return; }\n\n        this.pivotMode = pivotMode;\n\n        // we need to update grid columns to cover the scenario where user has groupSuppressAutoColumn=true, as\n        // this means we don't use auto group column UNLESS we are in pivot mode (it's mandatory in pivot mode),\n        // so need to updateGridColumn() to check it autoGroupCol needs to be added / removed\n        this.autoGroupsNeedBuilding = true;\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n\n        const event: ColumnPivotModeChangedEvent = {\n            type: Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public getSecondaryPivotColumn(pivotKeys: string[], valueColKey: Column | string): Column | null {\n        if (!this.secondaryColumnsPresent || !this.secondaryColumns) { return null; }\n\n        const valueColumnToFind = this.getPrimaryColumn(valueColKey);\n\n        let foundColumn: Column | null = null;\n\n        this.secondaryColumns.forEach(column => {\n            const thisPivotKeys = column.getColDef().pivotKeys;\n            const pivotValueColumn = column.getColDef().pivotValueColumn;\n\n            const pivotKeyMatches = areEqual(thisPivotKeys, pivotKeys);\n            const pivotValueMatches = pivotValueColumn === valueColumnToFind;\n\n            if (pivotKeyMatches && pivotValueMatches) {\n                foundColumn = column;\n            }\n        });\n\n        return foundColumn;\n    }\n\n    private setBeans(@Qualifier('loggerFactory') loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create('ColumnController');\n    }\n\n    private setFirstRightAndLastLeftPinned(source: ColumnEventType): void {\n        let lastLeft: Column | null;\n        let firstRight: Column | null;\n\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            lastLeft = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null;\n            firstRight = this.displayedColumnsRight ? last(this.displayedColumnsRight) : null;\n        } else {\n            lastLeft = this.displayedColumnsLeft ? last(this.displayedColumnsLeft) : null;\n            firstRight = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null;\n        }\n\n        this.gridColumns.forEach((column: Column) => {\n            column.setLastLeftPinned(column === lastLeft, source);\n            column.setFirstRightPinned(column === firstRight, source);\n        });\n    }\n\n    public autoSizeColumns(keys: (string | Column)[], skipHeader?: boolean, source: ColumnEventType = \"api\"): void {\n        // because of column virtualisation, we can only do this function on columns that are\n        // actually rendered, as non-rendered columns (outside the viewport and not rendered\n        // due to column virtualisation) are not present. this can result in all rendered columns\n        // getting narrowed, which in turn introduces more rendered columns on the RHS which\n        // did not get autosized in the original run, leaving the visible grid with columns on\n        // the LHS sized, but RHS no. so we keep looping through the visible columns until\n        // no more cols are available (rendered) to be resized\n\n        // we autosize after animation frames finish in case any cell renderers need to complete first. this can\n        // happen eg if client code is calling api.autoSizeAllColumns() straight after grid is initialised, but grid\n        // hasn't fully drawn out all the cells yet (due to cell renderers in animation frames).\n        this.animationFrameService.flushAllFrames();\n\n        // keep track of which cols we have resized in here\n        const columnsAutosized: Column[] = [];\n        // initialise with anything except 0 so that while loop executes at least once\n        let changesThisTimeAround = -1;\n\n        if (skipHeader == null) {\n            skipHeader = this.gridOptionsWrapper.isSkipHeaderOnAutoSize();\n        }\n\n        while (changesThisTimeAround !== 0) {\n            changesThisTimeAround = 0;\n            this.actionOnGridColumns(keys, (column: Column): boolean => {\n                // if already autosized, skip it\n                if (columnsAutosized.indexOf(column) >= 0) {\n                    return false;\n                }\n                // get how wide this col should be\n                const preferredWidth = this.autoWidthCalculator.getPreferredWidthForColumn(column, skipHeader);\n                // preferredWidth = -1 if this col is not on the screen\n                if (preferredWidth > 0) {\n                    const newWidth = this.normaliseColumnWidth(column, preferredWidth);\n                    column.setActualWidth(newWidth, source);\n                    columnsAutosized.push(column);\n                    changesThisTimeAround++;\n                }\n                return true;\n            }, source);\n        }\n\n        this.fireColumnResizedEvent(columnsAutosized, true, 'autosizeColumns');\n    }\n\n    public fireColumnResizedEvent(columns: Column[] | null, finished: boolean, source: ColumnEventType, flexColumns: Column[] | null = null): void {\n        if (columns && columns.length) {\n            const event: ColumnResizedEvent = {\n                type: Events.EVENT_COLUMN_RESIZED,\n                columns: columns,\n                column: columns.length === 1 ? columns[0] : null,\n                flexColumns: flexColumns,\n                finished: finished,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    public autoSizeColumn(key: string | Column | null, skipHeader?: boolean, source: ColumnEventType = \"api\"): void {\n        if (key) {\n            this.autoSizeColumns([key], skipHeader, source);\n        }\n    }\n\n    public autoSizeAllColumns(skipHeader?: boolean, source: ColumnEventType = \"api\"): void {\n        const allDisplayedColumns = this.getAllDisplayedColumns();\n        this.autoSizeColumns(allDisplayedColumns, skipHeader, source);\n    }\n\n    private getColumnsFromTree(rootColumns: OriginalColumnGroupChild[]): Column[] {\n        const result: Column[] = [];\n\n        const recursiveFindColumns = (childColumns: OriginalColumnGroupChild[]): void => {\n            for (let i = 0; i < childColumns.length; i++) {\n                const child = childColumns[i];\n                if (child instanceof Column) {\n                    result.push(child);\n                } else if (child instanceof OriginalColumnGroup) {\n                    recursiveFindColumns(child.getChildren());\n                }\n            }\n        };\n\n        recursiveFindColumns(rootColumns);\n\n        return result;\n    }\n\n    public getAllDisplayedTrees(): ColumnGroupChild[] | null {\n        if (this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre) {\n            return this.displayedTreeLeft\n                .concat(this.displayedTreeCentre)\n                .concat(this.displayedTreeRight);\n        }\n\n        return null;\n    }\n\n    // + columnSelectPanel\n    public getPrimaryColumnTree(): OriginalColumnGroupChild[] {\n        return this.primaryColumnTree;\n    }\n\n    // + gridPanel -> for resizing the body and setting top margin\n    public getHeaderRowCount(): number {\n        return this.gridHeaderRowCount;\n    }\n\n    // + headerRenderer -> setting pinned body width\n    public getDisplayedTreeLeft(): ColumnGroupChild[] {\n        return this.displayedTreeLeft;\n    }\n\n    // + headerRenderer -> setting pinned body width\n    public getDisplayedTreeRight(): ColumnGroupChild[] {\n        return this.displayedTreeRight;\n    }\n\n    // + headerRenderer -> setting pinned body width\n    public getDisplayedTreeCentre(): ColumnGroupChild[] {\n        return this.displayedTreeCentre;\n    }\n\n    // gridPanel -> ensureColumnVisible\n    public isColumnDisplayed(column: Column): boolean {\n        return this.getAllDisplayedColumns().indexOf(column) >= 0;\n    }\n\n    // + csvCreator\n    public getAllDisplayedColumns(): Column[] {\n        return this.displayedColumns;\n    }\n\n    public getViewportColumns(): Column[] {\n        return this.viewportColumns;\n    }\n\n    public getDisplayedLeftColumnsForRow(rowNode: RowNode): Column[] {\n        if (!this.colSpanActive) {\n            return this.displayedColumnsLeft;\n        }\n\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsLeft);\n    }\n\n    public getDisplayedRightColumnsForRow(rowNode: RowNode): Column[] {\n        if (!this.colSpanActive) {\n            return this.displayedColumnsRight;\n        }\n\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsRight);\n    }\n\n    private getDisplayedColumnsForRow(\n        rowNode: RowNode, displayedColumns: Column[],\n        filterCallback?: (column: Column) => boolean,\n        emptySpaceBeforeColumn?: (column: Column) => boolean\n    ): Column[] {\n\n        const result: Column[] = [];\n        let lastConsideredCol: Column | null = null;\n\n        for (let i = 0; i < displayedColumns.length; i++) {\n            const col = displayedColumns[i];\n            const maxAllowedColSpan = displayedColumns.length - i;\n            const colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);\n            const columnsToCheckFilter: Column[] = [col];\n\n            if (colSpan > 1) {\n                const colsToRemove = colSpan - 1;\n\n                for (let j = 1; j <= colsToRemove; j++) {\n                    columnsToCheckFilter.push(displayedColumns[i + j]);\n                }\n\n                i += colsToRemove;\n            }\n\n            // see which cols we should take out for column virtualisation\n            let filterPasses: boolean;\n\n            if (filterCallback) {\n                // if user provided a callback, means some columns may not be in the viewport.\n                // the user will NOT provide a callback if we are talking about pinned areas,\n                // as pinned areas have no horizontal scroll and do not virtualise the columns.\n                // if lots of columns, that means column spanning, and we set filterPasses = true\n                // if one or more of the columns spanned pass the filter.\n                filterPasses = false;\n                columnsToCheckFilter.forEach(colForFilter => {\n                    if (filterCallback(colForFilter)) { filterPasses = true; }\n                });\n            } else {\n                filterPasses = true;\n            }\n\n            if (filterPasses) {\n                if (result.length === 0 && lastConsideredCol) {\n                    const gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;\n                    if (gapBeforeColumn) {\n                        result.push(lastConsideredCol);\n                    }\n                }\n                result.push(col);\n            }\n\n            lastConsideredCol = col;\n        }\n\n        return result;\n    }\n\n    // + rowRenderer\n    // if we are not column spanning, this just returns back the virtual centre columns,\n    // however if we are column spanning, then different rows can have different virtual\n    // columns, so we have to work out the list for each individual row.\n    public getViewportCenterColumnsForRow(rowNode: RowNode): Column[] {\n        if (!this.colSpanActive) {\n            return this.viewportColumnsCenter;\n        }\n\n        const emptySpaceBeforeColumn = (col: Column) => {\n            const left = col.getLeft();\n\n            return exists(left) && left > this.viewportLeft;\n        };\n\n        // if doing column virtualisation, then we filter based on the viewport.\n        const filterCallback = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);\n\n        return this.getDisplayedColumnsForRow(\n            rowNode,\n            this.displayedColumnsCenter,\n            filterCallback,\n            emptySpaceBeforeColumn\n        );\n    }\n\n    public getAriaColumnIndex(col: Column): number {\n        return this.getAllGridColumns().indexOf(col) + 1;\n    }\n\n    private isColumnInViewport(col: Column): boolean {\n        const columnLeft = col.getLeft() || 0;\n        const columnRight = columnLeft + col.getActualWidth();\n\n        // adding 200 for buffer size, so some cols off viewport are rendered.\n        // this helps horizontal scrolling so user rarely sees white space (unless\n        // they scroll horizontally fast). however we are conservative, as the more\n        // buffer the slower the vertical redraw speed\n        const leftBounds = this.viewportLeft - 200;\n        const rightBounds = this.viewportRight + 200;\n\n        const columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;\n        const columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;\n\n        return !columnToMuchLeft && !columnToMuchRight;\n    }\n\n    // used by:\n    // + angularGrid -> setting pinned body width\n    // note: this should be cached\n    public getDisplayedColumnsLeftWidth() {\n        return this.getWidthOfColsInList(this.displayedColumnsLeft);\n    }\n\n    // note: this should be cached\n    public getDisplayedColumnsRightWidth() {\n        return this.getWidthOfColsInList(this.displayedColumnsRight);\n    }\n\n    public updatePrimaryColumnList(\n        keys: (string | Column)[] | null,\n        masterList: Column[],\n        actionIsAdd: boolean,\n        columnCallback: (column: Column) => void,\n        eventType: string,\n        source: ColumnEventType = \"api\"\n    ) {\n\n        if (!keys || missingOrEmpty(keys)) { return; }\n\n        let atLeastOne = false;\n\n        keys.forEach(key => {\n            const columnToAdd = this.getPrimaryColumn(key);\n            if (!columnToAdd) { return; }\n\n            if (actionIsAdd) {\n                if (masterList.indexOf(columnToAdd) >= 0) { return; }\n                masterList.push(columnToAdd);\n            } else {\n                if (masterList.indexOf(columnToAdd) < 0) { return; }\n                removeFromArray(masterList, columnToAdd);\n            }\n\n            columnCallback(columnToAdd);\n            atLeastOne = true;\n        });\n\n        if (!atLeastOne) { return; }\n\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n\n        this.updateDisplayedColumns(source);\n\n        const event: ColumnEvent = {\n            type: eventType,\n            columns: masterList,\n            column: masterList.length === 1 ? masterList[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public setRowGroupColumns(colKeys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.autoGroupsNeedBuilding = true;\n        this.setPrimaryColumnList(colKeys, this.rowGroupColumns,\n            Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            this.setRowGroupActive.bind(this),\n            source);\n    }\n\n    private setRowGroupActive(active: boolean, column: Column, source: ColumnEventType): void {\n        if (active === column.isRowGroupActive()) { return; }\n\n        column.setRowGroupActive(active, source);\n\n        if (!active && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup()) {\n            column.setVisible(true, source);\n        }\n    }\n\n    public addRowGroupColumn(key: string | Column | null, source: ColumnEventType = \"api\"): void {\n        if (key) { this.addRowGroupColumns([key], source); }\n    }\n\n    public addRowGroupColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, true,\n            this.setRowGroupActive.bind(this, true),\n            Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            source);\n    }\n\n    public removeRowGroupColumns(keys: (string | Column)[] | null, source: ColumnEventType = \"api\"): void {\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, false,\n            this.setRowGroupActive.bind(this, false),\n            Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            source);\n    }\n\n    public removeRowGroupColumn(key: string | Column | null, source: ColumnEventType = \"api\"): void {\n        if (key) { this.removeRowGroupColumns([key], source); }\n    }\n\n    public addPivotColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.updatePrimaryColumnList(keys, this.pivotColumns, true,\n            column => column.setPivotActive(true, source),\n            Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n    }\n\n    public setPivotColumns(colKeys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.setPrimaryColumnList(colKeys, this.pivotColumns, Events.EVENT_COLUMN_PIVOT_CHANGED,\n            (added: boolean, column: Column) => {\n                column.setPivotActive(added, source);\n            }, source\n        );\n    }\n\n    public addPivotColumn(key: string | Column, source: ColumnEventType = \"api\"): void {\n        this.addPivotColumns([key], source);\n    }\n\n    public removePivotColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.updatePrimaryColumnList(\n            keys,\n            this.pivotColumns,\n            false,\n            column => column.setPivotActive(false, source),\n            Events.EVENT_COLUMN_PIVOT_CHANGED,\n            source\n        );\n    }\n\n    public removePivotColumn(key: string | Column, source: ColumnEventType = \"api\"): void {\n        this.removePivotColumns([key], source);\n    }\n\n    private setPrimaryColumnList(\n        colKeys: (string | Column)[],\n        masterList: Column[],\n        eventName: string,\n        columnCallback: (added: boolean, column: Column) => void,\n        source: ColumnEventType\n    ): void {\n\n        masterList.length = 0;\n\n        if (exists(colKeys)) {\n            colKeys.forEach(key => {\n                const column = this.getPrimaryColumn(key);\n                if (column) {\n                    masterList.push(column);\n                }\n            });\n        }\n\n        this.primaryColumns.forEach(column => {\n            const added = masterList.indexOf(column) >= 0;\n            columnCallback(added, column);\n        });\n\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n\n        this.updateDisplayedColumns(source);\n\n        this.fireColumnEvent(eventName, masterList, source);\n    }\n\n    public setValueColumns(colKeys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.setPrimaryColumnList(colKeys, this.valueColumns,\n            Events.EVENT_COLUMN_VALUE_CHANGED,\n            this.setValueActive.bind(this),\n            source\n        );\n    }\n\n    private setValueActive(active: boolean, column: Column, source: ColumnEventType): void {\n        if (active === column.isValueActive()) { return; }\n\n        column.setValueActive(active, source);\n\n        if (active && !column.getAggFunc()) {\n            const initialAggFunc = this.aggFuncService.getDefaultAggFunc(column);\n            column.setAggFunc(initialAggFunc);\n        }\n    }\n\n    public addValueColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.updatePrimaryColumnList(keys, this.valueColumns, true,\n            this.setValueActive.bind(this, true),\n            Events.EVENT_COLUMN_VALUE_CHANGED,\n            source\n        );\n    }\n\n    public addValueColumn(colKey: (string | Column) | null | undefined, source: ColumnEventType = \"api\"): void {\n        if (colKey) { this.addValueColumns([colKey], source); }\n    }\n\n    public removeValueColumn(colKey: (string | Column), source: ColumnEventType = \"api\"): void {\n        this.removeValueColumns([colKey], source);\n    }\n\n    public removeValueColumns(keys: (string | Column)[], source: ColumnEventType = \"api\"): void {\n        this.updatePrimaryColumnList(keys, this.valueColumns, false,\n            this.setValueActive.bind(this, false),\n            Events.EVENT_COLUMN_VALUE_CHANGED,\n            source\n        );\n    }\n\n    // returns the width we can set to this col, taking into consideration min and max widths\n    private normaliseColumnWidth(column: Column, newWidth: number): number {\n        const minWidth = column.getMinWidth();\n\n        if (exists(minWidth) && newWidth < minWidth) {\n            newWidth = minWidth;\n        }\n\n        const maxWidth = column.getMaxWidth();\n        if (exists(maxWidth) && column.isGreaterThanMax(newWidth)) {\n            newWidth = maxWidth;\n        }\n\n        return newWidth;\n    }\n\n    private getPrimaryOrGridColumn(key: string | Column): Column | null {\n        const column = this.getPrimaryColumn(key);\n\n        return column || this.getGridColumn(key);\n    }\n\n    public setColumnWidths(\n        columnWidths: {\n            key: string | Column, // @key - the column who's size we want to change\n            newWidth: number; // @newWidth - width in pixels\n        }[],\n        shiftKey: boolean, // @takeFromAdjacent - if user has 'shift' pressed, then pixels are taken from adjacent column\n        finished: boolean, // @finished - ends up in the event, tells the user if more events are to come\n        source: ColumnEventType = \"api\"\n    ): void {\n        const sets: ColumnResizeSet[] = [];\n\n        columnWidths.forEach(columnWidth => {\n            const col = this.getPrimaryOrGridColumn(columnWidth.key);\n\n            if (!col) { return; }\n\n            sets.push({\n                width: columnWidth.newWidth,\n                ratios: [1],\n                columns: [col]\n            });\n\n            // if user wants to do shift resize by default, then we invert the shift operation\n            const defaultIsShift = this.gridOptionsWrapper.getColResizeDefault() === 'shift';\n\n            if (defaultIsShift) {\n                shiftKey = !shiftKey;\n            }\n\n            if (shiftKey) {\n                const otherCol = this.getDisplayedColAfter(col);\n                if (!otherCol) { return; }\n\n                const widthDiff = col.getActualWidth() - columnWidth.newWidth;\n                const otherColWidth = otherCol.getActualWidth() + widthDiff;\n\n                sets.push({\n                    width: otherColWidth,\n                    ratios: [1],\n                    columns: [otherCol]\n                });\n            }\n        });\n\n        if (sets.length === 0) { return; }\n\n        this.resizeColumnSets(sets, finished, source);\n\n    }\n\n    private checkMinAndMaxWidthsForSet(columnResizeSet: ColumnResizeSet): boolean {\n        const { columns, width } = columnResizeSet;\n\n        // every col has a min width, so sum them all up and see if we have enough room\n        // for all the min widths\n        let minWidthAccumulated = 0;\n        let maxWidthAccumulated = 0;\n        let maxWidthActive = true;\n\n        columns.forEach(col => {\n            const minWidth = col.getMinWidth();\n            minWidthAccumulated += minWidth || 0;\n\n            const maxWidth = col.getMaxWidth();\n            if (exists(maxWidth) && maxWidth > 0) {\n                maxWidthAccumulated += maxWidth;\n            } else {\n                // if at least one columns has no max width, it means the group of columns\n                // then has no max width, as at least one column can take as much width as possible\n                maxWidthActive = false;\n            }\n        });\n\n        const minWidthPasses = width >= minWidthAccumulated;\n        const maxWidthPasses = !maxWidthActive || (width <= maxWidthAccumulated);\n\n        return minWidthPasses && maxWidthPasses;\n    }\n\n    // method takes sets of columns and resizes them. either all sets will be resized, or nothing\n    // be resized. this is used for example when user tries to resize a group and holds shift key,\n    // then both the current group (grows), and the adjacent group (shrinks), will get resized,\n    // so that's two sets for this method.\n    public resizeColumnSets(\n        resizeSets: ColumnResizeSet[],\n        finished: boolean,\n        source: ColumnEventType\n    ): void {\n        const passMinMaxCheck = !resizeSets || resizeSets.every(this.checkMinAndMaxWidthsForSet.bind(this));\n\n        if (!passMinMaxCheck) {\n            // even though we are not going to resize beyond min/max size, we still need to raise event when finished\n            if (finished) {\n                const columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;\n                this.fireColumnResizedEvent(columns, finished, source);\n            }\n\n            return; // don't resize!\n        }\n\n        const changedCols: Column[] = [];\n        const allResizedCols: Column[] = [];\n\n        resizeSets.forEach(set => {\n            const { width, columns, ratios } = set;\n\n            // keep track of pixels used, and last column gets the remaining,\n            // to cater for rounding errors, and min width adjustments\n            const newWidths: { [colId: string]: number; } = {};\n            const finishedCols: { [colId: string]: boolean; } = {};\n\n            columns.forEach(col => allResizedCols.push(col));\n\n            // the loop below goes through each col. if a col exceeds it's min/max width,\n            // it then gets set to its min/max width and the column is removed marked as 'finished'\n            // and the calculation is done again leaving this column out. take for example columns\n            // {A, width: 50, maxWidth: 100}\n            // {B, width: 50}\n            // {C, width: 50}\n            // and then the set is set to width 600 - on the first pass the grid tries to set each column\n            // to 200. it checks A and sees 200 > 100 and so sets the width to 100. col A is then marked\n            // as 'finished' and the calculation is done again with the remaining cols B and C, which end up\n            // splitting the remaining 500 pixels.\n            let finishedColsGrew = true;\n            let loopCount = 0;\n\n            while (finishedColsGrew) {\n                loopCount++;\n                if (loopCount > 1000) {\n                    // this should never happen, but in the future, someone might introduce a bug here,\n                    // so we stop the browser from hanging and report bug properly\n                    console.error('AG Grid: infinite loop in resizeColumnSets');\n                    break;\n                }\n\n                finishedColsGrew = false;\n\n                const subsetCols: Column[] = [];\n                let subsetRatioTotal = 0;\n                let pixelsToDistribute = width;\n\n                columns.forEach((col: Column, index: number) => {\n                    const thisColFinished = finishedCols[col.getId()];\n                    if (thisColFinished) {\n                        pixelsToDistribute -= newWidths[col.getId()];\n                    } else {\n                        subsetCols.push(col);\n                        const ratioThisCol = ratios[index];\n                        subsetRatioTotal += ratioThisCol;\n                    }\n                });\n\n                // because we are not using all of the ratios (cols can be missing),\n                // we scale the ratio. if all columns are included, then subsetRatioTotal=1,\n                // and so the ratioScale will be 1.\n                const ratioScale = 1 / subsetRatioTotal;\n\n                subsetCols.forEach((col: Column, index: number) => {\n                    const lastCol = index === (subsetCols.length - 1);\n                    let colNewWidth: number;\n\n                    if (lastCol) {\n                        colNewWidth = pixelsToDistribute;\n                    } else {\n                        colNewWidth = Math.round(ratios[index] * width * ratioScale);\n                        pixelsToDistribute -= colNewWidth;\n                    }\n\n                    const minWidth = col.getMinWidth();\n                    const maxWidth = col.getMaxWidth();\n\n                    if (exists(minWidth) && colNewWidth < minWidth) {\n                        colNewWidth = minWidth;\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    } else if (exists(maxWidth) && maxWidth > 0 && colNewWidth > maxWidth) {\n                        colNewWidth = maxWidth;\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    }\n\n                    newWidths[col.getId()] = colNewWidth;\n                });\n            }\n\n            columns.forEach(col => {\n                const newWidth = newWidths[col.getId()];\n                if (col.getActualWidth() !== newWidth) {\n                    col.setActualWidth(newWidth, source);\n                    changedCols.push(col);\n                }\n            });\n        });\n\n        // if no cols changed, then no need to update more or send event.\n        const atLeastOneColChanged = changedCols.length > 0;\n\n        const flexedCols = this.refreshFlexedColumns({ resizingCols: allResizedCols, skipSetLeft: true });\n\n        if (atLeastOneColChanged) {\n            this.setLeftValues(source);\n            this.updateBodyWidths();\n            this.checkViewportColumns();\n        }\n\n        // check for change first, to avoid unnecessary firing of events\n        // however we always fire 'finished' events. this is important\n        // when groups are resized, as if the group is changing slowly,\n        // eg 1 pixel at a time, then each change will fire change events\n        // in all the columns in the group, but only one with get the pixel.\n        const colsForEvent = allResizedCols.concat(flexedCols);\n\n        if (atLeastOneColChanged || finished) {\n            this.fireColumnResizedEvent(colsForEvent, finished, source, flexedCols);\n        }\n    }\n\n    public setColumnAggFunc(key: string | Column | null | undefined, aggFunc: string, source: ColumnEventType = \"api\"): void {\n        if (!key) { return; }\n\n        const column = this.getPrimaryColumn(key);\n        if (!column) { return; }\n\n        column.setAggFunc(aggFunc);\n\n        this.fireColumnEvent(Events.EVENT_COLUMN_VALUE_CHANGED, [column], source);\n    }\n\n    private fireColumnEvent(type: string, columns: Column[], source: ColumnEventType): void {\n        const event: ColumnValueChangedEvent = {\n            type: type,\n            columns: columns,\n            column: (columns && columns.length == 1) ? columns[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    public moveRowGroupColumn(fromIndex: number, toIndex: number, source: ColumnEventType = \"api\"): void {\n        const column = this.rowGroupColumns[fromIndex];\n\n        this.rowGroupColumns.splice(fromIndex, 1);\n        this.rowGroupColumns.splice(toIndex, 0, column);\n\n        const event: ColumnRowGroupChangedEvent = {\n            type: Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            columns: this.rowGroupColumns,\n            column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    public moveColumns(columnsToMoveKeys: (string | Column)[], toIndex: number, source: ColumnEventType = \"api\"): void {\n        this.columnAnimationService.start();\n\n        if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {\n            console.warn('AG Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);\n            console.warn('AG Grid: remember that you should not count the moving columns when calculating the new index');\n            return;\n        }\n\n        // we want to pull all the columns out first and put them into an ordered list\n        const columnsToMove = this.getGridColumns(columnsToMoveKeys);\n        const failedRules = !this.doesMovePassRules(columnsToMove, toIndex);\n\n        if (failedRules) { return; }\n\n        moveInArray(this.gridColumns, columnsToMove, toIndex);\n        this.updateDisplayedColumns(source);\n\n        const event: ColumnMovedEvent = {\n            type: Events.EVENT_COLUMN_MOVED,\n            columns: columnsToMove,\n            column: columnsToMove.length === 1 ? columnsToMove[0] : null,\n            toIndex: toIndex,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n        this.columnAnimationService.finish();\n    }\n\n    public doesMovePassRules(columnsToMove: Column[], toIndex: number): boolean {\n        // make a copy of what the grid columns would look like after the move\n        const proposedColumnOrder = this.gridColumns.slice();\n        moveInArray(proposedColumnOrder, columnsToMove, toIndex);\n\n        // then check that the new proposed order of the columns passes all rules\n        if (!this.doesMovePassMarryChildren(proposedColumnOrder)) {\n            return false;\n        }\n\n        if (!this.doesMovePassLockedPositions(proposedColumnOrder)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // returns the provided cols sorted in same order as they appear in grid columns. eg if grid columns\n    // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]\n    public sortColumnsLikeGridColumns(cols: Column[]): void {\n        if (!cols || cols.length <= 1) { return; }\n\n        const notAllColsInGridColumns = cols.filter(c => this.gridColumns.indexOf(c) < 0).length > 0;\n        if (notAllColsInGridColumns) { return; }\n\n        cols.sort((a: Column, b: Column) => {\n            const indexA = this.gridColumns.indexOf(a);\n            const indexB = this.gridColumns.indexOf(b);\n            return indexA - indexB;\n        });\n    }\n\n    public doesMovePassLockedPositions(proposedColumnOrder: Column[]): boolean {\n        let foundNonLocked = false;\n        let rulePassed = true;\n\n        // go though the cols, see if any non-locked appear before any locked\n        proposedColumnOrder.forEach(col => {\n            if (col.getColDef().lockPosition) {\n                if (foundNonLocked) {\n                    rulePassed = false;\n                }\n            } else {\n                foundNonLocked = true;\n            }\n        });\n\n        return rulePassed;\n    }\n\n    public doesMovePassMarryChildren(allColumnsCopy: Column[]): boolean {\n        let rulePassed = true;\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, child => {\n            if (!(child instanceof OriginalColumnGroup)) { return; }\n\n            const columnGroup = child;\n            const colGroupDef = columnGroup.getColGroupDef();\n            const marryChildren = colGroupDef && colGroupDef.marryChildren;\n\n            if (!marryChildren) { return; }\n\n            const newIndexes: number[] = [];\n            columnGroup.getLeafColumns().forEach(col => {\n                const newColIndex = allColumnsCopy.indexOf(col);\n                newIndexes.push(newColIndex);\n            });\n\n            const maxIndex = Math.max.apply(Math, newIndexes);\n            const minIndex = Math.min.apply(Math, newIndexes);\n\n            // spread is how far the first column in this group is away from the last column\n            const spread = maxIndex - minIndex;\n            const maxSpread = columnGroup.getLeafColumns().length - 1;\n\n            // if the columns\n            if (spread > maxSpread) {\n                rulePassed = false;\n            }\n\n            // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)\n            // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));\n        });\n\n        return rulePassed;\n    }\n\n    public moveColumn(key: string | Column, toIndex: number, source: ColumnEventType = \"api\") {\n        this.moveColumns([key], toIndex, source);\n    }\n\n    public moveColumnByIndex(fromIndex: number, toIndex: number, source: ColumnEventType = \"api\"): void {\n        const column = this.gridColumns[fromIndex];\n        this.moveColumn(column, toIndex, source);\n    }\n\n    public getColumnDefs(): (ColDef | ColGroupDef)[] {\n\n        const cols = this.primaryColumns.slice();\n        if (this.gridColsArePrimary) {\n            cols.sort((a: Column, b: Column) => this.gridColumns.indexOf(a) - this.gridColumns.indexOf(b));\n        } else if (this.lastPrimaryOrder) {\n            cols.sort((a: Column, b: Column) => this.lastPrimaryOrder.indexOf(a) - this.lastPrimaryOrder.indexOf(b));\n        }\n\n        return this.columnDefFactory.buildColumnDefs(cols, this.rowGroupColumns, this.pivotColumns);\n    }\n\n    // used by:\n    // + angularGrid -> for setting body width\n    // + rowController -> setting main row widths (when inserting and resizing)\n    // need to cache this\n    public getBodyContainerWidth(): number {\n        return this.bodyWidth;\n    }\n\n    public getContainerWidth(pinned: string | null): number {\n        switch (pinned) {\n            case Constants.PINNED_LEFT:\n                return this.leftWidth;\n            case Constants.PINNED_RIGHT:\n                return this.rightWidth;\n            default:\n                return this.bodyWidth;\n        }\n    }\n\n    // after setColumnWidth or updateGroupsAndDisplayedColumns\n    private updateBodyWidths(): void {\n        const newBodyWidth = this.getWidthOfColsInList(this.displayedColumnsCenter);\n        const newLeftWidth = this.getWidthOfColsInList(this.displayedColumnsLeft);\n        const newRightWidth = this.getWidthOfColsInList(this.displayedColumnsRight);\n\n        // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed\n        // columns, due to RTL inverting the y coordinates\n        this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;\n\n        const atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;\n\n        if (atLeastOneChanged) {\n            this.bodyWidth = newBodyWidth;\n            this.leftWidth = newLeftWidth;\n            this.rightWidth = newRightWidth;\n            // when this fires, it is picked up by the gridPanel, which ends up in\n            // gridPanel calling setWidthAndScrollPosition(), which in turn calls setViewportPosition()\n            const event: DisplayedColumnsWidthChangedEvent = {\n                type: Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    // + rowController\n    public getValueColumns(): Column[] {\n        return this.valueColumns ? this.valueColumns : [];\n    }\n\n    // + rowController\n    public getPivotColumns(): Column[] {\n        return this.pivotColumns ? this.pivotColumns : [];\n    }\n\n    // + clientSideRowModel\n    public isPivotActive(): boolean {\n        return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;\n    }\n\n    // + toolPanel\n    public getRowGroupColumns(): Column[] {\n        return this.rowGroupColumns ? this.rowGroupColumns : [];\n    }\n\n    // + rowController -> while inserting rows\n    public getDisplayedCenterColumns(): Column[] {\n        return this.displayedColumnsCenter;\n    }\n\n    // + rowController -> while inserting rows\n    public getDisplayedLeftColumns(): Column[] {\n        return this.displayedColumnsLeft;\n    }\n\n    public getDisplayedRightColumns(): Column[] {\n        return this.displayedColumnsRight;\n    }\n\n    public getDisplayedColumns(type: string | null): Column[] {\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                return this.getDisplayedLeftColumns();\n            case Constants.PINNED_RIGHT:\n                return this.getDisplayedRightColumns();\n            default:\n                return this.getDisplayedCenterColumns();\n        }\n    }\n\n    // used by:\n    // + clientSideRowController -> sorting, building quick filter text\n    // + headerRenderer -> sorting (clearing icon)\n    public getAllPrimaryColumns(): Column[] | null {\n        return this.primaryColumns ? this.primaryColumns.slice() : null;\n    }\n\n    public getSecondaryColumns(): Column[] | null {\n        return this.secondaryColumns ? this.secondaryColumns.slice() : null;\n    }\n\n    public getAllColumnsForQuickFilter(): Column[] {\n        return this.columnsForQuickFilter;\n    }\n\n    // + moveColumnController\n    public getAllGridColumns(): Column[] {\n        return this.gridColumns;\n    }\n\n    public isEmpty(): boolean {\n        return missingOrEmpty(this.gridColumns);\n    }\n\n    public isRowGroupEmpty(): boolean {\n        return missingOrEmpty(this.rowGroupColumns);\n    }\n\n    public setColumnVisible(key: string | Column, visible: boolean, source: ColumnEventType = \"api\"): void {\n        this.setColumnsVisible([key], visible, source);\n    }\n\n    public setColumnsVisible(keys: (string | Column)[], visible = false, source: ColumnEventType = \"api\"): void {\n        this.columnAnimationService.start();\n\n        this.actionOnGridColumns(keys, (column: Column): boolean => {\n            if (column.isVisible() !== visible) {\n                column.setVisible(visible, source);\n                return true;\n            }\n            return false;\n        }, source, () => {\n            const event: ColumnVisibleEvent = {\n                type: Events.EVENT_COLUMN_VISIBLE,\n                visible: visible,\n                column: null,\n                columns: null,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            return event;\n        });\n        this.columnAnimationService.finish();\n    }\n\n    public setColumnPinned(key: string | Column | null, pinned: string | boolean | null, source: ColumnEventType = \"api\"): void {\n        if (key) {\n            this.setColumnsPinned([key], pinned, source);\n        }\n    }\n\n    public setColumnsPinned(keys: (string | Column)[], pinned: string | boolean | null, source: ColumnEventType = \"api\"): void {\n        if (this.gridOptionsWrapper.getDomLayout() === 'print') {\n            console.warn(`Changing the column pinning status is not allowed with domLayout='print'`);\n            return;\n        }\n        this.columnAnimationService.start();\n\n        let actualPinned: string | null;\n        if (pinned === true || pinned === Constants.PINNED_LEFT) {\n            actualPinned = Constants.PINNED_LEFT;\n        } else if (pinned === Constants.PINNED_RIGHT) {\n            actualPinned = Constants.PINNED_RIGHT;\n        } else {\n            actualPinned = null;\n        }\n\n        this.actionOnGridColumns(keys, (col: Column): boolean => {\n            if (col.getPinned() !== actualPinned) {\n                col.setPinned(actualPinned);\n                return true;\n            }\n            return false;\n        }, source, () => {\n            const event: ColumnPinnedEvent = {\n                type: Events.EVENT_COLUMN_PINNED,\n                pinned: actualPinned,\n                column: null,\n                columns: null,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            return event;\n        });\n\n        this.columnAnimationService.finish();\n    }\n\n    // does an action on a set of columns. provides common functionality for looking up the\n    // columns based on key, getting a list of effected columns, and then updated the event\n    // with either one column (if it was just one col) or a list of columns\n    // used by: autoResize, setVisible, setPinned\n    private actionOnGridColumns(// the column keys this action will be on\n        keys: (string | Column)[],\n        // the action to do - if this returns false, the column was skipped\n        // and won't be included in the event\n        action: (column: Column) => boolean,\n        // should return back a column event of the right type\n        source: ColumnEventType,\n        createEvent?: () => ColumnEvent): void {\n\n        if (missingOrEmpty(keys)) { return; }\n\n        const updatedColumns: Column[] = [];\n\n        keys.forEach((key: string | Column) => {\n            const column = this.getGridColumn(key);\n            if (!column) { return; }\n\n            // need to check for false with type (ie !== instead of !=)\n            // as not returning anything (undefined) would also be false\n            const resultOfAction = action(column);\n            if (resultOfAction !== false) {\n                updatedColumns.push(column);\n            }\n        });\n\n        if (!updatedColumns.length) { return; }\n\n        this.updateDisplayedColumns(source);\n\n        if (exists(createEvent) && createEvent) {\n            const event = createEvent();\n\n            event.columns = updatedColumns;\n            event.column = updatedColumns.length === 1 ? updatedColumns[0] : null;\n\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    public getDisplayedColBefore(col: Column): Column | null {\n        const allDisplayedColumns = this.getAllDisplayedColumns();\n        const oldIndex = allDisplayedColumns.indexOf(col);\n\n        if (oldIndex > 0) {\n            return allDisplayedColumns[oldIndex - 1];\n        }\n\n        return null;\n    }\n\n    // used by:\n    // + rowRenderer -> for navigation\n    public getDisplayedColAfter(col: Column): Column | null {\n        const allDisplayedColumns = this.getAllDisplayedColumns();\n        const oldIndex = allDisplayedColumns.indexOf(col);\n\n        if (oldIndex < (allDisplayedColumns.length - 1)) {\n            return allDisplayedColumns[oldIndex + 1];\n        }\n\n        return null;\n    }\n\n    public getDisplayedGroupAfter(columnGroup: ColumnGroup): ColumnGroup | null {\n        return this.getDisplayedGroupAtDirection(columnGroup, 'After');\n    }\n\n    public getDisplayedGroupBefore(columnGroup: ColumnGroup): ColumnGroup | null {\n        return this.getDisplayedGroupAtDirection(columnGroup, 'Before');\n    }\n\n    public getDisplayedGroupAtDirection(columnGroup: ColumnGroup, direction: 'After' | 'Before'): ColumnGroup | null {\n        // pick the last displayed column in this group\n        const requiredLevel = columnGroup.getOriginalColumnGroup().getLevel() + columnGroup.getPaddingLevel();\n        const colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();\n        const col: Column | null = direction === 'After' ? last(colGroupLeafColumns) : colGroupLeafColumns[0];\n        const getDisplayColMethod: 'getDisplayedColAfter' | 'getDisplayedColBefore' = `getDisplayedCol${direction}` as any;\n\n        while (true) {\n            // keep moving to the next col, until we get to another group\n            const column = this[getDisplayColMethod](col);\n\n            if (!column) { return null; }\n\n            const groupPointer = this.getColumnGroupAtLevel(column, requiredLevel);\n\n            if (groupPointer !== columnGroup) {\n                return groupPointer;\n            }\n        }\n    }\n\n    public getColumnGroupAtLevel(column: Column, level: number): ColumnGroup | null {\n        // get group at same level as the one we are looking for\n        let groupPointer: ColumnGroup = column.getParent();\n        let originalGroupLevel: number;\n        let groupPointerLevel: number;\n\n        while (true) {\n            const groupPointerOriginalColumnGroup = groupPointer.getOriginalColumnGroup();\n            originalGroupLevel = groupPointerOriginalColumnGroup.getLevel();\n            groupPointerLevel = groupPointer.getPaddingLevel();\n\n            if (originalGroupLevel + groupPointerLevel <= level) { break; }\n            groupPointer = groupPointer.getParent();\n        }\n\n        return groupPointer;\n    }\n\n    public isPinningLeft(): boolean {\n        return this.displayedColumnsLeft.length > 0;\n    }\n\n    public isPinningRight(): boolean {\n        return this.displayedColumnsRight.length > 0;\n    }\n\n    public getPrimaryAndSecondaryAndAutoColumns(): Column[] {\n        const result = this.primaryColumns ? this.primaryColumns.slice(0) : [];\n\n        if (this.groupAutoColumns && exists(this.groupAutoColumns)) {\n            this.groupAutoColumns.forEach(col => result.push(col));\n        }\n\n        if (this.secondaryColumnsPresent && this.secondaryColumns) {\n            this.secondaryColumns.forEach(column => result.push(column));\n        }\n\n        return result;\n    }\n\n    private createStateItemFromColumn(column: Column): ColumnState {\n        const rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;\n        const pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;\n        const aggFunc = column.isValueActive() ? column.getAggFunc() : null;\n        const sort = column.getSort() != null ? column.getSort() : null;\n        const sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;\n        const flex = column.getFlex() != null && column.getFlex() > 0 ? column.getFlex() : null;\n\n        const res: ColumnState = {\n            colId: column.getColId(),\n            width: column.getActualWidth(),\n            hide: !column.isVisible(),\n            pinned: column.getPinned(),\n            sort,\n            sortIndex,\n            aggFunc,\n            rowGroup: column.isRowGroupActive(),\n            rowGroupIndex,\n            pivot: column.isPivotActive(),\n            pivotIndex: pivotIndex,\n            flex\n        };\n\n        return res;\n    }\n\n    public getColumnState(): ColumnState[] {\n        if (missing(this.primaryColumns) || !this.isAlive()) { return []; }\n\n        const primaryColumnState: ColumnState[]\n            = this.primaryColumns.map(this.createStateItemFromColumn.bind(this));\n\n        const groupAutoColumnState: ColumnState[]\n            = this.groupAutoColumns\n                // if groupAutoCols, then include them\n                ? this.groupAutoColumns.map(this.createStateItemFromColumn.bind(this))\n                // otherwise no\n                : [];\n\n        const columnStateList = groupAutoColumnState.concat(primaryColumnState);\n\n        if (!this.pivotMode) {\n            this.orderColumnStateList(columnStateList);\n        }\n\n        return columnStateList;\n    }\n\n    private orderColumnStateList(columnStateList: any[]): void {\n        // for fast looking, store the index of each column\n        const gridColumnIdMap = convertToMap<string, number>(this.gridColumns.map((col, index) => [col.getColId(), index]));\n\n        columnStateList.sort((itemA: any, itemB: any) => {\n            const posA = gridColumnIdMap.has(itemA.colId) ? gridColumnIdMap.get(itemA.colId) : -1;\n            const posB = gridColumnIdMap.has(itemB.colId) ? gridColumnIdMap.get(itemB.colId) : -1;\n            return posA! - posB!;\n        });\n    }\n\n    public resetColumnState(source: ColumnEventType = \"api\"): void {\n        // NOTE = there is one bug here that no customer has noticed - if a column has colDef.lockPosition,\n        // this is ignored  below when ordering the cols. to work, we should always put lockPosition cols first.\n        // As a work around, developers should just put lockPosition columns first in their colDef list.\n\n        // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list\n        const primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n        const columnStates: ColumnState[] = [];\n\n        // we start at 1000, so if user has mix of rowGroup and group specified, it will work with both.\n        // eg IF user has ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=true,\n        // THEN result will be ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=1000\n        let letRowGroupIndex = 1000;\n        let letPivotIndex = 1000;\n\n        let colsToProcess: Column[] = [];\n        if (this.groupAutoColumns) {\n            colsToProcess = colsToProcess.concat(this.groupAutoColumns);\n        }\n\n        if (primaryColumns) {\n            colsToProcess = colsToProcess.concat(primaryColumns);\n        }\n\n        colsToProcess.forEach(column => {\n            const colDef = column.getColDef();\n            const sort = colDef.sort != null ? colDef.sort : null;\n            const sortIndex = colDef.sortIndex;\n            const hide = colDef.hide ? true : false;\n            const pinned = colDef.pinned ? colDef.pinned : null;\n\n            const width = colDef.width;\n            const flex = colDef.flex != null ? colDef.flex : null;\n\n            let rowGroupIndex: number | null | undefined = colDef.rowGroupIndex;\n            let rowGroup: boolean | null | undefined = colDef.rowGroup;\n\n            if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {\n                rowGroupIndex = null;\n                rowGroup = null;\n            }\n\n            let pivotIndex: number | null | undefined = colDef.pivotIndex;\n            let pivot: boolean | null | undefined = colDef.pivot;\n\n            if (pivotIndex == null && (pivot == null || pivot == false)) {\n                pivotIndex = null;\n                pivot = null;\n            }\n\n            const aggFunc = colDef.aggFunc != null ? colDef.aggFunc : null;\n\n            const stateItem = {\n                colId: column.getColId(),\n                sort,\n                sortIndex,\n                hide,\n                pinned,\n\n                width,\n                flex,\n\n                rowGroup,\n                rowGroupIndex,\n                pivot,\n                pivotIndex,\n                aggFunc,\n            };\n\n            if (missing(rowGroupIndex) && rowGroup) {\n                stateItem.rowGroupIndex = letRowGroupIndex++;\n            }\n\n            if (missing(pivotIndex) && pivot) {\n                stateItem.pivotIndex = letPivotIndex++;\n            }\n\n            columnStates.push(stateItem);\n        });\n\n        this.applyColumnState({ state: columnStates, applyOrder: true }, source);\n    }\n\n    public applyColumnState(params: ApplyColumnStateParams, source: ColumnEventType = \"api\"): boolean {\n        if (missingOrEmpty(this.primaryColumns)) { return false; }\n\n        if (params && params.state && !params.state.forEach) {\n            console.warn('AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.');\n            return false;\n        }\n\n        this.columnAnimationService.start();\n\n        const raiseEventsFunc = this.compareColumnStatesAndRaiseEvents(source);\n\n        this.autoGroupsNeedBuilding = true;\n\n        // at the end below, this list will have all columns we got no state for\n        const columnsWithNoState = this.primaryColumns.slice();\n\n        let success = true;\n\n        const rowGroupIndexes: { [key: string]: number; } = {};\n        const pivotIndexes: { [key: string]: number; } = {};\n        const autoGroupColumnStates: ColumnState[] = [];\n\n        const previousRowGroupCols = this.rowGroupColumns.slice();\n        const previousPivotCols = this.pivotColumns.slice();\n\n        if (params.state) {\n            params.state.forEach((state: ColumnState) => {\n                const groupAutoColumnId = Constants.GROUP_AUTO_COLUMN_ID;\n                const colId = state.colId || '';\n\n                // auto group columns are re-created so deferring syncing with ColumnState\n                const isAutoGroupColumn = startsWith(colId, groupAutoColumnId);\n                if (isAutoGroupColumn) {\n                    autoGroupColumnStates.push(state);\n                    return;\n                }\n\n                const column = this.getPrimaryColumn(colId);\n\n                if (!column) {\n                    // we don't log the failure, as it's possible the user is applying that has extra\n                    // cols in it. for example they could of save while row-grouping (so state includes\n                    // auto-group column) and then applied state when not grouping (so the auto-group\n                    // column would be in the state but no used).\n                    success = false;\n                } else {\n                    this.syncColumnWithStateItem(column, state, params.defaultState, rowGroupIndexes,\n                        pivotIndexes, false, source);\n                    removeFromArray(columnsWithNoState, column);\n                }\n            });\n        }\n\n        // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden\n        const applyDefaultsFunc = (col: Column) =>\n            this.syncColumnWithStateItem(col, null, params.defaultState, rowGroupIndexes,\n                pivotIndexes, false, source)\n\n        columnsWithNoState.forEach(applyDefaultsFunc);\n\n        // sort the lists according to the indexes that were provided\n        const comparator = (indexes: { [key: string]: number; }, oldList: Column[], colA: Column, colB: Column) => {\n\n            const indexA = indexes[colA.getId()];\n            const indexB = indexes[colB.getId()];\n\n            const aHasIndex = indexA != null;\n            const bHasIndex = indexB != null;\n\n            if (aHasIndex && bHasIndex) {\n                // both a and b are new cols with index, so sort on index\n                return indexA - indexB;\n            }\n\n            if (aHasIndex) {\n                // a has an index, so it should be before a\n                return -1;\n            }\n\n            if (bHasIndex) {\n                // b has an index, so it should be before a\n                return 1;\n            }\n\n            const oldIndexA = oldList.indexOf(colA);\n            const oldIndexB = oldList.indexOf(colB);\n\n            const aHasOldIndex = oldIndexA >= 0;\n            const bHasOldIndex = oldIndexB >= 0;\n\n            if (aHasOldIndex && bHasOldIndex) {\n                // both a and b are old cols, so sort based on last order\n                return oldIndexA - oldIndexB;\n            }\n\n            if (aHasOldIndex) {\n                // a is old, b is new, so b is first\n                return -1;\n            }\n\n            // this bit does matter, means both are new cols\n            // but without index or that b is old and a is new\n            return 1;\n        };\n\n        this.rowGroupColumns.sort(comparator.bind(this, rowGroupIndexes, previousRowGroupCols));\n        this.pivotColumns.sort(comparator.bind(this, pivotIndexes, previousPivotCols));\n\n        this.updateGridColumns();\n\n        // sync newly created auto group columns with ColumnState\n        const autoGroupColsCopy = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];\n        autoGroupColumnStates.forEach(stateItem => {\n            const autoCol = this.getAutoColumn(stateItem.colId!);\n            removeFromArray(autoGroupColsCopy, autoCol);\n            this.syncColumnWithStateItem(autoCol, stateItem, params.defaultState, null, null, true, source);\n        });\n        // autogroup cols with nothing else, apply the default\n        autoGroupColsCopy.forEach(applyDefaultsFunc);\n\n        this.applyOrderAfterApplyState(params);\n        this.updateDisplayedColumns(source);\n        this.dispatchEverythingChanged(source);\n\n        raiseEventsFunc();\n        this.columnAnimationService.finish();\n\n        return success;\n    }\n\n    private applyOrderAfterApplyState(params: ApplyColumnStateParams): void {\n        if (!this.gridColsArePrimary || !params.applyOrder || !params.state) { return; }\n\n        let newOrder: Column[] = [];\n        const processedColIds: {[id: string]:boolean} = {};\n\n        const gridColumnsMap: {[id: string]: Column} = {};\n        this.gridColumns.forEach(col => gridColumnsMap[col.getId()] = col);\n\n        params.state.forEach(item => {\n            if (!item.colId || processedColIds[item.colId]) { return; }\n            const col = gridColumnsMap[item.colId];\n            if (col) {\n                newOrder.push(col);\n                processedColIds[item.colId] = true;\n            }\n        });\n\n        // add in all other columns\n        this.gridColumns.forEach(col => {\n            if (!processedColIds[col.getColId()]) {\n                newOrder.push(col);\n            }\n        });\n\n        // this is already done in updateGridColumns, however we changed the order above (to match the order of the state\n        // columns) so we need to do it again. we could of put logic into the order above to take into account fixed\n        // columns, however if we did then we would have logic for updating fixed columns twice. reusing the logic here\n        // is less sexy for the code here, but it keeps consistency.\n        newOrder = this.putFixedColumnsFirst(newOrder);\n\n        if (!this.doesMovePassMarryChildren(newOrder)) {\n            console.warn('AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.');\n            return;\n        }\n\n        this.gridColumns = newOrder;\n    }\n\n    private compareColumnStatesAndRaiseEvents(source: ColumnEventType): () => void {\n\n        // if no columns to begin with, then it means we are setting columns for the first time, so\n        // there should be no events fired to show differences in columns.\n        const colsPreviouslyExisted = !!this.columnDefs;\n        if (!colsPreviouslyExisted) {\n            return () => {};\n        }\n\n        const startState = {\n            rowGroupColumns: this.rowGroupColumns.slice(),\n            pivotColumns: this.pivotColumns.slice(),\n            valueColumns: this.valueColumns.slice()\n        };\n\n        const columnStateBefore = this.getColumnState();\n        const columnStateBeforeMap: { [colId: string]: ColumnState; } = {};\n\n        columnStateBefore.forEach(col => {\n            columnStateBeforeMap[col.colId!] = col;\n        });\n\n        return () => {\n            if (this.gridOptionsWrapper.isSuppressColumnStateEvents()) { return; }\n\n            // raises generic ColumnEvents where all columns are returned rather than what has changed\n            const raiseWhenListsDifferent = (eventType: string, colsBefore: Column[], colsAfter: Column[], idMapper: (column: Column) => string) => {\n                const beforeList = colsBefore.map(idMapper).sort();\n                const afterList = colsAfter.map(idMapper).sort();\n                const unchanged = areEqual(beforeList, afterList);\n\n                if (unchanged) { return; }\n\n                // returning all columns rather than what has changed!\n                const event: ColumnEvent = {\n                    type: eventType,\n                    columns: colsAfter,\n                    column: colsAfter.length === 1 ? colsAfter[0] : null,\n                    api: this.gridApi,\n                    columnApi: this.columnApi,\n                    source: source\n                };\n\n                this.eventService.dispatchEvent(event);\n            };\n\n            // determines which columns have changed according to supplied predicate\n            const getChangedColumns = (changedPredicate: (cs: ColumnState, c: Column) => boolean): Column[] => {\n                const changedColumns: Column[] = [];\n\n                this.gridColumns.forEach(column => {\n                    const colStateBefore = columnStateBeforeMap[column.getColId()];\n                    if (colStateBefore && changedPredicate(colStateBefore, column)) {\n                        changedColumns.push(column);\n                    }\n                });\n\n                return changedColumns;\n            };\n\n            const columnIdMapper = (c: Column) => c.getColId();\n\n            raiseWhenListsDifferent(Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n                startState.rowGroupColumns,\n                this.rowGroupColumns,\n                columnIdMapper\n            );\n\n            raiseWhenListsDifferent(Events.EVENT_COLUMN_PIVOT_CHANGED,\n                startState.pivotColumns,\n                this.pivotColumns,\n                columnIdMapper\n            );\n\n            const valueChangePredicate = (cs: ColumnState, c: Column) => {\n                const oldActive = cs.aggFunc != null;\n\n                const activeChanged = oldActive != c.isValueActive();\n                // we only check aggFunc if the agg is active\n                const aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();\n\n                return activeChanged || aggFuncChanged;\n            }\n            const changedValues = getChangedColumns(valueChangePredicate);\n            if (changedValues.length > 0) {\n                // we pass all value columns, now the ones that changed. this is the same\n                // as pivot and rowGroup cols, but different to all other properties below.\n                // this is more for backwards compatibility, as it's always been this way.\n                // really it should be the other way, as the order of the cols makes no difference\n                // for valueColumns (apart from displaying them in the tool panel).\n                this.fireColumnEvent(Events.EVENT_COLUMN_VALUE_CHANGED, this.valueColumns, source);\n            }\n\n            const resizeChangePredicate = (cs: ColumnState, c: Column) => cs.width != c.getActualWidth();\n            this.fireColumnResizedEvent(getChangedColumns(resizeChangePredicate), true, source);\n\n            const pinnedChangePredicate = (cs: ColumnState, c: Column) => cs.pinned != c.getPinned();\n            this.raiseColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);\n\n            const visibilityChangePredicate = (cs: ColumnState, c: Column) => cs.hide == c.isVisible();\n            this.raiseColumnVisibleEvent(getChangedColumns(visibilityChangePredicate), source);\n\n            const sortChangePredicate = (cs: ColumnState, c: Column) => cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex();\n            if (getChangedColumns(sortChangePredicate).length > 0) {\n                this.sortController.dispatchSortChangedEvents();\n            }\n\n            // special handling for moved column events\n            this.raiseColumnMovedEvent(columnStateBefore, source);\n        };\n    }\n\n    private raiseColumnPinnedEvent(changedColumns: Column[], source: ColumnEventType) {\n        if (!changedColumns.length) { return; }\n\n        // if just one column, we use this, otherwise we don't include the col\n        const column: Column | null = changedColumns.length === 1 ? changedColumns[0] : null;\n\n        // only include visible if it's common in all columns\n        const pinned = this.getCommonValue(changedColumns, col => col.getPinned());\n\n        const event: ColumnPinnedEvent = {\n            type: Events.EVENT_COLUMN_PINNED,\n            // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'\n            pinned: pinned != null ? pinned : null,\n            columns: changedColumns,\n            column,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private getCommonValue<T>(cols: Column[], valueGetter: ((col: Column) => T)): T | undefined {\n        if (!cols || cols.length == 0) { return undefined; }\n\n        // compare each value to the first value. if nothing differs, then value is common so return it.\n        const firstValue = valueGetter(cols[0]);\n        for (let i = 1; i < cols.length; i++) {\n            if (firstValue !== valueGetter(cols[i])) {\n                // values differ, no common value\n                return undefined;\n            }\n        }\n\n        return firstValue;\n    }\n\n    private raiseColumnVisibleEvent(changedColumns: Column[], source: ColumnEventType) {\n        if (!changedColumns.length) { return; }\n\n        // if just one column, we use this, otherwise we don't include the col\n        const column: Column | null = changedColumns.length === 1 ? changedColumns[0] : null;\n\n        // only include visible if it's common in all columns\n        const visible = this.getCommonValue(changedColumns, col => col.isVisible());\n\n        const event: ColumnVisibleEvent = {\n            type: Events.EVENT_COLUMN_VISIBLE,\n            visible,\n            columns: changedColumns,\n            column,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private raiseColumnMovedEvent(colStateBefore: ColumnState[], source: ColumnEventType) {\n\n        // we are only interested in columns that were both present and visible before and after\n\n        const colStateAfter = this.getColumnState();\n\n        const colStateAfterMapped: { [id: string]: ColumnState; } = {};\n        colStateAfter.forEach(s => colStateAfterMapped[s.colId!] = s);\n\n        // get id's of cols in both before and after lists\n        const colsIntersectIds: { [id: string]: boolean; } = {};\n        colStateBefore.forEach(s => {\n            if (colStateAfterMapped[s.colId!]) {\n                colsIntersectIds[s.colId!] = true;\n            }\n        });\n\n        // filter state lists, so we only have cols that were present before and after\n        const beforeFiltered = filter(colStateBefore, c => colsIntersectIds[c.colId!]);\n        const afterFiltered = filter(colStateAfter, c => colsIntersectIds[c.colId!]);\n\n        // see if any cols are in a different location\n        const movedColumns: Column[] = [];\n\n        afterFiltered!.forEach((csAfter: ColumnState, index: number) => {\n            const csBefore = beforeFiltered && beforeFiltered[index];\n            if (csBefore && csBefore.colId !== csAfter.colId) {\n                const gridCol = this.getGridColumn(csBefore.colId!);\n                if (gridCol) {\n                    movedColumns.push(gridCol);\n                }\n            }\n        });\n\n        if (!movedColumns.length) { return; }\n\n        const event: ColumnMovedEvent = {\n            type: Events.EVENT_COLUMN_MOVED,\n            columns: movedColumns,\n            column: null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private syncColumnWithStateItem(\n        column: Column | null,\n        stateItem: ColumnState | null,\n        defaultState: ColumnState | undefined,\n        rowGroupIndexes: { [key: string]: number; } | null,\n        pivotIndexes: { [key: string]: number; } | null,\n        autoCol: boolean,\n        source: ColumnEventType\n    ): void {\n\n        if (!column) { return; }\n\n        const getValue = (key1: string, key2?: string): { value1: any, value2: any; } => {\n            const stateAny = stateItem as any;\n            const defaultAny = defaultState as any;\n            const obj: { value1: any, value2: any } = { value1: undefined, value2: undefined };\n            let calculated: boolean = false;\n\n            if (stateAny) {\n                if (stateAny[key1] !== undefined) {\n                    obj.value1 = stateAny[key1];\n                    calculated = true;\n                }\n                if (exists(key2) && stateAny[key2] !== undefined) {\n                    obj.value2 = stateAny[key2];\n                    calculated = true;\n                }\n            }\n\n            if (!calculated && defaultAny) {\n                if (defaultAny[key1] !== undefined) {\n                    obj.value1 = defaultAny[key1];\n                }\n                if (exists(key2) && defaultAny[key2] !== undefined) {\n                    obj.value2 = defaultAny[key2];\n                }\n            }\n\n            return obj;\n        };\n\n        // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true\n        const hide = getValue('hide').value1;\n        if (hide !== undefined) {\n            column.setVisible(!hide, source);\n        }\n\n        // sets pinned to 'left' or 'right'\n        const pinned = getValue('pinned').value1;\n        if (pinned !== undefined) {\n            column.setPinned(pinned);\n        }\n\n        // if width provided and valid, use it, otherwise stick with the old width\n        const minColWidth = this.gridOptionsWrapper.getMinColWidth();\n\n        // flex\n        const flex = getValue('flex').value1;\n        if (flex !== undefined) {\n            column.setFlex(flex);\n        }\n\n        // width - we only set width if column is not flexing\n        const noFlexThisCol = column.getFlex() <= 0;\n        if (noFlexThisCol) {\n            // both null and undefined means we skip, as it's not possible to 'clear' width (a column must have a width)\n            const width = getValue('width').value1;\n            if (width != null) {\n                if (minColWidth &&\n                    (width >= minColWidth)) {\n                    column.setActualWidth(width, source);\n                }\n            }\n        }\n\n        const sort = getValue('sort').value1;\n        if (sort !== undefined) {\n            if (sort === Constants.SORT_DESC || sort === Constants.SORT_ASC) {\n                column.setSort(sort);\n            } else {\n                column.setSort(undefined);\n            }\n        }\n\n        const sortIndex = getValue('sortIndex').value1;\n        if (sortIndex !== undefined) {\n            column.setSortIndex(sortIndex);\n        }\n\n        // we do not do aggFunc, rowGroup or pivot for auto cols, as you can't do these with auto col\n        if (autoCol) {\n            return;\n        }\n\n        const aggFunc = getValue('aggFunc').value1;\n        if (aggFunc !== undefined) {\n            if (typeof aggFunc === 'string') {\n                column.setAggFunc(aggFunc);\n                if (!column.isValueActive()) {\n                    column.setValueActive(true, source);\n                    this.valueColumns.push(column);\n                }\n            } else {\n                if (exists(aggFunc)) {\n                    console.warn('AG Grid: stateItem.aggFunc must be a string. if using your own aggregation ' +\n                        'functions, register the functions first before using them in get/set state. This is because it is ' +\n                        'intended for the column state to be stored and retrieved as simple JSON.');\n                }\n                column.setAggFunc(null);\n                if (column.isValueActive()) {\n                    column.setValueActive(false, source);\n                    removeFromArray(this.valueColumns, column);\n                }\n            }\n        }\n\n        const { value1: rowGroup, value2: rowGroupIndex } = getValue('rowGroup', 'rowGroupIndex');\n        if (rowGroup !== undefined || rowGroupIndex !== undefined) {\n            if (typeof rowGroupIndex === 'number' || rowGroup) {\n                if (!column.isRowGroupActive()) {\n                    column.setRowGroupActive(true, source);\n                    this.rowGroupColumns.push(column);\n                }\n                if (rowGroupIndexes && typeof rowGroupIndex === 'number') {\n                    rowGroupIndexes[column.getId()] = rowGroupIndex;\n                }\n            } else {\n                if (column.isRowGroupActive()) {\n                    column.setRowGroupActive(false, source);\n                    removeFromArray(this.rowGroupColumns, column);\n                }\n            }\n        }\n\n        const { value1: pivot, value2: pivotIndex } = getValue('pivot', 'pivotIndex');\n        if (pivot !== undefined || pivotIndex !== undefined) {\n            if (typeof pivotIndex === 'number' || pivot) {\n                if (!column.isPivotActive()) {\n                    column.setPivotActive(true, source);\n                    this.pivotColumns.push(column);\n                }\n                if (pivotIndexes && typeof pivotIndex === 'number') {\n                    pivotIndexes[column.getId()] = pivotIndex;\n                }\n            } else {\n                if (column.isPivotActive()) {\n                    column.setPivotActive(false, source);\n                    removeFromArray(this.pivotColumns, column);\n                }\n            }\n        }\n    }\n\n    public getGridColumns(keys: (string | Column)[]): Column[] {\n        return this.getColumns(keys, this.getGridColumn.bind(this));\n    }\n\n    private getColumns(keys: (string | Column)[], columnLookupCallback: (key: string | Column) => Column): Column[] {\n        const foundColumns: Column[] = [];\n\n        if (keys) {\n            keys.forEach((key: (string | Column)) => {\n                const column = columnLookupCallback(key);\n                if (column) {\n                    foundColumns.push(column);\n                }\n            });\n        }\n\n        return foundColumns;\n    }\n\n    // used by growGroupPanel\n    public getColumnWithValidation(key: string | Column | undefined): Column | null {\n        if (key == null) { return null; }\n\n        const column = this.getGridColumn(key);\n\n        if (!column) {\n            console.warn('AG Grid: could not find column ' + key);\n        }\n\n        return column;\n    }\n\n    public getPrimaryColumn(key: string | Column): Column | null {\n        return this.getColumn(key, this.primaryColumns, this.primaryColumnsMap);\n    }\n\n    public getGridColumn(key: string | Column): Column | null {\n        return this.getColumn(key, this.gridColumns, this.gridColumnsMap);\n    }\n\n    private getColumn(key: string | Column, columnList: Column[], columnMap: {[id: string]: Column}): Column | null {\n        if (!key) { return null; }\n\n        // most of the time this method gets called the key is a string, so we put this shortcut in\n        // for performance reasons, to see if we can match for ID (it doesn't do auto columns, that's done below)\n        if (typeof key == 'string' && columnMap[key]) {\n            return columnMap[key];\n        }\n\n        for (let i = 0; i < columnList.length; i++) {\n            if (this.columnsMatch(columnList[i], key)) {\n                return columnList[i];\n            }\n        }\n\n        return this.getAutoColumn(key);\n    }\n\n    private getAutoColumn(key: string | Column): Column | null {\n        if (\n            !this.groupAutoColumns ||\n            !exists(this.groupAutoColumns) ||\n            missing(this.groupAutoColumns)\n        ) { return null; }\n\n        return find(this.groupAutoColumns, groupCol => this.columnsMatch(groupCol, key));\n    }\n\n    private columnsMatch(column: Column, key: string | Column): boolean {\n        const columnMatches = column === key;\n        const colDefMatches = column.getColDef() === key;\n        const idMatches = column.getColId() == key;\n\n        return columnMatches || colDefMatches || idMatches;\n    }\n\n    public getDisplayNameForColumn(column: Column | null, location: string | null, includeAggFunc = false): string | null {\n        if (!column) { return null; }\n\n        const headerName: string | null = this.getHeaderName(column.getColDef(), column, null, null, location);\n\n        if (includeAggFunc) {\n            return this.wrapHeaderNameWithAggFunc(column, headerName);\n        }\n\n        return headerName;\n    }\n\n    public getDisplayNameForOriginalColumnGroup(\n        columnGroup: ColumnGroup | null,\n        originalColumnGroup: OriginalColumnGroup | null,\n        location: string\n    ): string | null {\n        const colGroupDef = originalColumnGroup ? originalColumnGroup.getColGroupDef() : null;\n\n        if (colGroupDef) {\n            return this.getHeaderName(colGroupDef, null, columnGroup, originalColumnGroup, location);\n        }\n\n        return null;\n    }\n\n    public getDisplayNameForColumnGroup(columnGroup: ColumnGroup, location: string): string | null {\n        return this.getDisplayNameForOriginalColumnGroup(columnGroup, columnGroup.getOriginalColumnGroup(), location);\n    }\n\n    // location is where the column is going to appear, ie who is calling us\n    private getHeaderName(\n        colDef: AbstractColDef,\n        column: Column | null,\n        columnGroup: ColumnGroup | null,\n        originalColumnGroup: OriginalColumnGroup | null,\n        location: string | null\n    ): string | null {\n        const headerValueGetter = colDef.headerValueGetter;\n\n        if (headerValueGetter) {\n            const params = {\n                colDef: colDef,\n                column: column,\n                columnGroup: columnGroup,\n                originalColumnGroup: originalColumnGroup,\n                location: location,\n                api: this.gridOptionsWrapper.getApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n\n            if (typeof headerValueGetter === 'function') {\n                // valueGetter is a function, so just call it\n                return headerValueGetter(params);\n            } else if (typeof headerValueGetter === 'string') {\n                // valueGetter is an expression, so execute the expression\n                return this.expressionService.evaluate(headerValueGetter, params);\n            }\n            console.warn('ag-grid: headerValueGetter must be a function or a string');\n            return '';\n        } else if (colDef.headerName != null) {\n            return colDef.headerName;\n        } else if ((colDef as ColDef).field) {\n            return camelCaseToHumanText((colDef as ColDef).field);\n        }\n\n        return '';\n    }\n\n    /*\n        private getHeaderGroupName(columnGroup: ColumnGroup): string {\n            let colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();\n            let headerValueGetter = colGroupDef.headerValueGetter;\n\n            if (headerValueGetter) {\n                let params = {\n                    columnGroup: columnGroup,\n                    colDef: colGroupDef,\n                    api: this.gridOptionsWrapper.getApi(),\n                    context: this.gridOptionsWrapper.getContext()\n                };\n\n                if (typeof headerValueGetter === 'function') {\n                    // valueGetter is a function, so just call it\n                    return headerValueGetter(params);\n                } else if (typeof headerValueGetter === 'string') {\n                    // valueGetter is an expression, so execute the expression\n                    return this.expressionService.evaluate(headerValueGetter, params);\n                } else {\n                    console.warn('ag-grid: headerValueGetter must be a function or a string');\n                    return '';\n                }\n            } else {\n                return colGroupDef.headerName;\n            }\n        }\n    */\n\n    private wrapHeaderNameWithAggFunc(column: Column, headerName: string | null): string | null {\n        if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) { return headerName; }\n\n        // only columns with aggregation active can have aggregations\n        const pivotValueColumn = column.getColDef().pivotValueColumn;\n        const pivotActiveOnThisColumn = exists(pivotValueColumn);\n        let aggFunc: string | IAggFunc | null | undefined = null;\n        let aggFuncFound: boolean;\n\n        // otherwise we have a measure that is active, and we are doing aggregation on it\n        if (pivotActiveOnThisColumn) {\n            aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;\n            aggFuncFound = true;\n        } else {\n            const measureActive = column.isValueActive();\n            const aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();\n\n            if (measureActive && aggregationPresent) {\n                aggFunc = column.getAggFunc();\n                aggFuncFound = true;\n            } else {\n                aggFuncFound = false;\n            }\n        }\n\n        if (aggFuncFound) {\n            const aggFuncString = (typeof aggFunc === 'string') ? aggFunc : 'func';\n            const localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n            const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n            return `${aggFuncStringTranslated}(${headerName})`;\n        }\n\n        return headerName;\n    }\n\n    // returns the group with matching colId and instanceId. If instanceId is missing,\n    // matches only on the colId.\n    public getColumnGroup(colId: string | ColumnGroup, instanceId?: number): ColumnGroup | null {\n        if (!colId) { return null; }\n        if (colId instanceof ColumnGroup) { return colId; }\n\n        const allColumnGroups = this.getAllDisplayedTrees();\n        const checkInstanceId = typeof instanceId === 'number';\n        let result: ColumnGroup | null = null;\n\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, (child: ColumnGroupChild) => {\n            if (child instanceof ColumnGroup) {\n                const columnGroup = child;\n                let matched: boolean;\n\n                if (checkInstanceId) {\n                    matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();\n                } else {\n                    matched = colId === columnGroup.getGroupId();\n                }\n\n                if (matched) {\n                    result = columnGroup;\n                }\n            }\n        });\n\n        return result;\n    }\n\n    public isReady(): boolean {\n        return this.ready;\n    }\n\n    private extractValueColumns(source: ColumnEventType, oldPrimaryColumns: Column[]): void {\n        this.valueColumns = this.extractColumns(\n            oldPrimaryColumns,\n            this.valueColumns,\n            (col: Column, flag: boolean) => col.setValueActive(flag, source),\n            // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null\n            () => undefined,\n            () => undefined,\n            // aggFunc is a string, so return it's existence\n            (colDef: ColDef) => {\n                const aggFunc = colDef.aggFunc;\n                // null or empty string means clear\n                if (aggFunc === null || aggFunc === '') {\n                    return null;\n                }\n                if (aggFunc === undefined) {\n                    return;\n                }\n\n                return !!aggFunc;\n            },\n            (colDef: ColDef) => {\n                // return false if any of the following: null, undefined, empty string\n                return colDef.initialAggFunc != null && colDef.initialAggFunc != '';\n            }\n        );\n\n        // all new columns added will have aggFunc missing, so set it to what is in the colDef\n        this.valueColumns.forEach(col => {\n            const colDef = col.getColDef();\n            // if aggFunc provided, we always override, as reactive property\n            if (colDef.aggFunc != null && colDef.aggFunc != '') {\n                col.setAggFunc(colDef.aggFunc);\n            } else {\n                // otherwise we use initialAggFunc only if no agg func set - which happens when new column only\n                if (!col.getAggFunc()) {\n                    col.setAggFunc(colDef.initialAggFunc);\n                }\n            }\n        });\n    }\n\n    private extractRowGroupColumns(source: ColumnEventType, oldPrimaryColumns: Column[]): void {\n        this.rowGroupColumns = this.extractColumns(oldPrimaryColumns, this.rowGroupColumns,\n            (col: Column, flag: boolean) => col.setRowGroupActive(flag, source),\n            (colDef: ColDef) => colDef.rowGroupIndex,\n            (colDef: ColDef) => colDef.initialRowGroupIndex,\n            (colDef: ColDef) => colDef.rowGroup,\n            (colDef: ColDef) => colDef.initialRowGroup,\n        );\n    }\n\n    private extractColumns(\n        oldPrimaryColumns: Column[] = [],\n        previousCols: Column[] = [],\n        setFlagFunc: (col: Column, flag: boolean) => void,\n        getIndexFunc: (colDef: ColDef) => number | null | undefined,\n        getInitialIndexFunc: (colDef: ColDef) => number | null | undefined,\n        getValueFunc: (colDef: ColDef) => boolean | null | undefined,\n        getInitialValueFunc: (colDef: ColDef) => boolean | undefined\n    ): Column[] {\n\n        const colsWithIndex: Column[] = [];\n        const colsWithValue: Column[] = [];\n\n        // go though all cols.\n        // if value, change\n        // if default only, change only if new\n        this.primaryColumns.forEach(col => {\n            const colIsNew = oldPrimaryColumns.indexOf(col) < 0;\n            const colDef = col.getColDef();\n\n            const value = attrToBoolean(getValueFunc(colDef));\n            const initialValue = attrToBoolean(getInitialValueFunc(colDef));\n            const index = attrToNumber(getIndexFunc(colDef));\n            const initialIndex = attrToNumber(getInitialIndexFunc(colDef));\n\n            let include: boolean;\n\n            if (colIsNew) {\n                // col is new, use values if present, otherwise use default values if present\n                const valuePresent = value !== undefined || index !== undefined;\n                if (valuePresent) {\n                    if (value !== undefined) {\n                        // if boolean value present, we take it's value, even if 'false'\n                        include = value;\n                    } else {\n                        // otherwise we based on number value. note that 'null' resets, however 'undefined' doesn't\n                        // go through this code path (undefined means 'ignore').\n                        include = index! >= 0;\n                    }\n                } else {\n                    include = initialValue || initialIndex! >= 0;\n                }\n            } else {\n                // col is not new, we ignore the default values, just use the values if provided\n                if (value !== undefined) { // value is never null, as attrToBoolean converts null to false\n                    include = value;\n                } else if (index !== undefined) {\n                    if (index === null) {\n                        include = false;\n                    } else {\n                        include = index >= 0;\n                    }\n                } else {\n                    // no values provided, we include if it was included last time\n                    include = previousCols.indexOf(col) >= 0;\n                }\n            }\n\n            if (include) {\n                const useIndex = colIsNew ? (index != null || initialIndex != null) : index != null;\n                if (useIndex) {\n                    colsWithIndex.push(col);\n                } else {\n                    colsWithValue.push(col);\n                }\n            }\n        });\n\n        const getIndexForCol = (col: Column): number => {\n            const index = getIndexFunc(col.getColDef());\n            const defaultIndex = getInitialIndexFunc(col.getColDef());\n\n            return index != null ? index : defaultIndex!;\n        };\n\n        // sort cols with index, and add these first\n        colsWithIndex.sort((colA, colB) => {\n            const indexA = getIndexForCol(colA);\n            const indexB = getIndexForCol(colB);\n\n            if (indexA === indexB) { return 0; }\n            if (indexA < indexB) { return -1; }\n\n            return 1;\n        });\n\n        const res: Column[] = ([] as Column[]).concat(colsWithIndex);\n\n        // second add columns that were there before and in the same order as they were before,\n        // so we are preserving order of current grouping of columns that simply have rowGroup=true\n        previousCols.forEach(col => {\n            if (colsWithValue.indexOf(col) >= 0) {\n                res.push(col);\n            }\n        });\n\n        // lastly put in all remaining cols\n        colsWithValue.forEach(col => {\n            if (res.indexOf(col) < 0) {\n                res.push(col);\n            }\n        });\n\n        // set flag=false for removed cols\n        previousCols.forEach(col => {\n            if (res.indexOf(col) < 0) {\n                setFlagFunc(col, false);\n            }\n        });\n        // set flag=true for newly added cols\n        res.forEach(col => {\n            if (previousCols.indexOf(col) < 0) {\n                setFlagFunc(col, true);\n            }\n        });\n\n        return res;\n    }\n\n    private extractPivotColumns(source: ColumnEventType, oldPrimaryColumns: Column[]): void {\n        this.pivotColumns = this.extractColumns(\n            oldPrimaryColumns,\n            this.pivotColumns,\n            (col: Column, flag: boolean) => col.setPivotActive(flag, source),\n            (colDef: ColDef) => colDef.pivotIndex,\n            (colDef: ColDef) => colDef.initialPivotIndex,\n            (colDef: ColDef) => colDef.pivot,\n            (colDef: ColDef) => colDef.initialPivot,\n        );\n    }\n\n    public resetColumnGroupState(source: ColumnEventType = \"api\"): void {\n        const stateItems: { groupId: string, open: boolean | undefined; }[] = [];\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, child => {\n            if (child instanceof OriginalColumnGroup) {\n                const colGroupDef = child.getColGroupDef();\n                const groupState = {\n                    groupId: child.getGroupId(),\n                    open: !colGroupDef ? undefined : colGroupDef.openByDefault\n                };\n                stateItems.push(groupState);\n            }\n        });\n\n        this.setColumnGroupState(stateItems, source);\n    }\n\n    public getColumnGroupState(): { groupId: string, open: boolean; }[] {\n        const columnGroupState: { groupId: string, open: boolean; }[] = [];\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, node => {\n            if (node instanceof OriginalColumnGroup) {\n                const originalColumnGroup = node;\n                columnGroupState.push({\n                    groupId: originalColumnGroup.getGroupId(),\n                    open: originalColumnGroup.isExpanded()\n                });\n            }\n        });\n\n        return columnGroupState;\n    }\n\n    public setColumnGroupState(stateItems: { groupId: string, open: boolean | undefined; }[], source: ColumnEventType = \"api\"): void {\n        this.columnAnimationService.start();\n\n        const impactedGroups: OriginalColumnGroup[] = [];\n\n        stateItems.forEach(stateItem => {\n            const groupKey = stateItem.groupId;\n            const newValue = stateItem.open;\n            const originalColumnGroup: OriginalColumnGroup | null = this.getOriginalColumnGroup(groupKey);\n\n            if (!originalColumnGroup) { return; }\n            if (originalColumnGroup.isExpanded() === newValue) { return; }\n\n            this.logger.log('columnGroupOpened(' + originalColumnGroup.getGroupId() + ',' + newValue + ')');\n            originalColumnGroup.setExpanded(newValue);\n            impactedGroups.push(originalColumnGroup);\n        });\n\n        this.updateGroupsAndDisplayedColumns(source);\n        this.setFirstRightAndLastLeftPinned(source);\n\n        impactedGroups.forEach(originalColumnGroup => {\n            const event: ColumnGroupOpenedEvent = {\n                type: Events.EVENT_COLUMN_GROUP_OPENED,\n                columnGroup: originalColumnGroup,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event);\n        });\n\n        this.columnAnimationService.finish();\n    }\n\n    // called by headerRenderer - when a header is opened or closed\n    public setColumnGroupOpened(key: OriginalColumnGroup | string | null, newValue: boolean, source: ColumnEventType = \"api\"): void {\n        let keyAsString: string;\n\n        if (key instanceof OriginalColumnGroup) {\n            keyAsString = key.getId();\n        } else {\n            keyAsString = key || '';\n        }\n        this.setColumnGroupState([{ groupId: keyAsString, open: newValue }], source);\n    }\n\n    public getOriginalColumnGroup(key: OriginalColumnGroup | string): OriginalColumnGroup | null {\n        if (key instanceof OriginalColumnGroup) { return key; }\n\n        if (typeof key !== 'string') {\n            console.error('AG Grid: group key must be a string');\n        }\n\n        // otherwise, search for the column group by id\n        let res: OriginalColumnGroup | null = null;\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, node => {\n            if (node instanceof OriginalColumnGroup) {\n                const originalColumnGroup = node;\n                if (originalColumnGroup.getId() === key) {\n                    res = originalColumnGroup;\n                }\n            }\n        });\n\n        return res;\n    }\n\n    private calculateColumnsForDisplay(): Column[] {\n        let columnsForDisplay: Column[];\n\n        if (this.pivotMode && !this.secondaryColumnsPresent) {\n            // pivot mode is on, but we are not pivoting, so we only\n            // show columns we are aggregating on\n            columnsForDisplay = this.gridColumns.filter(column => {\n                const isAutoGroupCol = this.groupAutoColumns && includes(this.groupAutoColumns, column);\n                const isValueCol = this.valueColumns && includes(this.valueColumns, column);\n                return isAutoGroupCol || isValueCol;\n            });\n\n        } else {\n            // otherwise continue as normal. this can be working on the primary\n            // or secondary columns, whatever the gridColumns are set to\n            columnsForDisplay = this.gridColumns.filter(column => {\n                // keep col if a) it's auto-group or b) it's visible\n                const isAutoGroupCol = this.groupAutoColumns && includes(this.groupAutoColumns, column);\n                return isAutoGroupCol || column.isVisible();\n            });\n        }\n\n        return columnsForDisplay;\n    }\n\n    private checkColSpanActiveInCols(columns: Column[]): boolean {\n        let result = false;\n\n        columns.forEach(col => {\n            if (exists(col.getColDef().colSpan)) {\n                result = true;\n            }\n        });\n\n        return result;\n    }\n\n    private calculateColumnsForGroupDisplay(): void {\n        this.groupDisplayColumns = [];\n\n        const checkFunc = (col: Column) => {\n            const colDef = col.getColDef();\n            if (colDef && exists(colDef.showRowGroup)) {\n                this.groupDisplayColumns.push(col);\n            }\n        };\n\n        this.gridColumns.forEach(checkFunc);\n\n        if (this.groupAutoColumns) {\n            this.groupAutoColumns.forEach(checkFunc);\n        }\n    }\n\n    public getGroupDisplayColumns(): Column[] {\n        return this.groupDisplayColumns;\n    }\n\n    private updateDisplayedColumns(source: ColumnEventType): void {\n        const columnsForDisplay = this.calculateColumnsForDisplay();\n\n        this.buildDisplayedTrees(columnsForDisplay);\n        this.calculateColumnsForGroupDisplay();\n\n        // also called when group opened/closed\n        this.updateGroupsAndDisplayedColumns(source);\n\n        // also called when group opened/closed\n        this.setFirstRightAndLastLeftPinned(source);\n    }\n\n    public isSecondaryColumnsPresent(): boolean {\n        return this.secondaryColumnsPresent;\n    }\n\n    public setSecondaryColumns(colDefs: (ColDef | ColGroupDef)[] | null, source: ColumnEventType = \"api\"): void {\n        const newColsPresent = colDefs && colDefs.length > 0;\n\n        // if not cols passed, and we had to cols anyway, then do nothing\n        if (!newColsPresent && !this.secondaryColumnsPresent) { return; }\n\n        if (newColsPresent) {\n            this.processSecondaryColumnDefinitions(colDefs);\n            const balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false);\n            this.secondaryBalancedTree = balancedTreeResult.columnTree;\n            this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n            this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);\n\n            this.secondaryColumnsPresent = true;\n        } else {\n            this.secondaryBalancedTree = null;\n            this.secondaryHeaderRowCount = -1;\n            this.secondaryColumns = null;\n            this.secondaryColumnsPresent = false;\n        }\n\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n    }\n\n    private processSecondaryColumnDefinitions(colDefs: (ColDef | ColGroupDef)[] | null): (ColDef | ColGroupDef)[] | undefined {\n\n        const columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();\n        const groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();\n\n        if (!columnCallback && !groupCallback) { return undefined; }\n\n        const searchForColDefs = (colDefs2: (ColDef | ColGroupDef)[]): void => {\n            colDefs2.forEach(function(abstractColDef: AbstractColDef) {\n                const isGroup = exists((abstractColDef as any).children);\n                if (isGroup) {\n                    const colGroupDef = abstractColDef as ColGroupDef;\n                    if (groupCallback) {\n                        groupCallback(colGroupDef);\n                    }\n                    searchForColDefs(colGroupDef.children);\n                } else {\n                    const colDef = abstractColDef as ColGroupDef;\n                    if (columnCallback) {\n                        columnCallback(colDef);\n                    }\n                }\n            });\n        };\n\n        if (colDefs) {\n            searchForColDefs(colDefs);\n        }\n    }\n\n    // called from: setColumnState, setColumnDefs, setSecondaryColumns\n    private updateGridColumns(): void {\n        if (this.gridColsArePrimary) {\n            this.lastPrimaryOrder = this.gridColumns;\n        }\n\n        if (this.secondaryColumns && this.secondaryBalancedTree) {\n            this.gridBalancedTree = this.secondaryBalancedTree.slice();\n            this.gridHeaderRowCount = this.secondaryHeaderRowCount;\n            this.gridColumns = this.secondaryColumns.slice();\n            this.gridColsArePrimary = false;\n        } else {\n            this.gridBalancedTree = this.primaryColumnTree.slice();\n            this.gridHeaderRowCount = this.primaryHeaderRowCount;\n            this.gridColumns = this.primaryColumns.slice();\n            this.gridColsArePrimary = true;\n\n            // updateGridColumns gets called after user adds a row group. we want to maintain the order of the columns\n            // when this happens (eg if user moved a column) rather than revert back to the original column order.\n            // likewise if changing in/out of pivot mode, we want to maintain the order of the primary cols\n            this.orderGridColsLikeLastPrimary();\n        }\n\n        this.addAutoGroupToGridColumns();\n\n        this.autoRowHeightColumns = this.gridColumns.filter(col => col.getColDef().autoHeight);\n\n        this.gridColumns = this.putFixedColumnsFirst(this.gridColumns);\n        this.setupQuickFilterColumns();\n        this.clearDisplayedAndViewportColumns();\n\n        this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);\n\n        this.gridColumnsMap = {};\n        this.gridColumns.forEach(col => this.gridColumnsMap[col.getId()] = col);\n\n        const event: GridColumnsChangedEvent = {\n            type: Events.EVENT_GRID_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n\n        this.eventService.dispatchEvent(event);\n    }\n\n    private orderGridColsLikeLastPrimary(): void {\n        if (missing(this.lastPrimaryOrder)) { return; }\n\n        const lastPrimaryOrderMapped = convertToMap<Column, number>(this.lastPrimaryOrder.map((col, index) => [col, index]));\n\n        // only do the sort if at least one column is accounted for. columns will be not accounted for\n        // if changing from secondary to primary columns\n        let noColsFound = true;\n        this.gridColumns.forEach(col => {\n            if (lastPrimaryOrderMapped.has(col)) {\n                noColsFound = false;\n            }\n        });\n\n        if (noColsFound) { return; }\n\n        // order cols in the same order as before. we need to make sure that all\n        // cols still exists, so filter out any that no longer exist.\n        const gridColsMap = convertToMap<Column, boolean>(this.gridColumns.map(col => [col, true]));\n        const oldColsOrdered = this.lastPrimaryOrder.filter(col => gridColsMap.has(col));\n        const oldColsMap = convertToMap<Column, boolean>(oldColsOrdered.map(col => [col, true]));\n        const newColsOrdered = this.gridColumns.filter(col => !oldColsMap.has(col));\n\n        // add in the new columns, at the end (if no group), or at the end of the group (if a group)\n        const newGridColumns = oldColsOrdered.slice();\n\n        newColsOrdered.forEach(newCol => {\n            let parent = newCol.getOriginalParent();\n\n            // if no parent, means we are not grouping, so just add the column to the end\n            if (!parent) {\n                newGridColumns.push(newCol);\n                return;\n            }\n\n            // find the group the column belongs to. if no siblings at the current level (eg col in group on it's\n            // own) then go up one level and look for siblings there.\n            const siblings: Column[] = [];\n            while (!siblings.length && parent) {\n                const leafCols = parent.getLeafColumns();\n                leafCols.forEach(leafCol => {\n                    const presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;\n                    const noYetInSiblings = siblings.indexOf(leafCol) < 0;\n                    if (presentInNewGriColumns && noYetInSiblings) {\n                        siblings.push(leafCol);\n                    }\n                });\n                parent = parent.getOriginalParent();\n            }\n\n            // if no siblings exist at any level, this means the col is in a group (or parent groups) on it's own\n            if (!siblings.length) {\n                newGridColumns.push(newCol);\n                return;\n            }\n\n            // find index of last column in the group\n            const indexes = siblings.map(col => newGridColumns.indexOf(col));\n            const lastIndex = Math.max(...indexes);\n\n            insertIntoArray(newGridColumns, newCol, lastIndex + 1);\n        });\n\n        this.gridColumns = newGridColumns;\n    }\n\n    public isPrimaryColumnGroupsPresent(): boolean {\n        return this.primaryHeaderRowCount > 1;\n    }\n\n    // if we are using autoGroupCols, then they should be included for quick filter. this covers the\n    // following scenarios:\n    // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on\n    // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this\n    //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)\n    private setupQuickFilterColumns(): void {\n        if (this.groupAutoColumns) {\n            this.columnsForQuickFilter = this.primaryColumns.concat(this.groupAutoColumns);\n        } else {\n            this.columnsForQuickFilter = this.primaryColumns;\n        }\n    }\n\n    private putFixedColumnsFirst(cols:Column[]): Column[] {\n        const locked = cols.filter(c => c.getColDef().lockPosition);\n        const unlocked = cols.filter(c => !c.getColDef().lockPosition);\n        return locked.concat(unlocked);\n    }\n\n    private addAutoGroupToGridColumns(): void {\n        // add in auto-group here\n        this.createGroupAutoColumnsIfNeeded();\n\n        if (missing(this.groupAutoColumns)) { return; }\n\n        this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;\n\n        const autoColBalancedTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);\n\n        this.gridBalancedTree = autoColBalancedTree.concat(this.gridBalancedTree);\n    }\n\n    // gets called after we copy down grid columns, to make sure any part of the gui\n    // that tries to draw, eg the header, it will get empty lists of columns rather\n    // than stale columns. for example, the header will received gridColumnsChanged\n    // event, so will try and draw, but it will draw successfully when it acts on the\n    // virtualColumnsChanged event\n    private clearDisplayedAndViewportColumns(): void {\n        this.displayedTreeLeft = [];\n        this.displayedTreeRight = [];\n        this.displayedTreeCentre = [];\n\n        this.viewportRowLeft = {};\n        this.viewportRowRight = {};\n        this.viewportRowCenter = {};\n\n        this.displayedColumnsLeft = [];\n        this.displayedColumnsRight = [];\n        this.displayedColumnsCenter = [];\n        this.displayedColumns = [];\n        this.viewportColumns = [];\n    }\n\n    private updateGroupsAndDisplayedColumns(source: ColumnEventType) {\n        this.updateOpenClosedVisibilityInColumnGroups();\n        this.deriveDisplayedColumns(source);\n        this.refreshFlexedColumns();\n        this.extractViewport();\n        this.updateBodyWidths();\n        // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display\n\n        const event: DisplayedColumnsChangedEvent = {\n            type: Events.EVENT_DISPLAYED_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    private deriveDisplayedColumns(source: ColumnEventType): void {\n        this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft);\n        this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter);\n        this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight);\n        this.joinDisplayedColumns();\n        this.setLeftValues(source);\n    }\n\n    private joinDisplayedColumns(): void {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.displayedColumns = this.displayedColumnsRight\n                .concat(this.displayedColumnsCenter)\n                .concat(this.displayedColumnsLeft);\n        } else {\n            this.displayedColumns = this.displayedColumnsLeft\n                .concat(this.displayedColumnsCenter)\n                .concat(this.displayedColumnsRight);\n        }\n    }\n\n    // sets the left pixel position of each column\n    private setLeftValues(source: ColumnEventType): void {\n        this.setLeftValuesOfColumns(source);\n        this.setLeftValuesOfGroups();\n    }\n\n    private setLeftValuesOfColumns(source: ColumnEventType): void {\n        // go through each list of displayed columns\n        const allColumns = this.primaryColumns.slice(0);\n\n        // let totalColumnWidth = this.getWidthOfColsInList()\n        const doingRtl = this.gridOptionsWrapper.isEnableRtl();\n\n        [\n            this.displayedColumnsLeft,\n            this.displayedColumnsRight,\n            this.displayedColumnsCenter\n        ].forEach(columns => {\n            if (doingRtl) {\n                // when doing RTL, we start at the top most pixel (ie RHS) and work backwards\n                let left = this.getWidthOfColsInList(columns);\n                columns.forEach(column => {\n                    left -= column.getActualWidth();\n                    column.setLeft(left, source);\n                });\n            } else {\n                // otherwise normal LTR, we start at zero\n                let left = 0;\n                columns.forEach(column => {\n                    column.setLeft(left, source);\n                    left += column.getActualWidth();\n                });\n            }\n            removeAllFromArray(allColumns, columns);\n        });\n\n        // items left in allColumns are columns not displayed, so remove the left position. this is\n        // important for the rows, as if a col is made visible, then taken out, then made visible again,\n        // we don't want the animation of the cell floating in from the old position, whatever that was.\n        allColumns.forEach((column: Column) => {\n            column.setLeft(null, source);\n        });\n    }\n\n    private setLeftValuesOfGroups(): void {\n        // a groups left value is the lest left value of it's children\n        [\n            this.displayedTreeLeft,\n            this.displayedTreeRight,\n            this.displayedTreeCentre\n        ].forEach(columns => {\n            columns.forEach(column => {\n                if (column instanceof ColumnGroup) {\n                    const columnGroup = column;\n                    columnGroup.checkLeft();\n                }\n            });\n        });\n    }\n\n    private derivedDisplayedColumnsFromDisplayedTree(tree: ColumnGroupChild[], columns: Column[]): void {\n        columns.length = 0;\n        this.columnUtils.depthFirstDisplayedColumnTreeSearch(tree, (child: ColumnGroupChild) => {\n            if (child instanceof Column) {\n                columns.push(child);\n            }\n        });\n    }\n\n    private extractViewportColumns(): void {\n        if (this.suppressColumnVirtualisation) {\n            // no virtualisation, so don't filter\n            this.viewportColumnsCenter = this.displayedColumnsCenter;\n        } else {\n            // filter out what should be visible\n            this.viewportColumnsCenter = this.filterOutColumnsWithinViewport();\n        }\n\n        this.viewportColumns = this.viewportColumnsCenter\n            .concat(this.displayedColumnsLeft)\n            .concat(this.displayedColumnsRight);\n    }\n\n    public getVirtualHeaderGroupRow(type: string | null, dept: number): ColumnGroupChild[] {\n        let result: ColumnGroupChild[];\n\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                result = this.viewportRowLeft[dept];\n                break;\n            case Constants.PINNED_RIGHT:\n                result = this.viewportRowRight[dept];\n                break;\n            default:\n                result = this.viewportRowCenter[dept];\n                break;\n        }\n\n        if (missing(result)) {\n            result = [];\n        }\n\n        return result;\n    }\n\n    private extractViewportRows(): void {\n\n        // go through each group, see if any of it's cols are displayed, and if yes,\n        // then this group is included\n        this.viewportRowLeft = {};\n        this.viewportRowRight = {};\n        this.viewportRowCenter = {};\n\n        // for easy lookup when building the groups.\n        const virtualColIds: { [key: string]: boolean; } = {};\n        this.viewportColumns.forEach(col => virtualColIds[col.getId()] = true);\n\n        const testGroup = (\n            children: ColumnGroupChild[],\n            result: { [row: number]: ColumnGroupChild[]; },\n            dept: number): boolean => {\n\n            let returnValue = false;\n\n            for (let i = 0; i < children.length; i++) {\n                // see if this item is within viewport\n                const child = children[i];\n                let addThisItem = false;\n\n                if (child instanceof Column) {\n                    // for column, test if column is included\n                    addThisItem = virtualColIds[child.getId()] === true;\n                } else {\n                    // if group, base decision on children\n                    const columnGroup = child as ColumnGroup;\n                    const displayedChildren = columnGroup.getDisplayedChildren();\n\n                    if (displayedChildren) {\n                        addThisItem = testGroup(displayedChildren, result, dept + 1);\n                    }\n                }\n\n                if (addThisItem) {\n                    returnValue = true;\n                    if (!result[dept]) {\n                        result[dept] = [];\n                    }\n                    result[dept].push(child);\n                }\n            }\n            return returnValue;\n        };\n\n        testGroup(this.displayedTreeLeft, this.viewportRowLeft, 0);\n        testGroup(this.displayedTreeRight, this.viewportRowRight, 0);\n        testGroup(this.displayedTreeCentre, this.viewportRowCenter, 0);\n    }\n\n    private extractViewport(): void {\n        this.extractViewportColumns();\n        this.extractViewportRows();\n    }\n\n    private filterOutColumnsWithinViewport(): Column[] {\n        return this.displayedColumnsCenter.filter(this.isColumnInViewport.bind(this));\n    }\n\n    public refreshFlexedColumns(params: { resizingCols?: Column[], skipSetLeft?: boolean, viewportWidth?: number, source?: ColumnEventType, fireResizedEvent?: boolean, updateBodyWidths?: boolean; } = {}): Column[] {\n        const source = params.source ? params.source : 'flex';\n\n        if (params.viewportWidth != null) {\n            this.flexViewportWidth = params.viewportWidth;\n        }\n\n        if (!this.flexViewportWidth) { return []; }\n\n        // If the grid has left-over space, divide it between flexing columns in proportion to their flex value.\n        // A \"flexing column\" is one that has a 'flex' value set and is not currently being constrained by its\n        // minWidth or maxWidth rules.\n\n        let flexAfterDisplayIndex = -1;\n        if (params.resizingCols) {\n            params.resizingCols.forEach(col => {\n                const indexOfCol = this.displayedColumnsCenter.indexOf(col);\n                if (flexAfterDisplayIndex < indexOfCol) {\n                    flexAfterDisplayIndex = indexOfCol;\n                }\n            });\n        }\n\n        const isColFlex = (col: Column) => {\n            const afterResizingCols = this.displayedColumnsCenter.indexOf(col) > flexAfterDisplayIndex;\n            return col.getFlex() && afterResizingCols;\n        };\n        const knownWidthColumns = this.displayedColumnsCenter.filter(col => !isColFlex(col));\n        const flexingColumns = this.displayedColumnsCenter.filter(col => isColFlex(col));\n        const changedColumns: Column[] = [];\n\n        if (!flexingColumns.length) {\n            return [];\n        }\n\n        const flexingColumnSizes: number[] = [];\n        let spaceForFlexingColumns: number;\n\n        outer: while (true) {\n            const totalFlex = flexingColumns.reduce((count, col) => count + col.getFlex(), 0);\n            spaceForFlexingColumns = this.flexViewportWidth - this.getWidthOfColsInList(knownWidthColumns);\n            for (let i = 0; i < flexingColumns.length; i++) {\n                const col = flexingColumns[i];\n                const widthByFlexRule = spaceForFlexingColumns * col.getFlex() / totalFlex;\n                let constrainedWidth = 0;\n\n                const minWidth = col.getMinWidth();\n                const maxWidth = col.getMaxWidth();\n\n                if (exists(minWidth) && widthByFlexRule < minWidth) {\n                    constrainedWidth = minWidth;\n                } else if (exists(maxWidth) && widthByFlexRule > maxWidth) {\n                    constrainedWidth = maxWidth;\n                }\n\n                if (constrainedWidth) {\n                    // This column is not in fact flexing as it is being constrained to a specific size\n                    // so remove it from the list of flexing columns and start again\n                    col.setActualWidth(constrainedWidth, source);\n                    removeFromArray(flexingColumns, col);\n                    changedColumns.push(col);\n                    knownWidthColumns.push(col);\n                    continue outer;\n                }\n\n                flexingColumnSizes[i] = Math.round(widthByFlexRule);\n            }\n            break;\n        }\n\n        let remainingSpace = spaceForFlexingColumns;\n        flexingColumns.forEach((col, i) => {\n            col.setActualWidth(Math.min(flexingColumnSizes[i], remainingSpace), source);\n            changedColumns.push(col);\n            remainingSpace -= flexingColumnSizes[i];\n        });\n\n        if (!params.skipSetLeft) {\n            this.setLeftValues(source);\n        }\n\n        if (params.updateBodyWidths) {\n            this.updateBodyWidths();\n        }\n\n        if (params.fireResizedEvent) {\n            this.fireColumnResizedEvent(changedColumns, true, source, flexingColumns);\n        }\n\n        // if the user sets rowData directly into GridOptions, then the row data is set before\n        // grid is attached to the DOM. this means the columns are not flexed, and then the rows\n        // have the wrong height (as they depend on column widths). so once the columns have\n        // been flexed for the first time (only happens once grid is attached to DOM, as dependency\n        // on getting the grid width, which only happens after attached after ResizeObserver fires)\n        // we get get rows to re-calc their heights.\n        if (!this.flexColsCalculatedAtLestOnce) {\n            if (this.gridOptionsWrapper.isRowModelDefault()) {\n                (this.rowModel as IClientSideRowModel).resetRowHeights();\n            }\n            this.flexColsCalculatedAtLestOnce = true;\n        }\n\n        return flexingColumns;\n    }\n\n    // called from api\n    public sizeColumnsToFit(gridWidth: any, source: ColumnEventType = \"sizeColumnsToFit\", silent?: boolean): void {\n        // avoid divide by zero\n        const allDisplayedColumns = this.getAllDisplayedColumns();\n\n        if (gridWidth <= 0 || !allDisplayedColumns.length) { return; }\n\n        const colsToSpread: Column[] = [];\n        const colsToNotSpread: Column[] = [];\n\n        allDisplayedColumns.forEach(column => {\n            if (column.getColDef().suppressSizeToFit === true) {\n                colsToNotSpread.push(column);\n            } else {\n                colsToSpread.push(column);\n            }\n        });\n\n        // make a copy of the cols that are going to be resized\n        const colsToFireEventFor = colsToSpread.slice(0);\n        let finishedResizing = false;\n\n        const moveToNotSpread = (column: Column) => {\n            removeFromArray(colsToSpread, column);\n            colsToNotSpread.push(column);\n        };\n\n        // resetting cols to their original width makes the sizeColumnsToFit more deterministic,\n        // rather than depending on the current size of the columns. most users call sizeColumnsToFit\n        // immediately after grid is created, so will make no difference. however if application is calling\n        // sizeColumnsToFit repeatedly (eg after column group is opened / closed repeatedly) we don't want\n        // the columns to start shrinking / growing over time.\n        //\n        // NOTE: the process below will assign values to `this.actualWidth` of each column without firing events\n        // for this reason we need to manually fire resize events after the resize has been done for each column.\n        colsToSpread.forEach(column => column.resetActualWidth(source));\n\n        while (!finishedResizing) {\n            finishedResizing = true;\n            const availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);\n            if (availablePixels <= 0) {\n                // no width, set everything to minimum\n                colsToSpread.forEach((column: Column) => {\n                    column.setMinimum(source);\n                });\n            } else {\n                const scale = availablePixels / this.getWidthOfColsInList(colsToSpread);\n                // we set the pixels for the last col based on what's left, as otherwise\n                // we could be a pixel or two short or extra because of rounding errors.\n                let pixelsForLastCol = availablePixels;\n                // backwards through loop, as we are removing items as we go\n                for (let i = colsToSpread.length - 1; i >= 0; i--) {\n                    const column = colsToSpread[i];\n                    const minWidth = column.getMinWidth();\n                    const maxWidth = column.getMaxWidth();\n                    let newWidth = Math.round(column.getActualWidth() * scale);\n\n                    if (exists(minWidth) && newWidth < minWidth) {\n                        newWidth = minWidth;\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    } else if (exists(maxWidth) && column.isGreaterThanMax(newWidth)) {\n                        newWidth = maxWidth;\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    } else if (i === 0) { // if this is the last column\n                        newWidth = pixelsForLastCol;\n                    }\n\n                    column.setActualWidth(newWidth, source, true);\n                    pixelsForLastCol -= newWidth;\n                }\n            }\n        }\n\n        // see notes above\n        colsToFireEventFor.forEach(col => {\n            col.fireColumnWidthChangedEvent(source);\n        });\n\n        this.setLeftValues(source);\n        this.updateBodyWidths();\n\n        if (silent) { return; }\n\n        this.fireColumnResizedEvent(colsToFireEventFor, true, source);\n    }\n\n    private buildDisplayedTrees(visibleColumns: Column[]) {\n        const leftVisibleColumns: Column[] = [];\n        const rightVisibleColumns: Column[] = [];\n        const centerVisibleColumns: Column[] = [];\n\n        visibleColumns.forEach(column => {\n            switch (column.getPinned()) {\n                case \"left\":\n                    leftVisibleColumns.push(column);\n                    break;\n                case \"right\":\n                    rightVisibleColumns.push(column);\n                    break;\n                default:\n                    centerVisibleColumns.push(column);\n                    break;\n            }\n        });\n\n        const groupInstanceIdCreator = new GroupInstanceIdCreator();\n\n        this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(\n            leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_LEFT, this.displayedTreeLeft);\n        this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(\n            rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_RIGHT, this.displayedTreeRight);\n        this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(\n            centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, null, this.displayedTreeCentre);\n\n        this.updateDisplayedMap();\n    }\n\n    private updateDisplayedMap(): void {\n        this.displayedColumnsAndGroupsMap = {};\n\n        const func = (child: ColumnGroupChild) => {\n            this.displayedColumnsAndGroupsMap[child.getUniqueId()] = child;\n        };\n\n        this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeCentre, func);\n        this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeLeft, func);\n        this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeRight, func);\n    }\n\n    public isDisplayed(item: ColumnGroupChild): boolean {\n        const fromMap = this.displayedColumnsAndGroupsMap[item.getUniqueId()];\n        // check for reference, in case new column / group with same id is now present\n        return fromMap === item;\n    }\n\n    private updateOpenClosedVisibilityInColumnGroups(): void {\n        const allColumnGroups = this.getAllDisplayedTrees();\n\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, child => {\n            if (child instanceof ColumnGroup) {\n                const columnGroup = child;\n                columnGroup.calculateDisplayedColumns();\n            }\n        });\n    }\n\n    public getGroupAutoColumns(): Column[] | null {\n        return this.groupAutoColumns;\n    }\n\n    private createGroupAutoColumnsIfNeeded(): void {\n        if (!this.autoGroupsNeedBuilding) { return; }\n\n        this.autoGroupsNeedBuilding = false;\n\n        const groupFullWidthRow = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode);\n        // we need to allow suppressing auto-column separately for group and pivot as the normal situation\n        // is CSRM and user provides group column themselves for normal view, but when they go into pivot the\n        // columns are generated by the grid so no opportunity for user to provide group column. so need a way\n        // to suppress auto-col for grouping only, and not pivot.\n        // however if using Viewport RM or SSRM and user is providing the columns, the user may wish full control\n        // of the group column in this instance.\n        const suppressAutoColumn = this.pivotMode ?\n            this.gridOptionsWrapper.isPivotSuppressAutoColumn() : this.gridOptionsWrapper.isGroupSuppressAutoColumn();\n\n        const groupingActive = this.rowGroupColumns.length > 0 || this.usingTreeData;\n        const needAutoColumns = groupingActive && !suppressAutoColumn && !groupFullWidthRow;\n\n        if (needAutoColumns) {\n            const newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);\n            const autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns);\n            // we force recreate when suppressColumnStateEvents changes, so new group cols pick up the new\n            // definitions. otherwise we could ignore the new cols because they appear to be the same.\n            if (autoColsDifferent || this.forceRecreateAutoGroups) {\n                this.groupAutoColumns = newAutoGroupCols;\n            }\n        } else {\n            this.groupAutoColumns = null;\n        }\n    }\n\n    private autoColsEqual(colsA: Column[] | null, colsB: Column[] | null): boolean {\n        return areEqual(colsA, colsB, (a, b) => a.getColId() === b.getColId());\n    }\n\n    private getWidthOfColsInList(columnList: Column[]) {\n        return columnList.reduce((width, col) => width + col.getActualWidth(), 0);\n    }\n\n    public getGridBalancedTree(): OriginalColumnGroupChild[] {\n        return this.gridBalancedTree;\n    }\n\n    public hasFloatingFilters(): boolean {\n        if (!this.gridColumns) { return false; }\n        const res = this.gridColumns.some(col => col.getColDef().floatingFilter);\n        return res;\n    }\n\n    public getFirstDisplayedColumn(): Column | null {\n        const isRtl = this.gridOptionsWrapper.isEnableRtl();\n        const queryOrder: ('getDisplayedLeftColumns' | 'getDisplayedCenterColumns' | 'getDisplayedRightColumns')[] = [\n            'getDisplayedLeftColumns',\n            'getDisplayedCenterColumns',\n            'getDisplayedRightColumns'\n        ];\n\n        if (isRtl) {\n            queryOrder.reverse();\n        }\n\n        for (let i = 0; i < queryOrder.length; i++) {\n            const container = this[queryOrder[i]]();\n            if (container.length) {\n                return isRtl ? last(container) : container[0];\n            }\n        }\n\n        return null;\n    }\n}\n"]}