{"version":3,"sources":["../../src/ts/valueService/expressionService.ts"],"names":[],"mappings":"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","file":"expressionService.js","sourcesContent":["import { Logger, LoggerFactory } from \"../logger\";\nimport { Bean } from \"../context/context\";\nimport { Qualifier } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\n\n@Bean('expressionService')\nexport class ExpressionService extends BeanStub {\n\n    private expressionToFunctionCache = {} as any;\n    private logger: Logger;\n\n    private setBeans(@Qualifier('loggerFactory') loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create('ExpressionService');\n    }\n\n    public evaluate(expressionOrFunc: Function | string | undefined, params: any): any {\n        if (typeof expressionOrFunc === 'function') {\n            // valueGetter is a function, so just call it\n            const func = expressionOrFunc;\n            return func(params);\n        } else if (typeof expressionOrFunc === 'string') {\n            // valueGetter is an expression, so execute the expression\n            const expression = expressionOrFunc;\n            return this.evaluateExpression(expression, params);\n        } else {\n            console.error('AG Grid: value should be either a string or a function', expressionOrFunc);\n        }\n    }\n\n    private evaluateExpression(expression: string, params: any): any {\n        try {\n            const javaScriptFunction = this.createExpressionFunction(expression);\n            // the params don't have all these values, rather we add every possible\n            // value a params can have, which makes whatever is in the params available.\n            const result = javaScriptFunction(params.value, params.context,\n                params.oldValue, params.newValue, params.value, params.node,\n                params.data, params.colDef, params.rowIndex, params.api, params.columnApi,\n                params.getValue, params.column, params.columnGroup);\n            return result;\n        } catch (e) {\n            // the expression failed, which can happen, as it's the client that\n            // provides the expression. so print a nice message\n            // tslint:disable-next-line\n            console.log('Processing of the expression failed');\n            // tslint:disable-next-line\n            console.log('Expression = ' + expression);\n            // tslint:disable-next-line\n            console.log('Params =', params);\n            // tslint:disable-next-line\n            console.log('Exception = ' + e);\n            return null;\n        }\n    }\n\n    private createExpressionFunction(expression: any) {\n        // check cache first\n        if (this.expressionToFunctionCache[expression]) {\n            return this.expressionToFunctionCache[expression];\n        }\n        // if not found in cache, return the function\n        const functionBody = this.createFunctionBody(expression);\n        const theFunction = new Function('x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup', functionBody);\n\n        // store in cache\n        this.expressionToFunctionCache[expression] = theFunction;\n\n        return theFunction;\n    }\n\n    private createFunctionBody(expression: any) {\n        // if the expression has the 'return' word in it, then use as is,\n        // if not, then wrap it with return and ';' to make a function\n        if (expression.indexOf('return') >= 0) {\n            return expression;\n        } else {\n            return 'return ' + expression + ';';\n        }\n    }\n}\n"]}